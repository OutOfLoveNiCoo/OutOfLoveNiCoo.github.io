<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
  <title>OutOfLove🥝</title>
  
  
  <link href="https://outoflovenicoo.github.io/atom.xml" rel="self"/>
  
  <link href="https://outoflovenicoo.github.io/"/>
  <updated>2025-04-20T14:00:00.000Z</updated>
  <id>https://outoflovenicoo.github.io/</id>
  
  <author>
    <name>OutOfLove🥝</name>
    
  </author>
  
  <generator uri="https://hexo.io/">Hexo</generator>
  
  <entry>
    <title>新的技术-MCP原理和使用</title>
    <link href="https://outoflovenicoo.github.io/posts/2025-04-20-%E6%96%B0%E7%9A%84%E6%8A%80%E6%9C%AF-MCP%E5%8E%9F%E7%90%86%E5%92%8C%E4%BD%BF%E7%94%A8.html"/>
    <id>https://outoflovenicoo.github.io/posts/2025-04-20-%E6%96%B0%E7%9A%84%E6%8A%80%E6%9C%AF-MCP%E5%8E%9F%E7%90%86%E5%92%8C%E4%BD%BF%E7%94%A8.html</id>
    <published>2025-04-20T10:19:03.000Z</published>
    <updated>2025-04-20T14:00:00.000Z</updated>
    
    <content type="html"><![CDATA[<h1 id="MCP介绍与原理："><a href="#MCP介绍与原理：" class="headerlink" title="MCP介绍与原理："></a>MCP介绍与原理：</h1><h2 id="1-介绍"><a href="#1-介绍" class="headerlink" title="1.介绍"></a>1.介绍</h2><p>​    MCP（Model Context Protocol，模型上下文协议） ，2024年11月底，由 Anthropic 推出的一种开放标准，旨在统一大型语言模型（LLM）与外部数据源和工具之间的通信协议。MCP 的主要目的在于解决当前 AI 模型因数据孤岛限制而无法充分发挥潜力的难题，MCP 使得 AI 应用能够安全地访问和操作本地及远程数据，为 AI 应用提供了连接万物的接口。</p><p>​    MCP 可以直接在 AI 与数据（包括本地数据和互联网数据）之间架起一座桥梁，通过 MCP 服务器和 MCP 客户端，大家只要都遵循这套协议，就能实现“万物互联”。</p><p>​    有了MCP，可以和数据和文件系统、开发工具、Web 和浏览器自动化、生产力和通信、各种社区生态能力全部集成，实现强大的协作工作能力，它的价值远不可估量。</p><p><img src="2025-04-20-新的技术-MCP原理和使用/v2-fa3cdcd616cd3dc22732fa3f529cc7f7_1440w.jpg" alt="img"></p><h3 id="MCP-与-Function-Calling-的区别"><a href="#MCP-与-Function-Calling-的区别" class="headerlink" title="MCP 与 Function Calling 的区别"></a><strong>MCP 与 Function Calling 的区别</strong></h3><p>这两种技术都旨在增强 AI 模型与外部数据的交互能力，但 MCP 不止可以增强 AI 模型，还可以是其他的应用系统。</p><p><img src="2025-04-20-新的技术-MCP原理和使用/v2-b82dc0e2da4a258438b84484d1af8319_1440w.jpg" alt="img"></p><h2 id="2-工作原理"><a href="#2-工作原理" class="headerlink" title="2.工作原理"></a>2.工作原理</h2><p>MCP 协议采用了一种独特的架构设计，它将 LLM 与资源之间的通信划分为三个主要部分：客户端、服务器和资源。</p><p>客户端负责发送请求给 MCP 服务器，服务器则将这些请求转发给相应的资源。这种分层的设计使得 MCP 协议能够更好地控制访问权限，确保只有经过授权的用户才能访问特定的资源。</p><p>以下是 MCP 的基本工作流程：</p><ul><li><p>初始化连接：客户端向服务器发送连接请求，建立通信通道。</p></li><li><p>发送请求：客户端根据需求构建请求消息，并发送给服务器。</p></li><li><p>处理请求：服务器接收到请求后，解析请求内容，执行相应的操作（如查询数据库、读取文件等）。</p></li><li><p>返回结果：服务器将处理结果封装成响应消息，发送回客户端。</p></li><li><p>断开连接：任务完成后，客户端可以主动关闭连接或等待服务器超时关闭。</p><p><img src="2025-04-20-新的技术-MCP原理和使用/v2-bb82edf5b8651051be151c279e7679e1_1440w-20250420103956741.jpg" alt="img"></p></li></ul><h3 id="MCP-核心架构"><a href="#MCP-核心架构" class="headerlink" title="MCP 核心架构"></a>MCP 核心架构</h3><p>MCP 遵循客户端-服务器架构（client-server），其中包含以下几个核心概念：</p><ul><li><p>MCP 主机（MCP Hosts）：发起请求的 LLM 应用程序（例如 <a href="https://zhida.zhihu.com/search?content_id=254488153&amp;content_type=Article&amp;match_order=1&amp;q=Claude+Desktop&amp;zhida_source=entity">Claude Desktop</a>、IDE 或 AI 工具）。</p></li><li><p>MCP 客户端（MCP Clients）：在主机程序内部，与 MCP server 保持 1:1 的连接。</p></li><li><p>MCP 服务器（MCP Servers）：为 MCP client 提供上下文、工具和 prompt 信息。</p></li><li><p>本地资源（Local Resources）：本地计算机中可供 MCP server 安全访问的资源（例如文件、数据库）。</p></li><li><p>远程资源（Remote Resources）：MCP server 可以连接到的远程资源（例如通过 API）。</p><p><img src="2025-04-20-新的技术-MCP原理和使用/v2-492a176fa0a06b585e752dc676d28b77_1440w.jpg" alt="img"></p></li></ul><h3 id="MCP-client-和-MCP-server"><a href="#MCP-client-和-MCP-server" class="headerlink" title="MCP client 和 MCP server"></a>MCP client 和 MCP server</h3><p>MCP client 充当 LLM 和 MCP server 之间的桥梁，MCP client 的工作流程如下：</p><ul><li>MCP client 首先从 MCP server 获取可用的工具列表。</li><li>将用户的查询连同工具描述通过 function calling 一起发送给 LLM。</li><li>LLM 决定是否需要使用工具以及使用哪些工具。</li><li>如果需要使用工具，MCP client 会通过 MCP server 执行相应的工具调用。</li><li>工具调用的结果会被发送回 LLM。</li><li>LLM 基于所有信息生成自然语言响应。</li><li>最后将响应展示给用户。</li></ul><p>MCP server 是 MCP 架构中的关键组件，它可以提供 3 种主要类型的功能：</p><ul><li>资源（Resources）：类似文件的数据，可以被客户端读取，如 API 响应或文件内容。</li><li>工具（Tools）：可以被 LLM 调用的函数（需要用户批准）。</li><li>提示（Prompts）：预先编写的模板，帮助用户完成特定任务。</li></ul><h3 id="通信机制"><a href="#通信机制" class="headerlink" title="通信机制"></a><strong>通信机制</strong></h3><p>MCP 协议支持两种主要的通信机制：基于标准输入输出的本地通信和基于<a href="https://zhida.zhihu.com/search?content_id=254488153&amp;content_type=Article&amp;match_order=1&amp;q=SSE&amp;zhida_source=entity">SSE</a>（<a href="https://link.zhihu.com/?target=https%3A//en.wikipedia.org/wiki/Server-sent_events">Server-Sent Events</a>）的远程通信。</p><p>这两种机制都使用 <a href="https://link.zhihu.com/?target=https%3A//www.jsonrpc.org/specification">JSON-RPC 2.0</a> 格式进行消息传输，确保了通信的标准化和可扩展性。</p><ul><li>本地通信<strong>：</strong>通过 stdio 传输数据，适用于在同一台机器上运行的客户端和服务器之间的通信。</li><li>远程通信<strong>：</strong>利用 SSE 与 HTTP 结合，实现跨网络的实时数据传输，适用于需要访问远程资源或分布式部署的场景。</li></ul><h2 id="3-MCP个人实践"><a href="#3-MCP个人实践" class="headerlink" title="3.MCP个人实践"></a>3.MCP个人实践</h2><h3 id="前言："><a href="#前言：" class="headerlink" title="前言："></a>前言：</h3><ol><li><p>安装 Claude Desktop： 确保已在 macOS 或 Windows 系统上安装最新版本的 Claude Desktop。</p><p>这一部分需要一个国外邮箱和国外手机号，国外手机号可以使用sms-activate获得。</p></li><li><p>配置 MCP 服务器： 在 Claude Desktop 的配置文件中，配置入口Claude Desktop—&gt;菜单—&gt;Settings—&gt;Developer—&gt;Edit Config：</p><p><img src="2025-04-20-新的技术-MCP原理和使用/image-20250420104518943.png" alt="image-20250420104518943"></p></li></ol><p><img src="2025-04-20-新的技术-MCP原理和使用/image-20250420104634339.png" alt="image-20250420104634339"></p><p>配置后，下面会出现锤子</p><p><img src="2025-04-20-新的技术-MCP原理和使用/image-20250420104729266.png" alt="image-20250420104729266"></p><h3 id="一、控制本地文件"><a href="#一、控制本地文件" class="headerlink" title="一、控制本地文件"></a>一、控制本地文件</h3><p><img src="2025-04-20-新的技术-MCP原理和使用/image-20250420104755519.png" alt="image-20250420104755519"></p><h3 id="二、实时搜索"><a href="#二、实时搜索" class="headerlink" title="二、实时搜索"></a>二、实时搜索</h3><p><strong>接入tavily实现实时搜索</strong></p><p><img src="2025-04-20-新的技术-MCP原理和使用/image-20250420104856401.png" alt="image-20250420104856401"></p><h2 id="参考博客："><a href="#参考博客：" class="headerlink" title="参考博客："></a>参考博客：</h2><p><a href="https://www.claudemcp.com/zh/docs/quickstart">ClaudeMcp使用文档</a></p><p><a href="https://zhuanlan.zhihu.com/p/27327515233">MCP原理详解</a></p><p><a href="https://blog.csdn.net/m0_37996629/article/details/146456420?ops_request_misc=%7B%22request%5Fid%22%3A%22f7bc1da06e0c3b4d1920f3cdec516773%22%2C%22scm%22%3A%2220140713.130102334..%22%7D&amp;request_id=f7bc1da06e0c3b4d1920f3cdec516773&amp;biz_id=0&amp;utm_medium=distribute.pc_search_result.none-task-blog-2~all~ElasticSearch~search_v2-6-146456420-null-null.142^v102^pc_search_result_base3&amp;utm_term=Claude %2B MCP&amp;spm=1018.2226.3001.4187">抢先体验:Claude + MCP 零成本实现网络搜索+网页爬虫_claude desktop下载-CSDN博客</a></p>]]></content>
    
    
    <summary type="html">🥧新的技术-MCP原理和使用</summary>
    
    
    
    <category term="学习" scheme="https://outoflovenicoo.github.io/categories/%E5%AD%A6%E4%B9%A0/"/>
    
    
    <category term="前沿" scheme="https://outoflovenicoo.github.io/tags/%E5%89%8D%E6%B2%BF/"/>
    
  </entry>
  
  <entry>
    <title>并发编程的内存泄漏与内存溢出问题</title>
    <link href="https://outoflovenicoo.github.io/posts/2025-04-19-%E5%B9%B6%E5%8F%91%E7%BC%96%E7%A8%8B%E7%9A%84%E5%86%85%E5%AD%98%E6%B3%84%E6%BC%8F%E4%B8%8E%E5%86%85%E5%AD%98%E6%BA%A2%E5%87%BA%E9%97%AE%E9%A2%98.html"/>
    <id>https://outoflovenicoo.github.io/posts/2025-04-19-%E5%B9%B6%E5%8F%91%E7%BC%96%E7%A8%8B%E7%9A%84%E5%86%85%E5%AD%98%E6%B3%84%E6%BC%8F%E4%B8%8E%E5%86%85%E5%AD%98%E6%BA%A2%E5%87%BA%E9%97%AE%E9%A2%98.html</id>
    <published>2025-04-19T10:19:03.000Z</published>
    <updated>2025-04-19T14:00:00.000Z</updated>
    
    <content type="html"><![CDATA[<h1>思维导图</h1><p><img src="2025-04-19-%E5%B9%B6%E5%8F%91%E7%BC%96%E7%A8%8B%E7%9A%84%E5%86%85%E5%AD%98%E6%B3%84%E6%BC%8F%E4%B8%8E%E5%86%85%E5%AD%98%E6%BA%A2%E5%87%BA%E9%97%AE%E9%A2%98/diagram.png" alt=""></p><p>在Java编程中，内存泄漏和内存溢出是常见且需要重点关注的问题。它们会导致程序性能下降，甚至崩溃。本文将详细介绍这两个概念、常见原因、表现迹象及解决方法。</p><h2 id="一、内存泄漏">一、内存泄漏</h2><h3 id="1-常见原因">1. 常见原因</h3><ul><li><p><strong>静态属性导致内存泄漏</strong>：静态变量生命周期长，若引用了大对象或长时间不用的对象，易导致内存泄漏。例如，静态集合类不断添加元素却不清理。</p></li><li><p><strong>未关闭的资源</strong>：数据库连接、文件流、网络连接等资源使用后未关闭，会一直占用内存。即使程序不再使用这些资源，垃圾回收器也无法回收，因为资源的引用未释放。</p></li><li><p><strong>使用ThreadLocal后未手动清理</strong>：ThreadLocal为每个线程提供独立变量副本，但若使用后不调用<code>remove</code>方法，线程长期存活时，ThreadLocal关联的对象会一直存在，占用内存。</p></li><li><p><strong>线程泄漏</strong>：线程结束后，相关资源未正确释放。如线程池中的线程未正确关闭，一直占用内存资源。</p></li></ul><h3 id="2-迹象">2. 迹象</h3><ul><li><p><strong>内存占用不断增加</strong>：观察程序内存占用，若持续上升且不释放，很可能存在内存泄漏。随着时间推移，内存占用越来越高，最终可能导致内存溢出。</p></li><li><p><strong>长时间运行后性能下降</strong>：程序运行一段时间后变慢，因内存泄漏使系统可用内存减少，垃圾回收频繁，影响程序执行效率。</p></li><li><p><strong>频繁的垃圾回收</strong>：尤其是Full GC频繁发生，说明内存中存在大量无法被回收的对象，可能是内存泄漏导致。</p></li></ul><h3 id="3-解决方法">3. 解决方法</h3><ul><li><p><strong>正确关闭资源</strong>：</p><ul><li><p>对于支持<code>try - with - resources</code>的资源（如<code>AutoCloseable</code>实现类），使用该语句自动关闭资源，确保资源使用后及时释放。</p></li><li><p>对于不支持的资源（如某些旧版数据库连接），在<code>finally</code>块中手动关闭，保证即使出现异常，资源也能释放。</p></li></ul></li><li><p><strong>使用ThreadLocal后手动清理</strong>：在使用完ThreadLocal变量后，及时调用<code>remove</code>方法，清除线程本地存储的变量，避免内存占用。</p></li><li><p><strong>避免线程泄漏</strong>：在线程不再需要时，调用<code>Thread</code>的<code>interrupt</code>方法或其他合适方式停止线程，确保线程相关资源正确关闭，如关闭线程池中的空闲线程。</p></li></ul><h2 id="二、内存溢出">二、内存溢出</h2><h3 id="1-常见原因-2">1. 常见原因</h3><ul><li><p><strong>大量对象创建</strong>：程序中循环或频繁创建大量对象，且未及时回收，超过JVM堆内存限制，导致内存溢出。例如，一次性加载大量数据到内存中创建对象。</p></li><li><p><strong>持久引用</strong>：如缓存、集合等数据结构长时间持有对象引用，即使对象不再使用，也无法被垃圾回收器回收，造成内存占用累积。</p></li><li><p><strong>递归调用</strong>：深度递归可能导致栈内存耗尽，出现<code>StackOverflowError</code>，这也是一种内存溢出情况。</p></li></ul><h3 id="2-JVM内存结构中的溢出情况">2. JVM内存结构中的溢出情况</h3><ul><li><p><strong>堆溢出</strong>：错误信息<code>java.lang.OutOfMemoryError: java heap space</code>。当堆中创建的对象过多，垃圾回收无法及时回收，且堆内存达到最大限制（通过<code>-Xmx</code>设置）时发生。</p></li><li><p><strong>方法区溢出</strong>：JDK 1.8前为<code>java.lang.OutOfMemoryError: PermGen space</code>，JDK 1.8后为<code>java.lang.OutOfMemoryError: Metaspace</code>。加载的类、常量过多，超过方法区内存限制时出现。</p></li><li><p><strong>直接内存溢出</strong>：错误信息<code>java.lang.OutOfMemoryError: Direct buffer memory</code>。使用<code>ByteBuffer.allocateDirect()</code>等分配直接内存时，若未正确管理（如未调用<code>clear</code>），直接内存使用过多导致溢出。</p></li></ul><h3 id="3-解决方法-2">3. 解决方法</h3><ul><li><p><strong>定位问题</strong>：通过<code>top</code>等命令定位到占用内存高的线程，分析其堆存储文件（如使用<code>jmap</code>生成堆转储文件，用<code>jhat</code>或其他工具分析），确定具体导致溢出的对象和代码。</p></li><li><p><strong>检查数据加载</strong>：若因一次从数据库取出过多数据导致内存中对象过多，修改查询方式，采用分页查询等，减少一次性加载的数据量。</p></li><li><p><strong>排查内存泄漏</strong>：检查<code>List</code>、<code>Map</code>等集合对象是否使用后未清除元素，确保不再使用的对象能被垃圾回收。例如，及时清除缓存中过期的数据。</p></li><li><p><strong>调整JVM参数</strong>：若启动参数中内存设定过小（<code>-Xms</code>、<code>-Xmx</code>），适当增加内存。但需注意，增加内存不是万能的，还需结合代码优化，避免无限制消耗内存。</p></li></ul><p>内存泄漏和内存溢出是Java程序中需要重点关注的问题。通过了解其原因、表现和解决方法，能更好地优化程序，提高稳定性和性能。在开发中，要养成良好的编码习惯，及时释放资源，合理管理对象引用，定期监控程序内存使用情况，以便及时发现和解决问题。 </p><h2 id="参考博客：">参考博客：</h2><p><a href="https://xiaolincoding.com/interview/jvm.html#%E5%86%85%E5%AD%98%E6%B3%84%E6%BC%8F%E5%92%8C%E5%86%85%E5%AD%98%E6%BA%A2%E5%87%BA%E7%9A%84%E7%90%86%E8%A7%A3">Java虚拟机面试题</a></p><p><a href="https://www.cnblogs.com/flydean/p/17722512.html">www.cnblogs.com</a></p>]]></content>
    
    
    <summary type="html">🥧并发编程的内存泄漏与内存溢出问题</summary>
    
    
    
    <category term="学习" scheme="https://outoflovenicoo.github.io/categories/%E5%AD%A6%E4%B9%A0/"/>
    
    
    <category term="思维导图" scheme="https://outoflovenicoo.github.io/tags/%E6%80%9D%E7%BB%B4%E5%AF%BC%E5%9B%BE/"/>
    
  </entry>
  
  <entry>
    <title>华为416批次笔试</title>
    <link href="https://outoflovenicoo.github.io/posts/2025-04-17-%E5%8D%8E%E4%B8%BA416%E6%89%B9%E6%AC%A1%E7%AC%94%E8%AF%95.html"/>
    <id>https://outoflovenicoo.github.io/posts/2025-04-17-%E5%8D%8E%E4%B8%BA416%E6%89%B9%E6%AC%A1%E7%AC%94%E8%AF%95.html</id>
    <published>2025-04-17T10:19:03.000Z</published>
    <updated>2025-04-17T14:00:00.000Z</updated>
    
    <content type="html"><![CDATA[<h1 id="2025年4月16日华为笔试复盘"><a href="#2025年4月16日华为笔试复盘" class="headerlink" title="2025年4月16日华为笔试复盘"></a>2025年4月16日华为笔试复盘</h1><p>​    这场笔试做的很糟糕，三道题一道也没a出来，不过幸好最后及格了，我觉得需要复盘一下为什么做的这么糟糕。</p><p>​    题目来源网站：CodeFun:<a href="https://codefun2000.com/pset/673c82a4d67fed3f6531c8e1">https://codefun2000.com/pset/673c82a4d67fed3f6531c8e1</a></p><h2 id="第一题"><a href="#第一题" class="headerlink" title="第一题"></a>第一题</h2><p><a href="https://codefun2000.com/p/P2845">https://codefun2000.com/p/P2845</a></p><p><img src="2025-04-17-华为416批次笔试/image-20250418102041869.png" alt="image-20250418102041869"></p><p><img src="2025-04-17-华为416批次笔试/image-20250418102120394.png" alt="image-20250418102120394"></p><p>其实看到这一题，我第一眼就想到用位运算，但是位运算不知道该怎么样去遍历，因为答案可能有多个行叠加。所以我采取了一个比较通用的dfs方法去遍历所有可能(但是没注意到m,n的长度最大为1000，位运算肯定超时)。</p><p>这是当时的做法（回忆版）</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> java.util.*;</span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Main</span> &#123;</span><br><span class="line">    <span class="keyword">static</span> <span class="type">int</span>[][] cases;</span><br><span class="line">    <span class="keyword">static</span> <span class="type">int</span> minCount;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">        <span class="type">Scanner</span> <span class="variable">sc</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Scanner</span>(System.in);</span><br><span class="line">        <span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> sc.nextInt();</span><br><span class="line">        <span class="type">int</span> <span class="variable">j</span> <span class="operator">=</span> sc.nextInt();</span><br><span class="line">        cases = <span class="keyword">new</span> <span class="title class_">int</span>[i][j];</span><br><span class="line">        </span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">x</span> <span class="operator">=</span> <span class="number">0</span>; x &lt; i; x++) &#123;</span><br><span class="line">            <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">y</span> <span class="operator">=</span> <span class="number">0</span>; y &lt; j; y++) &#123;</span><br><span class="line">                cases[x][y] = sc.nextInt();</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">        <span class="type">boolean</span>[] covered = <span class="keyword">new</span> <span class="title class_">boolean</span>[j];</span><br><span class="line">        <span class="type">int</span> <span class="variable">count</span> <span class="operator">=</span> <span class="number">0</span>;  </span><br><span class="line">        dfs(covered,<span class="number">0</span>,<span class="number">0</span>,<span class="number">0</span>);</span><br><span class="line">        System.out.println(allCovered ? count : -<span class="number">1</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">// DFS</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">dfs</span><span class="params">(<span class="type">boolean</span>[] covered, <span class="type">int</span> caseIndex, <span class="type">int</span> selected, <span class="type">int</span> coveredCount)</span> &#123;</span><br><span class="line">        <span class="comment">// 判断当前是否已经覆盖了所有模块</span></span><br><span class="line">        <span class="keyword">if</span> (coveredCount == covered.length) &#123;</span><br><span class="line">            minCount = Math.min(minCount, selected); <span class="comment">// 更新最小测试用例数</span></span><br><span class="line">            <span class="keyword">return</span>;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 如果当前已选择的测试用例数量已经大于或等于最小值，剪枝</span></span><br><span class="line">        <span class="keyword">if</span> (selected &gt;= minCount) &#123;</span><br><span class="line">            <span class="keyword">return</span>;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 递归选择每个测试用例</span></span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> caseIndex; i &lt; cases.length; i++) &#123;</span><br><span class="line">            <span class="type">boolean</span>[] newCov = Arrays.copyOf(covered, covered.length); <span class="comment">// 复制当前已覆盖的模块</span></span><br><span class="line">            <span class="type">int</span> <span class="variable">newCovCount</span> <span class="operator">=</span> coveredCount;</span><br><span class="line"></span><br><span class="line">            <span class="comment">// 更新覆盖状态</span></span><br><span class="line">            <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">j</span> <span class="operator">=</span> <span class="number">0</span>; j &lt; cases[i].length; j++) &#123;</span><br><span class="line">                <span class="keyword">if</span> (cases[i][j] == <span class="number">1</span> &amp;&amp; !newCov[j]) &#123;</span><br><span class="line">                    newCov[j] = <span class="literal">true</span>;</span><br><span class="line">                    newCovCount++;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">            dfs(newCov, i + <span class="number">1</span>, selected + <span class="number">1</span>, newCovCount);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br></pre></td></tr></table></figure><p>不出意外超时了，最后只通过了25%😭，这道题做了半天没a出来，<strong>进而影响了下一道题</strong>。</p><p>再来说一下这道题的正确做法吧，转化成集合去遍历，这里没想到</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> java.util.Scanner;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Main</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">        <span class="type">Scanner</span> <span class="variable">sc</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Scanner</span>(System.in);</span><br><span class="line">        <span class="comment">// 读取测试用例总数 n 和模块总数 m</span></span><br><span class="line">        <span class="type">int</span> <span class="variable">n</span> <span class="operator">=</span> sc.nextInt();</span><br><span class="line">        <span class="type">int</span> <span class="variable">m</span> <span class="operator">=</span> sc.nextInt();</span><br><span class="line">        <span class="type">int</span>[] tests = <span class="keyword">new</span> <span class="title class_">int</span>[n];</span><br><span class="line">        </span><br><span class="line">        <span class="comment">// 将每个测试用例转换为位掩码表示</span></span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i &lt; n; i++) &#123;</span><br><span class="line">            <span class="type">int</span> <span class="variable">mask</span> <span class="operator">=</span> <span class="number">0</span>;</span><br><span class="line">            <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">j</span> <span class="operator">=</span> <span class="number">0</span>; j &lt; m; j++) &#123;</span><br><span class="line">                <span class="type">int</span> <span class="variable">x</span> <span class="operator">=</span> sc.nextInt();</span><br><span class="line">                <span class="keyword">if</span> (x == <span class="number">1</span>) &#123;</span><br><span class="line">                    mask |= (<span class="number">1</span> &lt;&lt; j);</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">            tests[i] = mask;</span><br><span class="line">        &#125;</span><br><span class="line">        </span><br><span class="line">        <span class="comment">// 目标掩码：所有模块都被覆盖（低 m 位全为 1）</span></span><br><span class="line">        <span class="type">int</span> <span class="variable">target</span> <span class="operator">=</span> (<span class="number">1</span> &lt;&lt; m) - <span class="number">1</span>;</span><br><span class="line">        <span class="type">int</span> <span class="variable">ans</span> <span class="operator">=</span> Integer.MAX_VALUE;</span><br><span class="line">        </span><br><span class="line">        <span class="comment">// 枚举所有可能的测试用例子集（采用二进制枚举）</span></span><br><span class="line">      <span class="comment">/*</span></span><br><span class="line"><span class="comment">      暴力枚举，这里没想到</span></span><br><span class="line"><span class="comment">      0 0 0 都不选</span></span><br><span class="line"><span class="comment">      0 0 1 选第一个</span></span><br><span class="line"><span class="comment">      0 1 1 选第一个第二个</span></span><br><span class="line"><span class="comment">      1 1 1 全选</span></span><br><span class="line"><span class="comment">      */</span></span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">s</span> <span class="operator">=</span> <span class="number">0</span>; s &lt; (<span class="number">1</span> &lt;&lt; n); s++) &#123;</span><br><span class="line">            <span class="type">int</span> <span class="variable">unionMask</span> <span class="operator">=</span> <span class="number">0</span>;</span><br><span class="line">            <span class="type">int</span> <span class="variable">cnt</span> <span class="operator">=</span> <span class="number">0</span>;</span><br><span class="line">            <span class="comment">// 遍历子集中的每个测试用例，将其覆盖情况合并</span></span><br><span class="line">            <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i &lt; n; i++) &#123;</span><br><span class="line">              <span class="comment">// 选当前行</span></span><br><span class="line">                <span class="keyword">if</span> ((s &amp; (<span class="number">1</span> &lt;&lt; i)) != <span class="number">0</span>) &#123;</span><br><span class="line">                    unionMask |= tests[i];</span><br><span class="line">                    cnt++;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="comment">// 如果当前子集能够覆盖所有模块，则更新答案</span></span><br><span class="line">            <span class="keyword">if</span> (unionMask == target) &#123;</span><br><span class="line">                ans = Math.min(ans, cnt);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        </span><br><span class="line">        <span class="comment">// 如果没有满足要求的子集，输出 -1；否则输出最小用例数</span></span><br><span class="line">        System.out.println(ans == Integer.MAX_VALUE ? -<span class="number">1</span> : ans);</span><br><span class="line">        sc.close();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br></pre></td></tr></table></figure><h2 id="第二题"><a href="#第二题" class="headerlink" title="第二题"></a>第二题</h2><p><a href="https://codefun2000.com/p/P2846">https://codefun2000.com/p/P2846</a></p><p><img src="2025-04-17-华为416批次笔试/image-20250418105640610.png" alt="image-20250418105640610"></p><p><img src="2025-04-17-华为416批次笔试/image-20250418105657826.png" alt="image-20250418105657826"></p><p>因为第一题没a出来，导致做这题的思路都很乱。一开始想用一个TreeSet去存储图的信息，发现这样做不对。</p><p>然后想着用一个HashMap去存领接表，但是感觉图的构建很麻烦，这是一个双向图，整个思路都是乱的，想先写BFS的代码，写到一半意思到时间可能快不够了，继续做这题做不出来这次笔试就过不了，没办法，只能舍弃了，直接输出“NA”骗了7%的分，惭愧😭。</p><p>后面做完第三题再来看第二题，发现DFS应该也能做，但是没时间了。。。主要是这题图的构建要复杂一点。</p><p><strong>正确做法：</strong></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br><span class="line">132</span><br><span class="line">133</span><br><span class="line">134</span><br><span class="line">135</span><br><span class="line">136</span><br><span class="line">137</span><br><span class="line">138</span><br><span class="line">139</span><br><span class="line">140</span><br><span class="line">141</span><br><span class="line">142</span><br><span class="line">143</span><br><span class="line">144</span><br><span class="line">145</span><br><span class="line">146</span><br><span class="line">147</span><br><span class="line">148</span><br><span class="line">149</span><br><span class="line">150</span><br><span class="line">151</span><br><span class="line">152</span><br><span class="line">153</span><br><span class="line">154</span><br><span class="line">155</span><br><span class="line">156</span><br><span class="line">157</span><br><span class="line">158</span><br><span class="line">159</span><br><span class="line">160</span><br><span class="line">161</span><br><span class="line">162</span><br><span class="line">163</span><br><span class="line">164</span><br><span class="line">165</span><br><span class="line">166</span><br><span class="line">167</span><br><span class="line">168</span><br><span class="line">169</span><br><span class="line">170</span><br><span class="line">171</span><br><span class="line">172</span><br><span class="line">173</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> java.util.*;</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">RouteFinder</span> &#123;</span><br><span class="line">    <span class="comment">// 线路数量</span></span><br><span class="line">    <span class="keyword">static</span> <span class="type">int</span> N;</span><br><span class="line">    <span class="comment">// 起点站</span></span><br><span class="line">    <span class="keyword">static</span> String start;</span><br><span class="line">    <span class="comment">// 终点站</span></span><br><span class="line">    <span class="keyword">static</span> String target;</span><br><span class="line">    <span class="comment">// 存储线路之间的换乘信息，键为线路编号，值为该线路可换乘的线路及换乘站信息</span></span><br><span class="line">    <span class="keyword">static</span> Map&lt;Integer, List&lt;Route&gt;&gt; mp = <span class="keyword">new</span> <span class="title class_">HashMap</span>&lt;&gt;();</span><br><span class="line">    <span class="comment">// 存储每个站点所在的线路，键为站点名称，值为包含该站点的线路编号列表</span></span><br><span class="line">    <span class="keyword">static</span> Map&lt;String, List&lt;Integer&gt;&gt; mp1 = <span class="keyword">new</span> <span class="title class_">HashMap</span>&lt;&gt;();</span><br><span class="line">    <span class="comment">// 记录换乘次数，初始化为 -1</span></span><br><span class="line">    <span class="keyword">static</span> <span class="type">int</span> <span class="variable">cnt</span> <span class="operator">=</span> -<span class="number">1</span>;</span><br><span class="line">    <span class="comment">// 标记是否找到可达路线</span></span><br><span class="line">    <span class="keyword">static</span> <span class="type">boolean</span> <span class="variable">flag</span> <span class="operator">=</span> <span class="literal">false</span>;</span><br><span class="line">    <span class="comment">// 记录到达终点站所在的线路编号</span></span><br><span class="line">    <span class="keyword">static</span> <span class="type">int</span> targ;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 内部类，用于存储线路和换乘站信息</span></span><br><span class="line">    <span class="keyword">static</span> <span class="keyword">class</span> <span class="title class_">Route</span> &#123;</span><br><span class="line">        <span class="comment">// 可换乘的线路编号</span></span><br><span class="line">        <span class="type">int</span> line;</span><br><span class="line">        <span class="comment">// 换乘站名称</span></span><br><span class="line">        String station;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 构造函数，初始化线路和换乘站信息</span></span><br><span class="line">        Route(<span class="type">int</span> line, String station) &#123;</span><br><span class="line">            <span class="built_in">this</span>.line = line;</span><br><span class="line">            <span class="built_in">this</span>.station = station;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 广度优先搜索函数，用于查找从起点站到终点站的最短换乘路线</span></span><br><span class="line">    <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">bfs</span><span class="params">(<span class="type">int</span>[] visited, Set&lt;Integer&gt; tar, <span class="type">int</span>[] father)</span> &#123;</span><br><span class="line">        <span class="comment">// 创建一个队列，用于存储待访问的线路编号</span></span><br><span class="line">        Queue&lt;Integer&gt; qu = <span class="keyword">new</span> <span class="title class_">LinkedList</span>&lt;&gt;();</span><br><span class="line">        <span class="comment">// 将起点站所在的所有线路编号加入队列，并标记为已访问</span></span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> x : mp1.get(start)) &#123;</span><br><span class="line">            qu.add(x);</span><br><span class="line">            visited[x] = <span class="number">1</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">// 当队列不为空且未找到可达路线时，继续搜索</span></span><br><span class="line">        <span class="keyword">while</span> (!qu.isEmpty() &amp;&amp; !flag) &#123;</span><br><span class="line">            <span class="comment">// 换乘次数加 1</span></span><br><span class="line">            cnt++;</span><br><span class="line">            <span class="comment">// 获取当前队列的大小，即当前层的线路数量</span></span><br><span class="line">            <span class="type">int</span> <span class="variable">size</span> <span class="operator">=</span> qu.size();</span><br><span class="line">            <span class="comment">// 遍历当前层的所有线路</span></span><br><span class="line">            <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i &lt; size; i++) &#123;</span><br><span class="line">                <span class="comment">// 取出队列头部的线路编号</span></span><br><span class="line">                <span class="type">int</span> <span class="variable">tmp</span> <span class="operator">=</span> qu.poll();</span><br><span class="line">                <span class="comment">// 如果该线路是终点站所在的线路，标记找到可达路线，记录线路编号并跳出循环</span></span><br><span class="line">                <span class="keyword">if</span> (tar.contains(tmp)) &#123;</span><br><span class="line">                    targ = tmp;</span><br><span class="line">                    flag = <span class="literal">true</span>;</span><br><span class="line">                    <span class="keyword">break</span>;</span><br><span class="line">                &#125;</span><br><span class="line">                <span class="comment">// 遍历该线路可换乘的所有线路</span></span><br><span class="line">                <span class="keyword">for</span> (Route next : mp.getOrDefault(tmp, <span class="keyword">new</span> <span class="title class_">ArrayList</span>&lt;&gt;())) &#123;</span><br><span class="line">                    <span class="comment">// 如果该线路已被访问过，跳过</span></span><br><span class="line">                    <span class="keyword">if</span> (visited[next.line] == <span class="number">1</span>) <span class="keyword">continue</span>;</span><br><span class="line">                    <span class="comment">// 标记该线路为已访问</span></span><br><span class="line">                    visited[next.line] = <span class="number">1</span>;</span><br><span class="line">                    <span class="comment">// 将该线路加入队列</span></span><br><span class="line">                    qu.add(next.line);</span><br><span class="line">                    <span class="comment">// 记录该线路的父线路编号</span></span><br><span class="line">                    father[next.line] = tmp;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">        <span class="comment">// 创建 Scanner 对象，用于读取用户输入</span></span><br><span class="line">        <span class="type">Scanner</span> <span class="variable">scanner</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Scanner</span>(System.in);</span><br><span class="line">        <span class="comment">// 读取线路数量</span></span><br><span class="line">        N = scanner.nextInt();</span><br><span class="line">        <span class="comment">// 消耗掉换行符</span></span><br><span class="line">        scanner.nextLine();</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 二维数组，用于存储线路之间的换乘站信息</span></span><br><span class="line">        String[][] graph = <span class="keyword">new</span> <span class="title class_">String</span>[N][N];</span><br><span class="line">        <span class="comment">// 初始化二维数组，将所有元素设置为 &quot;*&quot;</span></span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i &lt; N; i++) &#123;</span><br><span class="line">            Arrays.fill(graph[i], <span class="string">&quot;*&quot;</span>);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 遍历每条线路</span></span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i &lt; N; i++) &#123;</span><br><span class="line">            <span class="comment">// 读取该线路上的所有站点信息</span></span><br><span class="line">            <span class="type">String</span> <span class="variable">s</span> <span class="operator">=</span> scanner.nextLine();</span><br><span class="line">            <span class="comment">// 将站点信息按空格分割成数组</span></span><br><span class="line">            String[] stations = s.split(<span class="string">&quot; &quot;</span>);</span><br><span class="line">            <span class="comment">// 遍历该线路上的每个站点</span></span><br><span class="line">            <span class="keyword">for</span> (String tmp : stations) &#123;</span><br><span class="line">                <span class="comment">// 如果该站点已经存在于 mp1 中，说明该站点是换乘站</span></span><br><span class="line">                <span class="keyword">if</span> (mp1.containsKey(tmp)) &#123;</span><br><span class="line">                    <span class="comment">// 获取该站点所在的所有线路编号列表</span></span><br><span class="line">                    List&lt;Integer&gt; a = mp1.get(tmp);</span><br><span class="line">                    <span class="comment">// 遍历该站点所在的所有线路</span></span><br><span class="line">                    <span class="keyword">for</span> (<span class="type">int</span> j : a) &#123;</span><br><span class="line">                        <span class="comment">// 更新 mp 中线路之间的换乘信息</span></span><br><span class="line">                        mp.computeIfAbsent(i, k -&gt; <span class="keyword">new</span> <span class="title class_">ArrayList</span>&lt;&gt;()).add(<span class="keyword">new</span> <span class="title class_">Route</span>(j, tmp));</span><br><span class="line">                        <span class="comment">// 更新 graph 中线路之间的换乘站信息</span></span><br><span class="line">                        graph[i][j] = tmp;</span><br><span class="line">                        <span class="comment">// 由于是双向图，更新反向的换乘信息</span></span><br><span class="line">                        mp.computeIfAbsent(j, k -&gt; <span class="keyword">new</span> <span class="title class_">ArrayList</span>&lt;&gt;()).add(<span class="keyword">new</span> <span class="title class_">Route</span>(i, tmp));</span><br><span class="line">                        graph[j][i] = tmp;</span><br><span class="line">                    &#125;</span><br><span class="line">                    <span class="comment">// 将当前线路编号加入该站点所在的线路编号列表</span></span><br><span class="line">                    mp1.get(tmp).add(i);</span><br><span class="line">                &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                    <span class="comment">// 如果该站点是第一次出现，创建一个新的线路编号列表，并将当前线路编号加入其中</span></span><br><span class="line">                    List&lt;Integer&gt; list = <span class="keyword">new</span> <span class="title class_">ArrayList</span>&lt;&gt;();</span><br><span class="line">                    list.add(i);</span><br><span class="line">                    <span class="comment">// 将该站点及其所在的线路编号列表存入 mp1 中</span></span><br><span class="line">                    mp1.put(tmp, list);</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 读取起点站和终点站名称</span></span><br><span class="line">        start = scanner.next();</span><br><span class="line">        target = scanner.next();</span><br><span class="line">        <span class="comment">// 用于标记线路是否已被访问过的数组</span></span><br><span class="line">        <span class="type">int</span>[] visited = <span class="keyword">new</span> <span class="title class_">int</span>[N];</span><br><span class="line">        <span class="comment">// 用于记录每个线路的父线路编号的数组，初始化为 -1</span></span><br><span class="line">        <span class="type">int</span>[] father = <span class="keyword">new</span> <span class="title class_">int</span>[N];</span><br><span class="line">        Arrays.fill(father, -<span class="number">1</span>);</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 如果起点站或终点站不在任何线路上，输出 &quot;NA&quot;</span></span><br><span class="line">        <span class="keyword">if</span> (!mp1.containsKey(start) || !mp1.containsKey(target)) &#123;</span><br><span class="line">            System.out.println(<span class="string">&quot;NA&quot;</span>);</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            <span class="comment">// 创建一个集合，存储终点站所在的所有线路编号</span></span><br><span class="line">            Set&lt;Integer&gt; tar = <span class="keyword">new</span> <span class="title class_">HashSet</span>&lt;&gt;(mp1.get(target));</span><br><span class="line">            <span class="comment">// 调用广度优先搜索函数进行搜索</span></span><br><span class="line">            bfs(visited, tar, father);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 如果未找到可达路线，输出 &quot;NA&quot;</span></span><br><span class="line">        <span class="keyword">if</span> (!flag) &#123;</span><br><span class="line">            System.out.println(<span class="string">&quot;NA&quot;</span>);</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            <span class="comment">// 用于存储最终的路线信息</span></span><br><span class="line">            List&lt;String&gt; result = <span class="keyword">new</span> <span class="title class_">ArrayList</span>&lt;&gt;();</span><br><span class="line">            <span class="comment">// 从终点站所在的线路开始回溯</span></span><br><span class="line">            <span class="type">int</span> <span class="variable">u</span> <span class="operator">=</span> targ;</span><br><span class="line">            <span class="comment">// 将终点站加入结果列表</span></span><br><span class="line">            result.add(target);</span><br><span class="line">            <span class="comment">// 回溯路线，直到找到起点站所在的线路</span></span><br><span class="line">            <span class="keyword">while</span> (father[u] != -<span class="number">1</span>) &#123;</span><br><span class="line">                <span class="comment">// 将换乘站加入结果列表</span></span><br><span class="line">                result.add(graph[father[u]][u]);</span><br><span class="line">                <span class="comment">// 更新当前线路为父线路</span></span><br><span class="line">                u = father[u];</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="comment">// 将起点站加入结果列表</span></span><br><span class="line">            result.add(start);</span><br><span class="line">            <span class="comment">// 获取结果列表的大小</span></span><br><span class="line">            <span class="type">int</span> <span class="variable">n</span> <span class="operator">=</span> result.size();</span><br><span class="line">            <span class="comment">// 输出路线信息，用 &quot;-&quot; 连接各个站点</span></span><br><span class="line">            <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> n - <span class="number">1</span>; i &gt; <span class="number">0</span>; i--) &#123;</span><br><span class="line">                System.out.print(result.get(i) + <span class="string">&quot;-&quot;</span>);</span><br><span class="line">            &#125;</span><br><span class="line">            System.out.println(result.get(<span class="number">0</span>));</span><br><span class="line">            <span class="comment">// 输出总换乘次数（包括起点站和终点站）</span></span><br><span class="line">            System.out.println(<span class="number">2</span> + cnt);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;    </span><br></pre></td></tr></table></figure><h2 id="第三题"><a href="#第三题" class="headerlink" title="第三题"></a>第三题</h2><p><img src="2025-04-17-华为416批次笔试/image-20250418110705215.png" alt="image-20250418110705215"></p><p><img src="2025-04-17-华为416批次笔试/image-20250418110727624.png" alt="image-20250418110727624"></p><p>这道题感觉比前面两题简单多了，有点像LeetCode和合并区间那道题，但是这里排序不能按照字典序进行排，索引比较朴素的思想是将ip地址转化成一个数进行排序。</p><p>我的做法：很奇怪，感觉没啥问题就只a了0.55</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> codefun.com.HuaWei;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> java.util.ArrayList;</span><br><span class="line"><span class="keyword">import</span> java.util.List;</span><br><span class="line"><span class="keyword">import</span> java.util.*;</span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">P2847</span> &#123;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 辅助方法：将IPv4地址转化为整数</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="type">long</span> <span class="title function_">ipToInt</span><span class="params">(String ip)</span> &#123;</span><br><span class="line">        String[] parts = ip.split(<span class="string">&quot;\\.&quot;</span>);</span><br><span class="line">        <span class="type">long</span> <span class="variable">result</span> <span class="operator">=</span> <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i &lt; <span class="number">4</span>; i++) &#123;</span><br><span class="line">            result += Integer.parseInt(parts[i]) * Math.pow(<span class="number">256</span>, <span class="number">3</span> - i);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> result;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> String <span class="title function_">intToIp</span><span class="params">(<span class="type">long</span> ipInt)</span> &#123;</span><br><span class="line">        <span class="type">int</span> <span class="variable">part1</span> <span class="operator">=</span> (<span class="type">int</span>) (ipInt / (<span class="type">int</span>)Math.pow(<span class="number">256</span>,<span class="number">3</span>));</span><br><span class="line">        <span class="type">int</span> <span class="variable">part2</span> <span class="operator">=</span> (<span class="type">int</span>)(ipInt / (<span class="type">int</span>)Math.pow(<span class="number">256</span>,<span class="number">2</span>)) % <span class="number">256</span>;</span><br><span class="line">        <span class="type">int</span> <span class="variable">part3</span> <span class="operator">=</span> (<span class="type">int</span>) ((ipInt / <span class="number">256</span>) % <span class="number">256</span>);</span><br><span class="line">        <span class="type">int</span> <span class="variable">part4</span> <span class="operator">=</span> (<span class="type">int</span>) (ipInt % <span class="number">256</span>);</span><br><span class="line">        <span class="keyword">return</span> part1 + <span class="string">&quot;.&quot;</span> + part2 + <span class="string">&quot;.&quot;</span> + part3 + <span class="string">&quot;.&quot;</span> + part4;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">        <span class="type">Scanner</span> <span class="variable">scanner</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Scanner</span>(System.in);</span><br><span class="line">        <span class="type">int</span> <span class="variable">N</span> <span class="operator">=</span> Integer.parseInt(scanner.nextLine());</span><br><span class="line">        List&lt;<span class="type">long</span>[]&gt; ipRanges = <span class="keyword">new</span> <span class="title class_">ArrayList</span>&lt;&gt;();</span><br><span class="line">        </span><br><span class="line">        <span class="comment">// 读取IP区间</span></span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i &lt; N; i++) &#123;</span><br><span class="line">            <span class="type">String</span> <span class="variable">line</span> <span class="operator">=</span> scanner.nextLine();</span><br><span class="line">            String[] parts = line.split(<span class="string">&quot; &quot;</span>);</span><br><span class="line">            <span class="type">long</span> <span class="variable">startIp</span> <span class="operator">=</span> ipToInt(parts[<span class="number">0</span>]);</span><br><span class="line">            <span class="type">long</span> <span class="variable">endIp</span> <span class="operator">=</span> ipToInt(parts[<span class="number">1</span>]);</span><br><span class="line">            ipRanges.add(<span class="keyword">new</span> <span class="title class_">long</span>[]&#123;startIp, endIp&#125;);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 按照业务需求进行排序</span></span><br><span class="line">        <span class="comment">// 排序规则: 先按IP占用数量 (endIp - startIp + 1)，再按起始IP排序</span></span><br><span class="line">        ipRanges.sort((a, b) -&gt; &#123;</span><br><span class="line">            <span class="type">long</span> <span class="variable">lenA</span> <span class="operator">=</span> a[<span class="number">1</span>] - a[<span class="number">0</span>] + <span class="number">1</span>;</span><br><span class="line">            <span class="type">long</span> <span class="variable">lenB</span> <span class="operator">=</span> b[<span class="number">1</span>] - b[<span class="number">0</span>] + <span class="number">1</span>;</span><br><span class="line">            <span class="keyword">if</span> (lenA == lenB) &#123;</span><br><span class="line">                <span class="keyword">return</span> Long.compare(a[<span class="number">0</span>], b[<span class="number">0</span>]);</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">return</span> Long.compare(lenA, lenB);</span><br><span class="line">        &#125;);</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 贪心算法，选择不重叠的区间</span></span><br><span class="line">        List&lt;<span class="type">long</span>[]&gt; result = <span class="keyword">new</span> <span class="title class_">ArrayList</span>&lt;&gt;();</span><br><span class="line">        <span class="type">long</span> <span class="variable">lastEnd</span> <span class="operator">=</span> -<span class="number">1</span>;</span><br><span class="line">        </span><br><span class="line">        <span class="keyword">for</span> (<span class="type">long</span>[] range : ipRanges) &#123;</span><br><span class="line">            <span class="keyword">if</span> (range[<span class="number">0</span>] &gt; lastEnd) &#123;</span><br><span class="line">                result.add(range);</span><br><span class="line">                lastEnd = range[<span class="number">1</span>];</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        </span><br><span class="line">        <span class="keyword">for</span> (<span class="type">long</span>[] range : result) &#123;</span><br><span class="line">            System.out.println(intToIp(range[<span class="number">0</span>]) + <span class="string">&quot; &quot;</span> + intToIp(range[<span class="number">1</span>]));</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure><p><strong>正确解法：</strong></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> codefun.com.HuaWei;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> java.util.*;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">P2847</span> &#123;</span><br><span class="line">    <span class="comment">// 将IPv4地址转化为整数，使用位运算保证精确性</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="type">long</span> <span class="title function_">ipToInt</span><span class="params">(String ip)</span> &#123;</span><br><span class="line">        String[] parts = ip.split(<span class="string">&quot;\\.&quot;</span>);</span><br><span class="line">        <span class="type">long</span> <span class="variable">result</span> <span class="operator">=</span> <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i &lt; <span class="number">4</span>; i++) &#123;</span><br><span class="line">            result |= (Long.parseLong(parts[i]) &lt;&lt; (<span class="number">24</span> - <span class="number">8</span> * i));</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> result;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 将整数转换回IPv4地址</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> String <span class="title function_">intToIp</span><span class="params">(<span class="type">long</span> ipInt)</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> ((ipInt &gt;&gt; <span class="number">24</span>) &amp; <span class="number">0xFF</span>) + <span class="string">&quot;.&quot;</span> +</span><br><span class="line">                ((ipInt &gt;&gt; <span class="number">16</span>) &amp; <span class="number">0xFF</span>) + <span class="string">&quot;.&quot;</span> +</span><br><span class="line">                ((ipInt &gt;&gt; <span class="number">8</span>) &amp; <span class="number">0xFF</span>) + <span class="string">&quot;.&quot;</span> +</span><br><span class="line">                (ipInt &amp; <span class="number">0xFF</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">        <span class="type">Scanner</span> <span class="variable">scanner</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Scanner</span>(System.in);</span><br><span class="line">        <span class="type">int</span> <span class="variable">N</span> <span class="operator">=</span> Integer.parseInt(scanner.nextLine().trim());  <span class="comment">// 读取业务数量</span></span><br><span class="line">        List&lt;<span class="type">long</span>[]&gt; ipRanges = <span class="keyword">new</span> <span class="title class_">ArrayList</span>&lt;&gt;();</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 读取每个业务的起始和结束IP，将其转为整数存储</span></span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i &lt; N; i++) &#123;</span><br><span class="line">            String[] parts = scanner.nextLine().split(<span class="string">&quot; &quot;</span>);</span><br><span class="line">            <span class="type">long</span> <span class="variable">start</span> <span class="operator">=</span> ipToInt(parts[<span class="number">0</span>]);</span><br><span class="line">            <span class="type">long</span> <span class="variable">end</span> <span class="operator">=</span> ipToInt(parts[<span class="number">1</span>]);</span><br><span class="line">            ipRanges.add(<span class="keyword">new</span> <span class="title class_">long</span>[]&#123;start, end&#125;);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 排序规则：</span></span><br><span class="line">        <span class="comment">// 1) 按结束IP升序</span></span><br><span class="line">        <span class="comment">// 2) 若结束IP相同，按区间长度(端点差+1)升序</span></span><br><span class="line">        <span class="comment">// 3) 若长度相同，按起始IP升序</span></span><br><span class="line">        ipRanges.sort((a, b) -&gt; &#123;</span><br><span class="line">            <span class="keyword">if</span> (a[<span class="number">1</span>] != b[<span class="number">1</span>]) &#123;</span><br><span class="line">                <span class="keyword">return</span> Long.compare(a[<span class="number">1</span>], b[<span class="number">1</span>]);</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="type">long</span> <span class="variable">lenA</span> <span class="operator">=</span> a[<span class="number">1</span>] - a[<span class="number">0</span>] + <span class="number">1</span>;</span><br><span class="line">            <span class="type">long</span> <span class="variable">lenB</span> <span class="operator">=</span> b[<span class="number">1</span>] - b[<span class="number">0</span>] + <span class="number">1</span>;</span><br><span class="line">            <span class="keyword">if</span> (lenA != lenB) &#123;</span><br><span class="line">                <span class="keyword">return</span> Long.compare(lenA, lenB);</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">return</span> Long.compare(a[<span class="number">0</span>], b[<span class="number">0</span>]);</span><br><span class="line">        &#125;);</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 贪心选择：选择不重叠、最早结束的区间以最大化业务数量</span></span><br><span class="line">        List&lt;<span class="type">long</span>[]&gt; result = <span class="keyword">new</span> <span class="title class_">ArrayList</span>&lt;&gt;();</span><br><span class="line">        <span class="type">long</span> <span class="variable">lastEnd</span> <span class="operator">=</span> -<span class="number">1</span>;</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">long</span>[] range : ipRanges) &#123;</span><br><span class="line">            <span class="keyword">if</span> (range[<span class="number">0</span>] &gt; lastEnd) &#123;</span><br><span class="line">                result.add(range);</span><br><span class="line">                lastEnd = range[<span class="number">1</span>];</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 输出最终规划的IP区间</span></span><br><span class="line">        <span class="keyword">for</span> (<span class="type">long</span>[] r : result) &#123;</span><br><span class="line">            System.out.println(intToIp(r[<span class="number">0</span>]) + <span class="string">&quot; &quot;</span> + intToIp(r[<span class="number">1</span>]));</span><br><span class="line">        &#125;</span><br><span class="line">        scanner.close();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure><p>主要改动了以下几处：</p><ol><li><p><strong>IP 转换方法优化</strong></p><ul><li><p>原来在 <code>ipToInt</code> 和 <code>intToIp</code> 中使用了 <code>Math.pow</code>，返回 <code>double</code> 再转 <code>long</code>，存在精度隐患。</p></li><li><p>要改成了位移运算：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">result |= (Long.parseLong(parts[i]) &lt;&lt; (<span class="number">24</span> - <span class="number">8</span> * i));</span><br></pre></td></tr></table></figure><p>和</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">((ipInt &gt;&gt; <span class="number">24</span>) &amp; <span class="number">0xFF</span>)</span><br></pre></td></tr></table></figure><p>这样既更高效，也完全精确。</p></li></ul></li><li><p><strong>排序规则</strong></p><ul><li>原先只按“区间长度（len）”和“起始 IP”排序，忽略了“结束 IP”对贪心选择的影响。</li><li>新版改为三层优先级：</li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 1) 按结束 IP 升序  </span></span><br><span class="line"><span class="comment">// 2) 若结束 IP 相同，再按区间长度升序  </span></span><br><span class="line"><span class="comment">// 3) 若长度相同，再按起始 IP 升序</span></span><br></pre></td></tr></table></figure><p>这样能保证贪心算法每次都选最早结束、最小占用的区间，以满足“最多业务数”、“最少地址量”和“起始最小”三重要求。</p></li></ol><p>这些改动确保了：</p><ul><li>IP 转换无精度误差</li><li>排序严格符合题意的三重比较</li><li>贪心算法能真正输出示例中预期的两个区间。</li></ul><p>反思：没有考虑数据精度对结果的影响。只是运气好过了0.55</p><h2 id="总结："><a href="#总结：" class="headerlink" title="总结："></a>总结：</h2><p>这次算法做的不太好，主要有以下这个原因：</p><ul><li>​    1.不敢用IDE写，用记事本导致写的优点磕磕绊绊</li><li>​    2.第一题没做出来影响了心态，然后做第二题脑袋一团浆糊。</li><li>​    3.做这场笔试之前，刷了很多次华为笔试真题。自己平时做感觉没问题，在考场上做却错漏百出，只能说平时和考场还是不一样。</li><li>​    4.太想进华为，导致做笔试压力很大。心情不平和影响了自己的思路。</li></ul><p>总而言之，继续多刷算法，继续加油！</p>]]></content>
    
    
    <summary type="html">🥧华为416批次笔试</summary>
    
    
    
    <category term="刷题" scheme="https://outoflovenicoo.github.io/categories/%E5%88%B7%E9%A2%98/"/>
    
    
    <category term="笔试" scheme="https://outoflovenicoo.github.io/tags/%E7%AC%94%E8%AF%95/"/>
    
  </entry>
  
  <entry>
    <title>Java集合学习</title>
    <link href="https://outoflovenicoo.github.io/posts/2025-04-17-Java%E9%9B%86%E5%90%88%E5%AD%A6%E4%B9%A0.html"/>
    <id>https://outoflovenicoo.github.io/posts/2025-04-17-Java%E9%9B%86%E5%90%88%E5%AD%A6%E4%B9%A0.html</id>
    <published>2025-04-17T10:19:03.000Z</published>
    <updated>2025-04-17T14:00:00.000Z</updated>
    
    <content type="html"><![CDATA[<h1 id="Java集合学习"><a href="#Java集合学习" class="headerlink" title="Java集合学习"></a>Java集合学习</h1><h2 id="个人总结思维导图："><a href="#个人总结思维导图：" class="headerlink" title="个人总结思维导图："></a>个人总结思维导图：</h2><p><img src="2025-04-17-Java集合学习/image-20250419111601404.png" alt="image-20250419111601404"></p><p>​    在面试的过程中，被问到了一些基础问题，Java的集合框架。当时回答的优点不太好，很多概念都有点模糊，根本原因是没有自己总结过，所以现在特地总结一下，当然这个总结可能还不完善，后续会不断迭代优化。</p><h2 id="单列集合部分"><a href="#单列集合部分" class="headerlink" title="单列集合部分"></a>单列集合部分</h2><h3 id="ArrayList"><a href="#ArrayList" class="headerlink" title="ArrayList"></a>ArrayList</h3><p>​    ArrayList是<code>List</code>接口的一个实现类。它的默认初始容量为0，当首次添加元素时，其容量会扩充到10。这种动态扩容的机制使得ArrayList在存储元素时具有一定的灵活性，适合元素数量不确定的场景。</p><h3 id="HashSet"><a href="#HashSet" class="headerlink" title="HashSet"></a>HashSet</h3><p>​    HashSet是<code>Set</code>接口的实现类，其实现原理基于哈希值。当向HashSet中加入对象时，会先计算对象的<code>hashcode</code>值来判断对象加入的位置，同时也会与其他已加入对象的<code>hashcode</code>值作比较。如果没有相同的<code>hashcode</code>值，HashSet会假设对象没有重复出现；但如果发现有相同<code>hashcode</code>值的对象，这时会调用<code>equals()</code>方法来检查对象是否真的相同，若两者相同，HashSet就不会让加入操作成功，以此保证集合中元素的唯一性。</p><h3 id="Queue与Deque"><a href="#Queue与Deque" class="headerlink" title="Queue与Deque"></a>Queue与Deque</h3><p>​    <code>Queue</code>（队列）接口有多种实现，比如<code>PriorityQueue</code>（优先队列）和<code>BlockingQueue</code>（阻塞队列，其下又细分<code>ArrayBlockingQueue</code>、<code>LinkedBlockingQueue</code>等）。<code>Deque</code>（双端队列）接口也有对应的实现类，如<code>ArrayDeque</code>（每次扩容为原来的2倍+1）和<code>LinkedList</code>，这些实现类为不同的队列操作需求提供了支持。</p><h3 id="Stack"><a href="#Stack" class="headerlink" title="Stack"></a>Stack</h3><p><code>Stack</code>（栈）不推荐使用，主要有两个原因。一是其线程安全机制低效且冗余，在多线程环境下性能不佳；二是它有着不合理的继承关系，<code>Stack</code>继承自<code>Vector</code>，而<code>Vector</code>本质上是一个基于数组的动态数组，是“可增长的对象数组”，并非专门为栈（LIFO，后进先出）设计的数据结构，这种设计上的不合理导致<code>Stack</code>在实际应用中存在诸多问题。</p><h2 id="双列集合部分"><a href="#双列集合部分" class="headerlink" title="双列集合部分"></a>双列集合部分</h2><h3 id="HashMap详解"><a href="#HashMap详解" class="headerlink" title="HashMap详解"></a>HashMap详解</h3><h4 id="实现原理"><a href="#实现原理" class="headerlink" title="实现原理"></a>实现原理</h4><p>​    HashMap的工作原理基于哈希表。它通过计算键的哈希值，并将其转化为数组索引，从而快速定位键值对的存储位置。在理想情况下，哈希函数能将键均匀分布到哈希表中，以最小化哈希冲突。在Java 1.7中，HashMap主要使用链表来解决哈希冲突，将具有相同哈希值的键值对链接在一起；但在Java 1.8中，为了进一步提高性能，当链表长度和数组长度超过一定阈值时，链表会转换为红黑树。红黑树作为一种自平衡的二叉搜索树，能够在哈希冲突较多时提供更快的查找、插入和删除操作功能。这样，HashMap结合哈希表、链表和红黑树的原理，实现了高效的键值对存储和查找功能。</p><h4 id="扩容机制"><a href="#扩容机制" class="headerlink" title="扩容机制"></a>扩容机制</h4><p>​    HashMap的扩容触发条件有两个：一是元素个数大于负载因子乘以桶大小；二是桶内元素个数大于8且桶的个数小于64时也会触发扩容。扩容时，会重新计算元素的位置，计算方式为<code>(n-1) &amp; hash</code>（<code>n</code>为新的容量），新的位置要么是原来的位置，要么是原来的位置加上旧容量。</p><p>​    需要注意的是，HashMap扩容时，不会对元素对象本身进行复制，而是将元素对象的引用迁移到新的哈希表中，然后根据新的容量重新计算元素在新哈希表中的位置。</p><h3 id="ConcurrentHashMap在JDK8中的实现"><a href="#ConcurrentHashMap在JDK8中的实现" class="headerlink" title="ConcurrentHashMap在JDK8中的实现"></a>ConcurrentHashMap在JDK8中的实现</h3><h4 id="put方法安全机制"><a href="#put方法安全机制" class="headerlink" title="put方法安全机制"></a>put方法安全机制</h4><p>​    在JDK8中，ConcurrentHashMap采用了分段锁，同时使用CAS（Compare and Swap，比较并交换）和<code>synchronized</code>来保证线程安全。其<code>put</code>方法的安全保证步骤如下：首先计算哈希值；接着判断数组是否初始化；然后根据哈希值定位到对应的桶位置；再判断桶是否为空，若为空则使用CAS操作尝试将新节点插入到该位置，若CAS操作成功，插入完成，若失败，说明有其他线程已经插入了节点，继续后续步骤；之后检查桶头节点的哈希值是否为<code>MOVED</code>（表示该桶正在进行扩容迁移），若是则协助进行扩容；最后加锁插入或更新，对桶的头节点使用<code>synchronized</code>关键字加锁，然后遍历链表或红黑树，若找到相同的键，更新其值，若未找到，将新节点插入到链表尾部（链表长度小于8）或插入到红黑树中（链表长度大于等于8且数组长度大于等于64），若插入后链表长度达到8且数组长度小于64，进行数组扩容；若数组长度大于等于64，将链表转换为红黑树。</p><h4 id="扩容机制-1"><a href="#扩容机制-1" class="headerlink" title="扩容机制"></a>扩容机制</h4><p>​    ConcurrentHashMap的扩容机制较为复杂。初始化迁移任务时，当一个线程发现需要扩容时，会先创建一个新的数组，其容量是原数组的两倍，同时，会将<code>sizeCtl</code>设置为一个负数，表示正在进行扩容操作，并记录参与扩容的线程数。多线程协助迁移时，ConcurrentHashMap支持多线程协助进行扩容操作，每个线程会领取一个或多个桶的迁移任务，将原数组中对应桶的节点迁移到新数组中，在迁移过程中，使用<code>ForwardingNode</code>节点标记原数组中已经迁移完成的桶，其他线程在访问这些桶时，会自动跳转到新数组中继续操作。链表迁移时，对于链表节点，会根据节点的哈希值重新计算在新数组中的位置，将链表拆分成两个链表，分别放入新数组的不同位置。红黑树迁移时，对于红黑树节点，同样会根据哈希值重新计算位置，可能会将红黑树拆分成两个链表或红黑树，再放入新数组中。当所有的迁移任务都完成后，将新数组替换原数组，扩容操作结束，同时，将<code>sizeCtl</code>更新为新的阈值。</p><h3 id="HashMap与HashTable的区别"><a href="#HashMap与HashTable的区别" class="headerlink" title="HashMap与HashTable的区别"></a>HashMap与HashTable的区别</h3><h4 id="线程安全"><a href="#线程安全" class="headerlink" title="线程安全"></a>线程安全</h4><p>​    HashTable是线程安全的，它的<code>put</code>、<code>get</code>等方法都使用<code>synchronized</code>关键字进行同步控制；而HashMap是非线程安全的，在多线程环境下如果不进行额外的同步控制，可能会出现数据不一致等问题。</p><h4 id="对null键值的支持"><a href="#对null键值的支持" class="headerlink" title="对null键值的支持"></a>对null键值的支持</h4><p>​    HashMap允许键和值为<code>null</code>，但是只能有一个<code>null</code>键，值可以有多个<code>null</code>；而HashTable不允许键或值为<code>null</code>，若尝试将<code>null</code>键或值放入HashTable中，会抛出<code>NullPointerException</code>。</p><h4 id="初始容量与扩容"><a href="#初始容量与扩容" class="headerlink" title="初始容量与扩容"></a>初始容量与扩容</h4><p>​    HashMap的初始容量为16（默认情况下），负载因子为0.75；HashTable的初始容量为11，负载因子同样为0.75。在扩容方面，HashMap扩容时新容量是原容量的2倍；HashTable扩容时新容量是原容量的2倍+1。</p><h4 id="哈希值计算"><a href="#哈希值计算" class="headerlink" title="哈希值计算"></a>哈希值计算</h4><p>​    HashMap在计算哈希值时，对哈希值进行了高位运算，以优化哈希值在数组中的分布，减少哈希冲突；而HashTable直接使用键的<code>hashCode()</code>方法返回的值作为哈希值，没有进行额外的处理。</p><p>总之，Java集合框架中的这些知识点在实际开发中非常重要，理解它们的实现原理和特性，能够帮助我们更合理地选择和使用集合类，写出高效、稳定的代码。 </p><h2 id="参考博客"><a href="#参考博客" class="headerlink" title="参考博客"></a>参考博客</h2><p><a href="https://javabetter.cn/collection/hashmap.html#_05%E3%80%81%E5%B0%8F%E7%BB%93">HashMap详解</a></p><p><a href="https://javaguide.cn/java/collection/hashmap-source-code.html">HashMap源码</a></p>]]></content>
    
    
    <summary type="html">🥧Java集合学习</summary>
    
    
    
    <category term="学习" scheme="https://outoflovenicoo.github.io/categories/%E5%AD%A6%E4%B9%A0/"/>
    
    
    <category term="思维导图" scheme="https://outoflovenicoo.github.io/tags/%E6%80%9D%E7%BB%B4%E5%AF%BC%E5%9B%BE/"/>
    
  </entry>
  
  <entry>
    <title>深入探讨多线程操作数组背后的CPU伪共享与MESI协议</title>
    <link href="https://outoflovenicoo.github.io/posts/2025-04-01-%E6%B7%B1%E5%85%A5%E6%8E%A2%E8%AE%A8%E5%A4%9A%E7%BA%BF%E7%A8%8B%E6%93%8D%E4%BD%9C%E6%95%B0%E7%BB%84%E8%83%8C%E5%90%8E%E7%9A%84CPU%E4%BC%AA%E5%85%B1%E4%BA%AB%E4%B8%8EMESI%E5%8D%8F%E8%AE%AE.html"/>
    <id>https://outoflovenicoo.github.io/posts/2025-04-01-%E6%B7%B1%E5%85%A5%E6%8E%A2%E8%AE%A8%E5%A4%9A%E7%BA%BF%E7%A8%8B%E6%93%8D%E4%BD%9C%E6%95%B0%E7%BB%84%E8%83%8C%E5%90%8E%E7%9A%84CPU%E4%BC%AA%E5%85%B1%E4%BA%AB%E4%B8%8EMESI%E5%8D%8F%E8%AE%AE.html</id>
    <published>2025-04-01T10:19:03.000Z</published>
    <updated>2025-04-12T14:00:00.000Z</updated>
    
    <content type="html"><![CDATA[<h2 id="思维导图：">思维导图：</h2><p><img src="2025-04-01-%E6%B7%B1%E5%85%A5%E6%8E%A2%E8%AE%A8%E5%A4%9A%E7%BA%BF%E7%A8%8B%E6%93%8D%E4%BD%9C%E6%95%B0%E7%BB%84%E8%83%8C%E5%90%8E%E7%9A%84CPU%E4%BC%AA%E5%85%B1%E4%BA%AB%E4%B8%8EMESI%E5%8D%8F%E8%AE%AE/diagram.png" alt=""></p><h2 id="前言：">前言：</h2><p>这是一道腾讯的面试题，通过这个问题我理解了CPU缓存的一致性怎么保障的，具体场景如下：</p><p>当我们面对这样一个场景：n个线程去操纵数组的n个元素，编号为i的线程只会操作下标为i的数组元素 <code>arr[i]++</code>，看似每个线程各司其职，互不干扰，然而实际运行中却可能出现性能问题。这背后涉及CPU缓存结构、伪共享问题、MESI协议以及CPU Cache数据的写入方式，下面我们逐步分析。</p><h2 id="一、CPU缓存结构：L1、L2、L3">一、CPU缓存结构：L1、L2、L3</h2><p>在现代多核CPU架构中，缓存系统分为多个层级：</p><ul><li><p><strong>L1缓存</strong>：每个CPU核心都有独立的L1缓存，且进一步细分为L1数据缓存（存放数据）和L1指令缓存（存放指令）。它的速度最快，但容量最小，通常只有几十KB。例如，在一些CPU中，L1数据缓存和指令缓存可能各为32KB。</p></li><li><p><strong>L2缓存</strong>：同样每个核心独立拥有，容量比L1大，速度稍慢于L1。一般为几百KB到几MB不等，例如某些CPU的L2缓存可能是256KB或512KB。它的作用是在L1未命中时，为核心提供数据和指令。</p></li><li><p><strong>L3缓存</strong>：通常为多个核心共享，容量更大，速度相对L1、L2更慢。L3缓存可以达到几MB甚至几十MB，例如一些高端CPU的L3缓存可能为12MB或更高。它作为更大范围的缓存池，减少核心对内存的直接访问。</p></li></ul><p>数据在内存与缓存之间以 **Cache Line**（缓存行，通常为64字节）为单位传输。当CPU读取数据时，会将包含目标数据的整个Cache Line读入缓存。</p><h2 id="二、CPU-Cache数据的写入方式">二、CPU Cache数据的写入方式</h2><h3 id="写直达（Write-Through）">写直达（Write - Through）</h3><p>写直达是指CPU在写入数据到Cache时，会同时将数据写入内存。具体流程为：当CPU执行写入数据操作时，先检查数据是否在CPU Cache中。如果在，直接将数据写入Cache Block；如果不在，则先将数据写入内存，再完成操作。这种方式的优点是能保证内存和Cache中的数据始终一致，但每次写入都需要访问内存，会增加内存总线的流量，降低写入效率。在多线程伪共享场景中，写直达会频繁触发内存写入操作，引发更多的总线事务，导致其他核心更频繁地感知到Cache Line的变化，加剧伪共享带来的性能损耗。</p><h3 id="写回（Write-Back）">写回（Write - Back）</h3><p>写回策略下，CPU先将数据写入Cache Block，并标记该Cache Block为“脏”（已修改）。当Cache Block需要被替换（例如新的数据要存入，而Cache已满）时，才将脏数据写回内存。具体流程为：CPU将数据写入Cache Block后，检查数据是否在其他CPU Cache中。如果不在，直接标记Cache Block为脏；如果在，则需要先使其他核心中相同的Cache Line失效（通过MESI协议），然后标记当前Cache Block为脏。写回方式减少了内存写入次数，提升了写入效率，但存在数据不一致的风险（在数据写回内存前，内存中的数据是旧的）。在伪共享场景中，写回虽然减少了内存写入，但一个核心对Cache Block的修改（标记为脏）会通过MESI协议使其他核心的相同Cache Line失效，当其他核心后续操作同属一个Cache Line的元素时，需要重新读取数据，这一过程依然会产生缓存状态切换和数据同步开销。</p><h2 id="三、伪共享问题：隐藏的性能杀手">三、伪共享问题：隐藏的性能杀手</h2><h3 id="伪共享的定义与成因">伪共享的定义与成因</h3><p>伪共享指多个线程操作不同变量，但这些变量因存储在同一个Cache Line中，导致彼此的操作互相影响。例如，在上述多线程操作数组的场景中，假设数组在内存中连续存储，一个Cache Line（64字节）可以存放16个 <code>int</code> 类型的数组元素（每个 <code>int</code> 占4字节）。若线程A操作 <code>arr[i]</code>，线程B操作 <code>arr[j]</code>（<code>i</code> 与 <code>j</code> 对应的元素在同一个Cache Line），尽管逻辑上两者无直接关联，但硬件层面的缓存机制会让它们产生交互。</p><h3 id="伪共享如何影响性能">伪共享如何影响性能</h3><p>当一个线程修改Cache Line中的数据（如 <code>arr[i]++</code>），根据MESI协议，该Cache Line状态会变为“已修改”（写回策略）或触发内存写入（写直达策略），其他核心中相同的Cache Line会被标记为“已失效”。若其他线程此时要操作同属一个Cache Line的其他元素，需重新从内存或其他核心获取数据，这一过程涉及缓存状态的频繁切换（如从“共享”到“已失效”再到重新加载）、数据同步以及总线通信开销。即使这些线程操作的是不同变量，也会因伪共享导致大量不必要的缓存同步操作，严重影响程序性能。</p><h2 id="四、MESI协议：缓存一致性的保障">四、MESI协议：缓存一致性的保障</h2><p>MESI协议定义了Cache Line的四种状态，用于保证多核CPU缓存一致性：</p><ul><li><p><strong>独占（Exclusive）</strong>：该Cache Line只在当前核心缓存中，且数据与内存一致。此时其他核心没有该Cache Line的副本。</p></li><li><p><strong>共享（Shared）</strong>：多个核心缓存中都有该Cache Line，且数据与内存一致。多个核心可以同时读取该Cache Line中的数据。</p></li><li><p><strong>已修改（Modified）</strong>：该Cache Line在当前核心缓存中被修改，与内存不一致。其他核心若要读取该数据，需先从当前核心获取最新数据，当前核心会在适当时候将数据写回内存。</p></li><li><p><strong>已失效（Invalidated）</strong>：该Cache Line在当前核心缓存中失效，需从内存或其他核心重新获取数据。</p></li></ul><p>在伪共享场景中，一个核心对Cache Line的修改会触发MESI协议的状态变更，导致其他核心的相同Cache Line失效，进而引发一系列数据同步操作，这就是伪共享影响性能的底层机制。</p><h2 id="五、解决伪共享：让缓存行“各司其职”">五、解决伪共享：让缓存行“各司其职”</h2><p>最直接的解决方式是通过字节填充，确保每个数组元素或相关变量单独占据一个Cache Line。在Java中，可以使用 <code>@Contended</code> 注解（需开启JVM参数 <code>-XX:-RestrictContended</code>）来实现。例如：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> sun.misc.Contended;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">ArrayExample</span> &#123;</span><br><span class="line">    <span class="meta">@Contended</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">volatile</span> <span class="type">long</span>[] arr;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="title function_">ArrayExample</span><span class="params">(<span class="type">int</span> size)</span> &#123;</span><br><span class="line">        arr = <span class="keyword">new</span> <span class="title class_">long</span>[size];</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">increment</span><span class="params">(<span class="type">int</span> i)</span> &#123;</span><br><span class="line">        arr[i]++;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>或者手动添加填充字段：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">PaddedLong</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">volatile</span> <span class="type">long</span> value;</span><br><span class="line">    <span class="comment">// 填充7个long类型字段，共56字节，加上value本身8字节，刚好占满一个64字节的Cache Line</span></span><br><span class="line">    <span class="keyword">private</span> <span class="type">long</span> p1, p2, p3, p4, p5, p6, p7; </span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">ArrayExample</span> &#123;</span><br><span class="line">    <span class="keyword">private</span> PaddedLong[] arr;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="title function_">ArrayExample</span><span class="params">(<span class="type">int</span> size)</span> &#123;</span><br><span class="line">        arr = <span class="keyword">new</span> <span class="title class_">PaddedLong</span>[size];</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i &lt; size; i++) &#123;</span><br><span class="line">            arr[i] = <span class="keyword">new</span> <span class="title class_">PaddedLong</span>();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">increment</span><span class="params">(<span class="type">int</span> i)</span> &#123;</span><br><span class="line">        arr[i].value++;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>通过上述方式，每个元素或包含元素的对象能独立占据Cache Line，避免因伪共享导致的性能损耗。</p><p>总结来看，多线程操作数组元素时，看似简单的逻辑在底层硬件（CPU缓存结构、Cache数据写入方式）与缓存协议（MESI协议）的影响下可能产生性能问题。其实在实际开发中，我们很少会多线程去操作一个数组，不过这个问题让我对CPU缓存一致性有了更深的理解，很有意义。</p><h2 id="参考博客：">参考博客：</h2><p><a href="https://xiaolincoding.com/os/1_hardware/cpu_mesi.html#cpu-cache-%E7%9A%84%E6%95%B0%E6%8D%AE%E5%86%99%E5%85%A5">2.4 CPU 缓存一致性</a></p><p><a href="https://mp.weixin.qq.com/s/PDUqwAIaUxNkbjvRfovaCg">十张图介绍MESI</a></p>]]></content>
    
    
    <summary type="html">🥧深入探讨多线程操作数组背后的CPU伪共享与MESI协议</summary>
    
    
    
    <category term="学习" scheme="https://outoflovenicoo.github.io/categories/%E5%AD%A6%E4%B9%A0/"/>
    
    
    <category term="思维导图" scheme="https://outoflovenicoo.github.io/tags/%E6%80%9D%E7%BB%B4%E5%AF%BC%E5%9B%BE/"/>
    
  </entry>
  
  <entry>
    <title>根据字符串数组构建一颗二叉树</title>
    <link href="https://outoflovenicoo.github.io/posts/2025-03-25-%E6%A0%B9%E6%8D%AE%E5%AD%97%E7%AC%A6%E4%B8%B2%E6%95%B0%E7%BB%84%E6%9E%84%E5%BB%BA%E4%B8%80%E9%A2%97%E4%BA%8C%E5%8F%89%E6%A0%91.html"/>
    <id>https://outoflovenicoo.github.io/posts/2025-03-25-%E6%A0%B9%E6%8D%AE%E5%AD%97%E7%AC%A6%E4%B8%B2%E6%95%B0%E7%BB%84%E6%9E%84%E5%BB%BA%E4%B8%80%E9%A2%97%E4%BA%8C%E5%8F%89%E6%A0%91.html</id>
    <published>2025-03-25T07:19:03.000Z</published>
    <updated>2025-03-25T14:00:00.000Z</updated>
    
    <content type="html"><![CDATA[<p><strong>在面试手撕的时候，经常需要根据输入的字符串构建一颗树，由于第一次做，磕磕绊绊才写出来，这里记录一下吧</strong></p><h3 id="样例"><a href="#样例" class="headerlink" title="样例"></a>样例</h3><p>根据字符串 <code>[1,2,3,null,4,null,5]</code> 构建二叉树时，需按照 <strong>层序遍历顺序</strong> 解析节点值，其中 <code>null</code> 表示空节点。以下是构建过程和结果：</p><h3 id="构建规则"><a href="#构建规则" class="headerlink" title="构建规则"></a><strong>构建规则</strong></h3><ol><li><strong>根节点</strong>：字符串中第一个非 <code>null</code> 的值（此处为 <code>1</code>）。</li><li><strong>层序填充</strong>：从根节点开始，按 <strong>左子节点 → 右子节点</strong> 的顺序依次填充后续节点：<ol><li>若当前节点为 <code>null</code>，则跳过其左右子节点。</li><li>空值（<code>null</code>）仅表示节点不存在，不参与树结构。</li></ol></li></ol><h3 id="详细构建步骤"><a href="#详细构建步骤" class="headerlink" title="详细构建步骤"></a><strong>详细构建步骤</strong></h3><h4 id="第-1-层（根节点）"><a href="#第-1-层（根节点）" class="headerlink" title="第 1 层（根节点）"></a><strong>第 1 层（根节点）</strong></h4><ul><li>节点值：<code>1</code>根节点为 <code>1</code>，对应位置 <code>i=0</code>。</li></ul><h4 id="第-2-层（根节点的左右子节点）"><a href="#第-2-层（根节点的左右子节点）" class="headerlink" title="第 2 层（根节点的左右子节点）"></a><strong>第 2 层（根节点的左右子节点）</strong></h4><ul><li>左子节点：位置 <code>i=1</code>，值为 <code>2</code>，非空，作为 <code>1</code> 的左子节点。 </li><li>右子节点：位置 <code>i=2</code>，值为 <code>3</code>，非空，作为 <code>1</code> 的右子节点。 </li></ul><h4 id="第-3-层（第-2-层节点的左右子节点）"><a href="#第-3-层（第-2-层节点的左右子节点）" class="headerlink" title="第 3 层（第 2 层节点的左右子节点）"></a><strong>第 3 层（第 2 层节点的左右子节点）</strong></h4><ul><li><strong>节点</strong> <strong><code>2</code></strong>的子节点： <ul><li>左子节点：位置 <code>i=3</code>，值为 <code>null</code>，跳过。 </li><li>右子节点：位置 <code>i=4</code>，值为 <code>4</code>，非空，作为 <code>2</code> 的右子节点。 </li></ul></li><li><strong>节点</strong> <strong><code>3</code></strong> 的子节点： <ul><li>左子节点：位置 <code>i=5</code>，值为 <code>null</code>，跳过。 </li><li>右子节点：位置 <code>i=6</code>，值为 <code>5</code>，非空，作为 <code>3</code> 的右子节点。 </li></ul></li></ul><h4 id="后续节点"><a href="#后续节点" class="headerlink" title="后续节点"></a><strong>后续节点</strong></h4><p>字符串中剩余内容（末尾逗号）可忽略，无有效节点。</p><h3 id="最终二叉-树结构"><a href="#最终二叉-树结构" class="headerlink" title="最终二叉**树结构**"></a><strong>最终二叉**</strong>树结构**</h3><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">  1</span><br><span class="line"> / \</span><br><span class="line">2   3</span><br><span class="line"> \   \</span><br><span class="line">  4   5</span><br></pre></td></tr></table></figure><ul><li><strong>根节点</strong>：<code>1</code></li><li><strong>左子树</strong>：以 <code>2</code> 为根，其右子节点为 <code>4</code>。 </li><li><strong>右子树</strong>：以 <code>3</code> 为根，其右子节点为 <code>5</code>。 </li></ul><h3 id="验证层序遍历"><a href="#验证层序遍历" class="headerlink" title="验证层序遍历"></a><strong>验证层序遍历</strong></h3><p>构建后的二叉树层序遍历结果与输入字符串一致（忽略 <code>null</code> 后的有效节点）： </p><p><code>[1, 2, 3, 4, 5]</code>，符合预期。</p><h3 id="代码："><a href="#代码：" class="headerlink" title="代码："></a>代码：</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> java.util.LinkedList;</span><br><span class="line"><span class="keyword">import</span> java.util.Queue;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 定义二叉树节点类</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">TreeNode</span> &#123;</span><br><span class="line">    <span class="type">int</span> val;</span><br><span class="line">    TreeNode left;</span><br><span class="line">    TreeNode right;</span><br><span class="line">    TreeNode(<span class="type">int</span> x) &#123; val = x; &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">BuildBinaryTree</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> TreeNode <span class="title function_">buildTree</span><span class="params">(String str)</span> &#123;</span><br><span class="line">        <span class="comment">// 去除首尾的方括号</span></span><br><span class="line">        str = str.substring(<span class="number">1</span>, str.length() - <span class="number">1</span>);</span><br><span class="line">        <span class="keyword">if</span> (str.isEmpty()) &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">null</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        String[] values = str.split(<span class="string">&quot;,&quot;</span>);</span><br><span class="line">        <span class="type">TreeNode</span> <span class="variable">root</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">TreeNode</span>(Integer.parseInt(values[<span class="number">0</span>]));</span><br><span class="line">        Queue&lt;TreeNode&gt; queue = <span class="keyword">new</span> <span class="title class_">LinkedList</span>&lt;&gt;();</span><br><span class="line">        queue.offer(root);</span><br><span class="line">        <span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">1</span>;</span><br><span class="line">        <span class="keyword">while</span> (!queue.isEmpty() &amp;&amp; i &lt; values.length) &#123;</span><br><span class="line">            <span class="type">TreeNode</span> <span class="variable">node</span> <span class="operator">=</span> queue.poll();</span><br><span class="line">            <span class="keyword">if</span> (!values[i].equals(<span class="string">&quot;null&quot;</span>)) &#123;</span><br><span class="line">                node.left = <span class="keyword">new</span> <span class="title class_">TreeNode</span>(Integer.parseInt(values[i]));</span><br><span class="line">                queue.offer(node.left);</span><br><span class="line">            &#125;</span><br><span class="line">            i++;</span><br><span class="line">            <span class="keyword">if</span> (i &lt; values.length &amp;&amp; !values[i].equals(<span class="string">&quot;null&quot;</span>)) &#123;</span><br><span class="line">                node.right = <span class="keyword">new</span> <span class="title class_">TreeNode</span>(Integer.parseInt(values[i]));</span><br><span class="line">                queue.offer(node.right);</span><br><span class="line">            &#125;</span><br><span class="line">            i++;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> root;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">        <span class="type">String</span> <span class="variable">input</span> <span class="operator">=</span> <span class="string">&quot;[1,2,3,null,4,null,5]&quot;</span>;</span><br><span class="line">        <span class="type">TreeNode</span> <span class="variable">root</span> <span class="operator">=</span> buildTree(input);</span><br><span class="line">        <span class="comment">// 这里可以添加遍历二叉树的代码来验证结果</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;    </span><br></pre></td></tr></table></figure>]]></content>
    
    
    <summary type="html">🥧根据字符串数组构建一颗二叉树</summary>
    
    
    
    <category term="刷题" scheme="https://outoflovenicoo.github.io/categories/%E5%88%B7%E9%A2%98/"/>
    
    
    <category term="手撕" scheme="https://outoflovenicoo.github.io/tags/%E6%89%8B%E6%92%95/"/>
    
  </entry>
  
  <entry>
    <title>Guava的eventBus的原理</title>
    <link href="https://outoflovenicoo.github.io/posts/2025-03-20-Guava%E7%9A%84eventBus%E7%9A%84%E5%8E%9F%E7%90%86.html"/>
    <id>https://outoflovenicoo.github.io/posts/2025-03-20-Guava%E7%9A%84eventBus%E7%9A%84%E5%8E%9F%E7%90%86.html</id>
    <published>2025-03-20T10:19:03.000Z</published>
    <updated>2025-03-20T14:00:00.000Z</updated>
    
    <content type="html"><![CDATA[<h1>Guava的eventBus的原理</h1><p><img src="2025-03-20-Guava%E7%9A%84eventBus%E7%9A%84%E5%8E%9F%E7%90%86/diagram.png" alt=""></p><p>在Java应用开发中，同一JVM内的事件通知场景普遍存在。相较于分布式消息队列（MQ），Guava提供的EventBus框架以轻量、便捷的特点成为首选。本文将从架构设计、运行机制、使用场景及注意事项等方面，深入解析EventBus的核心原理。</p><h2 id="一、EventBus的架构组成">一、EventBus的架构组成</h2><p>EventBus由以下核心模块构成：</p><ol><li><p><strong>事件发送器</strong>  </p><ul><li><p><strong>EventBus</strong>：同步事件发送器，默认使用<code>DirectExecutor</code>直接在当前线程执行事件处理逻辑。  </p></li><li><p><strong>AsyncEventBus</strong>：异步事件发送器，需传入自定义线程池（如<code>ThreadPoolExecutor</code>），通过线程池实现异步调度。  </p></li></ul></li><li><p><strong>事件载体（Event）</strong>事件是通知的最小单元，可定义任意类型的POJO作为事件（如<code>LoginEvent</code>、<code>RegisterEvent</code>）。  </p></li><li><p><strong>订阅者注册器（SubscriberRegistry）</strong>负责管理订阅者与事件的映射关系，通过反射扫描订阅者类中被<code>@Subscribe</code>注解标记的方法，并将其与事件类型绑定到<code>Multimap&lt;Class&lt;?&gt;, Subscriber&gt;</code>集合中。  </p></li><li><p><strong>事件分发器（Dispatcher）</strong>  </p><ul><li><p><strong>PerThreadQueuedDispatcher</strong>（EventBus默认）：基于线程本地队列（<code>ThreadLocal&lt;Queue&lt;Event&gt;&gt;</code>）实现同步分发，按顺序处理事件。  </p></li><li><p><strong>LegacyAsyncDispatcher</strong>（AsyncEventBus默认）：通过线程池异步执行事件处理逻辑。  </p></li></ul></li><li><p><strong>订阅者（Subscriber）</strong>  </p><ul><li><p><strong>Subscriber</strong>：无同步修饰的订阅者，适用于线程安全的事件处理方法（需通过<code>@AllowConcurrentEvents</code>注解声明）。  </p></li><li><p><strong>SynchronizedSubscriber</strong>：自动添加<code>synchronized</code>同步块的订阅者，确保非线程安全方法在并发场景下的串行执行。</p></li></ul></li></ol><h2 id="二、核心运行流程解析">二、核心运行流程解析</h2><h3 id="1-初始化与注册">1. 初始化与注册</h3><ul><li><p><strong>创建EventBus实例</strong>  </p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 同步EventBus</span></span><br><span class="line"><span class="type">EventBus</span> <span class="variable">eventBus</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">EventBus</span>(); </span><br><span class="line"><span class="comment">// 异步EventBus（需指定线程池）</span></span><br><span class="line"><span class="type">ThreadPoolExecutor</span> <span class="variable">executor</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">ThreadPoolExecutor</span>(<span class="number">5</span>, <span class="number">20</span>, <span class="number">30</span>, TimeUnit.SECONDS, <span class="keyword">new</span> <span class="title class_">LinkedBlockingQueue</span>&lt;&gt;(<span class="number">20</span>));</span><br><span class="line"><span class="type">AsyncEventBus</span> <span class="variable">asyncEventBus</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">AsyncEventBus</span>(executor);</span><br></pre></td></tr></table></figure></li><li><p><strong>注册订阅者</strong>通过<code>eventBus.register(listener)</code>方法将订阅者对象注册到框架中。底层通过反射遍历<code>listener</code>的所有方法，提取被<code>@Subscribe</code>标记的方法，封装为<code>Subscriber</code>对象，并按事件类型存储到<code>SubscriberRegistry</code>的<code>Multimap</code>中。</p></li></ul><h3 id="2-事件发送与处理">2. 事件发送与处理</h3><ul><li><p><strong>事件发布</strong>调用<code>eventBus.post(event)</code>触发事件分发：  </p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">eventBus.post(<span class="keyword">new</span> <span class="title class_">LoginEvent</span>(<span class="string">&quot;user&quot;</span>, <span class="string">&quot;password&quot;</span>));</span><br></pre></td></tr></table></figure></li><li><p><strong>分发逻辑</strong>  </p><ul><li><p><strong>同步模式（EventBus）</strong>：通过<code>PerThreadQueuedDispatcher</code>将事件存入当前线程的本地队列，按顺序逐个调用订阅者的处理方法，同步阻塞直至所有处理完成。  </p></li><li><p><strong>异步模式（AsyncEventBus）</strong>：通过<code>LegacyAsyncDispatcher</code>将事件处理逻辑提交到线程池，由线程池异步执行，发送线程无需等待结果。  </p></li></ul></li><li><p><strong>死亡事件（DeadEvent）</strong>若事件未被任何订阅者处理，EventBus会自动将其包装为<code>DeadEvent</code>并重新发布，可通过订阅<code>DeadEvent</code>捕获未处理的事件。</p></li></ul><h3 id="3-线程安全与并发控制">3. 线程安全与并发控制</h3><ul><li><p><strong>订阅者方法的线程安全</strong>  </p><ul><li><p>若方法被<code>@AllowConcurrentEvents</code>注解标记，EventBus会创建普通<code>Subscriber</code>，允许并发执行（需自行保证线程安全）。  </p></li><li><p>未标记注解的方法会被包装为<code>SynchronizedSubscriber</code>，通过<code>synchronized</code>关键字确保同一订阅者实例的方法串行执行，可能成为高并发场景的性能瓶颈。</p></li></ul></li></ul><h2 id="三、典型使用场景与代码示例">三、典型使用场景与代码示例</h2><h3 id="1-配置与初始化">1. 配置与初始化</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Configuration</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">EventBusConfig</span> &#123;</span><br><span class="line">    <span class="meta">@Bean</span></span><br><span class="line">    <span class="keyword">public</span> AsyncEventBus <span class="title function_">asyncEventBus</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="type">ThreadPoolExecutor</span> <span class="variable">executor</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">ThreadPoolExecutor</span>(</span><br><span class="line">            <span class="number">5</span>, <span class="number">20</span>, <span class="number">30</span>, TimeUnit.SECONDS,</span><br><span class="line">            <span class="keyword">new</span> <span class="title class_">LinkedBlockingQueue</span>&lt;&gt;(<span class="number">20</span>),</span><br><span class="line">            <span class="keyword">new</span> <span class="title class_">ThreadPoolExecutor</span>.CallerRunsPolicy() <span class="comment">// 拒绝策略示例</span></span><br><span class="line">        );</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">new</span> <span class="title class_">AsyncEventBus</span>(executor);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="2-订阅者定义">2. 订阅者定义</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Component</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">EventListener</span> &#123;</span><br><span class="line">    <span class="comment">// 同步处理登录事件</span></span><br><span class="line">    <span class="meta">@Subscribe</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">handleLoginEvent</span><span class="params">(LoginEvent event)</span> &#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;Received login event: &quot;</span> + event.getUsername());</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 异步处理注册事件（需AsyncEventBus）</span></span><br><span class="line">    <span class="meta">@Subscribe</span></span><br><span class="line">    <span class="meta">@AllowConcurrentEvents</span> <span class="comment">// 声明线程安全，允许并发处理</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">handleRegisterEvent</span><span class="params">(RegisterEvent event)</span> &#123;</span><br><span class="line">        <span class="comment">// 耗时操作示例</span></span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            Thread.sleep(<span class="number">1000</span>);</span><br><span class="line">        &#125; <span class="keyword">catch</span> (InterruptedException e) &#123;</span><br><span class="line">            Thread.currentThread().interrupt();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="3-事件发送">3. 事件发送</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Service</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">EventPublisher</span> &#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">final</span> EventBus eventBus;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="title function_">EventPublisher</span><span class="params">(EventBus eventBus)</span> &#123;</span><br><span class="line">        <span class="built_in">this</span>.eventBus = eventBus;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">publishLoginEvent</span><span class="params">(String username, String password)</span> &#123;</span><br><span class="line">        eventBus.post(<span class="keyword">new</span> <span class="title class_">LoginEvent</span>(username, password));</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="四、注意事项与性能优化">四、注意事项与性能优化</h2><ul><li><p><strong>线程池配置</strong>  </p><ul><li><p>异步模式下需合理设置线程池参数（如核心线程数、队列容量、拒绝策略），避免任务堆积或线程耗尽。  </p></li><li><p>建议为不同类型的事件分配独立线程池，防止高耗时事件阻塞其他事件处理。  </p></li></ul></li><li><p><strong>反射开销</strong>  </p><ul><li>订阅者注册过程依赖反射，高频率注册/注销场景可能影响性能，建议在系统启动阶段完成所有订阅者注册。  </li></ul></li><li><p><strong>并发控制</strong>  </p><ul><li>非线程安全的订阅者方法（未使用<code>@AllowConcurrentEvents</code>）会被自动同步，高并发时需评估串行执行的性能影响，必要时通过线程安全的数据结构或异步拆分优化。  </li></ul></li><li><p><strong>异常处理</strong>  </p><ul><li>事件处理方法若抛出异常，会被EventBus捕获并记录，但不会中断其他订阅者的执行。建议在方法内部添加try-catch块，避免未预期异常导致系统不稳定。  </li></ul></li></ul><h2 id="五、总结">五、总结</h2><p>Guava EventBus通过简洁的发布-订阅模式，为JVM内的事件通信提供了高效解决方案。理解其架构设计（如同步/异步分发机制、订阅者注册原理）和线程安全策略，能帮助开发者在实际项目中合理选择EventBus或AsyncEventBus，并通过优化线程池配置、减少反射开销等手段提升系统性能。在微服务或复杂业务场景中，结合分布式消息队列（如Kafka、RabbitMQ）与EventBus，可进一步构建层次化的事件驱动架构。</p><h2 id="参考博客：">参考博客：</h2><p><a href="https://cloud.tencent.com/developer/article/1377032">Guava原理深度解析</a></p>]]></content>
    
    
    <summary type="html">🥧Guava的eventBus的原理</summary>
    
    
    
    <category term="学习" scheme="https://outoflovenicoo.github.io/categories/%E5%AD%A6%E4%B9%A0/"/>
    
    
    <category term="原理" scheme="https://outoflovenicoo.github.io/tags/%E5%8E%9F%E7%90%86/"/>
    
  </entry>
  
  <entry>
    <title>CompletableFuture原理及其使用</title>
    <link href="https://outoflovenicoo.github.io/posts/2025-03-19-CompletableFuture%E5%8E%9F%E7%90%86%E5%8F%8A%E5%85%B6%E4%BD%BF%E7%94%A8.html"/>
    <id>https://outoflovenicoo.github.io/posts/2025-03-19-CompletableFuture%E5%8E%9F%E7%90%86%E5%8F%8A%E5%85%B6%E4%BD%BF%E7%94%A8.html</id>
    <published>2025-03-19T10:19:03.000Z</published>
    <updated>2025-03-19T14:00:00.000Z</updated>
    
    <content type="html"><![CDATA[<h1 id="思维导图："><a href="#思维导图：" class="headerlink" title="思维导图："></a>思维导图：</h1><p><img src="2025-03-19-CompletableFuture原理及其使用/diagram-5060644.png" alt=""></p><h1 id="深入理解CompletableFuture原理"><a href="#深入理解CompletableFuture原理" class="headerlink" title="深入理解CompletableFuture原理"></a>深入理解CompletableFuture原理</h1><p><strong>实习的时候用到了<code>CompletableFuture</code>，本着知其然要知其所以然的原则，总结一下<code>CompletableFuture</code>的原理吧。</strong></p><p>在Java的并发编程领域中，我们常常会遇到需要进行异步计算的场景。比如，当我们从数据库获取数据、调用远程服务接口时，如果这些操作在主线程中同步执行，可能会导致主线程阻塞，影响程序的响应性能。这时候，<code>CompletableFuture</code>就派上了大用场，它为我们提供了强大而灵活的异步编程支持。</p><h2 id="一、CompletableFuture实现的接口"><a href="#一、CompletableFuture实现的接口" class="headerlink" title="一、CompletableFuture实现的接口"></a>一、CompletableFuture实现的接口</h2><p><code>CompletableFuture</code>实现了<code>Future</code>和<code>CompletionStage</code>两个接口。<code>Future</code>接口大家相对比较熟悉，它主要用于表示异步计算的结果。我们可以通过它获取异步任务的执行结果、判断任务是否完成以及取消任务等操作。而<code>CompletionStage</code>接口则为异步编程带来了更多的灵活性和可编排性。它表示异步执行过程中的一个步骤（Stage），一个<code>CompletionStage</code>的完成可能会触发其他一系列<code>CompletionStage</code>的执行。我们可以根据实际业务需求，通过<code>CompletionStage</code>提供的<code>thenApply</code>、<code>thenCompose</code>等函数式编程方法，对这些步骤进行多样化的编排组合，从而实现复杂的异步逻辑。</p><h2 id="二、CompletableFuture的依赖关系"><a href="#二、CompletableFuture的依赖关系" class="headerlink" title="二、CompletableFuture的依赖关系"></a>二、CompletableFuture的依赖关系</h2><h3 id="一元依赖"><a href="#一元依赖" class="headerlink" title="一元依赖"></a>一元依赖</h3><p>当我们的任务只依赖于单个<code>CompletableFuture</code>时，就属于一元依赖的情况。在这种情况下，我们可以使用<code>thenApply</code>、<code>thenAccept</code>、<code>thenCompose</code>等方法。例如，<code>thenApply</code>方法接收一个函数作为参数，当依赖的<code>CompletableFuture</code>完成时，会将其结果作为参数传递给这个函数进行处理，并返回一个新的<code>CompletableFuture</code>，这个新的<code>CompletableFuture</code>的结果就是函数处理后的返回值。<code>thenAccept</code>方法则是在依赖的<code>CompletableFuture</code>完成时，接收其结果进行处理，但不返回新的结果。<code>thenCompose</code>方法与<code>thenApply</code>类似，不过它接收的函数返回值是一个<code>CompletableFuture</code>，这样可以方便地将多个异步操作进行链式组合。</p><h3 id="二元依赖"><a href="#二元依赖" class="headerlink" title="二元依赖"></a>二元依赖</h3><p>如果我们的任务依赖于两个<code>CompletableFuture</code>，那么可以使用<code>thenCombine</code>等回调方法来实现。<code>thenCombine</code>方法会等待两个<code>CompletableFuture</code>都完成后，将它们的结果作为参数传递给指定的函数进行处理，最终返回一个新的<code>CompletableFuture</code>，其结果是函数处理后的返回值。这种方式可以让我们在两个异步操作都完成后，对它们的结果进行整合处理。</p><h3 id="多元依赖"><a href="#多元依赖" class="headerlink" title="多元依赖"></a>多元依赖</h3><p>当任务依赖于多个<code>CompletableFuture</code>时，也就是多元依赖的情况。我们可以通过<code>allOf</code>或<code>anyOf</code>方法来实现。<code>allOf</code>方法会等待所有传入的<code>CompletableFuture</code>都完成后才返回，而<code>anyOf</code>方法则是只要有一个传入的<code>CompletableFuture</code>完成就会返回，返回的结果是第一个完成的<code>CompletableFuture</code>的结果。</p><h2 id="三、CompletableFuture的原理"><a href="#三、CompletableFuture的原理" class="headerlink" title="三、CompletableFuture的原理"></a>三、CompletableFuture的原理</h2><h3 id="内部字段"><a href="#内部字段" class="headerlink" title="内部字段"></a>内部字段</h3><p><code>CompletableFuture</code>内部包含两个重要字段：<code>result</code>和<code>stack</code> 。<code>result</code>用于存储异步计算的结果，而<code>stack</code>则在处理依赖关系和通知观察者等过程中发挥着关键作用。</p><h3 id="观察者与被观察者模式"><a href="#观察者与被观察者模式" class="headerlink" title="观察者与被观察者模式"></a>观察者与被观察者模式</h3><p><code>CompletableFuture</code>的工作原理类似于观察者与被观察者模式。例如，当我们调用<code>CompletableFuture.allOf(cf1, cf2, cf3)</code>时，这里的<code>cf1</code>、<code>cf2</code>、<code>cf3</code>就是被观察者，而调用<code>allOf</code>方法返回的<code>CompletableFuture</code>（假设为<code>CF</code> ）就是观察者。在执行过程中，<code>CF</code>会先把自己注册到<code>cf1</code>、<code>cf2</code>、<code>cf3</code>中成为观察者。当<code>cf1</code>执行完成后，它会将自己的结果保存在自身内部，同时根据<code>stack</code>中的信息去提醒观察者。只有当所有被观察者（<code>cf1</code>、<code>cf2</code>、<code>cf3</code> ）都执行完成后，观察者<code>CF</code>才会将最终的结果保存到自己的<code>result</code>字段中。</p><h2 id="四、CompletableFuture中的线程问题"><a href="#四、CompletableFuture中的线程问题" class="headerlink" title="四、CompletableFuture中的线程问题"></a>四、CompletableFuture中的线程问题</h2><h3 id="代码运行线程"><a href="#代码运行线程" class="headerlink" title="代码运行线程"></a>代码运行线程</h3><p>在<code>CompletableFuture</code>中，代码运行在哪个线程上，需要区分同步方法和异步方法。</p><ul><li><p><strong>同步方法（即不带Async后缀的方法）</strong>：如果在注册时，被依赖的操作已经执行完成，那么同步方法会直接由当前线程执行；如果注册时被依赖的操作还未执行完，那么同步方法会由回调线程执行。</p></li><li><p><strong>异步方法（即带Async后缀的方法）</strong>：我们可以选择是否传递线程池参数<code>Executor</code>来让异步方法运行在指定的线程池中。当不传递<code>Executor</code>时，会使用<code>ForkJoinPool</code>中的共用线程池<code>CommonPool</code> 。需要注意的是，<code>CommonPool</code>的大小是CPU核数 - 1，如果应用是IO密集型的，线程数可能会成为性能瓶颈。</p></li></ul><h3 id="线程池相关问题"><a href="#线程池相关问题" class="headerlink" title="线程池相关问题"></a>线程池相关问题</h3><ul><li><p><strong>异步回调要传线程池</strong>：由于<code>CommonPool</code>的大小有限，在一些高并发或IO密集型的场景下，可能无法满足需求。因此，在进行异步回调时，我们需要考虑传递合适的线程池参数，以避免线程资源不足的问题。</p></li><li><p><strong>线程池循环引用会导致死锁</strong>：在使用线程池时，如果出现循环引用的情况，就可能会导致死锁。比如，一个任务依赖另一个任务，而这两个任务又分别在不同的线程池中执行，且存在相互等待的情况，就可能会陷入死锁状态。</p></li><li><p><strong>异步RPC调用注意不要阻塞IO线程池</strong>：在进行异步RPC调用时，要特别注意不要阻塞IO线程池。因为IO线程池通常用于处理网络IO等操作，如果被阻塞，可能会影响整个系统的IO性能，导致响应延迟等问题。</p></li></ul><h2 id="五、设置超时时间"><a href="#五、设置超时时间" class="headerlink" title="五、设置超时时间"></a>五、设置超时时间</h2><p>在实际应用中，我们常常需要为异步操作设置超时时间，以避免长时间等待。在<code>CompletableFuture</code>中，可以使用<code>applyToEither</code>方法来判断是计算先完成还是先超时。具体实现方式是启动一个<code>ScheduledThreadpoolExecutor</code>线程，在指定的<code>timeout</code>时间后，直接调用<code>CompletableFuture.completeExceptionally(new TimeoutException())</code> ，这样当超过指定时间还未完成计算时，就会抛出<code>TimeoutException</code>异常，从而让我们可以对超时情况进行相应的处理。</p><h2 id="六、使用"><a href="#六、使用" class="headerlink" title="六、使用"></a>六、使用</h2><p>在实习的时候第一次用到了<code>CompletableFuture</code>，那个时候做的是一个官网的文档导出，先下载静态资源文件，下载完之后对其进行打包，再对所有文件进行打包，最后通过邮件发送给管理员，实现一个官网文档私有化的功能。</p><h3 id="流程图："><a href="#流程图：" class="headerlink" title="流程图："></a>流程图：</h3><p><img src="2025-03-19-CompletableFuture原理及其使用/image-20250419190430184-5060677-5060680.png" alt="image-20250419190430184"></p><h3 id="回忆版伪代码："><a href="#回忆版伪代码：" class="headerlink" title="回忆版伪代码："></a>回忆版伪代码：</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line"><span class="keyword">import</span> java.util.concurrent.CompletableFuture;</span><br><span class="line"><span class="keyword">import</span> java.util.concurrent.ExecutorService;</span><br><span class="line"><span class="keyword">import</span> java.util.concurrent.Executors;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 假设这些是下载和打包相关的方法，实际使用中需根据具体实现替换</span></span><br><span class="line"><span class="comment">// 下载html文件</span></span><br><span class="line"><span class="keyword">public</span> CompletableFuture&lt;String&gt; <span class="title function_">downloadHtmlFile</span><span class="params">(String documentName)</span> &#123;</span><br><span class="line">    <span class="comment">// 实际下载逻辑，这里返回一个CompletableFuture表示异步操作</span></span><br><span class="line">    <span class="keyword">return</span> CompletableFuture.supplyAsync(() -&gt; &#123;</span><br><span class="line">        <span class="comment">// 模拟下载操作，返回下载后的文件内容或路径等相关信息</span></span><br><span class="line">        <span class="keyword">return</span> <span class="string">&quot;downloaded_html_file_path_for_&quot;</span> + documentName;</span><br><span class="line">    &#125;, executorService);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 下载图片文件</span></span><br><span class="line"><span class="keyword">public</span> CompletableFuture&lt;String&gt; <span class="title function_">downloadImageFile</span><span class="params">(String documentName)</span> &#123;</span><br><span class="line">    <span class="keyword">return</span> CompletableFuture.supplyAsync(() -&gt; &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="string">&quot;downloaded_image_file_path_for_&quot;</span> + documentName;</span><br><span class="line">    &#125;, executorService);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 下载CSS文件</span></span><br><span class="line"><span class="keyword">public</span> CompletableFuture&lt;String&gt; <span class="title function_">downloadCssFile</span><span class="params">(String documentName)</span> &#123;</span><br><span class="line">    <span class="keyword">return</span> CompletableFuture.supplyAsync(() -&gt; &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="string">&quot;downloaded_css_file_path_for_&quot;</span> + documentName;</span><br><span class="line">    &#125;, executorService);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 打包文件</span></span><br><span class="line"><span class="keyword">public</span> CompletableFuture&lt;String&gt; <span class="title function_">packFiles</span><span class="params">(String[] filePaths)</span> &#123;</span><br><span class="line">    <span class="keyword">return</span> CompletableFuture.supplyAsync(() -&gt; &#123;</span><br><span class="line">        <span class="comment">// 实际打包逻辑，返回打包后的文件路径等相关信息</span></span><br><span class="line">        <span class="keyword">return</span> <span class="string">&quot;packed_file_path_for_&quot;</span> + filePaths[<span class="number">0</span>];</span><br><span class="line">    &#125;, executorService);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 发送邮件</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">sendEmail</span><span class="params">(String packedFilePath)</span> &#123;</span><br><span class="line">    <span class="comment">// 实际发送邮件逻辑</span></span><br><span class="line">    System.out.println(<span class="string">&quot;Sending email with file: &quot;</span> + packedFilePath);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Main</span> &#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="type">ExecutorService</span> <span class="variable">executorService</span> <span class="operator">=</span> Executors.newFixedThreadPool(<span class="number">10</span>);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">        <span class="comment">// 假设这里有n个文档，以数组形式表示文档名</span></span><br><span class="line">        String[] documentNames = &#123;<span class="string">&quot;document1&quot;</span>, <span class="string">&quot;document2&quot;</span>, <span class="string">&quot;document3&quot;</span>&#125;; </span><br><span class="line">        CompletableFuture[] allDownloadFutures = <span class="keyword">new</span> <span class="title class_">CompletableFuture</span>[documentNames.length];</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i &lt; documentNames.length; i++) &#123;</span><br><span class="line">            <span class="type">String</span> <span class="variable">documentName</span> <span class="operator">=</span> documentNames[i];</span><br><span class="line">            CompletableFuture&lt;String&gt; htmlFuture = downloadHtmlFile(documentName);</span><br><span class="line">            CompletableFuture&lt;String&gt; imageFuture = downloadImageFile(documentName);</span><br><span class="line">            CompletableFuture&lt;String&gt; cssFuture = downloadCssFile(documentName);</span><br><span class="line"></span><br><span class="line">            CompletableFuture[] subFutures = &#123;htmlFuture, imageFuture, cssFuture&#125;;</span><br><span class="line">            CompletableFuture&lt;String&gt; packFuture = CompletableFuture.allOf(subFutures)</span><br><span class="line">                   .thenApply(v -&gt; &#123;</span><br><span class="line">                        <span class="keyword">try</span> &#123;</span><br><span class="line">                            String[] filePaths = &#123;htmlFuture.get(), imageFuture.get(), cssFuture.get()&#125;;</span><br><span class="line">                            <span class="keyword">return</span> packFiles(filePaths).get();</span><br><span class="line">                        &#125; <span class="keyword">catch</span> (Exception e) &#123;</span><br><span class="line">                            e.printStackTrace();</span><br><span class="line">                            <span class="keyword">return</span> <span class="literal">null</span>;</span><br><span class="line">                        &#125;</span><br><span class="line">                    &#125;);</span><br><span class="line">            allDownloadFutures[i] = packFuture;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        CompletableFuture.allOf(allDownloadFutures)</span><br><span class="line">               .thenRun(() -&gt; &#123;</span><br><span class="line">                    <span class="keyword">try</span> &#123;</span><br><span class="line">                        <span class="keyword">for</span> (CompletableFuture&lt;String&gt; packFuture : allDownloadFutures) &#123;</span><br><span class="line">                            <span class="type">String</span> <span class="variable">packedFilePath</span> <span class="operator">=</span> packFuture.get();</span><br><span class="line">                            sendEmail(packedFilePath);</span><br><span class="line">                        &#125;</span><br><span class="line">                    &#125; <span class="keyword">catch</span> (Exception e) &#123;</span><br><span class="line">                        e.printStackTrace();</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125;);</span><br><span class="line"></span><br><span class="line">        executorService.shutdown();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">### 代码说明</span></span><br><span class="line"><span class="comment">1. **线程池初始化**：创建一个固定大小为10的线程池`executorService`，用于执行异步任务。</span></span><br><span class="line"><span class="comment">2. **下载任务**：定义了`downloadHtmlFile`、`downloadImageFile`、`downloadCssFile`三个方法，分别用于异步下载html、图片和CSS文件，每个方法返回一个`CompletableFuture`。</span></span><br><span class="line"><span class="comment">3. **打包任务**：`packFiles`方法用于将下载的文件进行打包，同样返回一个`CompletableFuture`。</span></span><br><span class="line"><span class="comment">4. **发送邮件**：`sendEmail`方法用于发送包含打包文件的邮件。</span></span><br><span class="line"><span class="comment">5. **主流程**：遍历文档名数组，对每个文档分别发起html、图片和CSS文件的下载任务，通过`CompletableFuture.allOf`等待这些子任务完成后进行打包。所有文档打包完成后，再通过`CompletableFuture.allOf`等待所有打包任务完成，最后依次发送邮件。</span></span><br><span class="line"><span class="comment">6. **线程池关闭**：在所有任务完成后，关闭线程池。 </span></span><br><span class="line"><span class="comment">*/</span></span><br></pre></td></tr></table></figure><h3 id="其它方式实现："><a href="#其它方式实现：" class="headerlink" title="其它方式实现："></a>其它方式实现：</h3><ul><li><p><strong>FutureTask</strong>：实现<code>Future</code>与<code>Runnable</code>接口，包装<code>Callable</code>或<code>Runnable</code>对象执行异步任务，能获取结果，但<code>get</code>方法会阻塞，轮询检查又消耗CPU，且任务编排能力有限。&#x20;</p></li><li><p><strong>线程池结合Runnable/Callable</strong>：利用<code>ExecutorService</code>创建线程池，提交<code>Runnable</code>（无返回值）或<code>Callable</code>（有返回值）任务执行，可控制线程数量、提高资源利用率，但复杂任务编排时代码较复杂，需手动处理任务顺序与结果传递。&#x20;</p></li><li><p><strong>Guava的ListenableFuture</strong>：扩展Java标准<code>Future</code>接口，通过<code>Futures.addCallback()</code>添加回调函数，任务完成时自动触发，避免阻塞，但引入库依赖，处理复杂任务组合不如<code>CompletableFuture</code>直观。&#x20;</p></li></ul><h2 id="总结："><a href="#总结：" class="headerlink" title="总结："></a>总结：</h2><ul><li><p><strong>接口实现</strong>：<code>CompletableFuture</code>实现<code>Future</code>和<code>CompletionStage</code>接口，前者表示异步计算结果，后者可对异步步骤编排组合，提供<code>thenApply</code>等函数式编程方法。</p></li><li><p><strong>依赖关系</strong>：分一元、二元和多元依赖。一元依赖用<code>thenApply</code>等处理单个<code>CompletableFuture</code>；二元依赖通过<code>thenCombine</code>整合两个结果；多元依赖用<code>allOf</code>或<code>anyOf</code>处理多个。</p></li><li><p><strong>原理</strong>：含<code>result</code>（存结果）和<code>stack</code>字段，基于观察者与被观察者模式，被观察者完成时按<code>stack</code>信息通知观察者处理结果。</p></li><li><p><strong>线程问题</strong>：同步方法依依赖操作状态由当前或回调线程执行；异步方法可指定线程池，否则用<code>CommonPool</code>，但在IO密集场景线程数可能成瓶颈。还提及线程池使用注意点，如异步回调传线程池、避免循环引用死锁、异步RPC不阻塞IO线程池。</p></li><li><p><strong>超时设置</strong>：用<code>applyToEither</code>结合<code>ScheduledThreadpoolExecutor</code>实现，超时抛<code>TimeoutException</code>。&#x20;</p></li></ul><blockquote><p><a href="https://tech.meituan.com/2022/05/12/principles-and-practices-of-completablefuture.html">CompletableFuture原理与实践-外卖商家端API的异步化</a></p><p><a href="https://blog.csdn.net/u013905744/article/details/109134516">java8中CompletableFuture异步处理超时的方法_completablefuture 超时-CSDN博客</a></p></blockquote>]]></content>
    
    
    <summary type="html">🥧CompletableFuture原理及其使用</summary>
    
    
    
    <category term="学习" scheme="https://outoflovenicoo.github.io/categories/%E5%AD%A6%E4%B9%A0/"/>
    
    
    <category term="原理" scheme="https://outoflovenicoo.github.io/tags/%E5%8E%9F%E7%90%86/"/>
    
  </entry>
  
  <entry>
    <title>SoundMentor-组织管理相关</title>
    <link href="https://outoflovenicoo.github.io/posts/2025-03-10-SoundMentor-%E7%BB%84%E7%BB%87%E7%AE%A1%E7%90%86%E7%9B%B8%E5%85%B3.html"/>
    <id>https://outoflovenicoo.github.io/posts/2025-03-10-SoundMentor-%E7%BB%84%E7%BB%87%E7%AE%A1%E7%90%86%E7%9B%B8%E5%85%B3.html</id>
    <published>2025-03-10T10:19:03.000Z</published>
    <updated>2025-03-10T14:00:00.000Z</updated>
    
    <content type="html"><![CDATA[<h2 id="1-组织相关的表">1.组织相关的表</h2><p><img src="2025-03-10-SoundMentor-%E7%BB%84%E7%BB%87%E7%AE%A1%E7%90%86%E7%9B%B8%E5%85%B3/image-1.png" alt=""></p><p><strong>通过RBAC控制组织权限</strong></p><p><img src="2025-03-10-SoundMentor-%E7%BB%84%E7%BB%87%E7%AE%A1%E7%90%86%E7%9B%B8%E5%85%B3/image.png" alt=""></p><p><img src="2025-03-10-SoundMentor-%E7%BB%84%E7%BB%87%E7%AE%A1%E7%90%86%E7%9B%B8%E5%85%B3/diagram.png" alt=""></p><h2 id="2-通过分享码加入组织">2.通过分享码加入组织</h2><p>这里用乐观锁，防止高并发下的人员溢出</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 通过分享码进入组织</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param</span> dto</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="meta">@Override</span></span><br><span class="line"><span class="meta">@Transactional(rollbackFor = Exception.class)</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">join</span><span class="params">(JoinOrganizationDTO dto)</span> &#123;</span><br><span class="line">    <span class="type">String</span> <span class="variable">shareCode</span> <span class="operator">=</span> dto.getShareCode();</span><br><span class="line">    <span class="type">Integer</span> <span class="variable">organizationId</span> <span class="operator">=</span> dto.getOrganizationId();</span><br><span class="line">    <span class="type">String</span> <span class="variable">s</span> <span class="operator">=</span> redisTemplate.opsForValue().get(SoundMentorConstant.ORGANIZATION_SHARE_CODE_KEY + organizationId);</span><br><span class="line">    <span class="keyword">if</span>(Objects.isNull(s))</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">throw</span> <span class="keyword">new</span> <span class="title class_">BizException</span>(ResultCodeEnum.INVALID_PARAM.getCode(),<span class="string">&quot;分享码不存在或已经失效&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span>(!StringUtils.equals(shareCode,s))</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">throw</span> <span class="keyword">new</span> <span class="title class_">BizException</span>(ResultCodeEnum.INVALID_PARAM.getCode(),<span class="string">&quot;分享码不正确&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="type">OrganizationDO</span> <span class="variable">organization</span> <span class="operator">=</span> <span class="built_in">this</span>.getById(organizationId);</span><br><span class="line">    <span class="keyword">if</span>(Objects.isNull(organization))</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">throw</span> <span class="keyword">new</span> <span class="title class_">BizException</span>(ResultCodeEnum.INVALID_PARAM.getCode(),<span class="string">&quot;组织不存在&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="type">OrganizationUserDO</span> <span class="variable">one</span> <span class="operator">=</span> ouService.lambdaQuery()</span><br><span class="line">            .eq(OrganizationUserDO::getOrganizationId, organizationId)</span><br><span class="line">            .eq(OrganizationUserDO::getUserId, userInfoApi.getUser().getId())</span><br><span class="line">            .one();</span><br><span class="line">    <span class="keyword">if</span> (!Objects.isNull(one))</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">throw</span> <span class="keyword">new</span> <span class="title class_">BizException</span>(ResultCodeEnum.INTERNAL_ERROR.getCode(),<span class="string">&quot;您已经加入该组织&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="type">boolean</span> <span class="variable">update</span> <span class="operator">=</span> <span class="built_in">this</span>.lambdaUpdate()</span><br><span class="line">            .setSql(<span class="string">&quot;spare_capacity=spare_capacity-1&quot;</span>)</span><br><span class="line">            .eq(OrganizationDO::getId, organizationId)</span><br><span class="line">            .gt(OrganizationDO::getSpareCapacity, <span class="number">0</span>)</span><br><span class="line">            .update();</span><br><span class="line">    <span class="keyword">if</span>(!update)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">throw</span> <span class="keyword">new</span> <span class="title class_">BizException</span>(ResultCodeEnum.INTERNAL_ERROR.getCode(),<span class="string">&quot;组织容量已满&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="type">OrganizationUserDO</span> <span class="variable">organizationUserDO</span> <span class="operator">=</span> OrganizationUserDO.builder()</span><br><span class="line">            .organizationId(organizationId)</span><br><span class="line">            .userId(userInfoApi.getUser().getId())</span><br><span class="line">            .organizationRole(OrganizationRole.USER.getCode())</span><br><span class="line">            .createTime(LocalDateTime.now())</span><br><span class="line">            .build();</span><br><span class="line">    ouService.save(organizationUserDO);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
    
    
    <summary type="html">🥧SoundMentor-组织管理相关</summary>
    
    
    
    <category term="项目" scheme="https://outoflovenicoo.github.io/categories/%E9%A1%B9%E7%9B%AE/"/>
    
    
    <category term="项目" scheme="https://outoflovenicoo.github.io/tags/%E9%A1%B9%E7%9B%AE/"/>
    
  </entry>
  
  <entry>
    <title>SoundMentor-多线程优化PPT任务执行</title>
    <link href="https://outoflovenicoo.github.io/posts/2025-03-10-SoundMentor-%E5%A4%9A%E7%BA%BF%E7%A8%8B%E4%BC%98%E5%8C%96PPT%E4%BB%BB%E5%8A%A1%E6%89%A7%E8%A1%8C.html"/>
    <id>https://outoflovenicoo.github.io/posts/2025-03-10-SoundMentor-%E5%A4%9A%E7%BA%BF%E7%A8%8B%E4%BC%98%E5%8C%96PPT%E4%BB%BB%E5%8A%A1%E6%89%A7%E8%A1%8C.html</id>
    <published>2025-03-10T10:19:03.000Z</published>
    <updated>2025-03-10T14:00:00.000Z</updated>
    
    <content type="html"><![CDATA[<p><strong>在最近做的ai语音合成项目中，有一个需求是：用户上传ppt，用ppt的url请求创建ppt讲解合成任务，这里需要关联用户和ppt，还需要下载解析ppt，拿到每一页做处理，并解析出每一页的内容向mq发送消息异步请求python大模型，还需做任务，ppt详情入库操作。</strong></p><p>这里一个ppt会有很多页，每一页都需要做两次数据库操作加mq消息发送，如果页码较多，那响应速度会很慢，所以这里引入一个自定义的单例线程池bean，通过线程池来并发执行每一页的任务，加速任务的执行，并且每页的任务异步执行，不阻塞主线程，且能减少线程开销，控制线程资源。</p><h2 id="自定义线程池">自定义线程池</h2><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Configuration</span></span><br><span class="line"><span class="meta">@Slf4j</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">ThreadPoolConfig</span> &#123;</span><br><span class="line">    <span class="meta">@Bean(&quot;task-thread-pool-executor&quot;)</span></span><br><span class="line">    <span class="keyword">public</span> ThreadPoolExecutor <span class="title function_">threadPoolExecutor</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="type">ThreadPoolExecutor</span> <span class="variable">threadPoolExecutor</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">ThreadPoolExecutor</span>(</span><br><span class="line">                <span class="number">10</span>,</span><br><span class="line">                <span class="number">50</span>,</span><br><span class="line">                <span class="number">60</span>,</span><br><span class="line">                TimeUnit.SECONDS,</span><br><span class="line">                <span class="keyword">new</span> <span class="title class_">ArrayBlockingQueue</span>&lt;Runnable&gt;(<span class="number">300</span>),</span><br><span class="line">                (r, executor) -&gt; &#123;</span><br><span class="line">                    log.info(<span class="string">&quot;线程池已满，任务&#123;&#125;,被丢弃&quot;</span>, r.toString());</span><br><span class="line">                &#125;</span><br><span class="line">        );</span><br><span class="line">        <span class="keyword">return</span> threadPoolExecutor;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="创建ppt讲解生成任务"><em>创建ppt讲解生成任务</em></h2><p>如果不采用多线程的方式，每次执行任务操作两次数据库 + mq发送，ppt页码一多可能就会很慢，采用多线程能优化它的执行速度。在经过测试后，发现用线程池比直接串行提高了50%的响应速度</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 创建ppt讲解生成任务</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param</span> param</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@return</span></span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="meta">@Override</span></span><br><span class="line"><span class="keyword">public</span> Integer <span class="title function_">createPPTSummary</span><span class="params">(CreatePPTSummaryTaskParam param)</span> &#123;</span><br><span class="line">    <span class="type">String</span> <span class="variable">pptUrl</span> <span class="operator">=</span> param.getPptUrl();</span><br><span class="line">    <span class="type">XMLSlideShow</span> <span class="variable">xmlSlideShow</span> <span class="operator">=</span> PPTXUtil.loadPPTX(pptUrl);</span><br><span class="line">    List&lt;XSLFSlide&gt; slides = xmlSlideShow.getSlides();</span><br><span class="line">    <span class="type">UserPptRelDO</span> <span class="variable">userPptRelDO</span> <span class="operator">=</span> userPptRelMapper.selectOne(<span class="keyword">new</span> <span class="title class_">LambdaQueryWrapper</span>&lt;UserPptRelDO&gt;()</span><br><span class="line">            .eq(UserPptRelDO::getPptUrl, pptUrl)</span><br><span class="line">            .eq(UserPptRelDO::getUserId, userInfoApi.getUser().getId()));</span><br><span class="line">    <span class="keyword">if</span> (Objects.isNull(userPptRelDO))</span><br><span class="line">    &#123;</span><br><span class="line">        userPptRelDO = <span class="keyword">new</span> <span class="title class_">UserPptRelDO</span>();</span><br><span class="line">        userPptRelDO.setPptUrl(pptUrl);</span><br><span class="line">        userPptRelDO.setUserId(userInfoApi.getUser().getId());</span><br><span class="line">        userPptRelDO.setPageCount(slides.size());</span><br><span class="line">        userPptRelDO.setCreateTime(LocalDateTime.now());</span><br><span class="line">        userPptRelMapper.insert(userPptRelDO);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i &lt; slides.size(); i++) &#123;</span><br><span class="line">        <span class="type">Integer</span> <span class="variable">userPptId</span> <span class="operator">=</span> userPptRelDO.getId();</span><br><span class="line">        <span class="type">Integer</span> <span class="variable">page</span> <span class="operator">=</span> i;</span><br><span class="line">        <span class="type">XSLFSlide</span> <span class="variable">slide</span> <span class="operator">=</span> slides.get(page);</span><br><span class="line">        threadPoolExecutor.execute(()-&gt;&#123;</span><br><span class="line">            <span class="keyword">try</span> &#123;</span><br><span class="line">                taskExec(userPptId,page,slide);</span><br><span class="line">            &#125; <span class="keyword">catch</span> (Exception e) &#123;</span><br><span class="line">                log.error(<span class="string">&quot;ppt&#123;&#125;的&#123;&#125;页任务执行失败,请重试&quot;</span>,userPptId,page);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> userPptRelDO.getId();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="PPT讲解任务执行">PPT讲解任务执行</h2><p>读入PPT，把PPT分成每一页，将每一页的信息插入到PPT详情表，最后多线程异步发MQ让Python进行讲解生成。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * ppt页生成讲解任务执行</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param</span> userPptId ppt标识</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param</span> page 页码</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param</span> slide ppt页对象</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="meta">@Transactional(rollbackFor = Exception.class)</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">taskExec</span><span class="params">(Integer userPptId, Integer page,XSLFSlide slide)</span> <span class="keyword">throws</span> Exception</span><br><span class="line">&#123;</span><br><span class="line">    <span class="type">TaskDO</span> <span class="variable">taskDO</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">TaskDO</span>();</span><br><span class="line">    <span class="type">PPTPageSummaryTaskDTO</span> <span class="variable">pptPageSummaryTaskDTO</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">PPTPageSummaryTaskDTO</span>();</span><br><span class="line">    pptPageSummaryTaskDTO.setUserPptId(userPptId);</span><br><span class="line">    pptPageSummaryTaskDTO.setPage(page);</span><br><span class="line">    pptPageSummaryTaskDTO.setContent(PPTXUtil.getSlideInfo(slide));</span><br><span class="line">    taskDO.setTaskDetail(JSON.toJSONString(pptPageSummaryTaskDTO));</span><br><span class="line">    taskDO.setType(TaskTypeEnum.PPT_SUMMARY.getCode());</span><br><span class="line">    taskDO.setUpdateTime(LocalDateTime.now());</span><br><span class="line">    taskDO.setCreateTime(LocalDateTime.now());</span><br><span class="line">    taskDO.setStatus(TaskStatusEnum.CREATED.getCode());</span><br><span class="line">    taskMapper.insert(taskDO);</span><br><span class="line">    TaskMessageDTO&lt;PPTPageSummaryTaskDTO&gt; taskMessage = <span class="keyword">new</span> <span class="title class_">TaskMessageDTO</span>&lt;&gt;();</span><br><span class="line">    taskMessage.setId(taskDO.getId());</span><br><span class="line">    taskMessage.setType(TaskTypeEnum.PPT_SUMMARY.getCode());</span><br><span class="line">    taskMessage.setStatus(TaskStatusEnum.CREATED.getCode());</span><br><span class="line">    taskMessage.setMessageBody(pptPageSummaryTaskDTO);</span><br><span class="line">    taskMessage.setCreateTime(LocalDateTime.now());</span><br><span class="line">    mqProducer.send(DirectRabbitConfig.EXCHANGE_NAME_PPT_SUMMARY, DirectRabbitConfig.ROUTING_KEY_PPT_SUMMARY,taskMessage);</span><br><span class="line">    <span class="type">UserPptDetailDO</span> <span class="variable">userPptDetailDO</span> <span class="operator">=</span> userPptDetailMapper.selectOne(<span class="keyword">new</span> <span class="title class_">LambdaQueryWrapper</span>&lt;UserPptDetailDO&gt;()</span><br><span class="line">            .eq(UserPptDetailDO::getUserPptId, userPptId)</span><br><span class="line">            .eq(UserPptDetailDO::getPptPage, page));</span><br><span class="line">    <span class="keyword">if</span>(Objects.isNull(userPptDetailDO))</span><br><span class="line">    &#123;</span><br><span class="line">        userPptDetailDO = <span class="keyword">new</span> <span class="title class_">UserPptDetailDO</span>();</span><br><span class="line">        userPptDetailDO.setUserPptId(userPptId);</span><br><span class="line">        userPptDetailDO.setPptPage(page);</span><br><span class="line">        userPptDetailDO.setCreateTime(LocalDateTime.now());</span><br><span class="line">        userPptDetailDO.setLastTaskId(taskDO.getId());</span><br><span class="line">        <span class="comment">//上传并添加预览图</span></span><br><span class="line">        <span class="type">InputStream</span> <span class="variable">inputStream</span> <span class="operator">=</span> PPTXUtil.convertSlideToImage(slide);</span><br><span class="line">        <span class="type">String</span> <span class="variable">imgUrl</span> <span class="operator">=</span> fileService.uploadFileToMinio(inputStream, FileTypeEnum.PNG, UUID.randomUUID().toString());</span><br><span class="line">        userPptDetailDO.setImgUrl(imgUrl);</span><br><span class="line">        userPptDetailMapper.insert(userPptDetailDO);</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        userPptDetailDO.setLastTaskId(taskDO.getId());</span><br><span class="line">        userPptDetailMapper.updateById(userPptDetailDO);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="创建ppt讲解语音生成任务"><em>创建ppt讲解语音生成任务</em></h2><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 创建ppt讲解语音生成任务</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param</span> param</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@return</span></span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="meta">@Override</span></span><br><span class="line"><span class="keyword">public</span> Integer <span class="title function_">createPPTSummaryVoice</span><span class="params">(CreatePPTSummaryVoiceParam param)</span> &#123;</span><br><span class="line">    <span class="type">UserSoundRelDO</span> <span class="variable">sound</span> <span class="operator">=</span> userSoundRelService.getById(param.getUserSoundId());</span><br><span class="line">    <span class="keyword">if</span>(Objects.isNull(sound))</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">throw</span>  <span class="keyword">new</span> <span class="title class_">BizException</span>(ResultCodeEnum.INVALID_PARAM.getCode(),<span class="string">&quot;声音库不存在&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span>(!sound.getUserId().equals(<span class="number">0</span>))</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">throw</span> <span class="keyword">new</span> <span class="title class_">BizException</span>(ResultCodeEnum.INVALID_PARAM.getCode(),<span class="string">&quot;目前服务器暂不支持自定义声音库&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="type">String</span> <span class="variable">apiParam</span> <span class="operator">=</span> sound.getApiParam();</span><br><span class="line">    List&lt;UserPptDetailDO&gt; userPptDetailDOS = userPptDetailMapper.selectList(<span class="keyword">new</span> <span class="title class_">LambdaQueryWrapper</span>&lt;UserPptDetailDO&gt;().eq(UserPptDetailDO::getUserPptId, param.getUserPptId()));</span><br><span class="line">    <span class="keyword">for</span> (UserPptDetailDO userPptDetailDO : userPptDetailDOS) &#123;</span><br><span class="line">        threadPoolExecutor.execute(()-&gt;&#123;</span><br><span class="line">            <span class="keyword">try</span> &#123;</span><br><span class="line">                taskExec(userPptDetailDO,apiParam,param.getRate());</span><br><span class="line">            &#125; <span class="keyword">catch</span> (Exception e) &#123;</span><br><span class="line">               log.info(<span class="string">&quot;ppt&#123;&#125;的&#123;&#125;页任务执行失败,请重试&quot;</span>,userPptDetailDO.getUserPptId(),userPptDetailDO.getPptPage());</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> param.getUserPptId();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="PPT语音生成任务执行">PPT语音生成任务执行</h2><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * ppt页生成讲解语音任务执行</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param</span> userPptDetailDO</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param</span> apiParam</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param</span> rate</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="meta">@Transactional(rollbackFor = Exception.class)</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">taskExec</span><span class="params">(UserPptDetailDO userPptDetailDO,String apiParam, Integer rate)</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="type">String</span> <span class="variable">summary</span> <span class="operator">=</span> userPptDetailDO.getSummary();</span><br><span class="line">    <span class="keyword">if</span>(StringUtils.isEmpty(summary))</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">throw</span> <span class="keyword">new</span> <span class="title class_">BizException</span>(ResultCodeEnum.INVALID_PARAM.getCode(),<span class="string">&quot;ppt&quot;</span>+userPptDetailDO.getUserPptId()+<span class="string">&quot;的&quot;</span>+userPptDetailDO.getPptPage()+<span class="string">&quot;页没有讲解&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="type">PPTSummaryVoiceMsgDTO</span> <span class="variable">pptSummaryVoiceMsgDTO</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">PPTSummaryVoiceMsgDTO</span>();</span><br><span class="line">    pptSummaryVoiceMsgDTO.setUserPptId(userPptDetailDO.getUserPptId());</span><br><span class="line">    pptSummaryVoiceMsgDTO.setPage(userPptDetailDO.getPptPage());</span><br><span class="line">    pptSummaryVoiceMsgDTO.setText(summary);</span><br><span class="line">    pptSummaryVoiceMsgDTO.setVoiceName(apiParam);</span><br><span class="line">    pptSummaryVoiceMsgDTO.setRate(rate);</span><br><span class="line">    <span class="type">TaskDO</span> <span class="variable">taskDO</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">TaskDO</span>();</span><br><span class="line">    taskDO.setType(TaskTypeEnum.PPT_SUMMARY_VOICE.getCode());</span><br><span class="line">    taskDO.setStatus(TaskStatusEnum.CREATED.getCode());</span><br><span class="line">    taskDO.setTaskDetail(JSON.toJSONString(pptSummaryVoiceMsgDTO));</span><br><span class="line">    taskDO.setCreateTime(LocalDateTime.now());</span><br><span class="line">    taskDO.setUpdateTime(LocalDateTime.now());</span><br><span class="line">    taskMapper.insert(taskDO);</span><br><span class="line">    userPptDetailDO.setLastTaskId(taskDO.getId());</span><br><span class="line">    userPptDetailMapper.updateById(userPptDetailDO);</span><br><span class="line">    TaskMessageDTO&lt;PPTSummaryVoiceMsgDTO&gt; message = <span class="keyword">new</span> <span class="title class_">TaskMessageDTO</span>&lt;&gt;();</span><br><span class="line">    message.setId(taskDO.getId());</span><br><span class="line">    message.setType(TaskTypeEnum.PPT_SUMMARY_VOICE.getCode());</span><br><span class="line">    message.setStatus(TaskStatusEnum.CREATED.getCode());</span><br><span class="line">    message.setMessageBody(pptSummaryVoiceMsgDTO);</span><br><span class="line">    message.setCreateTime(LocalDateTime.now());</span><br><span class="line">    mqProducer.send(DirectRabbitConfig.EXCHANGE_NAME_PPT_SUMMARY_VOICE, DirectRabbitConfig.ROUTING_KEY_PPT_SUMMARY_VOICE,message);</span><br><span class="line">    log.info(<span class="string">&quot;消息ID:&#123;&#125;,发送成功！-----------&gt;&gt; &#123;&#125;&quot;</span>,taskDO.getId(),message.toString());</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="MQ返回结果处理">MQ返回结果处理</h2><p><img src="2025-03-10-SoundMentor-%E5%A4%9A%E7%BA%BF%E7%A8%8B%E4%BC%98%E5%8C%96PPT%E4%BB%BB%E5%8A%A1%E6%89%A7%E8%A1%8C/image.png" alt=""></p><p>利用工厂+策略模式，对不同的消息类型进行不同的处理：</p><p><img src="2025-03-10-SoundMentor-%E5%A4%9A%E7%BA%BF%E7%A8%8B%E4%BC%98%E5%8C%96PPT%E4%BB%BB%E5%8A%A1%E6%89%A7%E8%A1%8C/image-1.png" alt=""></p><h3 id="普通TTS处理">普通TTS处理</h3><p><img src="2025-03-10-SoundMentor-%E5%A4%9A%E7%BA%BF%E7%A8%8B%E4%BC%98%E5%8C%96PPT%E4%BB%BB%E5%8A%A1%E6%89%A7%E8%A1%8C/image-2.png" alt=""></p><h3 id="PPT总结任务处理">PPT总结任务处理</h3><p><img src="2025-03-10-SoundMentor-%E5%A4%9A%E7%BA%BF%E7%A8%8B%E4%BC%98%E5%8C%96PPT%E4%BB%BB%E5%8A%A1%E6%89%A7%E8%A1%8C/image-3.png" alt=""></p><h3 id="PPT声音生成处理">PPT声音生成处理</h3><p><img src="2025-03-10-SoundMentor-%E5%A4%9A%E7%BA%BF%E7%A8%8B%E4%BC%98%E5%8C%96PPT%E4%BB%BB%E5%8A%A1%E6%89%A7%E8%A1%8C/image-4.png" alt=""></p><h3 id="声音训练处理">声音训练处理</h3><p><img src="2025-03-10-SoundMentor-%E5%A4%9A%E7%BA%BF%E7%A8%8B%E4%BC%98%E5%8C%96PPT%E4%BB%BB%E5%8A%A1%E6%89%A7%E8%A1%8C/image-5.png" alt=""></p><h2 id="有声PPT的合成">有声PPT的合成</h2><p>先下载原始ppt文件到临时目录下，用CountDownLatch协调任务完成，下载每一页的MP3并插入到PPT里面，最后上传打包。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> String <span class="title function_">getPpt</span><span class="params">(Integer userPptId)</span> &#123;</span><br><span class="line">    List&lt;UserPptDetailDO&gt; userPptDetailDOS = userPptDetailMapper.selectList(<span class="keyword">new</span> <span class="title class_">LambdaQueryWrapper</span>&lt;UserPptDetailDO&gt;()</span><br><span class="line">            .eq(UserPptDetailDO::getUserPptId, userPptId)</span><br><span class="line">            .orderByAsc(UserPptDetailDO::getPptPage));</span><br><span class="line">    <span class="keyword">if</span>(CollectionUtils.isEmpty(userPptDetailDOS))</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">throw</span> <span class="keyword">new</span> <span class="title class_">BizException</span>(ResultCodeEnum.INVALID_PARAM.getCode(),<span class="string">&quot;该ppt还未执行讲解生成&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="type">UserPptRelDO</span> <span class="variable">userPptRelDO</span> <span class="operator">=</span> userPptRelMapper.selectById(userPptId);</span><br><span class="line">    <span class="type">String</span> <span class="variable">pptUrl</span> <span class="operator">=</span> userPptRelDO.getPptUrl();</span><br><span class="line">    <span class="type">XMLSlideShow</span> <span class="variable">pptx</span> <span class="operator">=</span> PPTXUtil.loadPPTX(pptUrl);</span><br><span class="line">    <span class="type">String</span> <span class="variable">folderName</span> <span class="operator">=</span> <span class="string">&quot;temp/&quot;</span>+UUID.fastUUID();</span><br><span class="line">    FileUtil.createFolder(folderName);</span><br><span class="line">    <span class="keyword">try</span>(<span class="type">FileOutputStream</span> <span class="variable">outputStream</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">FileOutputStream</span>(folderName+<span class="string">&quot;/ppt.pptx&quot;</span>))</span><br><span class="line">    &#123;</span><br><span class="line">        HttpUtil.download(pptUrl,outputStream,<span class="literal">true</span>);</span><br><span class="line">        outputStream.flush();</span><br><span class="line">    &#125; <span class="keyword">catch</span> (Exception e) &#123;</span><br><span class="line">        <span class="keyword">throw</span> <span class="keyword">new</span> <span class="title class_">BizException</span>(ResultCodeEnum.FILE_ERROR.getCode(),<span class="string">&quot;下载ppt失败&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">try</span>&#123;</span><br><span class="line">        <span class="type">CountDownLatch</span> <span class="variable">countDownLatch</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">CountDownLatch</span>(userPptDetailDOS.size());</span><br><span class="line">        userPptDetailDOS.forEach(userPptDetailDO -&gt; &#123;</span><br><span class="line">            threadPoolExecutor.execute(() -&gt;&#123;</span><br><span class="line">                <span class="keyword">try</span>(<span class="type">FileOutputStream</span> <span class="variable">fileOutputStream</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">FileOutputStream</span>(folderName+<span class="string">&quot;/&quot;</span>+userPptDetailDO.getPptPage()+<span class="string">&quot;.mp3&quot;</span>)) &#123;</span><br><span class="line">                    HttpUtil.download(userPptDetailDO.getSoundUrl(),fileOutputStream,<span class="literal">true</span>);</span><br><span class="line">                    fileOutputStream.flush();</span><br><span class="line">                    PPTXUtil.addAudioToSlide(pptx,userPptDetailDO.getPptPage(),userPptDetailDO.getPptPage()+<span class="string">&quot;.mp3&quot;</span>);</span><br><span class="line">                &#125; <span class="keyword">catch</span> (Exception e) &#123;</span><br><span class="line">                    log.error(<span class="string">&quot;ppt&#123;&#125;的&#123;&#125;页音频插入失败&quot;</span>, userPptId, userPptDetailDO.getPptPage());</span><br><span class="line">                &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">                    countDownLatch.countDown();</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;);</span><br><span class="line">        &#125;);</span><br><span class="line">        countDownLatch.await(<span class="number">1</span>, TimeUnit.MINUTES);</span><br><span class="line">        PPTXUtil.savePPT(pptx,folderName+<span class="string">&quot;/ppt.pptx&quot;</span>);</span><br><span class="line">        <span class="type">InputStream</span> <span class="variable">inputStream</span> <span class="operator">=</span> FileUtil.zipFolder(folderName);</span><br><span class="line">        <span class="keyword">return</span> fileService.uploadFileToMinio(inputStream, FileTypeEnum.ZIP, UUID.fastUUID().toString());</span><br><span class="line">    &#125; <span class="keyword">catch</span> (Exception e) &#123;</span><br><span class="line">        <span class="keyword">throw</span> <span class="keyword">new</span> <span class="title class_">BizException</span>(ResultCodeEnum.FILE_ERROR.getCode(),<span class="string">&quot;生成有声ppt失败&quot;</span>);</span><br><span class="line">    &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            FileUtils.deleteDirectory(<span class="keyword">new</span> <span class="title class_">File</span>(folderName));</span><br><span class="line">        &#125; <span class="keyword">catch</span> (IOException e) &#123;</span><br><span class="line">            <span class="keyword">throw</span> <span class="keyword">new</span> <span class="title class_">BizException</span>(ResultCodeEnum.FILE_ERROR.getCode(),<span class="string">&quot;删除临时文件失败&quot;</span>);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
    
    
    <summary type="html">🥧SoundMentor-多线程优化PPT任务执行</summary>
    
    
    
    <category term="项目" scheme="https://outoflovenicoo.github.io/categories/%E9%A1%B9%E7%9B%AE/"/>
    
    
    <category term="项目" scheme="https://outoflovenicoo.github.io/tags/%E9%A1%B9%E7%9B%AE/"/>
    
  </entry>
  
  <entry>
    <title>个人对零拷贝技术的理解</title>
    <link href="https://outoflovenicoo.github.io/posts/2025-03-09-%E4%B8%AA%E4%BA%BA%E5%AF%B9%E9%9B%B6%E6%8B%B7%E8%B4%9D%E6%8A%80%E6%9C%AF%E7%9A%84%E7%90%86%E8%A7%A3.html"/>
    <id>https://outoflovenicoo.github.io/posts/2025-03-09-%E4%B8%AA%E4%BA%BA%E5%AF%B9%E9%9B%B6%E6%8B%B7%E8%B4%9D%E6%8A%80%E6%9C%AF%E7%9A%84%E7%90%86%E8%A7%A3.html</id>
    <published>2025-03-09T10:19:03.000Z</published>
    <updated>2025-03-23T14:00:00.000Z</updated>
    
    <content type="html"><![CDATA[<h1 id="思维导图"><a href="#思维导图" class="headerlink" title="思维导图"></a>思维导图</h1><p><img src="2025-03-09-个人对零拷贝技术的理解/image-20250414160743861.png" alt="image-20250414160743861"></p><h3 id="个人对零拷贝技术的理解：告别冗余拷贝，释放系统性能"><a href="#个人对零拷贝技术的理解：告别冗余拷贝，释放系统性能" class="headerlink" title="个人对零拷贝技术的理解：告别冗余拷贝，释放系统性能"></a>个人对零拷贝技术的理解：告别冗余拷贝，释放系统性能</h3><p>在计算机系统中，磁盘和网络传输往往是性能的瓶颈之一。传统的文件传输方式虽然逻辑简单，但在高并发场景下会因频繁的上下文切换和数据拷贝导致严重的性能损耗。而<strong>零拷贝（Zero-copy）</strong>技术的出现，正是为了解决这一问题。本文将从硬件协作到内核优化，逐步拆解零拷贝技术的原理与应用。</p><hr><h4 id="一、从DMA技术说起：让CPU“解放双手”"><a href="#一、从DMA技术说起：让CPU“解放双手”" class="headerlink" title="一、从DMA技术说起：让CPU“解放双手”"></a>一、从DMA技术说起：让CPU“解放双手”</h4><p>在早期计算机中，数据的传输完全依赖CPU。例如，当磁盘需要向内存传输数据时，CPU需要逐个字节地从磁盘控制器缓冲区读取数据，再写入内存。这种“全程陪跑”的方式让CPU无法处理其他任务，效率极低。</p><p><strong>DMA（直接内存访问）技术</strong>的引入彻底改变了这一局面。DMA控制器接管了数据搬运的工作，CPU只需告诉DMA“从哪里搬、搬到哪里”，后续的数据传输由DMA独立完成。这一过程无需CPU参与，从而释放了CPU资源。</p><p><strong>DMA的工作流程</strong>：  </p><ol><li>用户进程发起I/O请求；  </li><li>DMA将磁盘数据直接搬运到内核缓冲区；  </li><li>数据就绪后，DMA通知CPU将数据从内核缓冲区拷贝到用户空间。  </li></ol><p>至此，CPU只需在传输的开始和结束时介入，中间的数据搬运工作全部由DMA完成。</p><hr><h4 id="二、传统文件传输的“四宗罪”"><a href="#二、传统文件传输的“四宗罪”" class="headerlink" title="二、传统文件传输的“四宗罪”"></a>二、传统文件传输的“四宗罪”</h4><p>传统文件传输通过<code>read()</code>和<code>write()</code>系统调用实现，看似简单的两行代码，却隐藏着巨大的性能问题：  </p><ol><li><strong>4次上下文切换</strong>：每次系统调用涉及2次用户态与内核态的切换，两次调用共4次切换。  </li><li><strong>4次数据拷贝</strong>：<br>• DMA将磁盘数据拷贝到内核缓冲区；<br>• CPU将内核数据拷贝到用户缓冲区；<br>• CPU将用户数据拷贝到Socket内核缓冲区；<br>• DMA将Socket缓冲区数据拷贝到网卡。  </li></ol><p>这4次拷贝中，<strong>两次CPU参与的拷贝是冗余的</strong>，尤其是当用户不需要修改数据时，用户缓冲区的存在反而成了累赘。</p><hr><h4 id="三、零拷贝技术：如何实现“零”冗余？"><a href="#三、零拷贝技术：如何实现“零”冗余？" class="headerlink" title="三、零拷贝技术：如何实现“零”冗余？"></a>三、零拷贝技术：如何实现“零”冗余？</h4><p>零拷贝的核心目标是<strong>减少上下文切换和数据拷贝次数</strong>，具体通过两种方式实现：</p><h5 id="1-mmap-write：减少一次数据拷贝"><a href="#1-mmap-write：减少一次数据拷贝" class="headerlink" title="1. mmap + write：减少一次数据拷贝"></a>1. <code>mmap + write</code>：减少一次数据拷贝</h5><p><code>mmap()</code>系统调用将内核缓冲区映射到用户空间，使得用户进程与内核共享数据，省去了从内核到用户缓冲区的拷贝。但仍有3次数据拷贝（两次DMA，一次CPU），且需要4次上下文切换。</p><h5 id="2-sendfile-：系统调用的终极优化"><a href="#2-sendfile-：系统调用的终极优化" class="headerlink" title="2. sendfile()：系统调用的终极优化"></a>2. <code>sendfile()</code>：系统调用的终极优化</h5><p>Linux 2.1引入的<code>sendfile()</code>系统调用，将读取和发送合并为一次操作：<br>• <strong>2次上下文切换</strong>（1次系统调用）；<br>• <strong>3次数据拷贝</strong>（DMA拷贝磁盘到内核、CPU拷贝内核到Socket缓冲区、DMA拷贝到网卡）。  </p><p>若网卡支持<strong>SG-DMA（分散-聚集DMA）</strong>，则可进一步将CPU拷贝优化掉，仅需2次DMA拷贝，真正实现“零拷贝”。</p><hr><h4 id="四、PageCache：零拷贝的“加速器”"><a href="#四、PageCache：零拷贝的“加速器”" class="headerlink" title="四、PageCache：零拷贝的“加速器”"></a>四、PageCache：零拷贝的“加速器”</h4><p>零拷贝依赖内核的<strong>PageCache（页缓存）</strong>技术，它通过两种机制提升性能：  </p><ol><li><strong>缓存热点数据</strong>：最近访问的数据保留在内存中，减少磁盘访问。  </li><li><strong>预读机制</strong>：根据局部性原理，提前加载后续可能访问的数据。  </li></ol><p>然而，PageCache对<strong>大文件传输并不友好</strong>：<br>• 大文件会挤占缓存空间，影响小文件性能；<br>• 大文件的数据复用率低，预读反而浪费资源。  </p><p><strong>解决方案</strong>：针对大文件，采用<strong>异步I/O + 直接I/O</strong>，绕过PageCache，直接由磁盘到用户空间。</p><hr><h4 id="五、实践指南：何时用零拷贝？何时用直接I-O？"><a href="#五、实践指南：何时用零拷贝？何时用直接I-O？" class="headerlink" title="五、实践指南：何时用零拷贝？何时用直接I/O？"></a>五、实践指南：何时用零拷贝？何时用直接I/O？</h4><p>• <strong>小文件传输</strong>：优先使用零拷贝（如<code>sendfile</code>），结合PageCache加速。<br>• <strong>大文件传输</strong>：使用异步I/O + 直接I/O，避免PageCache污染。  </p><p><strong>Nginx配置示例</strong>：<br><figure class="highlight nginx"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="section">location</span> /video/ &#123;</span><br><span class="line">    <span class="attribute">sendfile</span> <span class="literal">on</span>;       <span class="comment"># 小文件用零拷贝</span></span><br><span class="line">    <span class="attribute">aio</span> <span class="literal">on</span>;            <span class="comment"># 大文件用异步I/O</span></span><br><span class="line">    <span class="attribute">directio</span> <span class="number">1024m</span>;    <span class="comment"># 超过1GB的文件启用直接I/O</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><hr><h4 id="六、总结"><a href="#六、总结" class="headerlink" title="六、总结"></a>六、总结</h4><p>零拷贝技术通过减少CPU参与的数据拷贝和上下文切换，显著提升了文件传输效率。其核心思想是：  </p><ol><li><strong>硬件协作</strong>：DMA承担数据搬运，释放CPU；  </li><li><strong>内核优化</strong>：合并系统调用，利用PageCache加速；  </li><li><strong>场景适配</strong>：区分大小文件，选择最优方案。  </li></ol><p>在高并发场景下，合理使用零拷贝（如Kafka、Nginx）可大幅提升吞吐量，而大文件传输则需另辟蹊径。</p>]]></content>
    
    
    <summary type="html">🥧个人对零拷贝技术的理解</summary>
    
    
    
    <category term="学习" scheme="https://outoflovenicoo.github.io/categories/%E5%AD%A6%E4%B9%A0/"/>
    
    
    <category term="操作系统" scheme="https://outoflovenicoo.github.io/tags/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/"/>
    
  </entry>
  
  <entry>
    <title>高性能网络模式</title>
    <link href="https://outoflovenicoo.github.io/posts/2025-03-09-%E9%AB%98%E6%80%A7%E8%83%BD%E7%BD%91%E7%BB%9C%E6%A8%A1%E5%BC%8F.html"/>
    <id>https://outoflovenicoo.github.io/posts/2025-03-09-%E9%AB%98%E6%80%A7%E8%83%BD%E7%BD%91%E7%BB%9C%E6%A8%A1%E5%BC%8F.html</id>
    <published>2025-03-09T10:19:03.000Z</published>
    <updated>2025-03-23T14:00:00.000Z</updated>
    
    <content type="html"><![CDATA[<h1 id="高性能网络模式：深入理解-Reactor-与-Proactor"><a href="#高性能网络模式：深入理解-Reactor-与-Proactor" class="headerlink" title="高性能网络模式：深入理解 Reactor 与 Proactor"></a>高性能网络模式：深入理解 Reactor 与 Proactor</h1><p>在构建高并发服务器时，传统的“一连接一线程”模型会面临性能瓶颈和资源浪费问题。<strong>I/O 多路复用技术</strong>的出现解决了这一难题，而基于此技术演化出的 <strong>Reactor</strong> 和 <strong>Proactor</strong> 模式，则成为了高性能网络编程的核心架构。本文将从设计思想、实现方案到应用场景，为你揭开这两种模式的神秘面纱。</p><h1 id="思维导图："><a href="#思维导图：" class="headerlink" title="思维导图："></a>思维导图：</h1><p><img src="2025-03-09-高性能网络模式/image-20250414161555385.png" alt="image-20250414161555385"></p><hr><h2 id="一、Reactor-模式：同步非阻塞的事件驱动模型"><a href="#一、Reactor-模式：同步非阻塞的事件驱动模型" class="headerlink" title="一、Reactor 模式：同步非阻塞的事件驱动模型"></a>一、Reactor 模式：同步非阻塞的事件驱动模型</h2><h3 id="1-核心思想"><a href="#1-核心思想" class="headerlink" title="1. 核心思想"></a>1. 核心思想</h3><p>Reactor 模式通过 <strong>事件分发机制</strong> 实现高效处理多连接。其核心由两个组件构成：<br>• <strong>Reactor</strong>：负责监听和分发事件（如连接建立、数据可读/写）<br>• <strong>处理资源池</strong>：线程/进程池负责具体业务处理</p><p><strong>类比现实场景</strong>：<br>Reactor 如同餐厅的接待员，持续监听客户请求（事件）。当新顾客到来（连接建立）时，接待员安排服务员（Handler）接待；当顾客点餐（数据到达）时，服务员开始处理订单。</p><hr><h3 id="2-三种经典实现方案"><a href="#2-三种经典实现方案" class="headerlink" title="2. 三种经典实现方案"></a>2. 三种经典实现方案</h3><h4 id="方案-1：单-Reactor-单进程-线程"><a href="#方案-1：单-Reactor-单进程-线程" class="headerlink" title="方案 1：单 Reactor 单进程/线程"></a>方案 1：单 Reactor 单进程/线程</h4><p><strong>架构组成</strong>：<br>• 单个进程/线程内包含三个核心对象：<br>  • <strong>Reactor</strong>：通过 <code>select</code>/<code>epoll</code> 监听所有事件<br>  • <strong>Acceptor</strong>：处理新连接建立<br>  • <strong>Handler</strong>：处理已建立连接的读写请求</p><p><strong>工作流程</strong>：  </p><ol><li>Reactor 监听所有事件，将连接建立事件分发给 Acceptor</li><li>Acceptor 调用 <code>accept()</code> 创建新连接，并生成对应的 Handler</li><li>Handler 处理数据读写（<code>read → 业务处理 → send</code>）</li></ol><p><strong>特点</strong>：<br>• 实现简单，无进程间通信开销<br>• 无法利用多核 CPU，业务处理必须非阻塞<br>• <strong>典型应用</strong>：Redis 6.0 前版本</p><hr><h4 id="方案-2：单-Reactor-多线程"><a href="#方案-2：单-Reactor-多线程" class="headerlink" title="方案 2：单 Reactor 多线程"></a>方案 2：单 Reactor 多线程</h4><p><strong>架构改进</strong>：<br>• 主线程保留 Reactor 和 Acceptor<br>• 引入线程池处理业务逻辑：<br>  • Handler 仅负责非阻塞 I/O 操作<br>  • 子线程处理业务后将结果返回主线程</p><p><strong>工作流程</strong>：  </p><ol><li>Reactor 监听事件，连接建立后由 Acceptor 创建 Handler</li><li>Handler 读取数据后，将数据提交给线程池处理</li><li>子线程完成业务逻辑，通过共享队列返回结果</li><li>主线程的 Handler 将结果发送给客户端</li></ol><p><strong>痛点</strong>：<br>• Reactor 单点可能成为性能瓶颈<br>• 需处理多线程资源共享问题<br>• <strong>典型应用</strong>：早期 Memcache</p><hr><h4 id="方案-3：多-Reactor-多进程-线程"><a href="#方案-3：多-Reactor-多进程-线程" class="headerlink" title="方案 3：多 Reactor 多进程/线程"></a>方案 3：多 Reactor 多进程/线程</h4><p><strong>架构设计</strong>：<br>• <strong>MainReactor</strong>：主线程/进程，仅处理新连接建立<br>• <strong>SubReactor</strong>：子线程/进程池，每个子单元管理一组连接<br>• <strong>Handler</strong>：绑定到 SubReactor 处理具体连接</p><p><strong>工作流程</strong>：  </p><ol><li>MainReactor 接收新连接，按负载均衡策略分配给 SubReactor</li><li>SubReactor 将连接加入自己的监听队列</li><li>事件触发时，SubReactor 调用对应 Handler 处理数据流</li></ol><p><strong>优势</strong>：<br>• 主从分工明确，扩展性强<br>• 避免单点性能瓶颈<br>• <strong>典型应用</strong>：Netty（多线程）、Nginx（多进程变体）</p><hr><h2 id="二、Proactor-模式：异步非阻塞的终极方案"><a href="#二、Proactor-模式：异步非阻塞的终极方案" class="headerlink" title="二、Proactor 模式：异步非阻塞的终极方案"></a>二、Proactor 模式：异步非阻塞的终极方案</h2><h3 id="1-核心思想-1"><a href="#1-核心思想-1" class="headerlink" title="1. 核心思想"></a>1. 核心思想</h3><p>Proactor 是真正的 <strong>异步 I/O 模型</strong>，其特点在于：<br>• <strong>操作系统完成 I/O 操作</strong>：包括数据从内核到用户空间的拷贝<br>• <strong>应用层只关注业务逻辑</strong>：处理已完成的 I/O 事件</p><p><strong>现实类比</strong>：<br>Proactor 如同外卖平台，骑手（系统内核）直接将餐品送到你家（数据就绪），你只需处理用餐（业务逻辑）即可。</p><hr><h3 id="2-工作流程"><a href="#2-工作流程" class="headerlink" title="2. 工作流程"></a>2. 工作流程</h3><ol><li><strong>注册异步操作</strong>：应用通过 <code>aio_read</code> 等接口发起请求，指定数据缓冲区</li><li><strong>系统内核执行 I/O</strong>：从网卡读取数据并自动拷贝到用户空间</li><li><strong>完成通知</strong>：内核通过回调通知 Proactor</li><li><strong>业务处理</strong>：Proactor 调用 Handler 处理数据</li></ol><hr><h3 id="3-平台支持差异"><a href="#3-平台支持差异" class="headerlink" title="3. 平台支持差异"></a>3. 平台支持差异</h3><div class="table-container"><table><thead><tr><th><strong>平台</strong></th><th><strong>实现方式</strong></th><th><strong>特点</strong></th></tr></thead><tbody><tr><td>Linux</td><td>模拟异步 I/O（如 <code>aio</code>）</td><td>仅支持文件操作，网络性能受限</td></tr><tr><td>Windows</td><td>原生支持 IOCP（完成端口）</td><td>真正异步，适合高性能网络服务</td></tr></tbody></table></div><hr><h2 id="三、Reactor-vs-Proactor-关键区别"><a href="#三、Reactor-vs-Proactor-关键区别" class="headerlink" title="三、Reactor vs Proactor 关键区别"></a>三、Reactor vs Proactor 关键区别</h2><div class="table-container"><table><thead><tr><th><strong>特性</strong></th><th><strong>Reactor</strong></th><th><strong>Proactor</strong></th></tr></thead><tbody><tr><td><strong>事件类型</strong></td><td>通知”可读/可写”（需应用主动处理数据）</td><td>通知”数据已就绪”（数据已存入应用缓冲区）</td></tr><tr><td><strong>数据处理</strong></td><td>应用层调用 <code>read</code>/<code>write</code> 完成 I/O 操作</td><td>系统自动完成数据读写</td></tr><tr><td><strong>性能瓶颈</strong></td><td>依赖非阻塞 I/O 和线程模型优化</td><td>依赖操作系统异步支持</td></tr><tr><td><strong>编程复杂度</strong></td><td>需处理非阻塞 I/O 状态和半包问题</td><td>只需关注业务逻辑</td></tr><tr><td><strong>典型应用</strong></td><td>Redis、Nginx、Netty</td><td>Windows IOCP 服务器</td></tr></tbody></table></div><hr><h2 id="四、如何选择网络模型？"><a href="#四、如何选择网络模型？" class="headerlink" title="四、如何选择网络模型？"></a>四、如何选择网络模型？</h2><h3 id="1-Reactor-适用场景"><a href="#1-Reactor-适用场景" class="headerlink" title="1. Reactor 适用场景"></a>1. Reactor 适用场景</h3><p>• <strong>跨平台需求</strong>（尤其是 Linux 环境）<br>• <strong>业务逻辑轻量</strong>（如微秒级处理）<br>• <strong>高并发连接</strong>（如百万级长连接）<br>• <strong>经典案例</strong>：<br>  • Redis：单 Reactor 处理内存级快速操作<br>  • Netty：多 Reactor 应对高并发网络请求</p><h3 id="2-Proactor-适用场景"><a href="#2-Proactor-适用场景" class="headerlink" title="2. Proactor 适用场景"></a>2. Proactor 适用场景</h3><p>• <strong>Windows 平台高性能服务</strong><br>• <strong>大数据量传输</strong>（如视频流处理）<br>• <strong>简化业务层开发</strong><br>• <strong>经典案例</strong>：<br>  • IIS 服务器：基于 IOCP 实现高效 HTTP 服务<br>  • 金融交易系统：低延迟处理高频交易数据</p><hr><h2 id="五、总结"><a href="#五、总结" class="headerlink" title="五、总结"></a>五、总结</h2><p><strong>Reactor 的本质</strong>：  </p><blockquote><p>“事件就绪时通知你处理” —— 应用程序仍需主动完成数据读写。</p></blockquote><p><strong>Proactor 的精髓</strong>：  </p><blockquote><p>“事件处理完通知你结果” —— 操作系统包揽脏活累活，应用层专注业务。</p></blockquote><p><strong>技术选型建议</strong>：<br>• 在 Linux 体系下，Reactor 仍是主流选择，结合 <code>epoll</code> 和线程池优化可达到 C10M 并发。<br>• Windows 平台优先考虑 Proactor（IOCP），充分发挥异步性能优势。<br>• 现代框架如 Netty 通过分层设计屏蔽底层差异，开发者可基于 API 统一编程模型。</p><p>理解这些底层网络模式是很重要的。因为无论是优化现有系统，还是设计新架构，Reactor 和 Proactor 的思想都将持续指引我们突破性能瓶颈。</p>]]></content>
    
    
    <summary type="html">🥧高性能网络模式</summary>
    
    
    
    <category term="学习" scheme="https://outoflovenicoo.github.io/categories/%E5%AD%A6%E4%B9%A0/"/>
    
    
    <category term="操作系统" scheme="https://outoflovenicoo.github.io/tags/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/"/>
    
  </entry>
  
  <entry>
    <title>MySQL如何存储数据</title>
    <link href="https://outoflovenicoo.github.io/posts/2025-03-09-MySQL%E5%A6%82%E4%BD%95%E5%AD%98%E5%82%A8%E6%95%B0%E6%8D%AE.html"/>
    <id>https://outoflovenicoo.github.io/posts/2025-03-09-MySQL%E5%A6%82%E4%BD%95%E5%AD%98%E5%82%A8%E6%95%B0%E6%8D%AE.html</id>
    <published>2025-03-09T10:19:03.000Z</published>
    <updated>2025-03-23T14:00:00.000Z</updated>
    
    <content type="html"><![CDATA[<h1 id="InnoDB存储引擎如何存储数据"><a href="#InnoDB存储引擎如何存储数据" class="headerlink" title="InnoDB存储引擎如何存储数据"></a>InnoDB存储引擎如何存储数据</h1><h2 id="思维导图："><a href="#思维导图：" class="headerlink" title="思维导图："></a><strong>思维导图：</strong></h2><p><img src="2025-03-09-MySQL如何存储数据/1.png" alt="img"></p><p>在MySQL数据库的世界里，InnoDB存储引擎堪称是数据存储的”心脏”。今天，我们就以一位数据库工程师的视角，揭开这个”心脏”的运作奥秘。准备好了吗？让我们沿着数据存储的脉络，开启一场技术探秘之旅！</p><h2 id="一、MySQL数据存储基石：InnoDB的精密设计"><a href="#一、MySQL数据存储基石：InnoDB的精密设计" class="headerlink" title="一、MySQL数据存储基石：InnoDB的精密设计"></a>一、MySQL数据存储基石：InnoDB的精密设计</h2><p>如果把数据库比作图书馆，InnoDB就是那个既懂分类又善管理的图书管理员。它通过精心设计的文件系统，将数据有序地存放在磁盘上。</p><h3 id="（一）磁盘文件里的”身份证”与”藏书阁”"><a href="#（一）磁盘文件里的”身份证”与”藏书阁”" class="headerlink" title="（一）磁盘文件里的”身份证”与”藏书阁”"></a>（一）磁盘文件里的”身份证”与”藏书阁”</h3><p><img src="2025-03-09-MySQL如何存储数据/2.png" alt="img"></p><p>当我们新建一个订单表<code>order</code>时，系统会悄悄生成几个关键文件：<br>• <strong>opt文件</strong>：就像是数据库的”身份证”，记录着默认的字符集（比如UTF-8）和校验规则。它确保中文不会变成乱码，数字比较时不会出错。<br>• <strong>frm文件</strong>：可以理解为”书架标签”，存储着表结构的定义。每次你DESC查看表结构时，系统其实就是在读取这个文件。<br>• <strong>idb文件</strong>：这才是真正的”藏书阁”。以<code>order.idb</code>为例，它存储着订单表的所有数据。就像现代图书馆的智能书架，MySQL 5.6.6之后默认每个表都有独立的.idb文件，这样要维护某个书架（表）时，再也不用搬动整个图书馆的藏书了。</p><p>举个真实案例：某电商平台发现订单表查询变慢，DBA通过<code>ALTER TABLE order ENGINE=InnoDB</code>重建表空间后，发现.idb文件体积缩小了30%，这正是独立表空间的优势体现。</p><h3 id="（二）表空间的俄罗斯套娃结构"><a href="#（二）表空间的俄罗斯套娃结构" class="headerlink" title="（二）表空间的俄罗斯套娃结构"></a>（二）表空间的俄罗斯套娃结构</h3><p>打开这个”藏书阁”，你会发现一个精妙的存储体系：</p><p><img src="2025-03-09-MySQL如何存储数据/3.png" alt="img"></p><figure class="highlight"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">表空间 → 段 → 区 → 页 → 行</span><br></pre></td></tr></table></figure><p>就像图书馆的分区管理：<br>• <strong>段（Segment）</strong>：类似图书馆的楼层分区（索引区、数据区）<br>• <strong>区（Extent）</strong>：每个楼层里的藏书区，由连续64个页组成（1MB）<br>• <strong>页（Page）</strong>：最基本的存储单元，相当于书架隔层（16KB）<br>• <strong>行（Row）</strong>：每本书就是一行数据</p><p>这种结构设计有个精妙之处：当需要新增数据时，InnoDB不是随意找个空位，而是整区整区地分配空间。就像图书馆扩建时直接增加整个书架区，而不是这里加一本那里塞一册。</p><h2 id="二、行格式"><a href="#二、行格式" class="headerlink" title="二、行格式"></a>二、行格式</h2><p>如果说表空间是图书馆，那么行格式就是书籍的排版规范。InnoDB支持多种行格式，我们以最常用的Compact格式为例，看看它是如何将数据”装订成册”的。</p><h3 id="（一）变长字段的"><a href="#（一）变长字段的" class="headerlink" title="（一）变长字段的"></a>（一）变长字段的</h3><p>假设我们有一张用户表：<br><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">CREATE TABLE</span> users (</span><br><span class="line">    id <span class="type">INT</span> <span class="keyword">NOT NULL</span>,</span><br><span class="line">    name <span class="type">VARCHAR</span>(<span class="number">20</span>),</span><br><span class="line">    email <span class="type">VARCHAR</span>(<span class="number">50</span>)</span><br><span class="line">);</span><br></pre></td></tr></table></figure><br>当插入一条记录：<br><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">INSERT INTO</span> users <span class="keyword">VALUES</span>(<span class="number">1</span>, <span class="string">&#x27;张三&#x27;</span>, <span class="string">&#x27;zhangsan@example.com&#x27;</span>);</span><br></pre></td></tr></table></figure><br>Compact行格式会先在数据行头部放置两把”尺子”：</p><ol><li><p><strong>变长字段长度列表</strong>：逆序记录每个变长字段的实际长度<br>• email长度23字节（ASCII每个字符1字节）<br>• name长度4字节（每个中文字符3字节？不！这里有个常见误区，实际存储长度取决于字符集）<br>• 存储方式：<code>[23,4]</code>的逆序十六进制<code>0x17 0x04</code></p></li><li><p><strong>NULL值标记位图</strong>：<br>• 三个字段都不允许NULL，所以这个列表不存在<br>• 如果允许NULL，会用位图标记哪些字段是NULL（1表示NULL）</p></li></ol><p>这里有个有趣的测试：将name字段改为CHAR(20)，实际存储长度会变成60字节（假设UTF8MB4字符集），而VARCHAR(20)实际存储长度根据内容变化。这就是CHAR类型在存储空间上的”以空间换时间”策略。</p><h3 id="（二）NULL值的存储"><a href="#（二）NULL值的存储" class="headerlink" title="（二）NULL值的存储"></a>（二）NULL值的存储</h3><p>当表中存在允许NULL的字段时，Compact行格式会施展它的”隐身术”：<br><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">CREATE TABLE</span> orders (</span><br><span class="line">    id <span class="type">INT</span> <span class="keyword">PRIMARY KEY</span>,</span><br><span class="line">    product <span class="type">VARCHAR</span>(<span class="number">100</span>),</span><br><span class="line">    buyer <span class="type">VARCHAR</span>(<span class="number">50</span>) <span class="keyword">NULL</span></span><br><span class="line">);</span><br></pre></td></tr></table></figure><br>假设插入：<br><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">INSERT INTO</span> orders <span class="keyword">VALUES</span>(<span class="number">1001</span>, <span class="string">&#x27;智能手机&#x27;</span>, <span class="keyword">NULL</span>);</span><br></pre></td></tr></table></figure><br>此时：</p><ol><li>NULL值列表用1字节表示：二进制<code>00000010</code>（逆序排列，第二位表示buyer为NULL）</li><li>实际数据区不存储NULL字段的值</li><li>省去了存储”NULL”字符串的空间</li></ol><p>根据统计，当表中存在多个可为NULL的字段时，这种设计可节省约5%的存储空间。某社交平台用户表优化后，仅NULL优化就减少了20GB的存储空间！</p><h2 id="三、当数据膨胀时的”分页存储术”"><a href="#三、当数据膨胀时的”分页存储术”" class="headerlink" title="三、当数据膨胀时的”分页存储术”"></a>三、当数据膨胀时的”分页存储术”</h2><p>想象一本百科全书太厚无法放入书架隔层，这时候就需要分册存放。InnoDB的行溢出机制就是这种智慧的数字版。</p><h3 id="（一）行溢出的临界点计算"><a href="#（一）行溢出的临界点计算" class="headerlink" title="（一）行溢出的临界点计算"></a>（一）行溢出的临界点计算</h3><p>每个页（16KB）能存储多少数据？我们通过公式计算：<br><figure class="highlight abnf"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">最大行长度 <span class="operator">=</span> 页大小(<span class="number">16384</span>) - 行头信息(约<span class="number">56</span>字节) ≈ <span class="number">16328</span>字节</span><br></pre></td></tr></table></figure><br>当某行数据超过这个阈值时，就会触发行溢出。比如一个包含10个TEXT字段的表，每条记录都可能需要溢出存储。</p><h3 id="（二）溢出页的”目录索引”"><a href="#（二）溢出页的”目录索引”" class="headerlink" title="（二）溢出页的”目录索引”"></a>（二）溢出页的”目录索引”</h3><p>当发生行溢出时，Compact行格式会：</p><ol><li>在原始页保留768字节的”书签”</li><li>剩余数据存入溢出页</li><li>用20字节的指针记录溢出页地址</li><li>多个溢出页通过链表连接</li></ol><p>这就像图书馆的书籍目录：<br>• 主书架存放目录页（包含各分册位置）<br>• 实际内容存放在多个分册书架</p><p>某论坛系统曾因大文本字段导致频繁行溢出，通过将大字段拆分到扩展表，查询性能提升了3倍。</p><h2 id="四、行格式设计"><a href="#四、行格式设计" class="headerlink" title="四、行格式设计"></a>四、行格式设计</h2><h3 id="（一）Compact-vs-Dynamic：选择的智慧"><a href="#（一）Compact-vs-Dynamic：选择的智慧" class="headerlink" title="（一）Compact vs Dynamic：选择的智慧"></a>（一）Compact vs Dynamic：选择的智慧</h3><p>MySQL 8.0默认使用Dynamic行格式，它在处理溢出时更激进：<br>• 仅保留20字节指针<br>• 所有变长字段数据优先存溢出页<br>• 更适合现代应用的大数据字段场景</p><p>选择建议：<br>• 频繁更新的大字段表 → Dynamic<br>• 需要兼容旧版本 → Compact<br>• 压缩需求 → Compressed</p><h3 id="（二）字符集的隐藏陷阱"><a href="#（二）字符集的隐藏陷阱" class="headerlink" title="（二）字符集的隐藏陷阱"></a>（二）字符集的隐藏陷阱</h3><p>当计算varchar(n)最大长度时，字符集的影响常被忽视：<br>• UTF8MB4字符集：每个字符最多4字节<br>• 实际最大n值 = (65535 - 长度列表 - NULL列表) / 4</p><p>例如允许NULL的单字段表：<br><figure class="highlight tap"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">(65535 -<span class="number"> 2 </span>- 1) /<span class="number"> 4 </span>≈ 16383字符</span><br></pre></td></tr></table></figure><br>某国际化电商就曾因未考虑字符集，导致地址字段被截断，损失百万订单。</p><h2 id="五、性能优化"><a href="#五、性能优化" class="headerlink" title="五、性能优化"></a>五、性能优化</h2><ol><li><strong>NULL值优化</strong>：将允许NULL的字段改为NOT NULL DEFAULT ‘’，可节省NULL列表空间</li><li><strong>大字段分离</strong>：将BLOB/TEXT字段拆分到扩展表</li><li><strong>行格式转换</strong>：<code>ALTER TABLE ... ROW_FORMAT=DYNAMIC</code></li><li><strong>页压缩</strong>：对历史数据表启用页压缩</li><li><strong>字符集选择</strong>：中文环境优先考虑UTF8MB4而非UTF8</li></ol><p>某金融系统通过上述优化组合拳，使核心交易表的TPS从1500提升到5200，效果显著。</p><h2 id="结语：存储之道的三重境界"><a href="#结语：存储之道的三重境界" class="headerlink" title="结语：存储之道的三重境界"></a>结语：存储之道的三重境界</h2><p>理解InnoDB的存储机制，就像修炼数据库的内功心法：</p><ol><li><strong>见山是山</strong>：看懂文件结构和行格式</li><li><strong>见山不是山</strong>：理解设计哲学与取舍权衡</li><li><strong>见山还是山</strong>：能根据业务特征定制存储方案</li></ol><p>当我们翻开InnoDB的存储宝典，看到的不仅是冷冰冰的数据结构，更是一群工程师对效率与可靠性的极致追求。下次当你执行一条SELECT语句时，不妨想象一下，这简单的查询背后，正有一支精密的”存储交响乐团”在为你演奏。</p><h1 id="参考博客："><a href="#参考博客：" class="headerlink" title="参考博客："></a>参考博客：</h1><p><a href="https://xiaolincoding.com/mysql/base/row_format.html#总结">MySQL 一行记录是怎么存储的？</a></p>]]></content>
    
    
    <summary type="html">🥧MySQL如何存储数据</summary>
    
    
    
    <category term="学习" scheme="https://outoflovenicoo.github.io/categories/%E5%AD%A6%E4%B9%A0/"/>
    
    
    <category term="MySQL" scheme="https://outoflovenicoo.github.io/tags/MySQL/"/>
    
  </entry>
  
  <entry>
    <title>联合索引学习笔记</title>
    <link href="https://outoflovenicoo.github.io/posts/2025-03-09-%E8%81%94%E5%90%88%E7%B4%A2%E5%BC%95%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0.html"/>
    <id>https://outoflovenicoo.github.io/posts/2025-03-09-%E8%81%94%E5%90%88%E7%B4%A2%E5%BC%95%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0.html</id>
    <published>2025-03-09T10:19:03.000Z</published>
    <updated>2025-03-23T14:00:00.000Z</updated>
    
    <content type="html"><![CDATA[<h1 id="联合索引底层以及内幕"><a href="#联合索引底层以及内幕" class="headerlink" title="联合索引底层以及内幕"></a>联合索引底层以及内幕</h1><p><a href="https://mp.weixin.qq.com/s/8qemhRg5MgXs1So5YCv0fQ">联合索引底层</a></p><p><a href="https://blog.csdn.net/wangye135/article/details/140389620">MySQL覆盖索引和索引跳跃扫描-CSDN博客</a></p><p><img src="2025-03-09-联合索引学习笔记/image-20250407160156273-4012927.png" alt="image-20250407160156273"></p><h3 id="被问到过一个面试题："><a href="#被问到过一个面试题：" class="headerlink" title="被问到过一个面试题："></a>被问到过一个面试题：</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">select a,c from t <span class="type">where</span> <span class="variable">a</span> <span class="operator">=</span> <span class="number">1</span> and b= <span class="number">2</span> order by c desc</span><br></pre></td></tr></table></figure><p>应该设置什么索引，c的升序和降序会有什么影响，哪个更快一点。</p><h3 id="升序索引与降序索引对查询性能的影响"><a href="#升序索引与降序索引对查询性能的影响" class="headerlink" title="升序索引与降序索引对查询性能的影响"></a>升序索引与降序索引对查询性能的影响</h3><h4 id="1-查询排序方向与索引排序方向一致"><a href="#1-查询排序方向与索引排序方向一致" class="headerlink" title="1. 查询排序方向与索引排序方向一致"></a>1. 查询排序方向与索引排序方向一致</h4><ul><li><strong>升序索引用于升序查询</strong>：当创建的索引是 <code>(a, b, c ASC)</code>（<code>ASC</code> 表示升序，可省略），并且查询语句是 <code>ORDER BY c ASC</code> 时，数据库可以直接按照索引中 <code>c</code> 列的顺序来返回结果，无需额外的排序操作，这样能显著提升查询效率。因为索引已经按照升序排列好了，数据库可以直接从索引中获取有序的数据。</li><li><strong>降序索引用于降序查询</strong>：如果创建的索引是 <code>(a, b, c DESC)</code>，而查询语句是 <code>ORDER BY c DESC</code>，数据库同样可以直接利用索引中 <code>c</code> 列的降序排列来返回结果，避免了额外的排序开销。</li></ul><h4 id="2-查询排序方向与索引排序方向不一致"><a href="#2-查询排序方向与索引排序方向不一致" class="headerlink" title="2. 查询排序方向与索引排序方向不一致"></a>2. 查询排序方向与索引排序方向不一致</h4><ul><li><strong>升序索引用于降序查询</strong>：当使用 <code>(a, b, c ASC)</code> 索引，而查询语句是 <code>ORDER BY c DESC</code> 时，数据库可能无法直接利用索引的顺序，需要对从索引中获取的数据进行额外的降序排序操作。这会增加查询的时间和资源消耗，尤其是在处理大量数据时，性能下降会更明显。</li><li><strong>降序索引用于升序查询</strong>：类似地，若使用 <code>(a, b, c DESC)</code> 索引，而查询是 <code>ORDER BY c ASC</code>，数据库也需要对数据进行额外的升序排序，导致性能降低。</li></ul><h3 id="哪个更快取决于具体场景"><a href="#哪个更快取决于具体场景" class="headerlink" title="哪个更快取决于具体场景"></a>哪个更快取决于具体场景</h3><ul><li><strong>如果查询中</strong> <strong><code>ORDER BY c</code></strong>的方向固定：<ul><li>若查询总是 <code>ORDER BY c ASC</code>，那么创建升序索引 <code>(a, b, c)</code> 会更快，因为可以直接利用索引的顺序。</li><li>若查询总是 <code>ORDER BY c DESC</code>，则创建降序索引 <code>(a, b, c DESC)</code> 更合适，能避免额外的排序操作。</li></ul></li><li><strong>如果查询中</strong> <strong><code>ORDER BY c</code></strong>的方向不固定：<ul><li>在某些数据库（如 MySQL 8.0 及以上版本）中，可以同时创建升序和降序索引，但这会增加索引维护的开销，因为每次插入、更新或删除数据时，都需要同时更新多个索引。</li><li>也可以考虑只创建一个升序索引，让数据库在需要降序排序时进行额外的排序操作。在数据量较小的情况下，这种额外排序的开销可能并不明显。</li></ul></li></ul><p><strong>示例代码</strong></p><p><strong>升序索引</strong></p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">-- 创建升序索引</span></span><br><span class="line"><span class="keyword">CREATE</span> INDEX idx_a_b_c_asc <span class="keyword">ON</span> t (a, b, c);</span><br><span class="line"></span><br><span class="line"><span class="comment">-- 升序查询</span></span><br><span class="line"><span class="keyword">SELECT</span> a, c <span class="keyword">FROM</span> t <span class="keyword">WHERE</span> a <span class="operator">=</span> <span class="number">1</span> <span class="keyword">AND</span> b <span class="operator">=</span> <span class="number">2</span> <span class="keyword">ORDER</span> <span class="keyword">BY</span> c <span class="keyword">ASC</span>;</span><br></pre></td></tr></table></figure><p><strong>降序索引</strong></p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">-- 创建降序索引</span></span><br><span class="line"><span class="keyword">CREATE</span> INDEX idx_a_b_c_desc <span class="keyword">ON</span> t (a, b, c <span class="keyword">DESC</span>);</span><br><span class="line"></span><br><span class="line"><span class="comment">-- 降序查询</span></span><br><span class="line"><span class="keyword">SELECT</span> a, c <span class="keyword">FROM</span> t <span class="keyword">WHERE</span> a <span class="operator">=</span> <span class="number">1</span> <span class="keyword">AND</span> b <span class="operator">=</span> <span class="number">2</span> <span class="keyword">ORDER</span> <span class="keyword">BY</span> c <span class="keyword">DESC</span>;</span><br></pre></td></tr></table></figure><p>综上所述，选择升序索引还是降序索引取决于查询中 <code>ORDER BY</code> 子句的排序方向。</p>]]></content>
    
    
    <summary type="html">🥧联合索引学习</summary>
    
    
    
    <category term="学习" scheme="https://outoflovenicoo.github.io/categories/%E5%AD%A6%E4%B9%A0/"/>
    
    
    <category term="MySQL" scheme="https://outoflovenicoo.github.io/tags/MySQL/"/>
    
  </entry>
  
  <entry>
    <title>个人对DeepSeek原理的理解</title>
    <link href="https://outoflovenicoo.github.io/posts/2025-02-20-%E4%B8%AA%E4%BA%BA%E5%AF%B9DeepSeek%E5%8E%9F%E7%90%86%E7%9A%84%E7%90%86%E8%A7%A3.html"/>
    <id>https://outoflovenicoo.github.io/posts/2025-02-20-%E4%B8%AA%E4%BA%BA%E5%AF%B9DeepSeek%E5%8E%9F%E7%90%86%E7%9A%84%E7%90%86%E8%A7%A3.html</id>
    <published>2025-02-20T10:19:03.000Z</published>
    <updated>2025-02-20T14:00:00.000Z</updated>
    
    <content type="html"><![CDATA[<p><img src="2025-02-20-%E4%B8%AA%E4%BA%BA%E5%AF%B9DeepSeek%E5%8E%9F%E7%90%86%E7%9A%84%E7%90%86%E8%A7%A3/diagram.png" alt=""></p><h1>深入理解DeepSeek：从训练到概念的全面解析</h1><p>​在如今的人工智能领域，大模型可谓是备受关注的焦点。DeepSeek作为其中一员，有着独特的技术路径和理念。今天，就来跟大家聊聊我对DeepSeek的一些理解，一下仅仅是我个人的理解，不一定保证正确。</p><h2 id="一、大模型训练步骤">一、大模型训练步骤</h2><h3 id="预训练：对Transformer结构的改进">预训练：对Transformer结构的改进</h3><p>DeepSeek在预训练阶段，对Transformer结构进行了一系列改进。Transformer结构在当下的大模型中广泛应用，而DeepSeek的改进独具匠心。</p><ul><li><p><strong>DeepSeekMoE</strong>：这一改进针对的是前馈神经网络（FNN）。FNN在处理信息时起着关键作用，DeepSeekMoE对其进行优化，能够更高效地处理和传递信息，让模型在面对大量数据时，能够更准确地捕捉其中的特征和规律。deepseek取代了传统transformer的FNN（前馈神经网络），改用了DeepSeekMoE（稀疏专家网络层，每一个专家都是一个独立的神经网络，这些专家可以是FNN，也可以是MoE层本身），当我们input时，它会通过门控网络，采取路由的方式，找到合适的专家，与传统的MoE对比，DeepSeek使用更细粒度的专家，并将一些专家隔离为共享专家，能够减少专家之间的知识冗余。<strong>与单纯的FNN相比</strong>，采用这种方式进行训练，不需要使用所有的参数，只需要通过路由找到合适的专家就行，能够减少计算量。</p></li><li><p><strong>MLA（改进MHA）</strong>：多头注意力机制（MHA）是Transformer的核心部分之一。deepseek采用MLA机制，<strong>代替了传统的MHA</strong>,标准的Transformer 架构里面的MHA架构会产出非常多的KV Cache。相比MQA的KV共用和GQA的KV分组，MLA的核心是注意力键和值的低秩联合压缩，以减少推理过程中的键值(KV)缓存。相比MHA具有更好的性能，但需要的 KV 缓存量要少得多。KV Cache的缓存量少保证了DeepSeek的训练成本较低。</p></li><li><p><strong>MTP</strong>：MTP在训练阶段和推理阶段都有着重要作用。<strong>MTP 的全称是 Multi - Token Prediction</strong>（多令牌预测），与之对应的是 DeepSeek-V3 发布之前业界普遍使用的单令牌预测（Single - Token Prediction，STP），STP 一次仅预测一个Token，而 MTP 可同时预测多个 Token，<strong>这一方案在训练阶段可以提升数据训练效率，在推理阶段可以实现显著加速</strong>。</p></li><li><p><strong>并行训练策略：</strong>deepseek还采取了并行训练策略，通过HAI-LLM 框架进行训练，但是这块我不太了解。</p></li></ul><h3 id="后训练：强化学习（GRPO-改进PPO）">后训练：强化学习（GRPO - 改进PPO）</h3><p>在预训练之后，DeepSeek进入后训练阶段，采用强化学习的方式，具体是通过GRPO（改进的近端策略优化算法PPO）来实现。PPO本身是一种在强化学习中常用的算法，而GRPO对其进行改进，使得模型在与环境交互的过程中，能够更有效地调整自身策略。通过不断地尝试和反馈，模型可以学习到如何做出更优的决策，进一步提升其性能和表现。DeepSeek采用强化学习GRPO算法，对比原始的PPO方案(一次输出一个结果)，GRPO（一次输出多个结果然后选最优的）只需要训练一个模型，不用训练Critic Model，GRPO通过优化PPO算法，移除了价值模型，降低了计算开销，同时利用群体相对优势函数和KL散度惩罚，确保策略更新既高效又稳定。</p><h2 id="二、其他相关概念">二、其他相关概念</h2><h3 id="大模型概念">大模型概念</h3><p>大模型如今已经成为人工智能发展的重要方向。它具有强大的学习能力和泛化能力，能够处理各种复杂的任务。通过大规模的数据训练，大模型可以学习到丰富的知识和模式，从而在自然语言处理、图像识别等多个领域发挥重要作用。</p><h3 id="知识蒸馏概念">知识蒸馏概念</h3><p>知识蒸馏是一种将大型模型学到的知识迁移到小型模型中的技术。通过让小型模型模仿大型模型的输出，能够在不损失太多性能的前提下，降低模型的复杂度和计算成本。这对于实际应用中资源受限的场景非常有帮助，比如在一些移动设备或者边缘设备上，通过知识蒸馏得到的小型模型可以更快地运行，同时也能保持较好的效果。</p><h3 id="AI-Agent概念">AI Agent概念</h3><p>AI Agent是一种能够感知环境，并根据感知结果采取行动以实现目标的智能体。在DeepSeek相关的情境中，AI Agent可以利用DeepSeek模型的能力，与外部环境进行交互。它可以根据环境中的信息做出决策，执行相应的操作，并通过不断地学习和调整，更好地适应环境，完成各种任务。</p><h2 id="参考博客：">参考博客：</h2><p><a href="https://arxiv.org/abs/2501.12948">DeepSeek-R1: Incentivizing Reasoning Capability in LLMs via Reinforcement Learning</a></p><p><a href="https://www.zhihu.com/question/11797471137/answer/122885941335">DeepSeek v3与v1的区别</a></p><p><a href="https://mp.weixin.qq.com/s/fUumK29XohD7Wm5bTlyokg">DeepSeek-V3 高效训练关键技术分析</a></p><p><a href="https://mp.weixin.qq.com/s/W4LzpMb3cIn0zVlW2oVung">漫谈DeepSeek及其背后的核心技术</a></p><p><a href="https://zhuanlan.zhihu.com/p/29123783155">AI agent是什么</a></p><p><a href="https://zhuanlan.zhihu.com/p/81467832">知识蒸馏是什么？</a></p><p><a href="https://www.zhihu.com/question/10766825126/answer/88583863333">DeepSeek的GRPO算法是什么？</a></p><p><a href="https://zhuanlan.zhihu.com/p/25600081364">聊一聊DeepSeek中用到的GRPO算法</a></p>]]></content>
    
    
    <summary type="html">🥧个人对DeepSeek原理的理解</summary>
    
    
    
    <category term="学习" scheme="https://outoflovenicoo.github.io/categories/%E5%AD%A6%E4%B9%A0/"/>
    
    
    <category term="前沿" scheme="https://outoflovenicoo.github.io/tags/%E5%89%8D%E6%B2%BF/"/>
    
  </entry>
  
  <entry>
    <title>工厂和策略模式优化消息处理</title>
    <link href="https://outoflovenicoo.github.io/posts/2025-01-11-%E5%B7%A5%E5%8E%82%E5%92%8C%E7%AD%96%E7%95%A5%E6%A8%A1%E5%BC%8F%E4%BC%98%E5%8C%96%E6%B6%88%E6%81%AF%E5%A4%84%E7%90%86.html"/>
    <id>https://outoflovenicoo.github.io/posts/2025-01-11-%E5%B7%A5%E5%8E%82%E5%92%8C%E7%AD%96%E7%95%A5%E6%A8%A1%E5%BC%8F%E4%BC%98%E5%8C%96%E6%B6%88%E6%81%AF%E5%A4%84%E7%90%86.html</id>
    <published>2025-01-11T10:19:03.000Z</published>
    <updated>2025-03-23T14:00:00.000Z</updated>
    
    <content type="html"><![CDATA[<h2 id="工厂和策略模式优化消息处理">工厂和策略模式优化消息处理</h2><p>有八中消息类型：</p><p><img src="2025-01-11-%E5%B7%A5%E5%8E%82%E5%92%8C%E7%AD%96%E7%95%A5%E6%A8%A1%E5%BC%8F%E4%BC%98%E5%8C%96%E6%B6%88%E6%81%AF%E5%A4%84%E7%90%86/image-1.png" alt=""></p><p>首先，为了让用户评论、点赞与消息发送解耦，可以采用观察者模式，用户评论触发一个消息通知事件</p><p><img src="2025-01-11-%E5%B7%A5%E5%8E%82%E5%92%8C%E7%AD%96%E7%95%A5%E6%A8%A1%E5%BC%8F%E4%BC%98%E5%8C%96%E6%B6%88%E6%81%AF%E5%A4%84%E7%90%86/image-3.png" alt=""></p><p>在处理消息时，不同的消息类型有不同的策略。</p><p>比如点赞消息时先聚合到redis，再迁移到数据库</p><p><img src="2025-01-11-%E5%B7%A5%E5%8E%82%E5%92%8C%E7%AD%96%E7%95%A5%E6%A8%A1%E5%BC%8F%E4%BC%98%E5%8C%96%E6%B6%88%E6%81%AF%E5%A4%84%E7%90%86/image-5.png" alt=""></p><p>官方消息是直接存消息表，在用户登录的时候将官方消息迁移到用户消息接收表（这样可以避免数据库压力太大）</p><p><img src="2025-01-11-%E5%B7%A5%E5%8E%82%E5%92%8C%E7%AD%96%E7%95%A5%E6%A8%A1%E5%BC%8F%E4%BC%98%E5%8C%96%E6%B6%88%E6%81%AF%E5%A4%84%E7%90%86/image-24.png" alt=""></p><p>用户的回复消息，是要先存入到消息表，生成一个消息id，再存入消息接受表。给消息id和用户id加唯一索引，这样可以避免用户收到重复的消息。</p><p><img src="2025-01-11-%E5%B7%A5%E5%8E%82%E5%92%8C%E7%AD%96%E7%95%A5%E6%A8%A1%E5%BC%8F%E4%BC%98%E5%8C%96%E6%B6%88%E6%81%AF%E5%A4%84%E7%90%86/image-26.png" alt=""></p><p>因为有三种不同的应对策略，所以可以写一个工厂来统一处理。首先先定义一个工厂，写一个消息处理的接口</p><p><img src="2025-01-11-%E5%B7%A5%E5%8E%82%E5%92%8C%E7%AD%96%E7%95%A5%E6%A8%A1%E5%BC%8F%E4%BC%98%E5%8C%96%E6%B6%88%E6%81%AF%E5%A4%84%E7%90%86/image-25.png" alt=""></p><p>接口：<br>注意，精髓是@PostConstruct，这个注解会让bean在初始化的时候，将hander注册到工厂里面。</p><p><img src="2025-01-11-%E5%B7%A5%E5%8E%82%E5%92%8C%E7%AD%96%E7%95%A5%E6%A8%A1%E5%BC%8F%E4%BC%98%E5%8C%96%E6%B6%88%E6%81%AF%E5%A4%84%E7%90%86/image-22.png" alt=""></p><p>针对接口定义三个实现类，处理不同的消息类型</p><p>点赞消息处理</p><p><img src="2025-01-11-%E5%B7%A5%E5%8E%82%E5%92%8C%E7%AD%96%E7%95%A5%E6%A8%A1%E5%BC%8F%E4%BC%98%E5%8C%96%E6%B6%88%E6%81%AF%E5%A4%84%E7%90%86/image-21.png" alt=""></p><p>官方消息处理</p><p><img src="2025-01-11-%E5%B7%A5%E5%8E%82%E5%92%8C%E7%AD%96%E7%95%A5%E6%A8%A1%E5%BC%8F%E4%BC%98%E5%8C%96%E6%B6%88%E6%81%AF%E5%A4%84%E7%90%86/image-23.png" alt=""></p><p>回复消息处理</p><p><img src="2025-01-11-%E5%B7%A5%E5%8E%82%E5%92%8C%E7%AD%96%E7%95%A5%E6%A8%A1%E5%BC%8F%E4%BC%98%E5%8C%96%E6%B6%88%E6%81%AF%E5%A4%84%E7%90%86/image-20250420152609880.png" alt="image-20250420152609880"></p>]]></content>
    
    
    <summary type="html">🥧工厂和策略模式优化消息处理</summary>
    
    
    
    <category term="学习" scheme="https://outoflovenicoo.github.io/categories/%E5%AD%A6%E4%B9%A0/"/>
    
    
    <category term="实习经验" scheme="https://outoflovenicoo.github.io/tags/%E5%AE%9E%E4%B9%A0%E7%BB%8F%E9%AA%8C/"/>
    
  </entry>
  
  <entry>
    <title>社区开发总结</title>
    <link href="https://outoflovenicoo.github.io/posts/2025-01-10-%E7%A4%BE%E5%8C%BA%E5%BC%80%E5%8F%91%E6%80%BB%E7%BB%93.html"/>
    <id>https://outoflovenicoo.github.io/posts/2025-01-10-%E7%A4%BE%E5%8C%BA%E5%BC%80%E5%8F%91%E6%80%BB%E7%BB%93.html</id>
    <published>2025-01-10T10:19:03.000Z</published>
    <updated>2025-03-23T14:00:00.000Z</updated>
    
    <content type="html"><![CDATA[<h1>RPA社区开发经验分享</h1><p><img src="2025-01-10-%E7%A4%BE%E5%8C%BA%E5%BC%80%E5%8F%91%E6%80%BB%E7%BB%93/diagram.png" alt=""></p><p>RPA社区的开发是我在实习的过程中主要做的一个事情，在开发RPA社区的过程中，我积累了不少宝贵经验，今天就来和大家分享一下。</p><h2 id="开发流程梳理">开发流程梳理</h2><h3 id="前期准备">前期准备</h3><ol><li><p><strong>阅读PRD</strong>：产品需求文档（PRD）是开发的基石。我们仔细研读其中的每一项需求，明确社区要实现的功能，比如用户的操作权限、管理端的功能模块等。只有把需求吃透，后续开发才不会偏离方向。  </p></li><li><p><strong>数据库设计</strong>：根据功能需求设计数据库结构。像帖子、用户信息、回复等数据，都需要合理规划存储方式。例如，为了方便查询和管理，我们将用户信息表与帖子表通过用户ID建立关联，确保数据的一致性和高效访问。  </p></li><li><p><strong>接口编写</strong>：编写接口是为了让不同模块之间能顺畅通信。我们按照功能模块划分，编写了帖子相关接口、用户接口、消息接口等。接口的设计遵循规范，保证数据的正确传输和交互。  </p></li></ol><h3 id="中期联调与测试">中期联调与测试</h3><ul><li><p><strong>前端联调</strong>：前端开发完成后，与后端进行联调。这一步主要是确保前端页面能正确展示后端传递的数据，用户操作能触发对应的后端逻辑。比如用户点击发布帖子按钮，前端能将帖子内容准确无误地传递给后端进行存储。  </p></li><li><p><strong>接口测试/Bug修复</strong>：对编写好的接口进行全面测试，检查接口的功能是否正常、响应时间是否符合要求等。一旦发现Bug，及时修复。通过不断测试和修复，保证社区功能的稳定性和可靠性。  </p></li></ul><h2 id="核心模块功能实现">核心模块功能实现</h2><h3 id="消息模块">消息模块</h3><p>消息模块是社区内用户互动的重要桥梁，包含获取消息和发送消息两大功能。在帖子发布时，系统会自动触发发送消息功能，及时通知相关用户或群体有新帖子发布。当帖子被点赞、回复被点赞或采纳时，同样会发送消息，让用户第一时间知晓自己的内容获得了互动，增强用户之间的连接和社区的活跃度。  </p><h3 id="帖子模块">帖子模块</h3><ul><li><p><strong>发布与互动</strong>：发布帖子时，除了常规的内容存储，还利用Guava将数据插入到ES（Elasticsearch）中，以便后续实现高效的帖子检索功能。点赞帖子时，不仅帖子的点赞数会加1，新的点赞记录会保存到点赞记录表，同时异步发送一条点赞消息，确保互动信息及时传达。  </p></li><li><p><strong>删除逻辑</strong>：在删除帖子功能中，通过事务控制确保数据一致性。用户只能删除自己的帖子，系统会先验证用户身份（将帖子的is_delete字段设置为1，传入当前用户ID进行校验），若用户不是帖子拥有者则操作失败。然后删除帖子相关回复，并在ES中删除对应记录，保证数据的完整性和准确性。  </p></li></ul><h3 id="回复模块">回复模块</h3><p>回复模块功能丰富，具备分页查询回复功能。如果用户查询时携带顶级评论ID，就能查看该顶级评论下的子评论，满足用户不同场景的查看需求。增加回复、删除回复、采纳回复以及点赞回复等操作，都会触发消息发送，让相关用户及时接收反馈，促进交流互动。  </p><h3 id="用户模块">用户模块</h3><p>用户端涵盖多个分页功能，包括用户回复分页、课程分页、帖子分页、主题分页等，方便用户分类查看自己的相关信息，清晰管理个人在社区内的各种活动记录，提升用户体验。  </p><h3 id="管理端模块">管理端模块</h3><ul><li><p><strong>黑名单模块</strong>：管理端的黑名单模块可进行分页查询黑名单列表，对违规用户进行批量封禁或解封操作，维护社区的良好秩序和环境。  </p></li><li><p><strong>帖子管理模块</strong>：支持分页查询所有帖子，便于管理员全面掌握社区内容情况。同时具备发布公告、批量上架/下架帖子、帖子置顶和删除等管理功能，灵活管理社区帖子内容，确保优质内容得到展示，违规内容及时处理。  </p></li><li><p><strong>标签模块</strong>：用于管理标签，包括分页查询标签、添加标签、删除标签以及标签关联帖子/主题等操作，帮助用户更便捷地分类和检索帖子内容，提升社区内容的组织性和可查找性。  </p></li><li><p><strong>话题管理模块</strong>：实现话题分页查询、话题关联帖子以及添加、修改话题等功能，围绕话题组织内容，促进用户参与特定主题的讨论，增强社区的话题性和互动性。  </p></li></ul><h2 id="项目瓶颈：">项目瓶颈：</h2><p>目前的RPA社区已经基本上覆盖了一个社区如知乎等的全部功能，但是我觉得由于目前开发的RPA社区是不完善的，随着用户的增多，这个项目可能有一些瓶颈，这可能是后端上的，也可能是资源上的。</p><p>​目前的RPA社区已经基本上覆盖了一个社区如知乎等的全部功能，但是我觉得由于目前开发的RPA社区是不完善的，随着用户的增多，这个项目可能有一些瓶颈，这可能是后端上的，也可能是资源上的。</p><h4 id="首先是数据库瓶颈：">首先是数据库瓶颈：</h4><p>目前的很多查询（比如查询帖子、查询回复）都是直接打到数据库的，我了解到数据库的QPS大概能支撑到5000左右，再多的话，可能就不太行了。并且，后续帖子数据量一上来，查询速度更慢了。我觉得可以这样优化：</p><ul><li>1.异步：在往数据库里写数据的时候，采用异步的形式去写，能够提升接口的吞吐量</li><li>2.缓存：将一些热点帖子、排行榜存入到Redis里，避免直接查询数据库</li><li>3.分库分表：针对后续数据量起来了，可以使用分库分表保证查询速度</li><li>4.高可用：对MySQL做主从架构的读写分离，redis做分片集群</li></ul><h4 id="然后是系统资源瓶颈：">然后是系统资源瓶颈：</h4><pre><code>我注意到项目里用的线程池可能是静态线程池，这样在社区高峰期线程池资源可能不够，会导致阻塞。所以我觉得改进的策略是用动态线程池，参考美团动态线程池最佳实践。</code></pre><h4 id="最后是网络传输延迟：">最后是网络传输延迟：</h4><p>用户分布广泛，跨地域访问导致TCP握手时间超过300ms，静态资源（如图片）加载缓慢 。</p><p><strong>原因：</strong></p><ul><li><p>长距离通信：跨运营商或跨地域调用增加RTT（往返时间）</p></li><li><p>未压缩资源：大体积图片/视频直接传输</p><p><strong>解决方案：</strong></p></li><li><p>CDN加速：将静态资源缓存至边缘节点（如阿里云OSS+CDN），缩短加载时间（这个公司里应该已经用了）</p></li><li><p>HTTP/2协议：多路复用减少连接数，头部压缩降低传输量</p></li><li><p>数据压缩：对JSON/文本数据启用Gzip压缩，减少带宽占用（这个不知道用没用）</p></li></ul><h2 id="总结：">总结：</h2><p>开发RPA社区是一个复杂但充满成就感的过程。从需求分析到功能实现，每一个模块都需要精心设计和开发。通过对消息模块、帖子模块、回复模块、用户模块以及管理端各模块的深入打造，我逐步构建起一个功能完善的社区。希望这些经验能给同样在进行社区开发或者对RPA感兴趣的朋友们一些参考，大家一起交流进步，共同推动RPA社区的发展与完善。 </p><p>最后说一下我认为的难点吧：</p><p>在社区里我觉得最难的就是消息那一部分的设计，根据Prd那边，社区系统一共有8种消息，比如用户点赞帖子、点赞回复、用户评论、用户采纳回答。其实从根本上来说是可以抽象出三类。</p><ul><li><p>官方公告</p><pre><code>  在官方公告这块我一开始设计的就是一发公告，直接向所有用户发一条记录，后面改成了拉取式，即用户登录主动从消息表中拉取消息。并且为了不让用户收到同一条消息，我们是给（消息id，用户id）加了唯一索引的。</code></pre></li><li><p>点赞消息</p><p>​点赞消息根据产品那块需要采取聚合策略，所谓聚合就是比如1000个人给你点赞，你就只能看到一条消息，消息内容是“xx等1000人给你的帖子点赞”。为了实现这个功能，我采取了redis缓存，用户每个人的点赞消息先存到redis当中，然后使用xxljob每三分钟对消息做聚合（根据帖子id/回答id，发送者，接受者），然后存到数据库里。这样可以减缓数据库的存储压力。</p></li><li><p>用户评论</p><pre><code>  然后是用户评论，这块没啥好说的，就是用户发表评论，我会往回复表里插入一条数据，然后异步发一条消息通知用户，这里为什么要用异步呢？是因为这里开了事务，我不想消息发送失败而导致用户评论部了，因为就算消息发送失败了，接收方也是可以根据帖子id去看到这条回复的。</code></pre></li></ul>]]></content>
    
    
    <summary type="html">🥧社区开发总结</summary>
    
    
    
    <category term="学习" scheme="https://outoflovenicoo.github.io/categories/%E5%AD%A6%E4%B9%A0/"/>
    
    
    <category term="实习经验" scheme="https://outoflovenicoo.github.io/tags/%E5%AE%9E%E4%B9%A0%E7%BB%8F%E9%AA%8C/"/>
    
  </entry>
  
  <entry>
    <title>Java基础面试题</title>
    <link href="https://outoflovenicoo.github.io/posts/2025-01-01-Java%E5%9F%BA%E7%A1%80.html"/>
    <id>https://outoflovenicoo.github.io/posts/2025-01-01-Java%E5%9F%BA%E7%A1%80.html</id>
    <published>2025-01-09T10:19:03.000Z</published>
    <updated>2025-03-23T14:00:00.000Z</updated>
    
    <content type="html"><![CDATA[<h1 id="2-Java"><a href="#2-Java" class="headerlink" title="2.Java"></a>2.Java</h1><p><img src="2025-01-01-Java基础/clip_image001.jpg" alt="img"></p><p>1.Java基础</p><p>1.1 BIO、NIO、AIO有什么区别</p><p><img src="2025-01-01-Java基础/clip_image003.jpg" alt="img"></p><p>1.2 Comparator与Comparable有什么区别</p><p><img src="2025-01-01-Java基础/clip_image005.jpg" alt="img"></p><p><img src="2025-01-01-Java基础/clip_image007.jpg" alt="img"></p><p><img src="2025-01-01-Java基础/clip_image009.jpg" alt="img"></p><p>1.3 说说你对Integer缓存的理解</p><p><img src="2025-01-01-Java基础/clip_image011.jpg" alt="img"></p><p>1.4 synchronized的实现原理</p><p>在JVM内部，每个Java对象都有头信息，其中包含了对象的一些元信息和状态标志。synchronized通过修改头信息的状态标志来实现锁的获取和释放。</p><p>当synchronized作用于某个对象时，它就会尝试获取这个对象的锁，如果锁没有被其他线程占用，则当前线程获取到锁，并可以执行同步代码块；如果锁已经被其他线程占用，那么当前线程就会阻塞在同步块之外，直到获取到锁才能进入同步块。</p><p>当 synchronized 作用于实例方法时，锁住的是当前实例对象（即 this）。当synchronized 作用于静态方法时，锁住的是当前类的 Class 对象。当 synchronized 作用于某个类时，此时它锁住的是整个类，而不是类的某个实例。在这种情况下，由于只有一个锁存在，所以所有使用该类的线程都需要等待锁的释放。</p><p>synchronized还支持可重入性，即在同一个线程中可以多次获取同一个锁，这样可以避免死锁问题。Java虚拟机会通过锁升级的方式来提升synchronized的效率，比如偏向锁、轻量级锁和重量级锁等机制，使得在竞争不激烈的情况下，synchronized的性能可以达到与非同步代码相当的水平。 </p><p>1.5⭐️ synchronized锁优化</p><p>轻量级锁和重量级锁的区别是轻量级锁会一直尝试获取锁，而重量级锁不会并且会阻塞</p><p>•     偏向锁：线程获取锁后在对象头记录线程标识，再次进入同步块无需额外加锁操作，提高性能。适用于锁基本无竞争场景，减少无竞争时加解锁开销。</p><p>•     轻量级锁：多个线程竞争同一锁时，JVM采用轻量级锁，以自旋方式尝试快速获取锁，不放弃CPU执行时间，避免线程阻塞和上下文切换开销。适用于短时间内锁竞争不激烈场景，自旋一段时间若未获取到锁，会升级为重量级锁。</p><p>•     重量级锁：线程对同一锁强烈竞争时，JVM将锁升级为重量级锁，此时线程进入阻塞状态等待锁释放。适用于竞争激烈场景，但因线程阻塞和上下文切换等操作，会带来较大性能开销。 </p><p>1.6 ⭐️讲讲你对ThreadLocal的理解</p><p><img src="2025-01-01-Java基础/clip_image013.jpg" alt="img"></p><p><img src="2025-01-01-Java基础/clip_image015.jpg" alt="img"></p><p>1.7 ✅JDK和JRE和JVM</p><p><img src="2025-01-01-Java基础/clip_image017.jpg" alt="img"></p><p>1.8 ✅什么是字节码？采用字节码的好处是什么？</p><p><img src="2025-01-01-Java基础/clip_image019.jpg" alt="img"></p><p>1.9 为什么不全部使用 AOT 呢？</p><p>使用AOT就是直接在运行前把字节码编译成机器码然后执行，但是这样就不能支持java的运行时动态特性了。</p><p><img src="2025-01-01-Java基础/clip_image021.jpg" alt="img"></p><p>1.10 ⭐️为什么说 Java 语言“编译与解释并存”？</p><p>答：java是编译型是指java代码要先编译成.Class字节码，jvm才能运行。此外，在jvm里面，热点代码通过JIT会直接编译成机器码然后执行。</p><p>Java是解释型语言是指，字节码在Jvm中的执行是通过解释器一句一句解释成机器码然后才能执行的。</p><p><img src="2025-01-01-Java基础/clip_image023.jpg" alt="img"></p><p><img src="2025-01-01-Java基础/clip_image025.jpg" alt="img"></p><p>1.11 基本类型和包装类型的区别？</p><p><img src="2025-01-01-Java基础/clip_image027.jpg" alt="img"></p><p>1.12 为什么浮点数运算的时候会有精度丢失的风险？</p><p><img src="2025-01-01-Java基础/clip_image029.jpg" alt="img"></p><p>1.13 面向对象三特征：封装、继承、多态</p><p><img src="2025-01-01-Java基础/clip_image031.jpg" alt="img"></p><p><img src="2025-01-01-Java基础/clip_image033.jpg" alt="img"></p><p>1.14 ⭐️向上转型，向下转型</p><p><img src="2025-01-01-Java基础/clip_image035.jpg" alt="img"></p><p>1.15 ✅为什么要有 hashCode？</p><p><img src="2025-01-01-Java基础/clip_image037.jpg" alt="img"></p><p>1.16 intern 方法有什么作用？</p><p>字符串常量池在堆里面。</p><p>运行时常量池在元空间（方法区）里面</p><p><img src="2025-01-01-Java基础/clip_image039.jpg" alt="img"></p><p>1.17 ✅Java异常体系</p><p><img src="2025-01-01-Java基础/clip_image041.jpg" alt="img"></p><p><img src="2025-01-01-Java基础/clip_image043.jpg" alt="img"></p><p>1.18 ⭐️注解的解析方法有哪几种？</p><p>Java中注解需被解析才生效，常见解析方法有：</p><p>•     编译期直接扫描：编译器编译Java代码时扫描并处理对应注解。如@Override注解，编译器会检测方法是否重写父类对应方法，用于在编译阶段进行语法和逻辑的检查，确保代码符合重写规范。</p><p>•     运行期通过反射处理：像Spring框架的@Value、@Component等框架自带注解，利用反射机制在运行时获取类、方法、字段等信息，并根据注解定义的规则进行相应处理，如依赖注入、组件注册等操作，增强了框架的灵活性和扩展性。 </p><p>2.Java集合</p><p>2.1 ArrayList怎么做的数组扩容</p><p><img src="2025-01-01-Java基础/clip_image045.jpg" alt="img"></p><p>2.2 什么是 fail-fast， 什么是 fail-safe</p><p><img src="2025-01-01-Java基础/clip_image047.jpg" alt="img"></p><p>2.3 如何实现数组和 List 之间的转换？</p><p><img src="2025-01-01-Java基础/clip_image049.jpg" alt="img"></p><p>2.4 ⭐️HashSet实现原理</p><p><img src="2025-01-01-Java基础/clip_image051.jpg" alt="img"></p><p>2.5 HashMap工作原理</p><p>HashMap基于哈希表工作，哈希表利用哈希函数将键映射到存储位置：</p><p>•     哈希映射：计算键的哈希值并转化为数组索引，以此快速定位键值对存储位置。理想状态下，哈希函数让键均匀分布，减少哈希冲突。</p><p>•     解决哈希冲突：</p><p>￮    Java 1.7：主要用链表解决，相同哈希值的键值对链接在一起。</p><p>￮    Java 1.8：当链表长度和数组长度超一定阈值，链表转换为红黑树。红黑树是自平衡二叉搜索树，在哈希冲突较多时，查找、插入和删除操作更快。</p><p>HashMap综合哈希表、链表和红黑树原理，实现高效的键值对存储与查找功能。 </p><p>2.6 ⭐️HashMap 的PUT工作流程？</p><p><img src="2025-01-01-Java基础/clip_image053.jpg" alt="img"></p><p>2.7 比较 HashSet、 LinkedHashSet 和 TreeSet 三者的异同</p><p><img src="2025-01-01-Java基础/clip_image055.jpg" alt="img"></p><p>2.8 ⭐️Queue 与 Deque 的区别</p><p><img src="2025-01-01-Java基础/clip_image057.jpg" alt="img"></p><p>2.9 在 Queue 中 poll()和 remove（）有什么区别？</p><p><img src="2025-01-01-Java基础/clip_image059.jpg" alt="img"></p><p>2.10 ⭐️ArrayDeque 与 LinkedList 的区别</p><p><img src="2025-01-01-Java基础/clip_image061.jpg" alt="img"></p><p>ArrayDeque： ArrayDeque 内部维护了一 个循环数组，通过两个指针 （front 和 rear）来标记队列的头部 和尾部。当向队列中添加元素 时，rear 指针向后移动；当从队 列中删除元素时，front 指针向 后移动。如果数组满了， ArrayDeque 会自动扩容。 ArrayDeque 的底层数组长度是2的幂次方，这样可以通 位运算来实现循环队列的操作， 提高性能。</p><p>LinkedList： LinkedList 内部使用双向链 表来存储元素。每个节点都包含 一个前驱节点和一个后继节点的 引用。通过这种方式， LinkedList 可以在任意位置高效 地插入和删除元素。 LinkedList 还有一个头结点 和尾节点的引用，分别表示链表 的头部和尾部。通过这两个引用，可以快速访问到链表的第一个和最后一个元素。</p><p>2.11 ⭐️HashMap 的长度为什么是2的幂次方</p><p><img src="2025-01-01-Java基础/clip_image063.jpg" alt="img"></p><p>2.12 ⭐️HashMap 多线程操作导致死循环问题</p><p><img src="2025-01-01-Java基础/clip_image065.jpg" alt="img"></p><p>2.13 ⭐️LinkedHashMap是什么？怎么买现的？</p><p><img src="2025-01-01-Java基础/clip_image067.jpg" alt="img"></p><p>2.14 ⭐️为什么 ConcurrentHashMap 比 HashTable 效率要高？</p><p><img src="2025-01-01-Java基础/clip_image069.jpg" alt="img"></p>]]></content>
    
    
    <summary type="html">🥧本人的Java基础面试总结</summary>
    
    
    
    <category term="面试题" scheme="https://outoflovenicoo.github.io/categories/%E9%9D%A2%E8%AF%95%E9%A2%98/"/>
    
    
    <category term="Java基础面试题" scheme="https://outoflovenicoo.github.io/tags/Java%E5%9F%BA%E7%A1%80%E9%9D%A2%E8%AF%95%E9%A2%98/"/>
    
  </entry>
  
  <entry>
    <title>MyBatis面试题</title>
    <link href="https://outoflovenicoo.github.io/posts/2025331p.html"/>
    <id>https://outoflovenicoo.github.io/posts/2025331p.html</id>
    <published>2025-01-09T10:19:03.000Z</published>
    <updated>2025-03-23T14:00:00.000Z</updated>
    
    <content type="html"><![CDATA[<h1 id="MyBatis"><a href="#MyBatis" class="headerlink" title="MyBatis"></a>MyBatis</h1><h2 id="1-什么是MyBatis"><a href="#1-什么是MyBatis" class="headerlink" title="1. 什么是MyBatis?"></a>1. 什么是MyBatis?</h2><p><img src="https://mcnfxurl5vzo.feishu.cn/space/api/box/stream/download/asynccode/?code=NWU3OGM0OWExNWVlYzY5MGJkNmNlZGU2NDZjN2YwODNfNXRjcUNzNWdDbEJBUDJINjhJejlxMEtEd1oyR3JHUmNfVG9rZW46Q1NmRGI0djBxb3BpVVd4cXROOGNuWXZ5blJiXzE3NDMzODkxNTM6MTc0MzM5Mjc1M19WNA" alt="img"></p><h2 id="2-Mybaits-的优点-amp-缺点"><a href="#2-Mybaits-的优点-amp-缺点" class="headerlink" title="2. Mybaits 的优点 &amp; 缺点"></a>2. Mybaits 的优点 &amp; 缺点</h2><p><img src="https://mcnfxurl5vzo.feishu.cn/space/api/box/stream/download/asynccode/?code=MzFlM2EzNDkzOWZiZjUxYmE4NWFkOTA2MzRjMjY3NDFfdEJMZm01TmFpZFY1b2xYUERoZmhsbWtKeW1uWWkweWFfVG9rZW46Q01wY2JnZnVab205b1N4THNvWGMyanB1bmZlXzE3NDMzODkxNTM6MTc0MzM5Mjc1M19WNA" alt="img"></p><h2 id="3-MyBatis的核心组件有哪些？"><a href="#3-MyBatis的核心组件有哪些？" class="headerlink" title="3. MyBatis的核心组件有哪些？"></a>3. MyBatis的核心组件有哪些？</h2><p><img src="https://mcnfxurl5vzo.feishu.cn/space/api/box/stream/download/asynccode/?code=ODAyNjFhYTJiYjllODY2YjYxNWE4Yjk0ODZiNGU1N2FfbUVvUXkzNnlhbnc2VXlkMWloWVJ6ZHBvVlFvYWRXRWRfVG9rZW46QVRpTWJncGdUbzVKN2J4OThCSWNlMlM3bjJlXzE3NDMzODkxNTM6MTc0MzM5Mjc1M19WNA" alt="img"></p><h2 id="4-⭐️MyBatis的工作流程是怎样的？"><a href="#4-⭐️MyBatis的工作流程是怎样的？" class="headerlink" title="4. ⭐️MyBatis的工作流程是怎样的？"></a>4. ⭐️MyBatis的工作流程是怎样的？</h2><p><img src="https://mcnfxurl5vzo.feishu.cn/space/api/box/stream/download/asynccode/?code=NjM5ODc0MjhiYmQ1YTc4OTU1YWE4YzkzNGVkMzBmYjJfbW4zYlJ3S1N5WnFqdGFja3dHa3F3dHNMem96Q2U0U0dfVG9rZW46SDBWWmI5TDRGbzVTOTB4VlVPZmNweWxkbjZkXzE3NDMzODkxNTM6MTc0MzM5Mjc1M19WNA" alt="img"></p><h2 id="5-⭐️MyBatis一二级缓存的区别？"><a href="#5-⭐️MyBatis一二级缓存的区别？" class="headerlink" title="5. ⭐️MyBatis一二级缓存的区别？"></a>5. ⭐️MyBatis一二级缓存的区别？</h2><p><img src="https://mcnfxurl5vzo.feishu.cn/space/api/box/stream/download/asynccode/?code=OTEyZjBjN2MyYjE2OGRhNGQ2ZDY5NDg2ZTZmNTRhYWFfazJieW5sazBkN1I5T2IwbGZ1V2xLeHR3dHN3VHF3NTRfVG9rZW46TkZTb2JaeWNOb1JuN1p4NFBUQWNWalRQbjFkXzE3NDMzODkxNTM6MTc0MzM5Mjc1M19WNA" alt="img"></p><h2 id="6-MyBatis如何处理延迟加载？"><a href="#6-MyBatis如何处理延迟加载？" class="headerlink" title="6.MyBatis如何处理延迟加载？"></a>6.MyBatis如何处理延迟加载？</h2><p><img src="https://mcnfxurl5vzo.feishu.cn/space/api/box/stream/download/asynccode/?code=NTk4ZGZkYWE4YTdlYjdhZjhkNDFiZmEyN2ViNjgxMTNfdTZ3bWEzZWY2N2ZtZEI2RG8yWWdzdk5Jekl1OXRVWHZfVG9rZW46RzQ2QmJJWFUwb1Q4emx4WHJmSmM2N2hTbmllXzE3NDMzODkxNTM6MTc0MzM5Mjc1M19WNA" alt="img"></p><h2 id="7-⭐️MyBatis中的动态SQL是什么？"><a href="#7-⭐️MyBatis中的动态SQL是什么？" class="headerlink" title="7. ⭐️MyBatis中的动态SQL是什么？"></a>7. ⭐️MyBatis中的动态SQL是什么？</h2><p><img src="https://mcnfxurl5vzo.feishu.cn/space/api/box/stream/download/asynccode/?code=N2Y1NGUzY2I5ZTYxZDMwNTEzMTdkOTQ3MmY1MjJhMzJfc2E1QmlhY004SkNpRjZrdHE3MU5QcFFGSkZvZkpKcnhfVG9rZW46QVdDUGIxamR4b0xkNjN4NEJiRmNDaUZTblliXzE3NDMzODkxNTM6MTc0MzM5Mjc1M19WNA" alt="img"></p><p><img src="https://mcnfxurl5vzo.feishu.cn/space/api/box/stream/download/asynccode/?code=NjUwODViOWZjYWEzNjRlZmUzMTY1YzVhMmE5MDhiNjdfanpSM3N0VWZqaGpzQWZMU1hnSmZQdTNFUnYzVGFQTXhfVG9rZW46S2dzN2JZQ3ZIb0hCQUV4VDdiUGNBdUpKblRkXzE3NDMzODkxNTM6MTc0MzM5Mjc1M19WNA" alt="img"></p><h2 id="8-⭐️MyBatis中XML映射有哪些标签？"><a href="#8-⭐️MyBatis中XML映射有哪些标签？" class="headerlink" title="8. ⭐️MyBatis中XML映射有哪些标签？"></a>8. ⭐️MyBatis中XML映射有哪些标签？</h2><p><img src="https://mcnfxurl5vzo.feishu.cn/space/api/box/stream/download/asynccode/?code=Njk0ZTQzYWVlZDk4MTM5MGQwMWY2MmZmMmRiMjdiNTdfOUdQTFZQYTV1ZWliMHRpVVJ6emJwRlRnWndDOE5YZXZfVG9rZW46QlZWV2JTWFNLbzY0elB4OTlUbmNJZkF0bkdoXzE3NDMzODkxNTM6MTc0MzM5Mjc1M19WNA" alt="img"></p><h2 id="9-模糊查询-like-语句该怎么写？"><a href="#9-模糊查询-like-语句该怎么写？" class="headerlink" title="9. 模糊查询 like 语句该怎么写？"></a>9. 模糊查询 like 语句该怎么写？</h2><p><img src="https://mcnfxurl5vzo.feishu.cn/space/api/box/stream/download/asynccode/?code=YjM1ODcxZGY3YjEyMmYyMWQyZjNjOGM2ODgxM2Y2ZjdfVzA0SWQxeXpIbVBvMXZWbHFtdHp4NlVFaG5oM01pYkpfVG9rZW46SElUb2J3NkV4bzVFSFJ4NkFFTGNRdWlXbk9iXzE3NDMzODkxNTM6MTc0MzM5Mjc1M19WNA" alt="img"></p><h2 id="10-⭐️-和-的区别是什么？"><a href="#10-⭐️-和-的区别是什么？" class="headerlink" title="10. ⭐️#{}和${}的区别是什么？"></a>10. ⭐️#{}和${}的区别是什么？</h2><p><img src="https://mcnfxurl5vzo.feishu.cn/space/api/box/stream/download/asynccode/?code=M2I2MmNlZmJmZTdjMmVkMTlmZmI2ZGU1N2NkNjc5ZGZfdWY5WnI3UmI0dXlrdmZtVkJXdzFRWmE2N1BIS05jakJfVG9rZW46UThwbGJMUXBwb3c3UWd4SlZubGNwak1ablNnXzE3NDMzODkxNTM6MTc0MzM5Mjc1M19WNA" alt="img"></p><p><img src="https://mcnfxurl5vzo.feishu.cn/space/api/box/stream/download/asynccode/?code=ODU3ZDNjNzAxZmUyYzBmM2U1MzcxMjdiMTE0YmZkNjhfcTFUcnlDQWdybWgyNXpoYVN1VXA1TmdHWEhwSlhSN2JfVG9rZW46THZVcmI4c3ppb2RyZVV4aXNYNGNwdkdlbmlnXzE3NDMzODkxNTM6MTc0MzM5Mjc1M19WNA" alt="img"></p><h2 id="11-讲讲MyBatis中二级缓存的缺点？"><a href="#11-讲讲MyBatis中二级缓存的缺点？" class="headerlink" title="11. 讲讲MyBatis中二级缓存的缺点？"></a>11. 讲讲MyBatis中二级缓存的缺点？</h2><p><img src="https://mcnfxurl5vzo.feishu.cn/space/api/box/stream/download/asynccode/?code=OGFiYjFhMTU0NzQ5MmZjYzlmZGFiYmMwZGJkMTBjZWFfbzVwWjFDaWlPYzdnNHJ4U05NWnlKc1JlMm1CN2VzRzVfVG9rZW46VEJWZmJKQ1pHbzRBTzJ4ZkNaVWN0bWw5bnRlXzE3NDMzODkxNTM6MTc0MzM5Mjc1M19WNA" alt="img"></p><h2 id="12-为什么说-Mybatis-是半ORM-映射工具？"><a href="#12-为什么说-Mybatis-是半ORM-映射工具？" class="headerlink" title="12. 为什么说 Mybatis 是半ORM 映射工具？"></a>12. 为什么说 Mybatis 是半ORM 映射工具？</h2><p><img src="https://mcnfxurl5vzo.feishu.cn/space/api/box/stream/download/asynccode/?code=Yjc0YWMzM2MzZjA3ODE0MTU3ODY2YzY1ZjQzMGRiMTBfV2I0NkJpN1g2ZTRhWXNhNnJDZjlEOHhIYXZzMGtkYTBfVG9rZW46UENyOGJlUTBvb2cwNkN4WWNCVWNLUEVKbmxiXzE3NDMzODkxNTM6MTc0MzM5Mjc1M19WNA" alt="img"></p><h2 id="13-⭐️如何在-MyBatis-中进行分页查询？"><a href="#13-⭐️如何在-MyBatis-中进行分页查询？" class="headerlink" title="13. ⭐️如何在 MyBatis 中进行分页查询？"></a>13. ⭐️如何在 MyBatis 中进行分页查询？</h2><p><img src="https://mcnfxurl5vzo.feishu.cn/space/api/box/stream/download/asynccode/?code=NjFlYzc3Zjc0MzJjODFkYWNjYjRmYTg1ZjIzZGQxZTFfakZCc0ZrNWdUR0Y0SlROMnJKZHJiZzZWdkRHMjFYUVlfVG9rZW46QWpGOGIyeGVmb3V0WlV4Nkxib2NHVTA5bmxlXzE3NDMzODkxNTM6MTc0MzM5Mjc1M19WNA" alt="img"></p><p><img src="https://mcnfxurl5vzo.feishu.cn/space/api/box/stream/download/asynccode/?code=YTJjZGQwZjc1M2U3YmYyN2ZkOWI3OTc2MjgxYWNjOTNfZXZNcm1GR0I3WllWRVJweDJjVVBJbWN0cG5LREk0YTFfVG9rZW46TGxyOGJvVmozb2F6STh4MWtIS2NhRlhYbmdoXzE3NDMzODkxNTM6MTc0MzM5Mjc1M19WNA" alt="img"></p><h2 id="14-Mybatis和Hibernate的区别是什么？"><a href="#14-Mybatis和Hibernate的区别是什么？" class="headerlink" title="14. Mybatis和Hibernate的区别是什么？"></a>14. Mybatis和Hibernate的区别是什么？</h2><p><img src="https://mcnfxurl5vzo.feishu.cn/space/api/box/stream/download/asynccode/?code=ZmM0N2E5YjUxZGQ0YzI3MTM4YzFiNWY0MmVmYzgzYjJfcVBXSlhhSmFCMXhKTjRQUlV6UzNmb3FnbDVIMWpNNXZfVG9rZW46RjVRNGJJY0xyb0Z6cEN4aEpGR2NNeW85bkJjXzE3NDMzODkxNTM6MTc0MzM5Mjc1M19WNA" alt="img"></p><h2 id="15-JDBC编程有哪些不足之处，MyBatis是如何解决这些问题的？"><a href="#15-JDBC编程有哪些不足之处，MyBatis是如何解决这些问题的？" class="headerlink" title="15. JDBC编程有哪些不足之处，MyBatis是如何解决这些问题的？"></a>15. JDBC编程有哪些不足之处，MyBatis是如何解决这些问题的？</h2><p><img src="https://mcnfxurl5vzo.feishu.cn/space/api/box/stream/download/asynccode/?code=ZjE1MTExMzkzODVjYzdhMTk5MGI0Mjc2MWNlMDMyZGNfNzlJV2NCd1dZUURwYW9ZU0ZobWxBcGlYb3BjeThieDFfVG9rZW46VzNrMmJXMlB2b3NrMzl4ZUk0OWNkUW1hbkFkXzE3NDMzODkxNTM6MTc0MzM5Mjc1M19WNA" alt="img"></p><h2 id="16-MyBatis编程步骤是什么样的？"><a href="#16-MyBatis编程步骤是什么样的？" class="headerlink" title="16. MyBatis编程步骤是什么样的？"></a>16. MyBatis编程步骤是什么样的？</h2><p><img src="https://mcnfxurl5vzo.feishu.cn/space/api/box/stream/download/asynccode/?code=ZTNjNTVkMTdiMTljZTg4MGNiZTc4M2ZjMTIxZWZlYzVfOHVubEdxQnVMczYwbnVhNk9weEU4YXdoaWtEZVRKV2FfVG9rZW46TXA1bmJSbDZ3b0pCN3p4RTNoQ2M5b2JXbnFmXzE3NDMzODkxNTM6MTc0MzM5Mjc1M19WNA" alt="img"></p><h2 id="17-Mybatis如何防止SQL注入？"><a href="#17-Mybatis如何防止SQL注入？" class="headerlink" title="17. Mybatis如何防止SQL注入？"></a>17. Mybatis如何防止SQL注入？</h2><p><img src="https://mcnfxurl5vzo.feishu.cn/space/api/box/stream/download/asynccode/?code=N2M0YjlkODM0MWNhYTNiZDMzNzg4ZmUwMTE0NzI3ZWZfbUJXMWtUZkh0elRTNmdNenVNbEU2OURObVNXbjM1OE9fVG9rZW46SlcyOWJSNjVlb0hDZHR4dW14VGM3UGhObk5nXzE3NDMzODkxNTM6MTc0MzM5Mjc1M19WNA" alt="img"></p><h2 id="⭐️18-Xml-映射文件中，除了常见的-select，insert，upcaeldelete-标签之外，还有哪些标签？"><a href="#⭐️18-Xml-映射文件中，除了常见的-select，insert，upcaeldelete-标签之外，还有哪些标签？" class="headerlink" title="⭐️18.Xml 映射文件中，除了常见的 select，insert，upcaeldelete 标签之外，还有哪些标签？"></a>⭐️18.Xml 映射文件中，除了常见的 select，insert，upcaeldelete 标签之外，还有哪些标签？</h2><p><img src="https://mcnfxurl5vzo.feishu.cn/space/api/box/stream/download/asynccode/?code=MDk5MTM5NzUwYzUyMDYwNTk0ODVjOWRmOWZmM2RlMDhfZ0gxRUJocG9EUjhtbkx0N0g2OGg5RmFSQ2dOU2E1dUxfVG9rZW46RFEwa2JZTmpBbzRjRzJ4bUx1UmN4Z2xFblBnXzE3NDMzODkxNTM6MTc0MzM5Mjc1M19WNA" alt="img"></p><p><img src="https://mcnfxurl5vzo.feishu.cn/space/api/box/stream/download/asynccode/?code=Yjk0ZGRiMjQxNzc4MDVmMDQ4NmQ2YThiNTZhMWZjMzRfaUxMaUlmUHFxSjE0RXdJb1VCYzRNaWFON2NEVURQNm9fVG9rZW46VW8ybWJkWDJ2b2JnblZ4MEw5c2NxN0lJblBlXzE3NDMzODkxNTM6MTc0MzM5Mjc1M19WNA" alt="img"></p><p><img src="https://mcnfxurl5vzo.feishu.cn/space/api/box/stream/download/asynccode/?code=ZDg5YTUwZmI1ZmZiZjliN2RhMmQ5MGE0MzcyNjNjOWVfYndDWlJaa2JmNG1Kb3pWQU8yWVA5RXlUZ3N5Q2dCeWlfVG9rZW46Vm4zZGJpeHE1b20wd214TVpBY2NPcFU3bkhmXzE3NDMzODkxNTM6MTc0MzM5Mjc1M19WNA" alt="img"></p><p><img src="https://mcnfxurl5vzo.feishu.cn/space/api/box/stream/download/asynccode/?code=OWQzMmQyNzczNzgwNTA3YmFmODlhYWY4MjQ4NzM0NDRfc2lBaWg5OFUwTE0zdnUyaXFDbmFxdHJSZHdlTVBYTnBfVG9rZW46RVVEeGI3QU93bzZ1ZG94N29PS2NzZVZRbjlnXzE3NDMzODkxNTM6MTc0MzM5Mjc1M19WNA" alt="img"></p><h2 id="19-Mybatis都有哪些Executor执行器？它们之间的区别是什么？"><a href="#19-Mybatis都有哪些Executor执行器？它们之间的区别是什么？" class="headerlink" title="19. Mybatis都有哪些Executor执行器？它们之间的区别是什么？"></a>19. Mybatis都有哪些Executor执行器？它们之间的区别是什么？</h2><p><img src="https://mcnfxurl5vzo.feishu.cn/space/api/box/stream/download/asynccode/?code=MWRhODk3MTMzZjZlNjEyN2I4OGI1MWMxM2ExN2QzNGZfMVdGOXZQdFJUVnVFVnJlaUpxVGR5aTN5MU1lNGx5d1VfVG9rZW46QU96MWJYd3Rvb0xGelJ4MndMdmNFQzEwbnVnXzE3NDMzODkxNTM6MTc0MzM5Mjc1M19WNA" alt="img"></p><p><img src="https://mcnfxurl5vzo.feishu.cn/space/api/box/stream/download/asynccode/?code=YWFjZjQzYzZiY2MwZWY0Mjk3YjQxMDJmMDUwZGVhMmJfRDBFdHFNVElkbTNGQUZXUHAwUDdjNlloOWxjeTVQUTFfVG9rZW46STdoWGJ1NzRqb2ZCa0F4WlJ0ZGNFRDFibkhTXzE3NDMzODkxNTM6MTc0MzM5Mjc1M19WNA" alt="img"></p><h2 id="20-⭐️MyBatis-工作原理是什么？"><a href="#20-⭐️MyBatis-工作原理是什么？" class="headerlink" title="20. ⭐️MyBatis 工作原理是什么？"></a>20. ⭐️MyBatis 工作原理是什么？</h2><p><img src="https://mcnfxurl5vzo.feishu.cn/space/api/box/stream/download/asynccode/?code=OTc4MzE0ZjAyZGU0ZTUwODg0OWVlOTc2N2Q1YTQxNGNfdDRnY1RZdkZ0MldsMUgzQThWVTBmMFpkNGZQZGQxYWZfVG9rZW46UUtTRmJEbHEzb1BBSkp4ZGNGSGNrbndybktnXzE3NDMzODkxNTM6MTc0MzM5Mjc1M19WNA" alt="img"></p><p><img src="https://mcnfxurl5vzo.feishu.cn/space/api/box/stream/download/asynccode/?code=MTZhOWY1YzJlMzBhYjJlZjg1OWI2MjVkMjNkMDBkM2ZfbXpoMmYwdXZTV3BSWXd6ZTBWV1pDUGNSMmVaczBPQVhfVG9rZW46Q2tKd2JwVmg2b1Y1MUV4R0lPM2NGQTdXblAyXzE3NDMzODkxNTM6MTc0MzM5Mjc1M19WNA" alt="img"></p><h2 id="21-⭐️Mybatis-能执行一对一、一对多的关联查询吗？"><a href="#21-⭐️Mybatis-能执行一对一、一对多的关联查询吗？" class="headerlink" title="21. ⭐️Mybatis 能执行一对一、一对多的关联查询吗？"></a>21. ⭐️Mybatis 能执行一对一、一对多的关联查询吗？</h2><p><img src="https://mcnfxurl5vzo.feishu.cn/space/api/box/stream/download/asynccode/?code=NmQ1NjI3ZDgzMDgwMzRjZDY2YmM4NjcwZWM5ZjQ3MDFfQkFQQlQ5bTEwdk95VVFPb053cDNhbXBqcmJyZENFRjVfVG9rZW46Q3J2cmI4cU9Ub2ZMa0x4cFZZdWNzWVBBbjVjXzE3NDMzODkxNTM6MTc0MzM5Mjc1M19WNA" alt="img"></p><p><img src="https://mcnfxurl5vzo.feishu.cn/space/api/box/stream/download/asynccode/?code=NWQ0NzU3YWQwODVhNjc5MDhiOTNjOGQxZjg3OGM3MmRfd04zUE5HVXJ4Q01ZOGlSektjUEdkZUZpWXRXSnl1VE5fVG9rZW46TEM1YmJqRnJJb01YVVZ4Y0ZyQ2Naajh0bkRkXzE3NDMzODkxNTM6MTc0MzM5Mjc1M19WNA" alt="img"></p><h2 id="22-⭐️-Mybatis-是否支持延迟加载？原理？"><a href="#22-⭐️-Mybatis-是否支持延迟加载？原理？" class="headerlink" title="22.⭐️ Mybatis 是否支持延迟加载？原理？"></a>22.⭐️ Mybatis 是否支持延迟加载？原理？</h2><p><img src="https://mcnfxurl5vzo.feishu.cn/space/api/box/stream/download/asynccode/?code=OTdmNTRiMDY0M2Q3Mjc2NjM2ZjI1OTI0Y2E3OGFiYzlfN2Q2NGw5R3l0Rk9VRWRjRVU1c0c5bnR4TjBxY3pRTWpfVG9rZW46VG1INWJrVFU1b3BJRUJ4OU1lYmNNQmFwbkJhXzE3NDMzODkxNTM6MTc0MzM5Mjc1M19WNA" alt="img"></p><h2 id="23-⭐️什么是MyBatis的接口绑定？有哪些实现方式？"><a href="#23-⭐️什么是MyBatis的接口绑定？有哪些实现方式？" class="headerlink" title="23. ⭐️什么是MyBatis的接口绑定？有哪些实现方式？"></a>23. ⭐️什么是MyBatis的接口绑定？有哪些实现方式？</h2><p><img src="https://mcnfxurl5vzo.feishu.cn/space/api/box/stream/download/asynccode/?code=OWZmNzdkZjU4NjIzYzQ4MGJiNGJhZjRjYjdhYjNiMDNfOExrZm5ueWZMVVJvYnlNSTh4eG5xbng2S0RKODZuT0RfVG9rZW46TENjUGJWeWM2b3g1VVh4U1ZYYmNVelJxbkdjXzE3NDMzODkxNTM6MTc0MzM5Mjc1M19WNA" alt="img"></p><h2 id="24-⭐️Mybatis是如何将sql执行结果封装为目标对象并返回的？都有哪些映射形式？"><a href="#24-⭐️Mybatis是如何将sql执行结果封装为目标对象并返回的？都有哪些映射形式？" class="headerlink" title="24. ⭐️Mybatis是如何将sql执行结果封装为目标对象并返回的？都有哪些映射形式？"></a>24. ⭐️Mybatis是如何将sql执行结果封装为目标对象并返回的？都有哪些映射形式？</h2><p><img src="https://mcnfxurl5vzo.feishu.cn/space/api/box/stream/download/asynccode/?code=OTY5ZjA2MmUxMGM2MjYwYjg1ODRhMjEyOTVlMzA4Y2NfU2N0ZW1VdURUMjlNTXBrZ3Q0ajRnZEpKdkM2MXFWMlZfVG9rZW46RDVxcGJuNXZGb1huYU94TEtuTWNJYnlUbmhoXzE3NDMzODkxNTM6MTc0MzM5Mjc1M19WNA" alt="img"></p><h2 id="25-⭐️-Mybatis的Xml映射文件中，不同的Xml映射文件，id是否可以重复？"><a href="#25-⭐️-Mybatis的Xml映射文件中，不同的Xml映射文件，id是否可以重复？" class="headerlink" title="25.⭐️ Mybatis的Xml映射文件中，不同的Xml映射文件，id是否可以重复？"></a>25.⭐️ Mybatis的Xml映射文件中，不同的Xml映射文件，id是否可以重复？</h2><p><img src="https://mcnfxurl5vzo.feishu.cn/space/api/box/stream/download/asynccode/?code=YzkwNjllNWE2ODE5MzIyMzU5NGMxNDgzOGU1NGI3YjRfR2dIdnoyUlZJTE9OVHJzc2IzeXlqOWdBT29SRkVPR05fVG9rZW46TTJoc2JJeEYxbzdDd0J4TEF2OWM0RTUzbkFiXzE3NDMzODkxNTM6MTc0MzM5Mjc1M19WNA" alt="img"></p><h2 id="26-⭐️MyBatis-如何执行批量操作？"><a href="#26-⭐️MyBatis-如何执行批量操作？" class="headerlink" title="26. ⭐️MyBatis 如何执行批量操作？"></a>26. ⭐️MyBatis 如何执行批量操作？</h2><p><img src="https://mcnfxurl5vzo.feishu.cn/space/api/box/stream/download/asynccode/?code=NTE0MTEyMGRmNmU3M2JiMDM1NTk2MmEwYzFhN2YzMGZfYlBMdVlyZkg4VnczMUpOVTNrbFlWdXlXYTk5TWVTcnpfVG9rZW46QjlMZGJWeDNZb2doMFl4Tk9RS2NLMDB5bklkXzE3NDMzODkxNTM6MTc0MzM5Mjc1M19WNA" alt="img"></p><p><img src="https://mcnfxurl5vzo.feishu.cn/space/api/box/stream/download/asynccode/?code=MzY2YWM1NjM0ODQ3YTkyYTgxYmM0MmY2ZmY4ZjdiNGJfd291dU9GN1RySjBpc2lwcGVkVnlCUzkwN0gzbno5ZURfVG9rZW46WHNtaGJDTjRCb1RkeU14QUpDeGNJTDRsbk5jXzE3NDMzODkxNTM6MTc0MzM5Mjc1M19WNA" alt="img"></p><p><img src="https://mcnfxurl5vzo.feishu.cn/space/api/box/stream/download/asynccode/?code=ZmYyMzIzMzU4M2ZkMzc0MTIzMTY2Yjk5Njg0ZWM2MTlfTlFocTM3amNkU2x2bVR0d0dBU0U5YTdwZjVvWW9nRG5fVG9rZW46SHhNcGIxUlhMb2dEa094aGszVWNnaDh3bmFmXzE3NDMzODkxNTM6MTc0MzM5Mjc1M19WNA" alt="img"></p><p><img src="https://mcnfxurl5vzo.feishu.cn/space/api/box/stream/download/asynccode/?code=MGQ5YWZlODVmNTgzZWQyNWVjMzliZDVkMmQwYzFhMTdfR2xGVWZXM1pMUnpMSXBxS1VXaDZHRDdKaGR1b3JiY29fVG9rZW46QW5TTGJKa1JOb2I4T0N4amZ0NGNoeWR5bkdlXzE3NDMzODkxNTM6MTc0MzM5Mjc1M19WNA" alt="img"></p><h2 id="27-⭐️在mapper-中如何传递多个参数？"><a href="#27-⭐️在mapper-中如何传递多个参数？" class="headerlink" title="27. ⭐️在mapper 中如何传递多个参数？"></a>27. ⭐️在mapper 中如何传递多个参数？</h2><p><img src="https://mcnfxurl5vzo.feishu.cn/space/api/box/stream/download/asynccode/?code=YTFkOTA0ZTc5ZTNiOTkwZTgxZjA4MjMzMzI0MzBiYjhfYUp2V0syblJjWjNiTWFSbElkUVJJTlpHbk9rNXdhOXBfVG9rZW46RVlUTmJQSlpFb2NjWWh4emNNM2NFNE5LbnBoXzE3NDMzODkxNTM6MTc0MzM5Mjc1M19WNA" alt="img"></p><p><img src="https://mcnfxurl5vzo.feishu.cn/space/api/box/stream/download/asynccode/?code=M2M4MDcwNjY4ZGMxYTA5ZGQyMTgxMTllMzZiY2ZjNjhfQ3NUcG5OYXZ5V1RyMXpEVnRPdVNJZzhWR1kzN0V1MUlfVG9rZW46VDlRc2JrRGF2b1NxQTF4UWdtOGNuSWZvbm5tXzE3NDMzODkxNTM6MTc0MzM5Mjc1M19WNA" alt="img"></p><p><img src="https://mcnfxurl5vzo.feishu.cn/space/api/box/stream/download/asynccode/?code=MzcwYzJjODg2ZTZiZjljY2YxNWUxMDkyOThhNDlmZWRfNEQ2eVpqSnBHYkZHdXZsMWJwZ3lQWU5kSURzd3BZaGdfVG9rZW46Skk4NmI4Z2tab2xQZXR4NlFSZmM0MzYzbnhoXzE3NDMzODkxNTM6MTc0MzM5Mjc1M19WNA" alt="img"></p><h2 id="28-⭐️简述Mybatis的插件运行原理，以及如何编写一个插件？"><a href="#28-⭐️简述Mybatis的插件运行原理，以及如何编写一个插件？" class="headerlink" title="28. ⭐️简述Mybatis的插件运行原理，以及如何编写一个插件？"></a>28. ⭐️简述Mybatis的插件运行原理，以及如何编写一个插件？</h2><p><img src="https://mcnfxurl5vzo.feishu.cn/space/api/box/stream/download/asynccode/?code=MDJjYmFlNjE1NzdiNTg2ZWYxZWY4NzBkZWIxY2I0NzdfQ3lJVFdzZXdmdjFRRjhaalo1UDFKZ1ViR085dmxKbXRfVG9rZW46RVN2UWJrTVdyb2xCdGt4Rnl0OWNhZTRrbkplXzE3NDMzODkxNTM6MTc0MzM5Mjc1M19WNA" alt="img"></p><h2 id="29-⭐️分页插件的原理是什么？"><a href="#29-⭐️分页插件的原理是什么？" class="headerlink" title="29. ⭐️分页插件的原理是什么？"></a>29. ⭐️分页插件的原理是什么？</h2><p><img src="https://mcnfxurl5vzo.feishu.cn/space/api/box/stream/download/asynccode/?code=ZWQxMjJlZDAzZjA3OWY1NGU0NGE1NWQ4M2E4MzMwMGVfeE94Z2NSbmY0MzNFTjZZUFlUQmk1ZTJnV0xBQXhIcURfVG9rZW46UGYwZ2JCOEFFb2NJeTR4M3I1RmM4WW9IbmdMXzE3NDMzODkxNTM6MTc0MzM5Mjc1M19WNA" alt="img"></p>]]></content>
    
    
    <summary type="html">🥧本人的MyBatis面试题总结</summary>
    
    
    
    <category term="面试题" scheme="https://outoflovenicoo.github.io/categories/%E9%9D%A2%E8%AF%95%E9%A2%98/"/>
    
    
    <category term="MyBatis" scheme="https://outoflovenicoo.github.io/tags/MyBatis/"/>
    
  </entry>
  
  <entry>
    <title>Rabbitmq面试题</title>
    <link href="https://outoflovenicoo.github.io/posts/2025331m.html"/>
    <id>https://outoflovenicoo.github.io/posts/2025331m.html</id>
    <published>2025-01-09T10:19:03.000Z</published>
    <updated>2025-03-23T14:00:00.000Z</updated>
    
    <content type="html"><![CDATA[<h1 id="PS"><a href="#PS" class="headerlink" title="PS:"></a>PS:</h1><p><strong>面试题总结自小林Coding，仅供个人学习使用，如有侵权可联系删除</strong></p><h1 id="概念："><a href="#概念：" class="headerlink" title="概念："></a>概念：</h1><h2 id="1-AMQP协议？"><a href="#1-AMQP协议？" class="headerlink" title="1. AMQP协议？"></a>1. AMQP协议？</h2><p>AMQP，即Advanced Message Queuing Protocol，高级消息队列协议，是应用层协议的开放标准，为面向消息的中间件设计。消息中间件用于组件解耦，发送者和使用者相互无感知。其主要特征包括面向消息、队列、路由、可靠性、安全性。RabbitMQ是开源的AMQP实现，服务器端用Erlang编写，支持多种客户端，用于分布式系统存储转发消息，在易用性等方面表现好。</p><p><strong>AMQP**</strong>三层协议**</p><ul><li><strong>Module Layer</strong>：最高层，定义客户端调用命令，用于实现业务逻辑。</li><li><strong>Session Layer</strong>：中间层，负责客户端命令与服务器应答传输，提供可靠性同步和错误处理。</li><li><strong>Transport Layer</strong>：最底层，传输二进制数据流，提供帧处理等功能。</li></ul><p><strong>AMQP**</strong>组件**</p><ul><li><strong>交换器**</strong>(Exchange)**：将消息路由到队列的组件。</li><li><strong>队列 (queue)</strong>：存储消息的数据结构，位于硬盘或内存。</li><li><strong>绑定 (Binding)</strong>：告知交换器消息投递队列的规则。</li></ul><h2 id="2-RabbitMQ包含哪些要素？"><a href="#2-RabbitMQ包含哪些要素？" class="headerlink" title="2. RabbitMQ包含哪些要素？"></a>2. RabbitMQ包含哪些要素？</h2><ul><li>生产者：消息队列创建者，发送消息到 MQ。</li><li>消费者：连接到 RabbitMQ，订阅到队列上，消费消息，支持持续订阅和单条订阅。</li><li>消息：包含有效载荷和标签，有效载荷指要传输的数据，标签描述有效载荷，RabbitMQ 用它决定谁获得消息，消费者只能拿到有效载荷，不知道生产者是谁。</li></ul><h2 id="3-RabbitMQ中消息可能有的几种状态？"><a href="#3-RabbitMQ中消息可能有的几种状态？" class="headerlink" title="3. RabbitMQ中消息可能有的几种状态？"></a>3. RabbitMQ中消息可能有的几种状态？</h2><ul><li>alpha：消息内容（包括消息体、属性和 headers）和消息索引都存储在内存。</li><li>beta：消息内容保存在磁盘中，消息索引保存在内存中。</li><li>gamma：消息内容保存在磁盘中，消息索引在磁盘和内存中都有。</li><li>delta：消息内容和索引都在磁盘中。</li></ul><h2 id="4-发送消息的过程？"><a href="#4-发送消息的过程？" class="headerlink" title="4. 发送消息的过程？"></a>4. 发送消息的过程？</h2><ul><li>生产者将消息发布到一个或多个交换器（Exchange）中。交换器根据路由键（Routing Key）将消息分配给特定的队列（Queue）。</li><li>交换器通过路由键将消息路由到一个或多个队列。若路由键为空，消息会被分配给所有绑定到该交换器的队列。</li><li>消息进入队列，等待被消费者接收。在队列中，消息会被存储在持久化存储中，以防服务器崩溃或重启时数据丢失。</li><li>消费者从队列中获取消息并处理。消费者可通过订阅一个或多个队列来接收消息。一旦消息被消费者接收，它将从队列中移除。</li></ul><h2 id="5-为什么要使用RabbitMQ？"><a href="#5-为什么要使用RabbitMQ？" class="headerlink" title="5. 为什么要使用RabbitMQ？"></a>5. 为什么要使用RabbitMQ？</h2><ul><li>在分布式系统下具备异步、削峰、负载均衡等一系列高级功能。</li><li>拥有持久化的机制，进程消息、队列中的信息也可以保存下来。</li><li>实现消费者和生产者之间的解耦。</li><li>对于高并发场景下，利用消息队列可以使得同步访问变为串行访问达到一定量的限流，利于数据库的操作。</li><li>可以使用消息队列达到异步下单的效果，排队中，后台进行逻辑下单。</li></ul><h2 id="6-Kafka、-ActiveMQ、-RabbitMQ、-RocketMQ有什么优缺点？"><a href="#6-Kafka、-ActiveMQ、-RabbitMQ、-RocketMQ有什么优缺点？" class="headerlink" title="6. Kafka、 ActiveMQ、 RabbitMQ、 RocketMQ有什么优缺点？"></a>6. Kafka、 ActiveMQ、 RabbitMQ、 RocketMQ有什么优缺点？</h2><p>一般的业务系统要引入 MQ，最早大家都用 ActiveMQ，但是现在确实大家用的不多了，没经过大规模吞吐量场景的验证，社区也不是很活跃，所以大家还是算了吧，我个人不推荐用这个了；</p><p>后来大家开始用 RabbitMQ，但是确实 erlang 语言阻止了大量的 Java 工程师去深入研究和掌控它，对公司而言，几乎处于不可控的状态，但是确实人家是开源的，比较稳定的支持，活跃度也高；</p><p>不过现在确实越来越多的公司会去用 RocketMQ，确实很不错，毕竟是阿里出品，但社区可能有突然黄掉的风险（目前 RocketMQ 已捐给，但 GitHub 上的活跃度其实不算高）对自己公司技术实力有绝对自信的，推荐用 RocketMQ，否则回去老老实实使用 RabbitMQ 吧，人家有活跃的开源社区，绝对不会黄；</p><p>所以中小型公司，技术实力较为一般，技术挑战不是特别高，用 RabbitMQ 是不错的选择；大型公司，基础架构研发实力较强，用 RocketMQ 是很好的选择；大数据领域的实时计算、日志采集等场景，使用 Kafka。</p><h1 id="应用："><a href="#应用：" class="headerlink" title="应用："></a>应用：</h1><h2 id="1-如何确保消息正确地发送至RabbitMQ？如何确保消息接收方消费了消息？"><a href="#1-如何确保消息正确地发送至RabbitMQ？如何确保消息接收方消费了消息？" class="headerlink" title="1. 如何确保消息正确地发送至RabbitMQ？如何确保消息接收方消费了消息？"></a>1. 如何确保消息正确地发送至RabbitMQ？如何确保消息接收方消费了消息？</h2><ul><li><strong>消息确认机制(**</strong>生产者确认<strong>**)</strong>：生产者在发送消息后，可通过消息确认机制（Confirm）确保消息正确发送至RabbitMQ。消息确认机制分为批量确认和单个确认两种方式，生产者可根据自身业务场景选择合适的方式。</li><li><strong>消息持久化</strong>：通过将消息设置为持久化的方式，可确保消息不会丢失。在RabbitMQ中，可将Exchange、Queue和Message都标记为持久化。在发送消息时，可以将消息的delivery - mode设置为2，表示消息需要持久化。</li><li><strong>连接超时设置（**</strong>生产者重连<strong>**）</strong>：在发送消息时，可通过设置连接超时时间，当超过指定时间后仍未收到发送消息响应，可以通过重发等方式确保消息正确地发送至RabbitMQ。</li><li><strong>消息**</strong>序列化<strong>**和反序列化</strong>：在发送和接收消息时，需要将消息对象序列化为二进制数据，再在接收方反序列化为对象类型。因此，需要确保消息的序列化和反序列化过程正确无误，可以采用JSON、Protobuf等常用的序列化框架。 </li></ul><h2 id="2-如何回答-消息队列-的丢失、重复与积压问题"><a href="#2-如何回答-消息队列-的丢失、重复与积压问题" class="headerlink" title="2. 如何回答**消息队列**的丢失、重复与积压问题"></a>2. <strong>如何回答**</strong>消息队列<strong>**的丢失、重复与积压问题</strong></h2><p><a href="https://learn.lianglianglee.com/专栏/架构设计面试精讲/08  MQ：如何回答消息队列的丢失、重复与积压问题.md">08 MQ:如何回答消息队列的丢失、重复与积压问题</a></p><ul><li><strong>消息确认机制</strong>：消费者处理消息后，向RabbitMQ发送消息确认（ACK），告知消息已正确处理。若未发送，RabbitMQ会将消息重新投到队列，造成重复消费。</li><li><strong>消息去重机制</strong>：可在应用程序中实现，比如用分布式缓存、数据库等存储系统记录已处理消息标识，下次处理时判断，若已处理则忽略，避免重复处理。</li><li><strong>消息幂等性处理（业务处理）</strong>：将消费者处理逻辑设计为幂等操作，即重复执行多次效果相同，防止因消息重复消费致业务数据错误。</li><li><strong>设置消息过期时间</strong>：发送消息时设置过期时间，过期后不再投递给消费者，避免重复消费。</li><li><strong>使用消息唯一标识符</strong>：在消息中添加如UUID这样的唯一标识符，保证每条消息有独一无二标识，避免重复消费和重复投递。 </li></ul><h2 id="3-如何保证消息持久化？"><a href="#3-如何保证消息持久化？" class="headerlink" title="3. 如何保证消息持久化？"></a>3. 如何保证消息持久化？</h2><ul><li><strong>消息的**</strong>delivery - mode<strong>**设置为2</strong>：在发送消息时，可以将消息的delivery - mode属性设置为2，表示消息需要被持久化。持久化的消息将会被写入磁盘，即使RabbitMQ重启或者崩溃，消息也仍然可以保留。</li><li><strong>队列的durable属性设置为true</strong>：在创建队列时，可以将队列的durable属性设置为true，表示队列是持久性的。持久化的队列将会在RabbitMQ重启或者崩溃后得到保留。</li><li><strong>将**</strong>交换器<strong>**的durable属性设置为true</strong>：在创建交换器时，可以将交换器的durable属性设置为true，表示交换器是持久性的。持久化的交换器将会在RabbitMQ重启或者崩溃后得到保留。</li><li><strong>使用事务机制</strong>：在发送消息时，可以使用事务机制来确保消息的持久性。通过开启事务，发送者可以将消息发送到RabbitMQ，然后等待RabbitMQ的确认，确认后再提交事务。使用事务机制可以确保消息的可靠性，但是会影响系统的性能。 </li></ul><h2 id="4-消息如何路由？"><a href="#4-消息如何路由？" class="headerlink" title="4. 消息如何路由？"></a>4. 消息如何路由？</h2><p> 消息的路由过程通过交换器（Exchange）实现。当消息被发送到 RabbitMQ 时，生产者将消息发布到交换器中，然后依据交换器的类型和绑定规则将消息路由到一个或多个队列中。</p><p> 消息路由的基本流程如下：</p><ul><li>生产者将消息发送到指定的交换器中。</li><li>交换器根据路由键（Routing Key）和绑定键（Binding Key）将消息发送到一个或多个队列中。路由键和绑定键可以是任意字符串，根据交换器的类型和绑定规则进行匹配。</li><li>若交换器类型为 direct，会根据路由键进行精确匹配，将消息发送到所有匹配的队列中。</li><li>若交换器类型为 fanout，会将消息发送到所有绑定到该交换器的队列中。</li><li>若交换器类型为 topic，会根据通配符匹配规则将消息发送到匹配的队列中。例如，路由键为 “foo.bar” 的消息可以匹配绑定键为 “*.bar” 或 “foo.#” 的队列。</li><li>若交换器类型为 headers，会根据消息的属性（headers）进行匹配，将消息发送到匹配的队列中。</li><li><p>如果没有匹配的队列，消息将被丢弃或返回给生产者，根据生产者的配置。</p><p>需注意，交换器和队列都需要进行绑定，否则消息将无法路由到队列中。另外，可根据需要在交换器和队列中配置各种属性，例如持久化、自动删除等，以满足不同的业务需求。</p></li></ul><h2 id="5．⭐️RabbitMQ的消息确认过程？"><a href="#5．⭐️RabbitMQ的消息确认过程？" class="headerlink" title="5．⭐️RabbitMQ的消息确认过程？"></a>5．⭐️RabbitMQ的消息确认过程？</h2><p><strong>消费者确认机制：</strong></p><p>为确认消费者是否成功处理消息，RabbitMQ 提供了消费者确认机制（Consumer Acknowledgement）。当消费者处理消息结束后，应向 RabbitMQ 发送一个回执，告知 RabbitMQ 自己的处理状态。回执有三种可选值：</p><ul><li>ack：成功处理消息，RabbitMQ 从队列中删除该消息。</li><li>nack：消息处理失败，RabbitMQ 需要再次投递消息。</li><li>reject：消息处理失败并拒绝该消息，RabbitMQ 从队列中删除该消息。</li></ul><p><img src="https://mcnfxurl5vzo.feishu.cn/space/api/box/stream/download/asynccode/?code=NzU2YmM3YmFkYTU4MGY3OThiZjVkNDkxMDkzNjNkYjlfZEtDMkh2N0FYbENvR2xEVm4wMnZJTjRWVWFKRElrYzlfVG9rZW46SUZQVWJLOUV4b3RmRVF4MWhPRWNHOEs3bmRkXzE3NDMzODg3ODE6MTc0MzM5MjM4MV9WNA" alt="img"></p><p>RabbitMQ的消息确认机制是指消费者在消费一条消息后，向RabbitMQ发送确认消息（ACK）的过程，以此告知RabbitMQ消息已被正确处理。<strong>该机制的作用是确保RabbitMQ能正确地将消息从队列中删除，避免重复投递和重复消费。</strong></p><p>消息确认机制的过程如下：</p><ul><li>消费者从RabbitMQ中获取消息并处理。</li><li>处理完成后，向RabbitMQ发送确认消息（ACK）。确认消息通常是一个简单的AMQP基本确认帧，带有消息的标识符（delivery tag）和是否批量确认的标记。</li><li>RabbitMQ收到确认消息后，将该消息从队列中删除。</li><li>如果消费者在一定时间内没有发送确认消息，RabbitMQ会认为消息未被正确处理，将会重新将消息投递到队列中，等待下一次消费。</li></ul><p>需要注意的是，在某些情况下，消费者可能无法正确处理消息，比如消费者崩溃或出现异常等。为避免这种情况导致消息丢失，<strong>RabbitMQ还提供了Nack</strong>（Negative Acknowledge）和Reject机制，可将消息标记为无法处理或无法路由的状态，使其重新回到队列中等待下一次投递。此外，可通过设置重试次数和重试时间间隔等参数，进行消息重试和延迟投递的配置，以满足不同的业务需求。 </p><h2 id="6-❓消息基于什么传输？"><a href="#6-❓消息基于什么传输？" class="headerlink" title="6. ❓消息基于什么传输？"></a>6. ❓消息基于什么传输？</h2><p><img src="https://mcnfxurl5vzo.feishu.cn/space/api/box/stream/download/asynccode/?code=NzJmYWVhZWU4ZmI4YWY2NDg4N2FjNmExZGYyOWNlY2RfZFhvUUFRZ1d0b1A5QkgzUjhDYWw4ZlZONU85c3k5OWhfVG9rZW46RWhMdmJ5YUJRb2hxSkd4MUQwT2NGYUtIbkdkXzE3NDMzODg3ODE6MTc0MzM5MjM4MV9WNA" alt="img"></p><h2 id="7-为什么不应该对所有的-message-都使用持久化机制？"><a href="#7-为什么不应该对所有的-message-都使用持久化机制？" class="headerlink" title="7. 为什么不应该对所有的 message 都使用持久化机制？"></a>7. 为什么不应该对所有的 message 都使用持久化机制？</h2><p>使用持久化机制会增加磁盘负担，尤其在高并发场景下，成本更高。若所有消息都用，会使RabbitMQ性能下降，影响系统性能。所以要依业务需求和消息重要性选择是否用。重要消息用它保可靠，临时消息可不用，减轻服务器负担。</p><p>若message设了persistent属性，但queue未设durable属性，queue的owner node异常时，在queue重建前，发往它的message将被阻塞；若message和queue都分别设了persistent和durable属性，queue的owner node异常且无法重启，queue无法在其他node重建，只能等其owner node重启后才能恢复使用，期间发送给该queue的消息也会被阻塞。</p><p>因此，是否对message持久化，需综合考量性能需求及可能问题。若想单RabbitMQ服务器达100000条/秒以上消息吞吐量，要么不用持久化保速度，用其他方式确保消息可靠；要么用持久化，且保证关键消息量不致性能瓶颈。 </p><h2 id="8-如何保证高可用的？RabbitMQ-的集群？"><a href="#8-如何保证高可用的？RabbitMQ-的集群？" class="headerlink" title="8. 如何保证高可用的？RabbitMQ 的集群？"></a>8. 如何保证高可用的？RabbitMQ 的集群？</h2><p><strong>普通集群模式</strong></p><p>普通集群模式是RabbitMQ最常见且最简单的集群模式。多台RabbitMQ服务器经网络连接成集群，共同管理消息队列，借节点间通信实现消息传递与路由。适用于多数应用场景，提供高可用性和可靠性。</p><p><strong>镜像集群模式</strong></p><p>一种高可用性集群模式，可提升RabbitMQ集群的可靠性与容错能力。每个节点有多个镜像节点，镜像节点自动复制主节点消息队列，主节点故障时接管消息队列处理。适用于对消息可靠性要求高的场景，但会增加网络带宽和存储成本</p><p><strong>Federated集群模式</strong></p><p>RabbitMQ的特殊集群模式，能将多个RabbitMQ集群组成逻辑整体，通过Federation插件实现集群间消息传递与路由。适用于需跨多数据中心或地理分布的场景，但会增加网络延迟和复杂度。 </p><h2 id="9-RabbitMQ上的一个queue中存放的message是否有数量限制？"><a href="#9-RabbitMQ上的一个queue中存放的message是否有数量限制？" class="headerlink" title="9. RabbitMQ上的一个queue中存放的message是否有数量限制？"></a>9. RabbitMQ上的一个queue中存放的message是否有数量限制？</h2><ul><li><strong>队列的大小限制</strong>：队列可通过配置参数限制大小，当队列大小达到限制，新消息无法入队。该限制能通过RabbitMQ的管理界面或者AMQP协议设置。</li><li><strong>内存**</strong>限制**：RabbitMQ中的消息队列保存在内存中，若队列中消息数量过多，会占用大量内存空间，可能致使系统性能下降甚至崩溃。所以，系统内存大小是队列存放消息数量的限制因素之一。 </li><li><strong>磁盘限制</strong>：当RabbitMQ的磁盘空间不足时，也会对队列中存放消息的数量形成限制。 </li></ul><h2 id="10-⭐️在单node系统和多node构成的cluster系统中声明queue，exchange，以及进行binding会有什么不同？"><a href="#10-⭐️在单node系统和多node构成的cluster系统中声明queue，exchange，以及进行binding会有什么不同？" class="headerlink" title="10. ⭐️在单node系统和多node构成的cluster系统中声明queue，exchange，以及进行binding会有什么不同？"></a>10. ⭐️在单node系统和多node构成的cluster系统中声明queue，exchange，以及进行binding会有什么不同？</h2><p>当你在单node上声明queue时，只要该node上相关元数据进行了变更，你就会得到Queue.Declare - ok回应；而在cluster上声明queue，则要求cluster上的全部node都要进行元数据成功更新，才会得到Queue.Declare - ok回应。另外，若node类型为RAM node则变更的数据仅保存在内存中，若类型为disk node则还要变更保存在磁盘上的数据。</p><p><strong>客户端连接到cluster中的任意node上是否都能正常工作？</strong></p><p>是的，客户端感觉不到不同。</p><p><strong>若cluster中拥有某个queue的owner node失效了，且该queue被声明具有durable属性，是否能够成功从其他node上重新声明该queue？</strong></p><p>不能，在这种情况下，将得到404 NOT FOUND错误。只能等queue所属的node恢复后才能使用该queue。但若该queue本身不具有durable属性，则可在其他node上重新声明。 </p><h2 id="11-向不存在的exchange发publish消息会发生什么？向不存在的queue执行consume动作会发生什么？"><a href="#11-向不存在的exchange发publish消息会发生什么？向不存在的queue执行consume动作会发生什么？" class="headerlink" title="11. 向不存在的exchange发publish消息会发生什么？向不存在的queue执行consume动作会发生什么？"></a>11. 向不存在的exchange发publish消息会发生什么？向不存在的queue执行consume动作会发生什么？</h2><p>都会收到 Channel.Close 信令告之不存在（内含原因 404 NOT FOUND）</p><h2 id="12-为什么说保证message被可靠持久化的条件是queue和exchange具有durable属性，同时message具有-persistent属性才行？"><a href="#12-为什么说保证message被可靠持久化的条件是queue和exchange具有durable属性，同时message具有-persistent属性才行？" class="headerlink" title="12. 为什么说保证message被可靠持久化的条件是queue和exchange具有durable属性，同时message具有 persistent属性才行？"></a>12. 为什么说保证message被可靠持久化的条件是queue和exchange具有durable属性，同时message具有 persistent属性才行？</h2><p>binding 关系可以表示为 exchange - binding - queue。从文档中我们知道，若要求投递的 message 能够不丢失，要求 message 本身设置 persistent 属性，要求 exchange 和 queue 都设置 durable 属性。其实这问题可以这么想，若 exchange 或 queue 未设置 durable 属性，则在其 crash 之后就会无法恢复，那么即使 message 设置了 persistent 属性，仍然存在 message 虽然能恢复但却无处容身的问题；同理，若 message 本身未设置 persistent 属性，则 message 的持久化更无从谈起。</p><h2 id="13-死信队列和延迟队列的使用？"><a href="#13-死信队列和延迟队列的使用？" class="headerlink" title="13. 死信队列和延迟队列的使用？"></a>13. 死信队列和延迟队列的使用？</h2><p> <strong>死信队列</strong></p><p> 当消息无法被正确处理时，可将其转发到死信队列，以便进一步处理。通过使用死信队列，能统一存储和管理无法处理的消息，并借助设置合适的TTL（存活时间）和DLX（死信交换器）等参数，灵活控制消息的转发和重新处理。</p><p> 使用死信队列的主要步骤：</p><ul><li>创建一个普通队列和一个死信交换器；</li><li>将普通队列绑定到死信交换器，并指定死信队列的路由键；</li><li><p>发送消息时，可将消息的TTL设为较小值，当消息未被消费者处理时，会转发到死信队列。</p><p>当需在一段时间后才能处理某个消息时，可使用延迟队列。通过设置消息的TTL和DLX等参数，能将消息转发到指定队列，以便在一定时间后再进行处理。适用于订单超时处理、提醒任务等场景。</p><p>使用延迟队列的主要步骤：</p></li><li><p>创建一个普通队列和一个交换器；</p></li><li>在交换器中设置消息的TTL和DLX等参数，将消息转发到指定队列；</li><li>在指定队列中处理消息。 </li></ul><h2 id="14-什么情况下producer不主动创建queue是安全的？"><a href="#14-什么情况下producer不主动创建queue是安全的？" class="headerlink" title="14. 什么情况下producer不主动创建queue是安全的？"></a>14. 什么情况下producer不主动创建queue是安全的？</h2><p>message是允许丢失的；实现了针对未处理消息的republish功能。</p><h2 id="15-如何保证消息的顺序性？"><a href="#15-如何保证消息的顺序性？" class="headerlink" title="15. 如何保证消息的顺序性？"></a>15. 如何保证消息的顺序性？</h2><p>只有一个队列仅有一个消费者的情况下才能保证顺序，否则只能通过全局 ID 实现（每条消息都有一个 msgId，关联的消息拥有一个 parentMsgId。可以在消费端实现前一条消息未消费，不处理下一条消息；也可以在生产端实现前一条消息未处理完不发下一条消息。</p><h2 id="16-消息什么时候会变成死信？"><a href="#16-消息什么时候会变成死信？" class="headerlink" title="16. 消息什么时候会变成死信？"></a>16. 消息什么时候会变成死信？</h2><p>消息拒绝并且没有设置重新入队；消息过期；消息堆积，并且队列达到最大长度，先入队的消息会变成 DL（死信）。</p><h2 id="17-⭐️-RabbitMQ事务机制："><a href="#17-⭐️-RabbitMQ事务机制：" class="headerlink" title="17.⭐️ RabbitMQ事务机制："></a>17.⭐️ RabbitMQ事务机制：</h2><p>RabbitMQ 支持事务机制，用于在发送消息时保证事务的原子性。事务机制允许在多个 RabbitMQ 操作中声明事务，并在最终确认消息被完全处理之前，将多个操作打包为一个原子操作。</p><p>在 RabbitMQ 中，事务机制的使用流程如下：</p><ul><li>开启事务：在发送消息之前，使用 txSelect 方法开启事务；</li><li>发送消息：使用 basicPublish 方法发送消息；</li><li>提交事务：使用 txCommit 方法提交事务，如果提交成功，则消息会被 RabbitMQ 确认，否则消息会被回滚；</li><li>回滚事务：使用 txRollback 方法回滚事务，如果回滚成功，则之前发送的消息会被撤销，否则消息会被继续处理。</li></ul><p>需要注意的是，使用事务机制会对 RabbitMQ 的性能产生一定的影响，因此建议在必要的情况下使用，例如在消息的可靠性要求非常高的场景下。在消息量较大的场景下，可以使用事务机制的替代方案，如消息确认机制（ACK 机制）等，以保证系统的高性能和可靠性。</p>]]></content>
    
    
    <summary type="html">🥧本人的Rabbitmq面试题总结</summary>
    
    
    
    <category term="面试题" scheme="https://outoflovenicoo.github.io/categories/%E9%9D%A2%E8%AF%95%E9%A2%98/"/>
    
    
    <category term="MQ" scheme="https://outoflovenicoo.github.io/tags/MQ/"/>
    
  </entry>
  
</feed>
