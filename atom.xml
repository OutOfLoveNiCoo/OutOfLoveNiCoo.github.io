<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
  <title>OutOfLove🥝</title>
  
  
  <link href="https://outoflovenicoo.github.io/atom.xml" rel="self"/>
  
  <link href="https://outoflovenicoo.github.io/"/>
  <updated>2025-04-19T14:00:00.000Z</updated>
  <id>https://outoflovenicoo.github.io/</id>
  
  <author>
    <name>OutOfLove🥝</name>
    
  </author>
  
  <generator uri="https://hexo.io/">Hexo</generator>
  
  <entry>
    <title>并发编程的内存泄漏与内存溢出问题</title>
    <link href="https://outoflovenicoo.github.io/posts/2025-04-19-%E5%B9%B6%E5%8F%91%E7%BC%96%E7%A8%8B%E7%9A%84%E5%86%85%E5%AD%98%E6%B3%84%E6%BC%8F%E4%B8%8E%E5%86%85%E5%AD%98%E6%BA%A2%E5%87%BA%E9%97%AE%E9%A2%98.html"/>
    <id>https://outoflovenicoo.github.io/posts/2025-04-19-%E5%B9%B6%E5%8F%91%E7%BC%96%E7%A8%8B%E7%9A%84%E5%86%85%E5%AD%98%E6%B3%84%E6%BC%8F%E4%B8%8E%E5%86%85%E5%AD%98%E6%BA%A2%E5%87%BA%E9%97%AE%E9%A2%98.html</id>
    <published>2025-04-19T10:19:03.000Z</published>
    <updated>2025-04-19T14:00:00.000Z</updated>
    
    <content type="html"><![CDATA[<h1>思维导图</h1><p><img src="2025-04-19-%E5%B9%B6%E5%8F%91%E7%BC%96%E7%A8%8B%E7%9A%84%E5%86%85%E5%AD%98%E6%B3%84%E6%BC%8F%E4%B8%8E%E5%86%85%E5%AD%98%E6%BA%A2%E5%87%BA%E9%97%AE%E9%A2%98/diagram.png" alt=""></p><p>在Java编程中，内存泄漏和内存溢出是常见且需要重点关注的问题。它们会导致程序性能下降，甚至崩溃。本文将详细介绍这两个概念、常见原因、表现迹象及解决方法。</p><h2 id="一、内存泄漏">一、内存泄漏</h2><h3 id="1-常见原因">1. 常见原因</h3><ul><li><p><strong>静态属性导致内存泄漏</strong>：静态变量生命周期长，若引用了大对象或长时间不用的对象，易导致内存泄漏。例如，静态集合类不断添加元素却不清理。</p></li><li><p><strong>未关闭的资源</strong>：数据库连接、文件流、网络连接等资源使用后未关闭，会一直占用内存。即使程序不再使用这些资源，垃圾回收器也无法回收，因为资源的引用未释放。</p></li><li><p><strong>使用ThreadLocal后未手动清理</strong>：ThreadLocal为每个线程提供独立变量副本，但若使用后不调用<code>remove</code>方法，线程长期存活时，ThreadLocal关联的对象会一直存在，占用内存。</p></li><li><p><strong>线程泄漏</strong>：线程结束后，相关资源未正确释放。如线程池中的线程未正确关闭，一直占用内存资源。</p></li></ul><h3 id="2-迹象">2. 迹象</h3><ul><li><p><strong>内存占用不断增加</strong>：观察程序内存占用，若持续上升且不释放，很可能存在内存泄漏。随着时间推移，内存占用越来越高，最终可能导致内存溢出。</p></li><li><p><strong>长时间运行后性能下降</strong>：程序运行一段时间后变慢，因内存泄漏使系统可用内存减少，垃圾回收频繁，影响程序执行效率。</p></li><li><p><strong>频繁的垃圾回收</strong>：尤其是Full GC频繁发生，说明内存中存在大量无法被回收的对象，可能是内存泄漏导致。</p></li></ul><h3 id="3-解决方法">3. 解决方法</h3><ul><li><p><strong>正确关闭资源</strong>：</p><ul><li><p>对于支持<code>try - with - resources</code>的资源（如<code>AutoCloseable</code>实现类），使用该语句自动关闭资源，确保资源使用后及时释放。</p></li><li><p>对于不支持的资源（如某些旧版数据库连接），在<code>finally</code>块中手动关闭，保证即使出现异常，资源也能释放。</p></li></ul></li><li><p><strong>使用ThreadLocal后手动清理</strong>：在使用完ThreadLocal变量后，及时调用<code>remove</code>方法，清除线程本地存储的变量，避免内存占用。</p></li><li><p><strong>避免线程泄漏</strong>：在线程不再需要时，调用<code>Thread</code>的<code>interrupt</code>方法或其他合适方式停止线程，确保线程相关资源正确关闭，如关闭线程池中的空闲线程。</p></li></ul><h2 id="二、内存溢出">二、内存溢出</h2><h3 id="1-常见原因-2">1. 常见原因</h3><ul><li><p><strong>大量对象创建</strong>：程序中循环或频繁创建大量对象，且未及时回收，超过JVM堆内存限制，导致内存溢出。例如，一次性加载大量数据到内存中创建对象。</p></li><li><p><strong>持久引用</strong>：如缓存、集合等数据结构长时间持有对象引用，即使对象不再使用，也无法被垃圾回收器回收，造成内存占用累积。</p></li><li><p><strong>递归调用</strong>：深度递归可能导致栈内存耗尽，出现<code>StackOverflowError</code>，这也是一种内存溢出情况。</p></li></ul><h3 id="2-JVM内存结构中的溢出情况">2. JVM内存结构中的溢出情况</h3><ul><li><p><strong>堆溢出</strong>：错误信息<code>java.lang.OutOfMemoryError: java heap space</code>。当堆中创建的对象过多，垃圾回收无法及时回收，且堆内存达到最大限制（通过<code>-Xmx</code>设置）时发生。</p></li><li><p><strong>方法区溢出</strong>：JDK 1.8前为<code>java.lang.OutOfMemoryError: PermGen space</code>，JDK 1.8后为<code>java.lang.OutOfMemoryError: Metaspace</code>。加载的类、常量过多，超过方法区内存限制时出现。</p></li><li><p><strong>直接内存溢出</strong>：错误信息<code>java.lang.OutOfMemoryError: Direct buffer memory</code>。使用<code>ByteBuffer.allocateDirect()</code>等分配直接内存时，若未正确管理（如未调用<code>clear</code>），直接内存使用过多导致溢出。</p></li></ul><h3 id="3-解决方法-2">3. 解决方法</h3><ul><li><p><strong>定位问题</strong>：通过<code>top</code>等命令定位到占用内存高的线程，分析其堆存储文件（如使用<code>jmap</code>生成堆转储文件，用<code>jhat</code>或其他工具分析），确定具体导致溢出的对象和代码。</p></li><li><p><strong>检查数据加载</strong>：若因一次从数据库取出过多数据导致内存中对象过多，修改查询方式，采用分页查询等，减少一次性加载的数据量。</p></li><li><p><strong>排查内存泄漏</strong>：检查<code>List</code>、<code>Map</code>等集合对象是否使用后未清除元素，确保不再使用的对象能被垃圾回收。例如，及时清除缓存中过期的数据。</p></li><li><p><strong>调整JVM参数</strong>：若启动参数中内存设定过小（<code>-Xms</code>、<code>-Xmx</code>），适当增加内存。但需注意，增加内存不是万能的，还需结合代码优化，避免无限制消耗内存。</p></li></ul><p>内存泄漏和内存溢出是Java程序中需要重点关注的问题。通过了解其原因、表现和解决方法，能更好地优化程序，提高稳定性和性能。在开发中，要养成良好的编码习惯，及时释放资源，合理管理对象引用，定期监控程序内存使用情况，以便及时发现和解决问题。 </p><h2 id="参考博客：">参考博客：</h2><p><a href="https://xiaolincoding.com/interview/jvm.html#%E5%86%85%E5%AD%98%E6%B3%84%E6%BC%8F%E5%92%8C%E5%86%85%E5%AD%98%E6%BA%A2%E5%87%BA%E7%9A%84%E7%90%86%E8%A7%A3">Java虚拟机面试题</a></p><p><a href="https://www.cnblogs.com/flydean/p/17722512.html">www.cnblogs.com</a></p>]]></content>
    
    
    <summary type="html">🥧并发编程的内存泄漏与内存溢出问题</summary>
    
    
    
    <category term="学习" scheme="https://outoflovenicoo.github.io/categories/%E5%AD%A6%E4%B9%A0/"/>
    
    
    <category term="思维导图" scheme="https://outoflovenicoo.github.io/tags/%E6%80%9D%E7%BB%B4%E5%AF%BC%E5%9B%BE/"/>
    
  </entry>
  
  <entry>
    <title>华为416批次笔试</title>
    <link href="https://outoflovenicoo.github.io/posts/2025-04-17-%E5%8D%8E%E4%B8%BA416%E6%89%B9%E6%AC%A1%E7%AC%94%E8%AF%95.html"/>
    <id>https://outoflovenicoo.github.io/posts/2025-04-17-%E5%8D%8E%E4%B8%BA416%E6%89%B9%E6%AC%A1%E7%AC%94%E8%AF%95.html</id>
    <published>2025-04-17T10:19:03.000Z</published>
    <updated>2025-04-17T14:00:00.000Z</updated>
    
    <content type="html"><![CDATA[<h1 id="2025年4月16日华为笔试复盘"><a href="#2025年4月16日华为笔试复盘" class="headerlink" title="2025年4月16日华为笔试复盘"></a>2025年4月16日华为笔试复盘</h1><p>​    这场笔试做的很糟糕，三道题一道也没a出来，不过幸好最后及格了，我觉得需要复盘一下为什么做的这么糟糕。</p><p>​    题目来源网站：CodeFun:<a href="https://codefun2000.com/pset/673c82a4d67fed3f6531c8e1">https://codefun2000.com/pset/673c82a4d67fed3f6531c8e1</a></p><h2 id="第一题"><a href="#第一题" class="headerlink" title="第一题"></a>第一题</h2><p><a href="https://codefun2000.com/p/P2845">https://codefun2000.com/p/P2845</a></p><p><img src="2025-04-17-华为416批次笔试/image-20250418102041869.png" alt="image-20250418102041869"></p><p><img src="2025-04-17-华为416批次笔试/image-20250418102120394.png" alt="image-20250418102120394"></p><p>其实看到这一题，我第一眼就想到用位运算，但是位运算不知道该怎么样去遍历，因为答案可能有多个行叠加。所以我采取了一个比较通用的dfs方法去遍历所有可能(但是没注意到m,n的长度最大为1000，位运算肯定超时)。</p><p>这是当时的做法（回忆版）</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> java.util.*;</span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Main</span> &#123;</span><br><span class="line">    <span class="keyword">static</span> <span class="type">int</span>[][] cases;</span><br><span class="line">    <span class="keyword">static</span> <span class="type">int</span> minCount;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">        <span class="type">Scanner</span> <span class="variable">sc</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Scanner</span>(System.in);</span><br><span class="line">        <span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> sc.nextInt();</span><br><span class="line">        <span class="type">int</span> <span class="variable">j</span> <span class="operator">=</span> sc.nextInt();</span><br><span class="line">        cases = <span class="keyword">new</span> <span class="title class_">int</span>[i][j];</span><br><span class="line">        </span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">x</span> <span class="operator">=</span> <span class="number">0</span>; x &lt; i; x++) &#123;</span><br><span class="line">            <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">y</span> <span class="operator">=</span> <span class="number">0</span>; y &lt; j; y++) &#123;</span><br><span class="line">                cases[x][y] = sc.nextInt();</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">        <span class="type">boolean</span>[] covered = <span class="keyword">new</span> <span class="title class_">boolean</span>[j];</span><br><span class="line">        <span class="type">int</span> <span class="variable">count</span> <span class="operator">=</span> <span class="number">0</span>;  </span><br><span class="line">        dfs(covered,<span class="number">0</span>,<span class="number">0</span>,<span class="number">0</span>);</span><br><span class="line">        System.out.println(allCovered ? count : -<span class="number">1</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">// DFS</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">dfs</span><span class="params">(<span class="type">boolean</span>[] covered, <span class="type">int</span> caseIndex, <span class="type">int</span> selected, <span class="type">int</span> coveredCount)</span> &#123;</span><br><span class="line">        <span class="comment">// 判断当前是否已经覆盖了所有模块</span></span><br><span class="line">        <span class="keyword">if</span> (coveredCount == covered.length) &#123;</span><br><span class="line">            minCount = Math.min(minCount, selected); <span class="comment">// 更新最小测试用例数</span></span><br><span class="line">            <span class="keyword">return</span>;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 如果当前已选择的测试用例数量已经大于或等于最小值，剪枝</span></span><br><span class="line">        <span class="keyword">if</span> (selected &gt;= minCount) &#123;</span><br><span class="line">            <span class="keyword">return</span>;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 递归选择每个测试用例</span></span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> caseIndex; i &lt; cases.length; i++) &#123;</span><br><span class="line">            <span class="type">boolean</span>[] newCov = Arrays.copyOf(covered, covered.length); <span class="comment">// 复制当前已覆盖的模块</span></span><br><span class="line">            <span class="type">int</span> <span class="variable">newCovCount</span> <span class="operator">=</span> coveredCount;</span><br><span class="line"></span><br><span class="line">            <span class="comment">// 更新覆盖状态</span></span><br><span class="line">            <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">j</span> <span class="operator">=</span> <span class="number">0</span>; j &lt; cases[i].length; j++) &#123;</span><br><span class="line">                <span class="keyword">if</span> (cases[i][j] == <span class="number">1</span> &amp;&amp; !newCov[j]) &#123;</span><br><span class="line">                    newCov[j] = <span class="literal">true</span>;</span><br><span class="line">                    newCovCount++;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">            dfs(newCov, i + <span class="number">1</span>, selected + <span class="number">1</span>, newCovCount);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br></pre></td></tr></table></figure><p>不出意外超时了，最后只通过了25%😭，这道题做了半天没a出来，<strong>进而影响了下一道题</strong>。</p><p>再来说一下这道题的正确做法吧，转化成集合去遍历，这里没想到</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> java.util.Scanner;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Main</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">        <span class="type">Scanner</span> <span class="variable">sc</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Scanner</span>(System.in);</span><br><span class="line">        <span class="comment">// 读取测试用例总数 n 和模块总数 m</span></span><br><span class="line">        <span class="type">int</span> <span class="variable">n</span> <span class="operator">=</span> sc.nextInt();</span><br><span class="line">        <span class="type">int</span> <span class="variable">m</span> <span class="operator">=</span> sc.nextInt();</span><br><span class="line">        <span class="type">int</span>[] tests = <span class="keyword">new</span> <span class="title class_">int</span>[n];</span><br><span class="line">        </span><br><span class="line">        <span class="comment">// 将每个测试用例转换为位掩码表示</span></span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i &lt; n; i++) &#123;</span><br><span class="line">            <span class="type">int</span> <span class="variable">mask</span> <span class="operator">=</span> <span class="number">0</span>;</span><br><span class="line">            <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">j</span> <span class="operator">=</span> <span class="number">0</span>; j &lt; m; j++) &#123;</span><br><span class="line">                <span class="type">int</span> <span class="variable">x</span> <span class="operator">=</span> sc.nextInt();</span><br><span class="line">                <span class="keyword">if</span> (x == <span class="number">1</span>) &#123;</span><br><span class="line">                    mask |= (<span class="number">1</span> &lt;&lt; j);</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">            tests[i] = mask;</span><br><span class="line">        &#125;</span><br><span class="line">        </span><br><span class="line">        <span class="comment">// 目标掩码：所有模块都被覆盖（低 m 位全为 1）</span></span><br><span class="line">        <span class="type">int</span> <span class="variable">target</span> <span class="operator">=</span> (<span class="number">1</span> &lt;&lt; m) - <span class="number">1</span>;</span><br><span class="line">        <span class="type">int</span> <span class="variable">ans</span> <span class="operator">=</span> Integer.MAX_VALUE;</span><br><span class="line">        </span><br><span class="line">        <span class="comment">// 枚举所有可能的测试用例子集（采用二进制枚举）</span></span><br><span class="line">      <span class="comment">/*</span></span><br><span class="line"><span class="comment">      暴力枚举，这里没想到</span></span><br><span class="line"><span class="comment">      0 0 0 都不选</span></span><br><span class="line"><span class="comment">      0 0 1 选第一个</span></span><br><span class="line"><span class="comment">      0 1 1 选第一个第二个</span></span><br><span class="line"><span class="comment">      1 1 1 全选</span></span><br><span class="line"><span class="comment">      */</span></span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">s</span> <span class="operator">=</span> <span class="number">0</span>; s &lt; (<span class="number">1</span> &lt;&lt; n); s++) &#123;</span><br><span class="line">            <span class="type">int</span> <span class="variable">unionMask</span> <span class="operator">=</span> <span class="number">0</span>;</span><br><span class="line">            <span class="type">int</span> <span class="variable">cnt</span> <span class="operator">=</span> <span class="number">0</span>;</span><br><span class="line">            <span class="comment">// 遍历子集中的每个测试用例，将其覆盖情况合并</span></span><br><span class="line">            <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i &lt; n; i++) &#123;</span><br><span class="line">              <span class="comment">// 选当前行</span></span><br><span class="line">                <span class="keyword">if</span> ((s &amp; (<span class="number">1</span> &lt;&lt; i)) != <span class="number">0</span>) &#123;</span><br><span class="line">                    unionMask |= tests[i];</span><br><span class="line">                    cnt++;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="comment">// 如果当前子集能够覆盖所有模块，则更新答案</span></span><br><span class="line">            <span class="keyword">if</span> (unionMask == target) &#123;</span><br><span class="line">                ans = Math.min(ans, cnt);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        </span><br><span class="line">        <span class="comment">// 如果没有满足要求的子集，输出 -1；否则输出最小用例数</span></span><br><span class="line">        System.out.println(ans == Integer.MAX_VALUE ? -<span class="number">1</span> : ans);</span><br><span class="line">        sc.close();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br></pre></td></tr></table></figure><h2 id="第二题"><a href="#第二题" class="headerlink" title="第二题"></a>第二题</h2><p><a href="https://codefun2000.com/p/P2846">https://codefun2000.com/p/P2846</a></p><p><img src="2025-04-17-华为416批次笔试/image-20250418105640610.png" alt="image-20250418105640610"></p><p><img src="2025-04-17-华为416批次笔试/image-20250418105657826.png" alt="image-20250418105657826"></p><p>因为第一题没a出来，导致做这题的思路都很乱。一开始想用一个TreeSet去存储图的信息，发现这样做不对。</p><p>然后想着用一个HashMap去存领接表，但是感觉图的构建很麻烦，这是一个双向图，整个思路都是乱的，想先写BFS的代码，写到一半意思到时间可能快不够了，继续做这题做不出来这次笔试就过不了，没办法，只能舍弃了，直接输出“NA”骗了7%的分，惭愧😭。</p><p>后面做完第三题再来看第二题，发现DFS应该也能做，但是没时间了。。。主要是这题图的构建要复杂一点。</p><p><strong>正确做法：</strong></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br><span class="line">132</span><br><span class="line">133</span><br><span class="line">134</span><br><span class="line">135</span><br><span class="line">136</span><br><span class="line">137</span><br><span class="line">138</span><br><span class="line">139</span><br><span class="line">140</span><br><span class="line">141</span><br><span class="line">142</span><br><span class="line">143</span><br><span class="line">144</span><br><span class="line">145</span><br><span class="line">146</span><br><span class="line">147</span><br><span class="line">148</span><br><span class="line">149</span><br><span class="line">150</span><br><span class="line">151</span><br><span class="line">152</span><br><span class="line">153</span><br><span class="line">154</span><br><span class="line">155</span><br><span class="line">156</span><br><span class="line">157</span><br><span class="line">158</span><br><span class="line">159</span><br><span class="line">160</span><br><span class="line">161</span><br><span class="line">162</span><br><span class="line">163</span><br><span class="line">164</span><br><span class="line">165</span><br><span class="line">166</span><br><span class="line">167</span><br><span class="line">168</span><br><span class="line">169</span><br><span class="line">170</span><br><span class="line">171</span><br><span class="line">172</span><br><span class="line">173</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> java.util.*;</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">RouteFinder</span> &#123;</span><br><span class="line">    <span class="comment">// 线路数量</span></span><br><span class="line">    <span class="keyword">static</span> <span class="type">int</span> N;</span><br><span class="line">    <span class="comment">// 起点站</span></span><br><span class="line">    <span class="keyword">static</span> String start;</span><br><span class="line">    <span class="comment">// 终点站</span></span><br><span class="line">    <span class="keyword">static</span> String target;</span><br><span class="line">    <span class="comment">// 存储线路之间的换乘信息，键为线路编号，值为该线路可换乘的线路及换乘站信息</span></span><br><span class="line">    <span class="keyword">static</span> Map&lt;Integer, List&lt;Route&gt;&gt; mp = <span class="keyword">new</span> <span class="title class_">HashMap</span>&lt;&gt;();</span><br><span class="line">    <span class="comment">// 存储每个站点所在的线路，键为站点名称，值为包含该站点的线路编号列表</span></span><br><span class="line">    <span class="keyword">static</span> Map&lt;String, List&lt;Integer&gt;&gt; mp1 = <span class="keyword">new</span> <span class="title class_">HashMap</span>&lt;&gt;();</span><br><span class="line">    <span class="comment">// 记录换乘次数，初始化为 -1</span></span><br><span class="line">    <span class="keyword">static</span> <span class="type">int</span> <span class="variable">cnt</span> <span class="operator">=</span> -<span class="number">1</span>;</span><br><span class="line">    <span class="comment">// 标记是否找到可达路线</span></span><br><span class="line">    <span class="keyword">static</span> <span class="type">boolean</span> <span class="variable">flag</span> <span class="operator">=</span> <span class="literal">false</span>;</span><br><span class="line">    <span class="comment">// 记录到达终点站所在的线路编号</span></span><br><span class="line">    <span class="keyword">static</span> <span class="type">int</span> targ;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 内部类，用于存储线路和换乘站信息</span></span><br><span class="line">    <span class="keyword">static</span> <span class="keyword">class</span> <span class="title class_">Route</span> &#123;</span><br><span class="line">        <span class="comment">// 可换乘的线路编号</span></span><br><span class="line">        <span class="type">int</span> line;</span><br><span class="line">        <span class="comment">// 换乘站名称</span></span><br><span class="line">        String station;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 构造函数，初始化线路和换乘站信息</span></span><br><span class="line">        Route(<span class="type">int</span> line, String station) &#123;</span><br><span class="line">            <span class="built_in">this</span>.line = line;</span><br><span class="line">            <span class="built_in">this</span>.station = station;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 广度优先搜索函数，用于查找从起点站到终点站的最短换乘路线</span></span><br><span class="line">    <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">bfs</span><span class="params">(<span class="type">int</span>[] visited, Set&lt;Integer&gt; tar, <span class="type">int</span>[] father)</span> &#123;</span><br><span class="line">        <span class="comment">// 创建一个队列，用于存储待访问的线路编号</span></span><br><span class="line">        Queue&lt;Integer&gt; qu = <span class="keyword">new</span> <span class="title class_">LinkedList</span>&lt;&gt;();</span><br><span class="line">        <span class="comment">// 将起点站所在的所有线路编号加入队列，并标记为已访问</span></span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> x : mp1.get(start)) &#123;</span><br><span class="line">            qu.add(x);</span><br><span class="line">            visited[x] = <span class="number">1</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">// 当队列不为空且未找到可达路线时，继续搜索</span></span><br><span class="line">        <span class="keyword">while</span> (!qu.isEmpty() &amp;&amp; !flag) &#123;</span><br><span class="line">            <span class="comment">// 换乘次数加 1</span></span><br><span class="line">            cnt++;</span><br><span class="line">            <span class="comment">// 获取当前队列的大小，即当前层的线路数量</span></span><br><span class="line">            <span class="type">int</span> <span class="variable">size</span> <span class="operator">=</span> qu.size();</span><br><span class="line">            <span class="comment">// 遍历当前层的所有线路</span></span><br><span class="line">            <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i &lt; size; i++) &#123;</span><br><span class="line">                <span class="comment">// 取出队列头部的线路编号</span></span><br><span class="line">                <span class="type">int</span> <span class="variable">tmp</span> <span class="operator">=</span> qu.poll();</span><br><span class="line">                <span class="comment">// 如果该线路是终点站所在的线路，标记找到可达路线，记录线路编号并跳出循环</span></span><br><span class="line">                <span class="keyword">if</span> (tar.contains(tmp)) &#123;</span><br><span class="line">                    targ = tmp;</span><br><span class="line">                    flag = <span class="literal">true</span>;</span><br><span class="line">                    <span class="keyword">break</span>;</span><br><span class="line">                &#125;</span><br><span class="line">                <span class="comment">// 遍历该线路可换乘的所有线路</span></span><br><span class="line">                <span class="keyword">for</span> (Route next : mp.getOrDefault(tmp, <span class="keyword">new</span> <span class="title class_">ArrayList</span>&lt;&gt;())) &#123;</span><br><span class="line">                    <span class="comment">// 如果该线路已被访问过，跳过</span></span><br><span class="line">                    <span class="keyword">if</span> (visited[next.line] == <span class="number">1</span>) <span class="keyword">continue</span>;</span><br><span class="line">                    <span class="comment">// 标记该线路为已访问</span></span><br><span class="line">                    visited[next.line] = <span class="number">1</span>;</span><br><span class="line">                    <span class="comment">// 将该线路加入队列</span></span><br><span class="line">                    qu.add(next.line);</span><br><span class="line">                    <span class="comment">// 记录该线路的父线路编号</span></span><br><span class="line">                    father[next.line] = tmp;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">        <span class="comment">// 创建 Scanner 对象，用于读取用户输入</span></span><br><span class="line">        <span class="type">Scanner</span> <span class="variable">scanner</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Scanner</span>(System.in);</span><br><span class="line">        <span class="comment">// 读取线路数量</span></span><br><span class="line">        N = scanner.nextInt();</span><br><span class="line">        <span class="comment">// 消耗掉换行符</span></span><br><span class="line">        scanner.nextLine();</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 二维数组，用于存储线路之间的换乘站信息</span></span><br><span class="line">        String[][] graph = <span class="keyword">new</span> <span class="title class_">String</span>[N][N];</span><br><span class="line">        <span class="comment">// 初始化二维数组，将所有元素设置为 &quot;*&quot;</span></span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i &lt; N; i++) &#123;</span><br><span class="line">            Arrays.fill(graph[i], <span class="string">&quot;*&quot;</span>);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 遍历每条线路</span></span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i &lt; N; i++) &#123;</span><br><span class="line">            <span class="comment">// 读取该线路上的所有站点信息</span></span><br><span class="line">            <span class="type">String</span> <span class="variable">s</span> <span class="operator">=</span> scanner.nextLine();</span><br><span class="line">            <span class="comment">// 将站点信息按空格分割成数组</span></span><br><span class="line">            String[] stations = s.split(<span class="string">&quot; &quot;</span>);</span><br><span class="line">            <span class="comment">// 遍历该线路上的每个站点</span></span><br><span class="line">            <span class="keyword">for</span> (String tmp : stations) &#123;</span><br><span class="line">                <span class="comment">// 如果该站点已经存在于 mp1 中，说明该站点是换乘站</span></span><br><span class="line">                <span class="keyword">if</span> (mp1.containsKey(tmp)) &#123;</span><br><span class="line">                    <span class="comment">// 获取该站点所在的所有线路编号列表</span></span><br><span class="line">                    List&lt;Integer&gt; a = mp1.get(tmp);</span><br><span class="line">                    <span class="comment">// 遍历该站点所在的所有线路</span></span><br><span class="line">                    <span class="keyword">for</span> (<span class="type">int</span> j : a) &#123;</span><br><span class="line">                        <span class="comment">// 更新 mp 中线路之间的换乘信息</span></span><br><span class="line">                        mp.computeIfAbsent(i, k -&gt; <span class="keyword">new</span> <span class="title class_">ArrayList</span>&lt;&gt;()).add(<span class="keyword">new</span> <span class="title class_">Route</span>(j, tmp));</span><br><span class="line">                        <span class="comment">// 更新 graph 中线路之间的换乘站信息</span></span><br><span class="line">                        graph[i][j] = tmp;</span><br><span class="line">                        <span class="comment">// 由于是双向图，更新反向的换乘信息</span></span><br><span class="line">                        mp.computeIfAbsent(j, k -&gt; <span class="keyword">new</span> <span class="title class_">ArrayList</span>&lt;&gt;()).add(<span class="keyword">new</span> <span class="title class_">Route</span>(i, tmp));</span><br><span class="line">                        graph[j][i] = tmp;</span><br><span class="line">                    &#125;</span><br><span class="line">                    <span class="comment">// 将当前线路编号加入该站点所在的线路编号列表</span></span><br><span class="line">                    mp1.get(tmp).add(i);</span><br><span class="line">                &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                    <span class="comment">// 如果该站点是第一次出现，创建一个新的线路编号列表，并将当前线路编号加入其中</span></span><br><span class="line">                    List&lt;Integer&gt; list = <span class="keyword">new</span> <span class="title class_">ArrayList</span>&lt;&gt;();</span><br><span class="line">                    list.add(i);</span><br><span class="line">                    <span class="comment">// 将该站点及其所在的线路编号列表存入 mp1 中</span></span><br><span class="line">                    mp1.put(tmp, list);</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 读取起点站和终点站名称</span></span><br><span class="line">        start = scanner.next();</span><br><span class="line">        target = scanner.next();</span><br><span class="line">        <span class="comment">// 用于标记线路是否已被访问过的数组</span></span><br><span class="line">        <span class="type">int</span>[] visited = <span class="keyword">new</span> <span class="title class_">int</span>[N];</span><br><span class="line">        <span class="comment">// 用于记录每个线路的父线路编号的数组，初始化为 -1</span></span><br><span class="line">        <span class="type">int</span>[] father = <span class="keyword">new</span> <span class="title class_">int</span>[N];</span><br><span class="line">        Arrays.fill(father, -<span class="number">1</span>);</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 如果起点站或终点站不在任何线路上，输出 &quot;NA&quot;</span></span><br><span class="line">        <span class="keyword">if</span> (!mp1.containsKey(start) || !mp1.containsKey(target)) &#123;</span><br><span class="line">            System.out.println(<span class="string">&quot;NA&quot;</span>);</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            <span class="comment">// 创建一个集合，存储终点站所在的所有线路编号</span></span><br><span class="line">            Set&lt;Integer&gt; tar = <span class="keyword">new</span> <span class="title class_">HashSet</span>&lt;&gt;(mp1.get(target));</span><br><span class="line">            <span class="comment">// 调用广度优先搜索函数进行搜索</span></span><br><span class="line">            bfs(visited, tar, father);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 如果未找到可达路线，输出 &quot;NA&quot;</span></span><br><span class="line">        <span class="keyword">if</span> (!flag) &#123;</span><br><span class="line">            System.out.println(<span class="string">&quot;NA&quot;</span>);</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            <span class="comment">// 用于存储最终的路线信息</span></span><br><span class="line">            List&lt;String&gt; result = <span class="keyword">new</span> <span class="title class_">ArrayList</span>&lt;&gt;();</span><br><span class="line">            <span class="comment">// 从终点站所在的线路开始回溯</span></span><br><span class="line">            <span class="type">int</span> <span class="variable">u</span> <span class="operator">=</span> targ;</span><br><span class="line">            <span class="comment">// 将终点站加入结果列表</span></span><br><span class="line">            result.add(target);</span><br><span class="line">            <span class="comment">// 回溯路线，直到找到起点站所在的线路</span></span><br><span class="line">            <span class="keyword">while</span> (father[u] != -<span class="number">1</span>) &#123;</span><br><span class="line">                <span class="comment">// 将换乘站加入结果列表</span></span><br><span class="line">                result.add(graph[father[u]][u]);</span><br><span class="line">                <span class="comment">// 更新当前线路为父线路</span></span><br><span class="line">                u = father[u];</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="comment">// 将起点站加入结果列表</span></span><br><span class="line">            result.add(start);</span><br><span class="line">            <span class="comment">// 获取结果列表的大小</span></span><br><span class="line">            <span class="type">int</span> <span class="variable">n</span> <span class="operator">=</span> result.size();</span><br><span class="line">            <span class="comment">// 输出路线信息，用 &quot;-&quot; 连接各个站点</span></span><br><span class="line">            <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> n - <span class="number">1</span>; i &gt; <span class="number">0</span>; i--) &#123;</span><br><span class="line">                System.out.print(result.get(i) + <span class="string">&quot;-&quot;</span>);</span><br><span class="line">            &#125;</span><br><span class="line">            System.out.println(result.get(<span class="number">0</span>));</span><br><span class="line">            <span class="comment">// 输出总换乘次数（包括起点站和终点站）</span></span><br><span class="line">            System.out.println(<span class="number">2</span> + cnt);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;    </span><br></pre></td></tr></table></figure><h2 id="第三题"><a href="#第三题" class="headerlink" title="第三题"></a>第三题</h2><p><img src="2025-04-17-华为416批次笔试/image-20250418110705215.png" alt="image-20250418110705215"></p><p><img src="2025-04-17-华为416批次笔试/image-20250418110727624.png" alt="image-20250418110727624"></p><p>这道题感觉比前面两题简单多了，有点像LeetCode和合并区间那道题，但是这里排序不能按照字典序进行排，索引比较朴素的思想是将ip地址转化成一个数进行排序。</p><p>我的做法：很奇怪，感觉没啥问题就只a了0.55</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> codefun.com.HuaWei;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> java.util.ArrayList;</span><br><span class="line"><span class="keyword">import</span> java.util.List;</span><br><span class="line"><span class="keyword">import</span> java.util.*;</span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">P2847</span> &#123;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 辅助方法：将IPv4地址转化为整数</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="type">long</span> <span class="title function_">ipToInt</span><span class="params">(String ip)</span> &#123;</span><br><span class="line">        String[] parts = ip.split(<span class="string">&quot;\\.&quot;</span>);</span><br><span class="line">        <span class="type">long</span> <span class="variable">result</span> <span class="operator">=</span> <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i &lt; <span class="number">4</span>; i++) &#123;</span><br><span class="line">            result += Integer.parseInt(parts[i]) * Math.pow(<span class="number">256</span>, <span class="number">3</span> - i);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> result;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> String <span class="title function_">intToIp</span><span class="params">(<span class="type">long</span> ipInt)</span> &#123;</span><br><span class="line">        <span class="type">int</span> <span class="variable">part1</span> <span class="operator">=</span> (<span class="type">int</span>) (ipInt / (<span class="type">int</span>)Math.pow(<span class="number">256</span>,<span class="number">3</span>));</span><br><span class="line">        <span class="type">int</span> <span class="variable">part2</span> <span class="operator">=</span> (<span class="type">int</span>)(ipInt / (<span class="type">int</span>)Math.pow(<span class="number">256</span>,<span class="number">2</span>)) % <span class="number">256</span>;</span><br><span class="line">        <span class="type">int</span> <span class="variable">part3</span> <span class="operator">=</span> (<span class="type">int</span>) ((ipInt / <span class="number">256</span>) % <span class="number">256</span>);</span><br><span class="line">        <span class="type">int</span> <span class="variable">part4</span> <span class="operator">=</span> (<span class="type">int</span>) (ipInt % <span class="number">256</span>);</span><br><span class="line">        <span class="keyword">return</span> part1 + <span class="string">&quot;.&quot;</span> + part2 + <span class="string">&quot;.&quot;</span> + part3 + <span class="string">&quot;.&quot;</span> + part4;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">        <span class="type">Scanner</span> <span class="variable">scanner</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Scanner</span>(System.in);</span><br><span class="line">        <span class="type">int</span> <span class="variable">N</span> <span class="operator">=</span> Integer.parseInt(scanner.nextLine());</span><br><span class="line">        List&lt;<span class="type">long</span>[]&gt; ipRanges = <span class="keyword">new</span> <span class="title class_">ArrayList</span>&lt;&gt;();</span><br><span class="line">        </span><br><span class="line">        <span class="comment">// 读取IP区间</span></span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i &lt; N; i++) &#123;</span><br><span class="line">            <span class="type">String</span> <span class="variable">line</span> <span class="operator">=</span> scanner.nextLine();</span><br><span class="line">            String[] parts = line.split(<span class="string">&quot; &quot;</span>);</span><br><span class="line">            <span class="type">long</span> <span class="variable">startIp</span> <span class="operator">=</span> ipToInt(parts[<span class="number">0</span>]);</span><br><span class="line">            <span class="type">long</span> <span class="variable">endIp</span> <span class="operator">=</span> ipToInt(parts[<span class="number">1</span>]);</span><br><span class="line">            ipRanges.add(<span class="keyword">new</span> <span class="title class_">long</span>[]&#123;startIp, endIp&#125;);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 按照业务需求进行排序</span></span><br><span class="line">        <span class="comment">// 排序规则: 先按IP占用数量 (endIp - startIp + 1)，再按起始IP排序</span></span><br><span class="line">        ipRanges.sort((a, b) -&gt; &#123;</span><br><span class="line">            <span class="type">long</span> <span class="variable">lenA</span> <span class="operator">=</span> a[<span class="number">1</span>] - a[<span class="number">0</span>] + <span class="number">1</span>;</span><br><span class="line">            <span class="type">long</span> <span class="variable">lenB</span> <span class="operator">=</span> b[<span class="number">1</span>] - b[<span class="number">0</span>] + <span class="number">1</span>;</span><br><span class="line">            <span class="keyword">if</span> (lenA == lenB) &#123;</span><br><span class="line">                <span class="keyword">return</span> Long.compare(a[<span class="number">0</span>], b[<span class="number">0</span>]);</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">return</span> Long.compare(lenA, lenB);</span><br><span class="line">        &#125;);</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 贪心算法，选择不重叠的区间</span></span><br><span class="line">        List&lt;<span class="type">long</span>[]&gt; result = <span class="keyword">new</span> <span class="title class_">ArrayList</span>&lt;&gt;();</span><br><span class="line">        <span class="type">long</span> <span class="variable">lastEnd</span> <span class="operator">=</span> -<span class="number">1</span>;</span><br><span class="line">        </span><br><span class="line">        <span class="keyword">for</span> (<span class="type">long</span>[] range : ipRanges) &#123;</span><br><span class="line">            <span class="keyword">if</span> (range[<span class="number">0</span>] &gt; lastEnd) &#123;</span><br><span class="line">                result.add(range);</span><br><span class="line">                lastEnd = range[<span class="number">1</span>];</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        </span><br><span class="line">        <span class="keyword">for</span> (<span class="type">long</span>[] range : result) &#123;</span><br><span class="line">            System.out.println(intToIp(range[<span class="number">0</span>]) + <span class="string">&quot; &quot;</span> + intToIp(range[<span class="number">1</span>]));</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure><p><strong>正确解法：</strong></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> codefun.com.HuaWei;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> java.util.*;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">P2847</span> &#123;</span><br><span class="line">    <span class="comment">// 将IPv4地址转化为整数，使用位运算保证精确性</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="type">long</span> <span class="title function_">ipToInt</span><span class="params">(String ip)</span> &#123;</span><br><span class="line">        String[] parts = ip.split(<span class="string">&quot;\\.&quot;</span>);</span><br><span class="line">        <span class="type">long</span> <span class="variable">result</span> <span class="operator">=</span> <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i &lt; <span class="number">4</span>; i++) &#123;</span><br><span class="line">            result |= (Long.parseLong(parts[i]) &lt;&lt; (<span class="number">24</span> - <span class="number">8</span> * i));</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> result;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 将整数转换回IPv4地址</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> String <span class="title function_">intToIp</span><span class="params">(<span class="type">long</span> ipInt)</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> ((ipInt &gt;&gt; <span class="number">24</span>) &amp; <span class="number">0xFF</span>) + <span class="string">&quot;.&quot;</span> +</span><br><span class="line">                ((ipInt &gt;&gt; <span class="number">16</span>) &amp; <span class="number">0xFF</span>) + <span class="string">&quot;.&quot;</span> +</span><br><span class="line">                ((ipInt &gt;&gt; <span class="number">8</span>) &amp; <span class="number">0xFF</span>) + <span class="string">&quot;.&quot;</span> +</span><br><span class="line">                (ipInt &amp; <span class="number">0xFF</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">        <span class="type">Scanner</span> <span class="variable">scanner</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Scanner</span>(System.in);</span><br><span class="line">        <span class="type">int</span> <span class="variable">N</span> <span class="operator">=</span> Integer.parseInt(scanner.nextLine().trim());  <span class="comment">// 读取业务数量</span></span><br><span class="line">        List&lt;<span class="type">long</span>[]&gt; ipRanges = <span class="keyword">new</span> <span class="title class_">ArrayList</span>&lt;&gt;();</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 读取每个业务的起始和结束IP，将其转为整数存储</span></span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i &lt; N; i++) &#123;</span><br><span class="line">            String[] parts = scanner.nextLine().split(<span class="string">&quot; &quot;</span>);</span><br><span class="line">            <span class="type">long</span> <span class="variable">start</span> <span class="operator">=</span> ipToInt(parts[<span class="number">0</span>]);</span><br><span class="line">            <span class="type">long</span> <span class="variable">end</span> <span class="operator">=</span> ipToInt(parts[<span class="number">1</span>]);</span><br><span class="line">            ipRanges.add(<span class="keyword">new</span> <span class="title class_">long</span>[]&#123;start, end&#125;);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 排序规则：</span></span><br><span class="line">        <span class="comment">// 1) 按结束IP升序</span></span><br><span class="line">        <span class="comment">// 2) 若结束IP相同，按区间长度(端点差+1)升序</span></span><br><span class="line">        <span class="comment">// 3) 若长度相同，按起始IP升序</span></span><br><span class="line">        ipRanges.sort((a, b) -&gt; &#123;</span><br><span class="line">            <span class="keyword">if</span> (a[<span class="number">1</span>] != b[<span class="number">1</span>]) &#123;</span><br><span class="line">                <span class="keyword">return</span> Long.compare(a[<span class="number">1</span>], b[<span class="number">1</span>]);</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="type">long</span> <span class="variable">lenA</span> <span class="operator">=</span> a[<span class="number">1</span>] - a[<span class="number">0</span>] + <span class="number">1</span>;</span><br><span class="line">            <span class="type">long</span> <span class="variable">lenB</span> <span class="operator">=</span> b[<span class="number">1</span>] - b[<span class="number">0</span>] + <span class="number">1</span>;</span><br><span class="line">            <span class="keyword">if</span> (lenA != lenB) &#123;</span><br><span class="line">                <span class="keyword">return</span> Long.compare(lenA, lenB);</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">return</span> Long.compare(a[<span class="number">0</span>], b[<span class="number">0</span>]);</span><br><span class="line">        &#125;);</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 贪心选择：选择不重叠、最早结束的区间以最大化业务数量</span></span><br><span class="line">        List&lt;<span class="type">long</span>[]&gt; result = <span class="keyword">new</span> <span class="title class_">ArrayList</span>&lt;&gt;();</span><br><span class="line">        <span class="type">long</span> <span class="variable">lastEnd</span> <span class="operator">=</span> -<span class="number">1</span>;</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">long</span>[] range : ipRanges) &#123;</span><br><span class="line">            <span class="keyword">if</span> (range[<span class="number">0</span>] &gt; lastEnd) &#123;</span><br><span class="line">                result.add(range);</span><br><span class="line">                lastEnd = range[<span class="number">1</span>];</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 输出最终规划的IP区间</span></span><br><span class="line">        <span class="keyword">for</span> (<span class="type">long</span>[] r : result) &#123;</span><br><span class="line">            System.out.println(intToIp(r[<span class="number">0</span>]) + <span class="string">&quot; &quot;</span> + intToIp(r[<span class="number">1</span>]));</span><br><span class="line">        &#125;</span><br><span class="line">        scanner.close();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure><p>主要改动了以下几处：</p><ol><li><p><strong>IP 转换方法优化</strong></p><ul><li><p>原来在 <code>ipToInt</code> 和 <code>intToIp</code> 中使用了 <code>Math.pow</code>，返回 <code>double</code> 再转 <code>long</code>，存在精度隐患。</p></li><li><p>要改成了位移运算：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">result |= (Long.parseLong(parts[i]) &lt;&lt; (<span class="number">24</span> - <span class="number">8</span> * i));</span><br></pre></td></tr></table></figure><p>和</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">((ipInt &gt;&gt; <span class="number">24</span>) &amp; <span class="number">0xFF</span>)</span><br></pre></td></tr></table></figure><p>这样既更高效，也完全精确。</p></li></ul></li><li><p><strong>排序规则</strong></p><ul><li>原先只按“区间长度（len）”和“起始 IP”排序，忽略了“结束 IP”对贪心选择的影响。</li><li>新版改为三层优先级：</li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 1) 按结束 IP 升序  </span></span><br><span class="line"><span class="comment">// 2) 若结束 IP 相同，再按区间长度升序  </span></span><br><span class="line"><span class="comment">// 3) 若长度相同，再按起始 IP 升序</span></span><br></pre></td></tr></table></figure><p>这样能保证贪心算法每次都选最早结束、最小占用的区间，以满足“最多业务数”、“最少地址量”和“起始最小”三重要求。</p></li></ol><p>这些改动确保了：</p><ul><li>IP 转换无精度误差</li><li>排序严格符合题意的三重比较</li><li>贪心算法能真正输出示例中预期的两个区间。</li></ul><p>反思：没有考虑数据精度对结果的影响。只是运气好过了0.55</p><h2 id="总结："><a href="#总结：" class="headerlink" title="总结："></a>总结：</h2><p>这次算法做的不太好，主要有以下这个原因：</p><ul><li>​    1.不敢用IDE写，用记事本导致写的优点磕磕绊绊</li><li>​    2.第一题没做出来影响了心态，然后做第二题脑袋一团浆糊。</li><li>​    3.做这场笔试之前，刷了很多次华为笔试真题。自己平时做感觉没问题，在考场上做却错漏百出，只能说平时和考场还是不一样。</li><li>​    4.太想进华为，导致做笔试压力很大。心情不平和影响了自己的思路。</li></ul><p>总而言之，继续多刷算法，继续加油！</p>]]></content>
    
    
    <summary type="html">🥧华为416批次笔试</summary>
    
    
    
    <category term="刷题" scheme="https://outoflovenicoo.github.io/categories/%E5%88%B7%E9%A2%98/"/>
    
    
    <category term="笔试" scheme="https://outoflovenicoo.github.io/tags/%E7%AC%94%E8%AF%95/"/>
    
  </entry>
  
  <entry>
    <title>Java集合学习</title>
    <link href="https://outoflovenicoo.github.io/posts/2025-04-17-Java%E9%9B%86%E5%90%88%E5%AD%A6%E4%B9%A0.html"/>
    <id>https://outoflovenicoo.github.io/posts/2025-04-17-Java%E9%9B%86%E5%90%88%E5%AD%A6%E4%B9%A0.html</id>
    <published>2025-04-17T10:19:03.000Z</published>
    <updated>2025-04-17T14:00:00.000Z</updated>
    
    <content type="html"><![CDATA[<h1 id="Java集合学习"><a href="#Java集合学习" class="headerlink" title="Java集合学习"></a>Java集合学习</h1><h2 id="个人总结思维导图："><a href="#个人总结思维导图：" class="headerlink" title="个人总结思维导图："></a>个人总结思维导图：</h2><p><img src="2025-04-17-Java集合学习/image-20250419111601404.png" alt="image-20250419111601404"></p><p>​    在面试的过程中，被问到了一些基础问题，Java的集合框架。当时回答的优点不太好，很多概念都有点模糊，根本原因是没有自己总结过，所以现在特地总结一下，当然这个总结可能还不完善，后续会不断迭代优化。</p><h2 id="单列集合部分"><a href="#单列集合部分" class="headerlink" title="单列集合部分"></a>单列集合部分</h2><h3 id="ArrayList"><a href="#ArrayList" class="headerlink" title="ArrayList"></a>ArrayList</h3><p>​    ArrayList是<code>List</code>接口的一个实现类。它的默认初始容量为0，当首次添加元素时，其容量会扩充到10。这种动态扩容的机制使得ArrayList在存储元素时具有一定的灵活性，适合元素数量不确定的场景。</p><h3 id="HashSet"><a href="#HashSet" class="headerlink" title="HashSet"></a>HashSet</h3><p>​    HashSet是<code>Set</code>接口的实现类，其实现原理基于哈希值。当向HashSet中加入对象时，会先计算对象的<code>hashcode</code>值来判断对象加入的位置，同时也会与其他已加入对象的<code>hashcode</code>值作比较。如果没有相同的<code>hashcode</code>值，HashSet会假设对象没有重复出现；但如果发现有相同<code>hashcode</code>值的对象，这时会调用<code>equals()</code>方法来检查对象是否真的相同，若两者相同，HashSet就不会让加入操作成功，以此保证集合中元素的唯一性。</p><h3 id="Queue与Deque"><a href="#Queue与Deque" class="headerlink" title="Queue与Deque"></a>Queue与Deque</h3><p>​    <code>Queue</code>（队列）接口有多种实现，比如<code>PriorityQueue</code>（优先队列）和<code>BlockingQueue</code>（阻塞队列，其下又细分<code>ArrayBlockingQueue</code>、<code>LinkedBlockingQueue</code>等）。<code>Deque</code>（双端队列）接口也有对应的实现类，如<code>ArrayDeque</code>（每次扩容为原来的2倍+1）和<code>LinkedList</code>，这些实现类为不同的队列操作需求提供了支持。</p><h3 id="Stack"><a href="#Stack" class="headerlink" title="Stack"></a>Stack</h3><p><code>Stack</code>（栈）不推荐使用，主要有两个原因。一是其线程安全机制低效且冗余，在多线程环境下性能不佳；二是它有着不合理的继承关系，<code>Stack</code>继承自<code>Vector</code>，而<code>Vector</code>本质上是一个基于数组的动态数组，是“可增长的对象数组”，并非专门为栈（LIFO，后进先出）设计的数据结构，这种设计上的不合理导致<code>Stack</code>在实际应用中存在诸多问题。</p><h2 id="双列集合部分"><a href="#双列集合部分" class="headerlink" title="双列集合部分"></a>双列集合部分</h2><h3 id="HashMap详解"><a href="#HashMap详解" class="headerlink" title="HashMap详解"></a>HashMap详解</h3><h4 id="实现原理"><a href="#实现原理" class="headerlink" title="实现原理"></a>实现原理</h4><p>​    HashMap的工作原理基于哈希表。它通过计算键的哈希值，并将其转化为数组索引，从而快速定位键值对的存储位置。在理想情况下，哈希函数能将键均匀分布到哈希表中，以最小化哈希冲突。在Java 1.7中，HashMap主要使用链表来解决哈希冲突，将具有相同哈希值的键值对链接在一起；但在Java 1.8中，为了进一步提高性能，当链表长度和数组长度超过一定阈值时，链表会转换为红黑树。红黑树作为一种自平衡的二叉搜索树，能够在哈希冲突较多时提供更快的查找、插入和删除操作功能。这样，HashMap结合哈希表、链表和红黑树的原理，实现了高效的键值对存储和查找功能。</p><h4 id="扩容机制"><a href="#扩容机制" class="headerlink" title="扩容机制"></a>扩容机制</h4><p>​    HashMap的扩容触发条件有两个：一是元素个数大于负载因子乘以桶大小；二是桶内元素个数大于8且桶的个数小于64时也会触发扩容。扩容时，会重新计算元素的位置，计算方式为<code>(n-1) &amp; hash</code>（<code>n</code>为新的容量），新的位置要么是原来的位置，要么是原来的位置加上旧容量。</p><p>​    需要注意的是，HashMap扩容时，不会对元素对象本身进行复制，而是将元素对象的引用迁移到新的哈希表中，然后根据新的容量重新计算元素在新哈希表中的位置。</p><h3 id="ConcurrentHashMap在JDK8中的实现"><a href="#ConcurrentHashMap在JDK8中的实现" class="headerlink" title="ConcurrentHashMap在JDK8中的实现"></a>ConcurrentHashMap在JDK8中的实现</h3><h4 id="put方法安全机制"><a href="#put方法安全机制" class="headerlink" title="put方法安全机制"></a>put方法安全机制</h4><p>​    在JDK8中，ConcurrentHashMap采用了分段锁，同时使用CAS（Compare and Swap，比较并交换）和<code>synchronized</code>来保证线程安全。其<code>put</code>方法的安全保证步骤如下：首先计算哈希值；接着判断数组是否初始化；然后根据哈希值定位到对应的桶位置；再判断桶是否为空，若为空则使用CAS操作尝试将新节点插入到该位置，若CAS操作成功，插入完成，若失败，说明有其他线程已经插入了节点，继续后续步骤；之后检查桶头节点的哈希值是否为<code>MOVED</code>（表示该桶正在进行扩容迁移），若是则协助进行扩容；最后加锁插入或更新，对桶的头节点使用<code>synchronized</code>关键字加锁，然后遍历链表或红黑树，若找到相同的键，更新其值，若未找到，将新节点插入到链表尾部（链表长度小于8）或插入到红黑树中（链表长度大于等于8且数组长度大于等于64），若插入后链表长度达到8且数组长度小于64，进行数组扩容；若数组长度大于等于64，将链表转换为红黑树。</p><h4 id="扩容机制-1"><a href="#扩容机制-1" class="headerlink" title="扩容机制"></a>扩容机制</h4><p>​    ConcurrentHashMap的扩容机制较为复杂。初始化迁移任务时，当一个线程发现需要扩容时，会先创建一个新的数组，其容量是原数组的两倍，同时，会将<code>sizeCtl</code>设置为一个负数，表示正在进行扩容操作，并记录参与扩容的线程数。多线程协助迁移时，ConcurrentHashMap支持多线程协助进行扩容操作，每个线程会领取一个或多个桶的迁移任务，将原数组中对应桶的节点迁移到新数组中，在迁移过程中，使用<code>ForwardingNode</code>节点标记原数组中已经迁移完成的桶，其他线程在访问这些桶时，会自动跳转到新数组中继续操作。链表迁移时，对于链表节点，会根据节点的哈希值重新计算在新数组中的位置，将链表拆分成两个链表，分别放入新数组的不同位置。红黑树迁移时，对于红黑树节点，同样会根据哈希值重新计算位置，可能会将红黑树拆分成两个链表或红黑树，再放入新数组中。当所有的迁移任务都完成后，将新数组替换原数组，扩容操作结束，同时，将<code>sizeCtl</code>更新为新的阈值。</p><h3 id="HashMap与HashTable的区别"><a href="#HashMap与HashTable的区别" class="headerlink" title="HashMap与HashTable的区别"></a>HashMap与HashTable的区别</h3><h4 id="线程安全"><a href="#线程安全" class="headerlink" title="线程安全"></a>线程安全</h4><p>​    HashTable是线程安全的，它的<code>put</code>、<code>get</code>等方法都使用<code>synchronized</code>关键字进行同步控制；而HashMap是非线程安全的，在多线程环境下如果不进行额外的同步控制，可能会出现数据不一致等问题。</p><h4 id="对null键值的支持"><a href="#对null键值的支持" class="headerlink" title="对null键值的支持"></a>对null键值的支持</h4><p>​    HashMap允许键和值为<code>null</code>，但是只能有一个<code>null</code>键，值可以有多个<code>null</code>；而HashTable不允许键或值为<code>null</code>，若尝试将<code>null</code>键或值放入HashTable中，会抛出<code>NullPointerException</code>。</p><h4 id="初始容量与扩容"><a href="#初始容量与扩容" class="headerlink" title="初始容量与扩容"></a>初始容量与扩容</h4><p>​    HashMap的初始容量为16（默认情况下），负载因子为0.75；HashTable的初始容量为11，负载因子同样为0.75。在扩容方面，HashMap扩容时新容量是原容量的2倍；HashTable扩容时新容量是原容量的2倍+1。</p><h4 id="哈希值计算"><a href="#哈希值计算" class="headerlink" title="哈希值计算"></a>哈希值计算</h4><p>​    HashMap在计算哈希值时，对哈希值进行了高位运算，以优化哈希值在数组中的分布，减少哈希冲突；而HashTable直接使用键的<code>hashCode()</code>方法返回的值作为哈希值，没有进行额外的处理。</p><p>总之，Java集合框架中的这些知识点在实际开发中非常重要，理解它们的实现原理和特性，能够帮助我们更合理地选择和使用集合类，写出高效、稳定的代码。 </p><h2 id="参考博客"><a href="#参考博客" class="headerlink" title="参考博客"></a>参考博客</h2><p><a href="https://javabetter.cn/collection/hashmap.html#_05%E3%80%81%E5%B0%8F%E7%BB%93">HashMap详解</a></p><p><a href="https://javaguide.cn/java/collection/hashmap-source-code.html">HashMap源码</a></p>]]></content>
    
    
    <summary type="html">🥧Java集合学习</summary>
    
    
    
    <category term="学习" scheme="https://outoflovenicoo.github.io/categories/%E5%AD%A6%E4%B9%A0/"/>
    
    
    <category term="思维导图" scheme="https://outoflovenicoo.github.io/tags/%E6%80%9D%E7%BB%B4%E5%AF%BC%E5%9B%BE/"/>
    
  </entry>
  
  <entry>
    <title>深入探讨多线程操作数组背后的CPU伪共享与MESI协议</title>
    <link href="https://outoflovenicoo.github.io/posts/2025-04-01-%E6%B7%B1%E5%85%A5%E6%8E%A2%E8%AE%A8%E5%A4%9A%E7%BA%BF%E7%A8%8B%E6%93%8D%E4%BD%9C%E6%95%B0%E7%BB%84%E8%83%8C%E5%90%8E%E7%9A%84CPU%E4%BC%AA%E5%85%B1%E4%BA%AB%E4%B8%8EMESI%E5%8D%8F%E8%AE%AE.html"/>
    <id>https://outoflovenicoo.github.io/posts/2025-04-01-%E6%B7%B1%E5%85%A5%E6%8E%A2%E8%AE%A8%E5%A4%9A%E7%BA%BF%E7%A8%8B%E6%93%8D%E4%BD%9C%E6%95%B0%E7%BB%84%E8%83%8C%E5%90%8E%E7%9A%84CPU%E4%BC%AA%E5%85%B1%E4%BA%AB%E4%B8%8EMESI%E5%8D%8F%E8%AE%AE.html</id>
    <published>2025-04-01T10:19:03.000Z</published>
    <updated>2025-04-12T14:00:00.000Z</updated>
    
    <content type="html"><![CDATA[<h2 id="思维导图：">思维导图：</h2><p><img src="2025-04-01-%E6%B7%B1%E5%85%A5%E6%8E%A2%E8%AE%A8%E5%A4%9A%E7%BA%BF%E7%A8%8B%E6%93%8D%E4%BD%9C%E6%95%B0%E7%BB%84%E8%83%8C%E5%90%8E%E7%9A%84CPU%E4%BC%AA%E5%85%B1%E4%BA%AB%E4%B8%8EMESI%E5%8D%8F%E8%AE%AE/diagram.png" alt=""></p><h2 id="前言：">前言：</h2><p>这是一道腾讯的面试题，通过这个问题我理解了CPU缓存的一致性怎么保障的，具体场景如下：</p><p>当我们面对这样一个场景：n个线程去操纵数组的n个元素，编号为i的线程只会操作下标为i的数组元素 <code>arr[i]++</code>，看似每个线程各司其职，互不干扰，然而实际运行中却可能出现性能问题。这背后涉及CPU缓存结构、伪共享问题、MESI协议以及CPU Cache数据的写入方式，下面我们逐步分析。</p><h2 id="一、CPU缓存结构：L1、L2、L3">一、CPU缓存结构：L1、L2、L3</h2><p>在现代多核CPU架构中，缓存系统分为多个层级：</p><ul><li><p><strong>L1缓存</strong>：每个CPU核心都有独立的L1缓存，且进一步细分为L1数据缓存（存放数据）和L1指令缓存（存放指令）。它的速度最快，但容量最小，通常只有几十KB。例如，在一些CPU中，L1数据缓存和指令缓存可能各为32KB。</p></li><li><p><strong>L2缓存</strong>：同样每个核心独立拥有，容量比L1大，速度稍慢于L1。一般为几百KB到几MB不等，例如某些CPU的L2缓存可能是256KB或512KB。它的作用是在L1未命中时，为核心提供数据和指令。</p></li><li><p><strong>L3缓存</strong>：通常为多个核心共享，容量更大，速度相对L1、L2更慢。L3缓存可以达到几MB甚至几十MB，例如一些高端CPU的L3缓存可能为12MB或更高。它作为更大范围的缓存池，减少核心对内存的直接访问。</p></li></ul><p>数据在内存与缓存之间以 **Cache Line**（缓存行，通常为64字节）为单位传输。当CPU读取数据时，会将包含目标数据的整个Cache Line读入缓存。</p><h2 id="二、CPU-Cache数据的写入方式">二、CPU Cache数据的写入方式</h2><h3 id="写直达（Write-Through）">写直达（Write - Through）</h3><p>写直达是指CPU在写入数据到Cache时，会同时将数据写入内存。具体流程为：当CPU执行写入数据操作时，先检查数据是否在CPU Cache中。如果在，直接将数据写入Cache Block；如果不在，则先将数据写入内存，再完成操作。这种方式的优点是能保证内存和Cache中的数据始终一致，但每次写入都需要访问内存，会增加内存总线的流量，降低写入效率。在多线程伪共享场景中，写直达会频繁触发内存写入操作，引发更多的总线事务，导致其他核心更频繁地感知到Cache Line的变化，加剧伪共享带来的性能损耗。</p><h3 id="写回（Write-Back）">写回（Write - Back）</h3><p>写回策略下，CPU先将数据写入Cache Block，并标记该Cache Block为“脏”（已修改）。当Cache Block需要被替换（例如新的数据要存入，而Cache已满）时，才将脏数据写回内存。具体流程为：CPU将数据写入Cache Block后，检查数据是否在其他CPU Cache中。如果不在，直接标记Cache Block为脏；如果在，则需要先使其他核心中相同的Cache Line失效（通过MESI协议），然后标记当前Cache Block为脏。写回方式减少了内存写入次数，提升了写入效率，但存在数据不一致的风险（在数据写回内存前，内存中的数据是旧的）。在伪共享场景中，写回虽然减少了内存写入，但一个核心对Cache Block的修改（标记为脏）会通过MESI协议使其他核心的相同Cache Line失效，当其他核心后续操作同属一个Cache Line的元素时，需要重新读取数据，这一过程依然会产生缓存状态切换和数据同步开销。</p><h2 id="三、伪共享问题：隐藏的性能杀手">三、伪共享问题：隐藏的性能杀手</h2><h3 id="伪共享的定义与成因">伪共享的定义与成因</h3><p>伪共享指多个线程操作不同变量，但这些变量因存储在同一个Cache Line中，导致彼此的操作互相影响。例如，在上述多线程操作数组的场景中，假设数组在内存中连续存储，一个Cache Line（64字节）可以存放16个 <code>int</code> 类型的数组元素（每个 <code>int</code> 占4字节）。若线程A操作 <code>arr[i]</code>，线程B操作 <code>arr[j]</code>（<code>i</code> 与 <code>j</code> 对应的元素在同一个Cache Line），尽管逻辑上两者无直接关联，但硬件层面的缓存机制会让它们产生交互。</p><h3 id="伪共享如何影响性能">伪共享如何影响性能</h3><p>当一个线程修改Cache Line中的数据（如 <code>arr[i]++</code>），根据MESI协议，该Cache Line状态会变为“已修改”（写回策略）或触发内存写入（写直达策略），其他核心中相同的Cache Line会被标记为“已失效”。若其他线程此时要操作同属一个Cache Line的其他元素，需重新从内存或其他核心获取数据，这一过程涉及缓存状态的频繁切换（如从“共享”到“已失效”再到重新加载）、数据同步以及总线通信开销。即使这些线程操作的是不同变量，也会因伪共享导致大量不必要的缓存同步操作，严重影响程序性能。</p><h2 id="四、MESI协议：缓存一致性的保障">四、MESI协议：缓存一致性的保障</h2><p>MESI协议定义了Cache Line的四种状态，用于保证多核CPU缓存一致性：</p><ul><li><p><strong>独占（Exclusive）</strong>：该Cache Line只在当前核心缓存中，且数据与内存一致。此时其他核心没有该Cache Line的副本。</p></li><li><p><strong>共享（Shared）</strong>：多个核心缓存中都有该Cache Line，且数据与内存一致。多个核心可以同时读取该Cache Line中的数据。</p></li><li><p><strong>已修改（Modified）</strong>：该Cache Line在当前核心缓存中被修改，与内存不一致。其他核心若要读取该数据，需先从当前核心获取最新数据，当前核心会在适当时候将数据写回内存。</p></li><li><p><strong>已失效（Invalidated）</strong>：该Cache Line在当前核心缓存中失效，需从内存或其他核心重新获取数据。</p></li></ul><p>在伪共享场景中，一个核心对Cache Line的修改会触发MESI协议的状态变更，导致其他核心的相同Cache Line失效，进而引发一系列数据同步操作，这就是伪共享影响性能的底层机制。</p><h2 id="五、解决伪共享：让缓存行“各司其职”">五、解决伪共享：让缓存行“各司其职”</h2><p>最直接的解决方式是通过字节填充，确保每个数组元素或相关变量单独占据一个Cache Line。在Java中，可以使用 <code>@Contended</code> 注解（需开启JVM参数 <code>-XX:-RestrictContended</code>）来实现。例如：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> sun.misc.Contended;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">ArrayExample</span> &#123;</span><br><span class="line">    <span class="meta">@Contended</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">volatile</span> <span class="type">long</span>[] arr;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="title function_">ArrayExample</span><span class="params">(<span class="type">int</span> size)</span> &#123;</span><br><span class="line">        arr = <span class="keyword">new</span> <span class="title class_">long</span>[size];</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">increment</span><span class="params">(<span class="type">int</span> i)</span> &#123;</span><br><span class="line">        arr[i]++;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>或者手动添加填充字段：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">PaddedLong</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">volatile</span> <span class="type">long</span> value;</span><br><span class="line">    <span class="comment">// 填充7个long类型字段，共56字节，加上value本身8字节，刚好占满一个64字节的Cache Line</span></span><br><span class="line">    <span class="keyword">private</span> <span class="type">long</span> p1, p2, p3, p4, p5, p6, p7; </span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">ArrayExample</span> &#123;</span><br><span class="line">    <span class="keyword">private</span> PaddedLong[] arr;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="title function_">ArrayExample</span><span class="params">(<span class="type">int</span> size)</span> &#123;</span><br><span class="line">        arr = <span class="keyword">new</span> <span class="title class_">PaddedLong</span>[size];</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i &lt; size; i++) &#123;</span><br><span class="line">            arr[i] = <span class="keyword">new</span> <span class="title class_">PaddedLong</span>();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">increment</span><span class="params">(<span class="type">int</span> i)</span> &#123;</span><br><span class="line">        arr[i].value++;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>通过上述方式，每个元素或包含元素的对象能独立占据Cache Line，避免因伪共享导致的性能损耗。</p><p>总结来看，多线程操作数组元素时，看似简单的逻辑在底层硬件（CPU缓存结构、Cache数据写入方式）与缓存协议（MESI协议）的影响下可能产生性能问题。其实在实际开发中，我们很少会多线程去操作一个数组，不过这个问题让我对CPU缓存一致性有了更深的理解，很有意义。</p><h2 id="参考博客：">参考博客：</h2><p><a href="https://xiaolincoding.com/os/1_hardware/cpu_mesi.html#cpu-cache-%E7%9A%84%E6%95%B0%E6%8D%AE%E5%86%99%E5%85%A5">2.4 CPU 缓存一致性</a></p><p><a href="https://mp.weixin.qq.com/s/PDUqwAIaUxNkbjvRfovaCg">十张图介绍MESI</a></p>]]></content>
    
    
    <summary type="html">🥧深入探讨多线程操作数组背后的CPU伪共享与MESI协议</summary>
    
    
    
    <category term="学习" scheme="https://outoflovenicoo.github.io/categories/%E5%AD%A6%E4%B9%A0/"/>
    
    
    <category term="思维导图" scheme="https://outoflovenicoo.github.io/tags/%E6%80%9D%E7%BB%B4%E5%AF%BC%E5%9B%BE/"/>
    
  </entry>
  
  <entry>
    <title>根据字符串数组构建一颗二叉树</title>
    <link href="https://outoflovenicoo.github.io/posts/2025-03-25-%E6%A0%B9%E6%8D%AE%E5%AD%97%E7%AC%A6%E4%B8%B2%E6%95%B0%E7%BB%84%E6%9E%84%E5%BB%BA%E4%B8%80%E9%A2%97%E4%BA%8C%E5%8F%89%E6%A0%91.html"/>
    <id>https://outoflovenicoo.github.io/posts/2025-03-25-%E6%A0%B9%E6%8D%AE%E5%AD%97%E7%AC%A6%E4%B8%B2%E6%95%B0%E7%BB%84%E6%9E%84%E5%BB%BA%E4%B8%80%E9%A2%97%E4%BA%8C%E5%8F%89%E6%A0%91.html</id>
    <published>2025-03-25T07:19:03.000Z</published>
    <updated>2025-03-25T14:00:00.000Z</updated>
    
    <content type="html"><![CDATA[<p><strong>在面试手撕的时候，经常需要根据输入的字符串构建一颗树，由于第一次做，磕磕绊绊才写出来，这里记录一下吧</strong></p><h3 id="样例"><a href="#样例" class="headerlink" title="样例"></a>样例</h3><p>根据字符串 <code>[1,2,3,null,4,null,5]</code> 构建二叉树时，需按照 <strong>层序遍历顺序</strong> 解析节点值，其中 <code>null</code> 表示空节点。以下是构建过程和结果：</p><h3 id="构建规则"><a href="#构建规则" class="headerlink" title="构建规则"></a><strong>构建规则</strong></h3><ol><li><strong>根节点</strong>：字符串中第一个非 <code>null</code> 的值（此处为 <code>1</code>）。</li><li><strong>层序填充</strong>：从根节点开始，按 <strong>左子节点 → 右子节点</strong> 的顺序依次填充后续节点：<ol><li>若当前节点为 <code>null</code>，则跳过其左右子节点。</li><li>空值（<code>null</code>）仅表示节点不存在，不参与树结构。</li></ol></li></ol><h3 id="详细构建步骤"><a href="#详细构建步骤" class="headerlink" title="详细构建步骤"></a><strong>详细构建步骤</strong></h3><h4 id="第-1-层（根节点）"><a href="#第-1-层（根节点）" class="headerlink" title="第 1 层（根节点）"></a><strong>第 1 层（根节点）</strong></h4><ul><li>节点值：<code>1</code>根节点为 <code>1</code>，对应位置 <code>i=0</code>。</li></ul><h4 id="第-2-层（根节点的左右子节点）"><a href="#第-2-层（根节点的左右子节点）" class="headerlink" title="第 2 层（根节点的左右子节点）"></a><strong>第 2 层（根节点的左右子节点）</strong></h4><ul><li>左子节点：位置 <code>i=1</code>，值为 <code>2</code>，非空，作为 <code>1</code> 的左子节点。 </li><li>右子节点：位置 <code>i=2</code>，值为 <code>3</code>，非空，作为 <code>1</code> 的右子节点。 </li></ul><h4 id="第-3-层（第-2-层节点的左右子节点）"><a href="#第-3-层（第-2-层节点的左右子节点）" class="headerlink" title="第 3 层（第 2 层节点的左右子节点）"></a><strong>第 3 层（第 2 层节点的左右子节点）</strong></h4><ul><li><strong>节点</strong> <strong><code>2</code></strong>的子节点： <ul><li>左子节点：位置 <code>i=3</code>，值为 <code>null</code>，跳过。 </li><li>右子节点：位置 <code>i=4</code>，值为 <code>4</code>，非空，作为 <code>2</code> 的右子节点。 </li></ul></li><li><strong>节点</strong> <strong><code>3</code></strong> 的子节点： <ul><li>左子节点：位置 <code>i=5</code>，值为 <code>null</code>，跳过。 </li><li>右子节点：位置 <code>i=6</code>，值为 <code>5</code>，非空，作为 <code>3</code> 的右子节点。 </li></ul></li></ul><h4 id="后续节点"><a href="#后续节点" class="headerlink" title="后续节点"></a><strong>后续节点</strong></h4><p>字符串中剩余内容（末尾逗号）可忽略，无有效节点。</p><h3 id="最终二叉-树结构"><a href="#最终二叉-树结构" class="headerlink" title="最终二叉**树结构**"></a><strong>最终二叉**</strong>树结构**</h3><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">  1</span><br><span class="line"> / \</span><br><span class="line">2   3</span><br><span class="line"> \   \</span><br><span class="line">  4   5</span><br></pre></td></tr></table></figure><ul><li><strong>根节点</strong>：<code>1</code></li><li><strong>左子树</strong>：以 <code>2</code> 为根，其右子节点为 <code>4</code>。 </li><li><strong>右子树</strong>：以 <code>3</code> 为根，其右子节点为 <code>5</code>。 </li></ul><h3 id="验证层序遍历"><a href="#验证层序遍历" class="headerlink" title="验证层序遍历"></a><strong>验证层序遍历</strong></h3><p>构建后的二叉树层序遍历结果与输入字符串一致（忽略 <code>null</code> 后的有效节点）： </p><p><code>[1, 2, 3, 4, 5]</code>，符合预期。</p><h3 id="代码："><a href="#代码：" class="headerlink" title="代码："></a>代码：</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> java.util.LinkedList;</span><br><span class="line"><span class="keyword">import</span> java.util.Queue;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 定义二叉树节点类</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">TreeNode</span> &#123;</span><br><span class="line">    <span class="type">int</span> val;</span><br><span class="line">    TreeNode left;</span><br><span class="line">    TreeNode right;</span><br><span class="line">    TreeNode(<span class="type">int</span> x) &#123; val = x; &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">BuildBinaryTree</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> TreeNode <span class="title function_">buildTree</span><span class="params">(String str)</span> &#123;</span><br><span class="line">        <span class="comment">// 去除首尾的方括号</span></span><br><span class="line">        str = str.substring(<span class="number">1</span>, str.length() - <span class="number">1</span>);</span><br><span class="line">        <span class="keyword">if</span> (str.isEmpty()) &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">null</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        String[] values = str.split(<span class="string">&quot;,&quot;</span>);</span><br><span class="line">        <span class="type">TreeNode</span> <span class="variable">root</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">TreeNode</span>(Integer.parseInt(values[<span class="number">0</span>]));</span><br><span class="line">        Queue&lt;TreeNode&gt; queue = <span class="keyword">new</span> <span class="title class_">LinkedList</span>&lt;&gt;();</span><br><span class="line">        queue.offer(root);</span><br><span class="line">        <span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">1</span>;</span><br><span class="line">        <span class="keyword">while</span> (!queue.isEmpty() &amp;&amp; i &lt; values.length) &#123;</span><br><span class="line">            <span class="type">TreeNode</span> <span class="variable">node</span> <span class="operator">=</span> queue.poll();</span><br><span class="line">            <span class="keyword">if</span> (!values[i].equals(<span class="string">&quot;null&quot;</span>)) &#123;</span><br><span class="line">                node.left = <span class="keyword">new</span> <span class="title class_">TreeNode</span>(Integer.parseInt(values[i]));</span><br><span class="line">                queue.offer(node.left);</span><br><span class="line">            &#125;</span><br><span class="line">            i++;</span><br><span class="line">            <span class="keyword">if</span> (i &lt; values.length &amp;&amp; !values[i].equals(<span class="string">&quot;null&quot;</span>)) &#123;</span><br><span class="line">                node.right = <span class="keyword">new</span> <span class="title class_">TreeNode</span>(Integer.parseInt(values[i]));</span><br><span class="line">                queue.offer(node.right);</span><br><span class="line">            &#125;</span><br><span class="line">            i++;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> root;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">        <span class="type">String</span> <span class="variable">input</span> <span class="operator">=</span> <span class="string">&quot;[1,2,3,null,4,null,5]&quot;</span>;</span><br><span class="line">        <span class="type">TreeNode</span> <span class="variable">root</span> <span class="operator">=</span> buildTree(input);</span><br><span class="line">        <span class="comment">// 这里可以添加遍历二叉树的代码来验证结果</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;    </span><br></pre></td></tr></table></figure>]]></content>
    
    
    <summary type="html">🥧根据字符串数组构建一颗二叉树</summary>
    
    
    
    <category term="刷题" scheme="https://outoflovenicoo.github.io/categories/%E5%88%B7%E9%A2%98/"/>
    
    
    <category term="手撕" scheme="https://outoflovenicoo.github.io/tags/%E6%89%8B%E6%92%95/"/>
    
  </entry>
  
  <entry>
    <title>Guava的eventBus的原理</title>
    <link href="https://outoflovenicoo.github.io/posts/2025-03-20-Guava%E7%9A%84eventBus%E7%9A%84%E5%8E%9F%E7%90%86.html"/>
    <id>https://outoflovenicoo.github.io/posts/2025-03-20-Guava%E7%9A%84eventBus%E7%9A%84%E5%8E%9F%E7%90%86.html</id>
    <published>2025-03-20T10:19:03.000Z</published>
    <updated>2025-03-20T14:00:00.000Z</updated>
    
    <content type="html"><![CDATA[<h1>Guava的eventBus的原理</h1><p><img src="2025-03-20-Guava%E7%9A%84eventBus%E7%9A%84%E5%8E%9F%E7%90%86/diagram.png" alt=""></p><p>在Java应用开发中，同一JVM内的事件通知场景普遍存在。相较于分布式消息队列（MQ），Guava提供的EventBus框架以轻量、便捷的特点成为首选。本文将从架构设计、运行机制、使用场景及注意事项等方面，深入解析EventBus的核心原理。</p><h2 id="一、EventBus的架构组成">一、EventBus的架构组成</h2><p>EventBus由以下核心模块构成：</p><ol><li><p><strong>事件发送器</strong>  </p><ul><li><p><strong>EventBus</strong>：同步事件发送器，默认使用<code>DirectExecutor</code>直接在当前线程执行事件处理逻辑。  </p></li><li><p><strong>AsyncEventBus</strong>：异步事件发送器，需传入自定义线程池（如<code>ThreadPoolExecutor</code>），通过线程池实现异步调度。  </p></li></ul></li><li><p><strong>事件载体（Event）</strong>事件是通知的最小单元，可定义任意类型的POJO作为事件（如<code>LoginEvent</code>、<code>RegisterEvent</code>）。  </p></li><li><p><strong>订阅者注册器（SubscriberRegistry）</strong>负责管理订阅者与事件的映射关系，通过反射扫描订阅者类中被<code>@Subscribe</code>注解标记的方法，并将其与事件类型绑定到<code>Multimap&lt;Class&lt;?&gt;, Subscriber&gt;</code>集合中。  </p></li><li><p><strong>事件分发器（Dispatcher）</strong>  </p><ul><li><p><strong>PerThreadQueuedDispatcher</strong>（EventBus默认）：基于线程本地队列（<code>ThreadLocal&lt;Queue&lt;Event&gt;&gt;</code>）实现同步分发，按顺序处理事件。  </p></li><li><p><strong>LegacyAsyncDispatcher</strong>（AsyncEventBus默认）：通过线程池异步执行事件处理逻辑。  </p></li></ul></li><li><p><strong>订阅者（Subscriber）</strong>  </p><ul><li><p><strong>Subscriber</strong>：无同步修饰的订阅者，适用于线程安全的事件处理方法（需通过<code>@AllowConcurrentEvents</code>注解声明）。  </p></li><li><p><strong>SynchronizedSubscriber</strong>：自动添加<code>synchronized</code>同步块的订阅者，确保非线程安全方法在并发场景下的串行执行。</p></li></ul></li></ol><h2 id="二、核心运行流程解析">二、核心运行流程解析</h2><h3 id="1-初始化与注册">1. 初始化与注册</h3><ul><li><p><strong>创建EventBus实例</strong>  </p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 同步EventBus</span></span><br><span class="line"><span class="type">EventBus</span> <span class="variable">eventBus</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">EventBus</span>(); </span><br><span class="line"><span class="comment">// 异步EventBus（需指定线程池）</span></span><br><span class="line"><span class="type">ThreadPoolExecutor</span> <span class="variable">executor</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">ThreadPoolExecutor</span>(<span class="number">5</span>, <span class="number">20</span>, <span class="number">30</span>, TimeUnit.SECONDS, <span class="keyword">new</span> <span class="title class_">LinkedBlockingQueue</span>&lt;&gt;(<span class="number">20</span>));</span><br><span class="line"><span class="type">AsyncEventBus</span> <span class="variable">asyncEventBus</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">AsyncEventBus</span>(executor);</span><br></pre></td></tr></table></figure></li><li><p><strong>注册订阅者</strong>通过<code>eventBus.register(listener)</code>方法将订阅者对象注册到框架中。底层通过反射遍历<code>listener</code>的所有方法，提取被<code>@Subscribe</code>标记的方法，封装为<code>Subscriber</code>对象，并按事件类型存储到<code>SubscriberRegistry</code>的<code>Multimap</code>中。</p></li></ul><h3 id="2-事件发送与处理">2. 事件发送与处理</h3><ul><li><p><strong>事件发布</strong>调用<code>eventBus.post(event)</code>触发事件分发：  </p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">eventBus.post(<span class="keyword">new</span> <span class="title class_">LoginEvent</span>(<span class="string">&quot;user&quot;</span>, <span class="string">&quot;password&quot;</span>));</span><br></pre></td></tr></table></figure></li><li><p><strong>分发逻辑</strong>  </p><ul><li><p><strong>同步模式（EventBus）</strong>：通过<code>PerThreadQueuedDispatcher</code>将事件存入当前线程的本地队列，按顺序逐个调用订阅者的处理方法，同步阻塞直至所有处理完成。  </p></li><li><p><strong>异步模式（AsyncEventBus）</strong>：通过<code>LegacyAsyncDispatcher</code>将事件处理逻辑提交到线程池，由线程池异步执行，发送线程无需等待结果。  </p></li></ul></li><li><p><strong>死亡事件（DeadEvent）</strong>若事件未被任何订阅者处理，EventBus会自动将其包装为<code>DeadEvent</code>并重新发布，可通过订阅<code>DeadEvent</code>捕获未处理的事件。</p></li></ul><h3 id="3-线程安全与并发控制">3. 线程安全与并发控制</h3><ul><li><p><strong>订阅者方法的线程安全</strong>  </p><ul><li><p>若方法被<code>@AllowConcurrentEvents</code>注解标记，EventBus会创建普通<code>Subscriber</code>，允许并发执行（需自行保证线程安全）。  </p></li><li><p>未标记注解的方法会被包装为<code>SynchronizedSubscriber</code>，通过<code>synchronized</code>关键字确保同一订阅者实例的方法串行执行，可能成为高并发场景的性能瓶颈。</p></li></ul></li></ul><h2 id="三、典型使用场景与代码示例">三、典型使用场景与代码示例</h2><h3 id="1-配置与初始化">1. 配置与初始化</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Configuration</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">EventBusConfig</span> &#123;</span><br><span class="line">    <span class="meta">@Bean</span></span><br><span class="line">    <span class="keyword">public</span> AsyncEventBus <span class="title function_">asyncEventBus</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="type">ThreadPoolExecutor</span> <span class="variable">executor</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">ThreadPoolExecutor</span>(</span><br><span class="line">            <span class="number">5</span>, <span class="number">20</span>, <span class="number">30</span>, TimeUnit.SECONDS,</span><br><span class="line">            <span class="keyword">new</span> <span class="title class_">LinkedBlockingQueue</span>&lt;&gt;(<span class="number">20</span>),</span><br><span class="line">            <span class="keyword">new</span> <span class="title class_">ThreadPoolExecutor</span>.CallerRunsPolicy() <span class="comment">// 拒绝策略示例</span></span><br><span class="line">        );</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">new</span> <span class="title class_">AsyncEventBus</span>(executor);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="2-订阅者定义">2. 订阅者定义</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Component</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">EventListener</span> &#123;</span><br><span class="line">    <span class="comment">// 同步处理登录事件</span></span><br><span class="line">    <span class="meta">@Subscribe</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">handleLoginEvent</span><span class="params">(LoginEvent event)</span> &#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;Received login event: &quot;</span> + event.getUsername());</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 异步处理注册事件（需AsyncEventBus）</span></span><br><span class="line">    <span class="meta">@Subscribe</span></span><br><span class="line">    <span class="meta">@AllowConcurrentEvents</span> <span class="comment">// 声明线程安全，允许并发处理</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">handleRegisterEvent</span><span class="params">(RegisterEvent event)</span> &#123;</span><br><span class="line">        <span class="comment">// 耗时操作示例</span></span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            Thread.sleep(<span class="number">1000</span>);</span><br><span class="line">        &#125; <span class="keyword">catch</span> (InterruptedException e) &#123;</span><br><span class="line">            Thread.currentThread().interrupt();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="3-事件发送">3. 事件发送</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Service</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">EventPublisher</span> &#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">final</span> EventBus eventBus;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="title function_">EventPublisher</span><span class="params">(EventBus eventBus)</span> &#123;</span><br><span class="line">        <span class="built_in">this</span>.eventBus = eventBus;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">publishLoginEvent</span><span class="params">(String username, String password)</span> &#123;</span><br><span class="line">        eventBus.post(<span class="keyword">new</span> <span class="title class_">LoginEvent</span>(username, password));</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="四、注意事项与性能优化">四、注意事项与性能优化</h2><ul><li><p><strong>线程池配置</strong>  </p><ul><li><p>异步模式下需合理设置线程池参数（如核心线程数、队列容量、拒绝策略），避免任务堆积或线程耗尽。  </p></li><li><p>建议为不同类型的事件分配独立线程池，防止高耗时事件阻塞其他事件处理。  </p></li></ul></li><li><p><strong>反射开销</strong>  </p><ul><li>订阅者注册过程依赖反射，高频率注册/注销场景可能影响性能，建议在系统启动阶段完成所有订阅者注册。  </li></ul></li><li><p><strong>并发控制</strong>  </p><ul><li>非线程安全的订阅者方法（未使用<code>@AllowConcurrentEvents</code>）会被自动同步，高并发时需评估串行执行的性能影响，必要时通过线程安全的数据结构或异步拆分优化。  </li></ul></li><li><p><strong>异常处理</strong>  </p><ul><li>事件处理方法若抛出异常，会被EventBus捕获并记录，但不会中断其他订阅者的执行。建议在方法内部添加try-catch块，避免未预期异常导致系统不稳定。  </li></ul></li></ul><h2 id="五、总结">五、总结</h2><p>Guava EventBus通过简洁的发布-订阅模式，为JVM内的事件通信提供了高效解决方案。理解其架构设计（如同步/异步分发机制、订阅者注册原理）和线程安全策略，能帮助开发者在实际项目中合理选择EventBus或AsyncEventBus，并通过优化线程池配置、减少反射开销等手段提升系统性能。在微服务或复杂业务场景中，结合分布式消息队列（如Kafka、RabbitMQ）与EventBus，可进一步构建层次化的事件驱动架构。</p><h2 id="参考博客：">参考博客：</h2><p><a href="https://cloud.tencent.com/developer/article/1377032">Guava原理深度解析</a></p>]]></content>
    
    
    <summary type="html">🥧Guava的eventBus的原理</summary>
    
    
    
    <category term="学习" scheme="https://outoflovenicoo.github.io/categories/%E5%AD%A6%E4%B9%A0/"/>
    
    
    <category term="原理" scheme="https://outoflovenicoo.github.io/tags/%E5%8E%9F%E7%90%86/"/>
    
  </entry>
  
  <entry>
    <title>CompletableFuture原理及其使用</title>
    <link href="https://outoflovenicoo.github.io/posts/2025-03-19-CompletableFuture%E5%8E%9F%E7%90%86%E5%8F%8A%E5%85%B6%E4%BD%BF%E7%94%A8.html"/>
    <id>https://outoflovenicoo.github.io/posts/2025-03-19-CompletableFuture%E5%8E%9F%E7%90%86%E5%8F%8A%E5%85%B6%E4%BD%BF%E7%94%A8.html</id>
    <published>2025-03-19T10:19:03.000Z</published>
    <updated>2025-03-19T14:00:00.000Z</updated>
    
    <content type="html"><![CDATA[<h1 id="思维导图："><a href="#思维导图：" class="headerlink" title="思维导图："></a>思维导图：</h1><p><img src="2025-03-19-CompletableFuture原理及其使用/diagram-5060644.png" alt=""></p><h1 id="深入理解CompletableFuture原理"><a href="#深入理解CompletableFuture原理" class="headerlink" title="深入理解CompletableFuture原理"></a>深入理解CompletableFuture原理</h1><p><strong>实习的时候用到了<code>CompletableFuture</code>，本着知其然要知其所以然的原则，总结一下<code>CompletableFuture</code>的原理吧。</strong></p><p>在Java的并发编程领域中，我们常常会遇到需要进行异步计算的场景。比如，当我们从数据库获取数据、调用远程服务接口时，如果这些操作在主线程中同步执行，可能会导致主线程阻塞，影响程序的响应性能。这时候，<code>CompletableFuture</code>就派上了大用场，它为我们提供了强大而灵活的异步编程支持。</p><h2 id="一、CompletableFuture实现的接口"><a href="#一、CompletableFuture实现的接口" class="headerlink" title="一、CompletableFuture实现的接口"></a>一、CompletableFuture实现的接口</h2><p><code>CompletableFuture</code>实现了<code>Future</code>和<code>CompletionStage</code>两个接口。<code>Future</code>接口大家相对比较熟悉，它主要用于表示异步计算的结果。我们可以通过它获取异步任务的执行结果、判断任务是否完成以及取消任务等操作。而<code>CompletionStage</code>接口则为异步编程带来了更多的灵活性和可编排性。它表示异步执行过程中的一个步骤（Stage），一个<code>CompletionStage</code>的完成可能会触发其他一系列<code>CompletionStage</code>的执行。我们可以根据实际业务需求，通过<code>CompletionStage</code>提供的<code>thenApply</code>、<code>thenCompose</code>等函数式编程方法，对这些步骤进行多样化的编排组合，从而实现复杂的异步逻辑。</p><h2 id="二、CompletableFuture的依赖关系"><a href="#二、CompletableFuture的依赖关系" class="headerlink" title="二、CompletableFuture的依赖关系"></a>二、CompletableFuture的依赖关系</h2><h3 id="一元依赖"><a href="#一元依赖" class="headerlink" title="一元依赖"></a>一元依赖</h3><p>当我们的任务只依赖于单个<code>CompletableFuture</code>时，就属于一元依赖的情况。在这种情况下，我们可以使用<code>thenApply</code>、<code>thenAccept</code>、<code>thenCompose</code>等方法。例如，<code>thenApply</code>方法接收一个函数作为参数，当依赖的<code>CompletableFuture</code>完成时，会将其结果作为参数传递给这个函数进行处理，并返回一个新的<code>CompletableFuture</code>，这个新的<code>CompletableFuture</code>的结果就是函数处理后的返回值。<code>thenAccept</code>方法则是在依赖的<code>CompletableFuture</code>完成时，接收其结果进行处理，但不返回新的结果。<code>thenCompose</code>方法与<code>thenApply</code>类似，不过它接收的函数返回值是一个<code>CompletableFuture</code>，这样可以方便地将多个异步操作进行链式组合。</p><h3 id="二元依赖"><a href="#二元依赖" class="headerlink" title="二元依赖"></a>二元依赖</h3><p>如果我们的任务依赖于两个<code>CompletableFuture</code>，那么可以使用<code>thenCombine</code>等回调方法来实现。<code>thenCombine</code>方法会等待两个<code>CompletableFuture</code>都完成后，将它们的结果作为参数传递给指定的函数进行处理，最终返回一个新的<code>CompletableFuture</code>，其结果是函数处理后的返回值。这种方式可以让我们在两个异步操作都完成后，对它们的结果进行整合处理。</p><h3 id="多元依赖"><a href="#多元依赖" class="headerlink" title="多元依赖"></a>多元依赖</h3><p>当任务依赖于多个<code>CompletableFuture</code>时，也就是多元依赖的情况。我们可以通过<code>allOf</code>或<code>anyOf</code>方法来实现。<code>allOf</code>方法会等待所有传入的<code>CompletableFuture</code>都完成后才返回，而<code>anyOf</code>方法则是只要有一个传入的<code>CompletableFuture</code>完成就会返回，返回的结果是第一个完成的<code>CompletableFuture</code>的结果。</p><h2 id="三、CompletableFuture的原理"><a href="#三、CompletableFuture的原理" class="headerlink" title="三、CompletableFuture的原理"></a>三、CompletableFuture的原理</h2><h3 id="内部字段"><a href="#内部字段" class="headerlink" title="内部字段"></a>内部字段</h3><p><code>CompletableFuture</code>内部包含两个重要字段：<code>result</code>和<code>stack</code> 。<code>result</code>用于存储异步计算的结果，而<code>stack</code>则在处理依赖关系和通知观察者等过程中发挥着关键作用。</p><h3 id="观察者与被观察者模式"><a href="#观察者与被观察者模式" class="headerlink" title="观察者与被观察者模式"></a>观察者与被观察者模式</h3><p><code>CompletableFuture</code>的工作原理类似于观察者与被观察者模式。例如，当我们调用<code>CompletableFuture.allOf(cf1, cf2, cf3)</code>时，这里的<code>cf1</code>、<code>cf2</code>、<code>cf3</code>就是被观察者，而调用<code>allOf</code>方法返回的<code>CompletableFuture</code>（假设为<code>CF</code> ）就是观察者。在执行过程中，<code>CF</code>会先把自己注册到<code>cf1</code>、<code>cf2</code>、<code>cf3</code>中成为观察者。当<code>cf1</code>执行完成后，它会将自己的结果保存在自身内部，同时根据<code>stack</code>中的信息去提醒观察者。只有当所有被观察者（<code>cf1</code>、<code>cf2</code>、<code>cf3</code> ）都执行完成后，观察者<code>CF</code>才会将最终的结果保存到自己的<code>result</code>字段中。</p><h2 id="四、CompletableFuture中的线程问题"><a href="#四、CompletableFuture中的线程问题" class="headerlink" title="四、CompletableFuture中的线程问题"></a>四、CompletableFuture中的线程问题</h2><h3 id="代码运行线程"><a href="#代码运行线程" class="headerlink" title="代码运行线程"></a>代码运行线程</h3><p>在<code>CompletableFuture</code>中，代码运行在哪个线程上，需要区分同步方法和异步方法。</p><ul><li><p><strong>同步方法（即不带Async后缀的方法）</strong>：如果在注册时，被依赖的操作已经执行完成，那么同步方法会直接由当前线程执行；如果注册时被依赖的操作还未执行完，那么同步方法会由回调线程执行。</p></li><li><p><strong>异步方法（即带Async后缀的方法）</strong>：我们可以选择是否传递线程池参数<code>Executor</code>来让异步方法运行在指定的线程池中。当不传递<code>Executor</code>时，会使用<code>ForkJoinPool</code>中的共用线程池<code>CommonPool</code> 。需要注意的是，<code>CommonPool</code>的大小是CPU核数 - 1，如果应用是IO密集型的，线程数可能会成为性能瓶颈。</p></li></ul><h3 id="线程池相关问题"><a href="#线程池相关问题" class="headerlink" title="线程池相关问题"></a>线程池相关问题</h3><ul><li><p><strong>异步回调要传线程池</strong>：由于<code>CommonPool</code>的大小有限，在一些高并发或IO密集型的场景下，可能无法满足需求。因此，在进行异步回调时，我们需要考虑传递合适的线程池参数，以避免线程资源不足的问题。</p></li><li><p><strong>线程池循环引用会导致死锁</strong>：在使用线程池时，如果出现循环引用的情况，就可能会导致死锁。比如，一个任务依赖另一个任务，而这两个任务又分别在不同的线程池中执行，且存在相互等待的情况，就可能会陷入死锁状态。</p></li><li><p><strong>异步RPC调用注意不要阻塞IO线程池</strong>：在进行异步RPC调用时，要特别注意不要阻塞IO线程池。因为IO线程池通常用于处理网络IO等操作，如果被阻塞，可能会影响整个系统的IO性能，导致响应延迟等问题。</p></li></ul><h2 id="五、设置超时时间"><a href="#五、设置超时时间" class="headerlink" title="五、设置超时时间"></a>五、设置超时时间</h2><p>在实际应用中，我们常常需要为异步操作设置超时时间，以避免长时间等待。在<code>CompletableFuture</code>中，可以使用<code>applyToEither</code>方法来判断是计算先完成还是先超时。具体实现方式是启动一个<code>ScheduledThreadpoolExecutor</code>线程，在指定的<code>timeout</code>时间后，直接调用<code>CompletableFuture.completeExceptionally(new TimeoutException())</code> ，这样当超过指定时间还未完成计算时，就会抛出<code>TimeoutException</code>异常，从而让我们可以对超时情况进行相应的处理。</p><h2 id="六、使用"><a href="#六、使用" class="headerlink" title="六、使用"></a>六、使用</h2><p>在实习的时候第一次用到了<code>CompletableFuture</code>，那个时候做的是一个官网的文档导出，先下载静态资源文件，下载完之后对其进行打包，再对所有文件进行打包，最后通过邮件发送给管理员，实现一个官网文档私有化的功能。</p><h3 id="流程图："><a href="#流程图：" class="headerlink" title="流程图："></a>流程图：</h3><p><img src="2025-03-19-CompletableFuture原理及其使用/image-20250419190430184-5060677-5060680.png" alt="image-20250419190430184"></p><h3 id="回忆版伪代码："><a href="#回忆版伪代码：" class="headerlink" title="回忆版伪代码："></a>回忆版伪代码：</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line"><span class="keyword">import</span> java.util.concurrent.CompletableFuture;</span><br><span class="line"><span class="keyword">import</span> java.util.concurrent.ExecutorService;</span><br><span class="line"><span class="keyword">import</span> java.util.concurrent.Executors;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 假设这些是下载和打包相关的方法，实际使用中需根据具体实现替换</span></span><br><span class="line"><span class="comment">// 下载html文件</span></span><br><span class="line"><span class="keyword">public</span> CompletableFuture&lt;String&gt; <span class="title function_">downloadHtmlFile</span><span class="params">(String documentName)</span> &#123;</span><br><span class="line">    <span class="comment">// 实际下载逻辑，这里返回一个CompletableFuture表示异步操作</span></span><br><span class="line">    <span class="keyword">return</span> CompletableFuture.supplyAsync(() -&gt; &#123;</span><br><span class="line">        <span class="comment">// 模拟下载操作，返回下载后的文件内容或路径等相关信息</span></span><br><span class="line">        <span class="keyword">return</span> <span class="string">&quot;downloaded_html_file_path_for_&quot;</span> + documentName;</span><br><span class="line">    &#125;, executorService);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 下载图片文件</span></span><br><span class="line"><span class="keyword">public</span> CompletableFuture&lt;String&gt; <span class="title function_">downloadImageFile</span><span class="params">(String documentName)</span> &#123;</span><br><span class="line">    <span class="keyword">return</span> CompletableFuture.supplyAsync(() -&gt; &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="string">&quot;downloaded_image_file_path_for_&quot;</span> + documentName;</span><br><span class="line">    &#125;, executorService);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 下载CSS文件</span></span><br><span class="line"><span class="keyword">public</span> CompletableFuture&lt;String&gt; <span class="title function_">downloadCssFile</span><span class="params">(String documentName)</span> &#123;</span><br><span class="line">    <span class="keyword">return</span> CompletableFuture.supplyAsync(() -&gt; &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="string">&quot;downloaded_css_file_path_for_&quot;</span> + documentName;</span><br><span class="line">    &#125;, executorService);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 打包文件</span></span><br><span class="line"><span class="keyword">public</span> CompletableFuture&lt;String&gt; <span class="title function_">packFiles</span><span class="params">(String[] filePaths)</span> &#123;</span><br><span class="line">    <span class="keyword">return</span> CompletableFuture.supplyAsync(() -&gt; &#123;</span><br><span class="line">        <span class="comment">// 实际打包逻辑，返回打包后的文件路径等相关信息</span></span><br><span class="line">        <span class="keyword">return</span> <span class="string">&quot;packed_file_path_for_&quot;</span> + filePaths[<span class="number">0</span>];</span><br><span class="line">    &#125;, executorService);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 发送邮件</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">sendEmail</span><span class="params">(String packedFilePath)</span> &#123;</span><br><span class="line">    <span class="comment">// 实际发送邮件逻辑</span></span><br><span class="line">    System.out.println(<span class="string">&quot;Sending email with file: &quot;</span> + packedFilePath);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Main</span> &#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="type">ExecutorService</span> <span class="variable">executorService</span> <span class="operator">=</span> Executors.newFixedThreadPool(<span class="number">10</span>);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">        <span class="comment">// 假设这里有n个文档，以数组形式表示文档名</span></span><br><span class="line">        String[] documentNames = &#123;<span class="string">&quot;document1&quot;</span>, <span class="string">&quot;document2&quot;</span>, <span class="string">&quot;document3&quot;</span>&#125;; </span><br><span class="line">        CompletableFuture[] allDownloadFutures = <span class="keyword">new</span> <span class="title class_">CompletableFuture</span>[documentNames.length];</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i &lt; documentNames.length; i++) &#123;</span><br><span class="line">            <span class="type">String</span> <span class="variable">documentName</span> <span class="operator">=</span> documentNames[i];</span><br><span class="line">            CompletableFuture&lt;String&gt; htmlFuture = downloadHtmlFile(documentName);</span><br><span class="line">            CompletableFuture&lt;String&gt; imageFuture = downloadImageFile(documentName);</span><br><span class="line">            CompletableFuture&lt;String&gt; cssFuture = downloadCssFile(documentName);</span><br><span class="line"></span><br><span class="line">            CompletableFuture[] subFutures = &#123;htmlFuture, imageFuture, cssFuture&#125;;</span><br><span class="line">            CompletableFuture&lt;String&gt; packFuture = CompletableFuture.allOf(subFutures)</span><br><span class="line">                   .thenApply(v -&gt; &#123;</span><br><span class="line">                        <span class="keyword">try</span> &#123;</span><br><span class="line">                            String[] filePaths = &#123;htmlFuture.get(), imageFuture.get(), cssFuture.get()&#125;;</span><br><span class="line">                            <span class="keyword">return</span> packFiles(filePaths).get();</span><br><span class="line">                        &#125; <span class="keyword">catch</span> (Exception e) &#123;</span><br><span class="line">                            e.printStackTrace();</span><br><span class="line">                            <span class="keyword">return</span> <span class="literal">null</span>;</span><br><span class="line">                        &#125;</span><br><span class="line">                    &#125;);</span><br><span class="line">            allDownloadFutures[i] = packFuture;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        CompletableFuture.allOf(allDownloadFutures)</span><br><span class="line">               .thenRun(() -&gt; &#123;</span><br><span class="line">                    <span class="keyword">try</span> &#123;</span><br><span class="line">                        <span class="keyword">for</span> (CompletableFuture&lt;String&gt; packFuture : allDownloadFutures) &#123;</span><br><span class="line">                            <span class="type">String</span> <span class="variable">packedFilePath</span> <span class="operator">=</span> packFuture.get();</span><br><span class="line">                            sendEmail(packedFilePath);</span><br><span class="line">                        &#125;</span><br><span class="line">                    &#125; <span class="keyword">catch</span> (Exception e) &#123;</span><br><span class="line">                        e.printStackTrace();</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125;);</span><br><span class="line"></span><br><span class="line">        executorService.shutdown();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">### 代码说明</span></span><br><span class="line"><span class="comment">1. **线程池初始化**：创建一个固定大小为10的线程池`executorService`，用于执行异步任务。</span></span><br><span class="line"><span class="comment">2. **下载任务**：定义了`downloadHtmlFile`、`downloadImageFile`、`downloadCssFile`三个方法，分别用于异步下载html、图片和CSS文件，每个方法返回一个`CompletableFuture`。</span></span><br><span class="line"><span class="comment">3. **打包任务**：`packFiles`方法用于将下载的文件进行打包，同样返回一个`CompletableFuture`。</span></span><br><span class="line"><span class="comment">4. **发送邮件**：`sendEmail`方法用于发送包含打包文件的邮件。</span></span><br><span class="line"><span class="comment">5. **主流程**：遍历文档名数组，对每个文档分别发起html、图片和CSS文件的下载任务，通过`CompletableFuture.allOf`等待这些子任务完成后进行打包。所有文档打包完成后，再通过`CompletableFuture.allOf`等待所有打包任务完成，最后依次发送邮件。</span></span><br><span class="line"><span class="comment">6. **线程池关闭**：在所有任务完成后，关闭线程池。 </span></span><br><span class="line"><span class="comment">*/</span></span><br></pre></td></tr></table></figure><h3 id="其它方式实现："><a href="#其它方式实现：" class="headerlink" title="其它方式实现："></a>其它方式实现：</h3><ul><li><p><strong>FutureTask</strong>：实现<code>Future</code>与<code>Runnable</code>接口，包装<code>Callable</code>或<code>Runnable</code>对象执行异步任务，能获取结果，但<code>get</code>方法会阻塞，轮询检查又消耗CPU，且任务编排能力有限。&#x20;</p></li><li><p><strong>线程池结合Runnable/Callable</strong>：利用<code>ExecutorService</code>创建线程池，提交<code>Runnable</code>（无返回值）或<code>Callable</code>（有返回值）任务执行，可控制线程数量、提高资源利用率，但复杂任务编排时代码较复杂，需手动处理任务顺序与结果传递。&#x20;</p></li><li><p><strong>Guava的ListenableFuture</strong>：扩展Java标准<code>Future</code>接口，通过<code>Futures.addCallback()</code>添加回调函数，任务完成时自动触发，避免阻塞，但引入库依赖，处理复杂任务组合不如<code>CompletableFuture</code>直观。&#x20;</p></li></ul><h2 id="总结："><a href="#总结：" class="headerlink" title="总结："></a>总结：</h2><ul><li><p><strong>接口实现</strong>：<code>CompletableFuture</code>实现<code>Future</code>和<code>CompletionStage</code>接口，前者表示异步计算结果，后者可对异步步骤编排组合，提供<code>thenApply</code>等函数式编程方法。</p></li><li><p><strong>依赖关系</strong>：分一元、二元和多元依赖。一元依赖用<code>thenApply</code>等处理单个<code>CompletableFuture</code>；二元依赖通过<code>thenCombine</code>整合两个结果；多元依赖用<code>allOf</code>或<code>anyOf</code>处理多个。</p></li><li><p><strong>原理</strong>：含<code>result</code>（存结果）和<code>stack</code>字段，基于观察者与被观察者模式，被观察者完成时按<code>stack</code>信息通知观察者处理结果。</p></li><li><p><strong>线程问题</strong>：同步方法依依赖操作状态由当前或回调线程执行；异步方法可指定线程池，否则用<code>CommonPool</code>，但在IO密集场景线程数可能成瓶颈。还提及线程池使用注意点，如异步回调传线程池、避免循环引用死锁、异步RPC不阻塞IO线程池。</p></li><li><p><strong>超时设置</strong>：用<code>applyToEither</code>结合<code>ScheduledThreadpoolExecutor</code>实现，超时抛<code>TimeoutException</code>。&#x20;</p></li></ul><blockquote><p><a href="https://tech.meituan.com/2022/05/12/principles-and-practices-of-completablefuture.html">CompletableFuture原理与实践-外卖商家端API的异步化</a></p><p><a href="https://blog.csdn.net/u013905744/article/details/109134516">java8中CompletableFuture异步处理超时的方法_completablefuture 超时-CSDN博客</a></p></blockquote>]]></content>
    
    
    <summary type="html">🥧CompletableFuture原理及其使用</summary>
    
    
    
    <category term="学习" scheme="https://outoflovenicoo.github.io/categories/%E5%AD%A6%E4%B9%A0/"/>
    
    
    <category term="原理" scheme="https://outoflovenicoo.github.io/tags/%E5%8E%9F%E7%90%86/"/>
    
  </entry>
  
  <entry>
    <title>个人对零拷贝技术的理解</title>
    <link href="https://outoflovenicoo.github.io/posts/2025-03-09-%E4%B8%AA%E4%BA%BA%E5%AF%B9%E9%9B%B6%E6%8B%B7%E8%B4%9D%E6%8A%80%E6%9C%AF%E7%9A%84%E7%90%86%E8%A7%A3.html"/>
    <id>https://outoflovenicoo.github.io/posts/2025-03-09-%E4%B8%AA%E4%BA%BA%E5%AF%B9%E9%9B%B6%E6%8B%B7%E8%B4%9D%E6%8A%80%E6%9C%AF%E7%9A%84%E7%90%86%E8%A7%A3.html</id>
    <published>2025-03-09T10:19:03.000Z</published>
    <updated>2025-03-23T14:00:00.000Z</updated>
    
    <content type="html"><![CDATA[<h1 id="思维导图"><a href="#思维导图" class="headerlink" title="思维导图"></a>思维导图</h1><p><img src="2025-03-09-个人对零拷贝技术的理解/image-20250414160743861.png" alt="image-20250414160743861"></p><h3 id="个人对零拷贝技术的理解：告别冗余拷贝，释放系统性能"><a href="#个人对零拷贝技术的理解：告别冗余拷贝，释放系统性能" class="headerlink" title="个人对零拷贝技术的理解：告别冗余拷贝，释放系统性能"></a>个人对零拷贝技术的理解：告别冗余拷贝，释放系统性能</h3><p>在计算机系统中，磁盘和网络传输往往是性能的瓶颈之一。传统的文件传输方式虽然逻辑简单，但在高并发场景下会因频繁的上下文切换和数据拷贝导致严重的性能损耗。而<strong>零拷贝（Zero-copy）</strong>技术的出现，正是为了解决这一问题。本文将从硬件协作到内核优化，逐步拆解零拷贝技术的原理与应用。</p><hr><h4 id="一、从DMA技术说起：让CPU“解放双手”"><a href="#一、从DMA技术说起：让CPU“解放双手”" class="headerlink" title="一、从DMA技术说起：让CPU“解放双手”"></a>一、从DMA技术说起：让CPU“解放双手”</h4><p>在早期计算机中，数据的传输完全依赖CPU。例如，当磁盘需要向内存传输数据时，CPU需要逐个字节地从磁盘控制器缓冲区读取数据，再写入内存。这种“全程陪跑”的方式让CPU无法处理其他任务，效率极低。</p><p><strong>DMA（直接内存访问）技术</strong>的引入彻底改变了这一局面。DMA控制器接管了数据搬运的工作，CPU只需告诉DMA“从哪里搬、搬到哪里”，后续的数据传输由DMA独立完成。这一过程无需CPU参与，从而释放了CPU资源。</p><p><strong>DMA的工作流程</strong>：  </p><ol><li>用户进程发起I/O请求；  </li><li>DMA将磁盘数据直接搬运到内核缓冲区；  </li><li>数据就绪后，DMA通知CPU将数据从内核缓冲区拷贝到用户空间。  </li></ol><p>至此，CPU只需在传输的开始和结束时介入，中间的数据搬运工作全部由DMA完成。</p><hr><h4 id="二、传统文件传输的“四宗罪”"><a href="#二、传统文件传输的“四宗罪”" class="headerlink" title="二、传统文件传输的“四宗罪”"></a>二、传统文件传输的“四宗罪”</h4><p>传统文件传输通过<code>read()</code>和<code>write()</code>系统调用实现，看似简单的两行代码，却隐藏着巨大的性能问题：  </p><ol><li><strong>4次上下文切换</strong>：每次系统调用涉及2次用户态与内核态的切换，两次调用共4次切换。  </li><li><strong>4次数据拷贝</strong>：<br>• DMA将磁盘数据拷贝到内核缓冲区；<br>• CPU将内核数据拷贝到用户缓冲区；<br>• CPU将用户数据拷贝到Socket内核缓冲区；<br>• DMA将Socket缓冲区数据拷贝到网卡。  </li></ol><p>这4次拷贝中，<strong>两次CPU参与的拷贝是冗余的</strong>，尤其是当用户不需要修改数据时，用户缓冲区的存在反而成了累赘。</p><hr><h4 id="三、零拷贝技术：如何实现“零”冗余？"><a href="#三、零拷贝技术：如何实现“零”冗余？" class="headerlink" title="三、零拷贝技术：如何实现“零”冗余？"></a>三、零拷贝技术：如何实现“零”冗余？</h4><p>零拷贝的核心目标是<strong>减少上下文切换和数据拷贝次数</strong>，具体通过两种方式实现：</p><h5 id="1-mmap-write：减少一次数据拷贝"><a href="#1-mmap-write：减少一次数据拷贝" class="headerlink" title="1. mmap + write：减少一次数据拷贝"></a>1. <code>mmap + write</code>：减少一次数据拷贝</h5><p><code>mmap()</code>系统调用将内核缓冲区映射到用户空间，使得用户进程与内核共享数据，省去了从内核到用户缓冲区的拷贝。但仍有3次数据拷贝（两次DMA，一次CPU），且需要4次上下文切换。</p><h5 id="2-sendfile-：系统调用的终极优化"><a href="#2-sendfile-：系统调用的终极优化" class="headerlink" title="2. sendfile()：系统调用的终极优化"></a>2. <code>sendfile()</code>：系统调用的终极优化</h5><p>Linux 2.1引入的<code>sendfile()</code>系统调用，将读取和发送合并为一次操作：<br>• <strong>2次上下文切换</strong>（1次系统调用）；<br>• <strong>3次数据拷贝</strong>（DMA拷贝磁盘到内核、CPU拷贝内核到Socket缓冲区、DMA拷贝到网卡）。  </p><p>若网卡支持<strong>SG-DMA（分散-聚集DMA）</strong>，则可进一步将CPU拷贝优化掉，仅需2次DMA拷贝，真正实现“零拷贝”。</p><hr><h4 id="四、PageCache：零拷贝的“加速器”"><a href="#四、PageCache：零拷贝的“加速器”" class="headerlink" title="四、PageCache：零拷贝的“加速器”"></a>四、PageCache：零拷贝的“加速器”</h4><p>零拷贝依赖内核的<strong>PageCache（页缓存）</strong>技术，它通过两种机制提升性能：  </p><ol><li><strong>缓存热点数据</strong>：最近访问的数据保留在内存中，减少磁盘访问。  </li><li><strong>预读机制</strong>：根据局部性原理，提前加载后续可能访问的数据。  </li></ol><p>然而，PageCache对<strong>大文件传输并不友好</strong>：<br>• 大文件会挤占缓存空间，影响小文件性能；<br>• 大文件的数据复用率低，预读反而浪费资源。  </p><p><strong>解决方案</strong>：针对大文件，采用<strong>异步I/O + 直接I/O</strong>，绕过PageCache，直接由磁盘到用户空间。</p><hr><h4 id="五、实践指南：何时用零拷贝？何时用直接I-O？"><a href="#五、实践指南：何时用零拷贝？何时用直接I-O？" class="headerlink" title="五、实践指南：何时用零拷贝？何时用直接I/O？"></a>五、实践指南：何时用零拷贝？何时用直接I/O？</h4><p>• <strong>小文件传输</strong>：优先使用零拷贝（如<code>sendfile</code>），结合PageCache加速。<br>• <strong>大文件传输</strong>：使用异步I/O + 直接I/O，避免PageCache污染。  </p><p><strong>Nginx配置示例</strong>：<br><figure class="highlight nginx"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="section">location</span> /video/ &#123;</span><br><span class="line">    <span class="attribute">sendfile</span> <span class="literal">on</span>;       <span class="comment"># 小文件用零拷贝</span></span><br><span class="line">    <span class="attribute">aio</span> <span class="literal">on</span>;            <span class="comment"># 大文件用异步I/O</span></span><br><span class="line">    <span class="attribute">directio</span> <span class="number">1024m</span>;    <span class="comment"># 超过1GB的文件启用直接I/O</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><hr><h4 id="六、总结"><a href="#六、总结" class="headerlink" title="六、总结"></a>六、总结</h4><p>零拷贝技术通过减少CPU参与的数据拷贝和上下文切换，显著提升了文件传输效率。其核心思想是：  </p><ol><li><strong>硬件协作</strong>：DMA承担数据搬运，释放CPU；  </li><li><strong>内核优化</strong>：合并系统调用，利用PageCache加速；  </li><li><strong>场景适配</strong>：区分大小文件，选择最优方案。  </li></ol><p>在高并发场景下，合理使用零拷贝（如Kafka、Nginx）可大幅提升吞吐量，而大文件传输则需另辟蹊径。</p>]]></content>
    
    
    <summary type="html">🥧个人对零拷贝技术的理解</summary>
    
    
    
    <category term="学习" scheme="https://outoflovenicoo.github.io/categories/%E5%AD%A6%E4%B9%A0/"/>
    
    
    <category term="操作系统" scheme="https://outoflovenicoo.github.io/tags/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/"/>
    
  </entry>
  
  <entry>
    <title>高性能网络模式</title>
    <link href="https://outoflovenicoo.github.io/posts/2025-03-09-%E9%AB%98%E6%80%A7%E8%83%BD%E7%BD%91%E7%BB%9C%E6%A8%A1%E5%BC%8F.html"/>
    <id>https://outoflovenicoo.github.io/posts/2025-03-09-%E9%AB%98%E6%80%A7%E8%83%BD%E7%BD%91%E7%BB%9C%E6%A8%A1%E5%BC%8F.html</id>
    <published>2025-03-09T10:19:03.000Z</published>
    <updated>2025-03-23T14:00:00.000Z</updated>
    
    <content type="html"><![CDATA[<h1 id="高性能网络模式：深入理解-Reactor-与-Proactor"><a href="#高性能网络模式：深入理解-Reactor-与-Proactor" class="headerlink" title="高性能网络模式：深入理解 Reactor 与 Proactor"></a>高性能网络模式：深入理解 Reactor 与 Proactor</h1><p>在构建高并发服务器时，传统的“一连接一线程”模型会面临性能瓶颈和资源浪费问题。<strong>I/O 多路复用技术</strong>的出现解决了这一难题，而基于此技术演化出的 <strong>Reactor</strong> 和 <strong>Proactor</strong> 模式，则成为了高性能网络编程的核心架构。本文将从设计思想、实现方案到应用场景，为你揭开这两种模式的神秘面纱。</p><h1 id="思维导图："><a href="#思维导图：" class="headerlink" title="思维导图："></a>思维导图：</h1><p><img src="2025-03-09-高性能网络模式/image-20250414161555385.png" alt="image-20250414161555385"></p><hr><h2 id="一、Reactor-模式：同步非阻塞的事件驱动模型"><a href="#一、Reactor-模式：同步非阻塞的事件驱动模型" class="headerlink" title="一、Reactor 模式：同步非阻塞的事件驱动模型"></a>一、Reactor 模式：同步非阻塞的事件驱动模型</h2><h3 id="1-核心思想"><a href="#1-核心思想" class="headerlink" title="1. 核心思想"></a>1. 核心思想</h3><p>Reactor 模式通过 <strong>事件分发机制</strong> 实现高效处理多连接。其核心由两个组件构成：<br>• <strong>Reactor</strong>：负责监听和分发事件（如连接建立、数据可读/写）<br>• <strong>处理资源池</strong>：线程/进程池负责具体业务处理</p><p><strong>类比现实场景</strong>：<br>Reactor 如同餐厅的接待员，持续监听客户请求（事件）。当新顾客到来（连接建立）时，接待员安排服务员（Handler）接待；当顾客点餐（数据到达）时，服务员开始处理订单。</p><hr><h3 id="2-三种经典实现方案"><a href="#2-三种经典实现方案" class="headerlink" title="2. 三种经典实现方案"></a>2. 三种经典实现方案</h3><h4 id="方案-1：单-Reactor-单进程-线程"><a href="#方案-1：单-Reactor-单进程-线程" class="headerlink" title="方案 1：单 Reactor 单进程/线程"></a>方案 1：单 Reactor 单进程/线程</h4><p><strong>架构组成</strong>：<br>• 单个进程/线程内包含三个核心对象：<br>  • <strong>Reactor</strong>：通过 <code>select</code>/<code>epoll</code> 监听所有事件<br>  • <strong>Acceptor</strong>：处理新连接建立<br>  • <strong>Handler</strong>：处理已建立连接的读写请求</p><p><strong>工作流程</strong>：  </p><ol><li>Reactor 监听所有事件，将连接建立事件分发给 Acceptor</li><li>Acceptor 调用 <code>accept()</code> 创建新连接，并生成对应的 Handler</li><li>Handler 处理数据读写（<code>read → 业务处理 → send</code>）</li></ol><p><strong>特点</strong>：<br>• 实现简单，无进程间通信开销<br>• 无法利用多核 CPU，业务处理必须非阻塞<br>• <strong>典型应用</strong>：Redis 6.0 前版本</p><hr><h4 id="方案-2：单-Reactor-多线程"><a href="#方案-2：单-Reactor-多线程" class="headerlink" title="方案 2：单 Reactor 多线程"></a>方案 2：单 Reactor 多线程</h4><p><strong>架构改进</strong>：<br>• 主线程保留 Reactor 和 Acceptor<br>• 引入线程池处理业务逻辑：<br>  • Handler 仅负责非阻塞 I/O 操作<br>  • 子线程处理业务后将结果返回主线程</p><p><strong>工作流程</strong>：  </p><ol><li>Reactor 监听事件，连接建立后由 Acceptor 创建 Handler</li><li>Handler 读取数据后，将数据提交给线程池处理</li><li>子线程完成业务逻辑，通过共享队列返回结果</li><li>主线程的 Handler 将结果发送给客户端</li></ol><p><strong>痛点</strong>：<br>• Reactor 单点可能成为性能瓶颈<br>• 需处理多线程资源共享问题<br>• <strong>典型应用</strong>：早期 Memcache</p><hr><h4 id="方案-3：多-Reactor-多进程-线程"><a href="#方案-3：多-Reactor-多进程-线程" class="headerlink" title="方案 3：多 Reactor 多进程/线程"></a>方案 3：多 Reactor 多进程/线程</h4><p><strong>架构设计</strong>：<br>• <strong>MainReactor</strong>：主线程/进程，仅处理新连接建立<br>• <strong>SubReactor</strong>：子线程/进程池，每个子单元管理一组连接<br>• <strong>Handler</strong>：绑定到 SubReactor 处理具体连接</p><p><strong>工作流程</strong>：  </p><ol><li>MainReactor 接收新连接，按负载均衡策略分配给 SubReactor</li><li>SubReactor 将连接加入自己的监听队列</li><li>事件触发时，SubReactor 调用对应 Handler 处理数据流</li></ol><p><strong>优势</strong>：<br>• 主从分工明确，扩展性强<br>• 避免单点性能瓶颈<br>• <strong>典型应用</strong>：Netty（多线程）、Nginx（多进程变体）</p><hr><h2 id="二、Proactor-模式：异步非阻塞的终极方案"><a href="#二、Proactor-模式：异步非阻塞的终极方案" class="headerlink" title="二、Proactor 模式：异步非阻塞的终极方案"></a>二、Proactor 模式：异步非阻塞的终极方案</h2><h3 id="1-核心思想-1"><a href="#1-核心思想-1" class="headerlink" title="1. 核心思想"></a>1. 核心思想</h3><p>Proactor 是真正的 <strong>异步 I/O 模型</strong>，其特点在于：<br>• <strong>操作系统完成 I/O 操作</strong>：包括数据从内核到用户空间的拷贝<br>• <strong>应用层只关注业务逻辑</strong>：处理已完成的 I/O 事件</p><p><strong>现实类比</strong>：<br>Proactor 如同外卖平台，骑手（系统内核）直接将餐品送到你家（数据就绪），你只需处理用餐（业务逻辑）即可。</p><hr><h3 id="2-工作流程"><a href="#2-工作流程" class="headerlink" title="2. 工作流程"></a>2. 工作流程</h3><ol><li><strong>注册异步操作</strong>：应用通过 <code>aio_read</code> 等接口发起请求，指定数据缓冲区</li><li><strong>系统内核执行 I/O</strong>：从网卡读取数据并自动拷贝到用户空间</li><li><strong>完成通知</strong>：内核通过回调通知 Proactor</li><li><strong>业务处理</strong>：Proactor 调用 Handler 处理数据</li></ol><hr><h3 id="3-平台支持差异"><a href="#3-平台支持差异" class="headerlink" title="3. 平台支持差异"></a>3. 平台支持差异</h3><div class="table-container"><table><thead><tr><th><strong>平台</strong></th><th><strong>实现方式</strong></th><th><strong>特点</strong></th></tr></thead><tbody><tr><td>Linux</td><td>模拟异步 I/O（如 <code>aio</code>）</td><td>仅支持文件操作，网络性能受限</td></tr><tr><td>Windows</td><td>原生支持 IOCP（完成端口）</td><td>真正异步，适合高性能网络服务</td></tr></tbody></table></div><hr><h2 id="三、Reactor-vs-Proactor-关键区别"><a href="#三、Reactor-vs-Proactor-关键区别" class="headerlink" title="三、Reactor vs Proactor 关键区别"></a>三、Reactor vs Proactor 关键区别</h2><div class="table-container"><table><thead><tr><th><strong>特性</strong></th><th><strong>Reactor</strong></th><th><strong>Proactor</strong></th></tr></thead><tbody><tr><td><strong>事件类型</strong></td><td>通知”可读/可写”（需应用主动处理数据）</td><td>通知”数据已就绪”（数据已存入应用缓冲区）</td></tr><tr><td><strong>数据处理</strong></td><td>应用层调用 <code>read</code>/<code>write</code> 完成 I/O 操作</td><td>系统自动完成数据读写</td></tr><tr><td><strong>性能瓶颈</strong></td><td>依赖非阻塞 I/O 和线程模型优化</td><td>依赖操作系统异步支持</td></tr><tr><td><strong>编程复杂度</strong></td><td>需处理非阻塞 I/O 状态和半包问题</td><td>只需关注业务逻辑</td></tr><tr><td><strong>典型应用</strong></td><td>Redis、Nginx、Netty</td><td>Windows IOCP 服务器</td></tr></tbody></table></div><hr><h2 id="四、如何选择网络模型？"><a href="#四、如何选择网络模型？" class="headerlink" title="四、如何选择网络模型？"></a>四、如何选择网络模型？</h2><h3 id="1-Reactor-适用场景"><a href="#1-Reactor-适用场景" class="headerlink" title="1. Reactor 适用场景"></a>1. Reactor 适用场景</h3><p>• <strong>跨平台需求</strong>（尤其是 Linux 环境）<br>• <strong>业务逻辑轻量</strong>（如微秒级处理）<br>• <strong>高并发连接</strong>（如百万级长连接）<br>• <strong>经典案例</strong>：<br>  • Redis：单 Reactor 处理内存级快速操作<br>  • Netty：多 Reactor 应对高并发网络请求</p><h3 id="2-Proactor-适用场景"><a href="#2-Proactor-适用场景" class="headerlink" title="2. Proactor 适用场景"></a>2. Proactor 适用场景</h3><p>• <strong>Windows 平台高性能服务</strong><br>• <strong>大数据量传输</strong>（如视频流处理）<br>• <strong>简化业务层开发</strong><br>• <strong>经典案例</strong>：<br>  • IIS 服务器：基于 IOCP 实现高效 HTTP 服务<br>  • 金融交易系统：低延迟处理高频交易数据</p><hr><h2 id="五、总结"><a href="#五、总结" class="headerlink" title="五、总结"></a>五、总结</h2><p><strong>Reactor 的本质</strong>：  </p><blockquote><p>“事件就绪时通知你处理” —— 应用程序仍需主动完成数据读写。</p></blockquote><p><strong>Proactor 的精髓</strong>：  </p><blockquote><p>“事件处理完通知你结果” —— 操作系统包揽脏活累活，应用层专注业务。</p></blockquote><p><strong>技术选型建议</strong>：<br>• 在 Linux 体系下，Reactor 仍是主流选择，结合 <code>epoll</code> 和线程池优化可达到 C10M 并发。<br>• Windows 平台优先考虑 Proactor（IOCP），充分发挥异步性能优势。<br>• 现代框架如 Netty 通过分层设计屏蔽底层差异，开发者可基于 API 统一编程模型。</p><p>理解这些底层网络模式是很重要的。因为无论是优化现有系统，还是设计新架构，Reactor 和 Proactor 的思想都将持续指引我们突破性能瓶颈。</p>]]></content>
    
    
    <summary type="html">🥧高性能网络模式</summary>
    
    
    
    <category term="学习" scheme="https://outoflovenicoo.github.io/categories/%E5%AD%A6%E4%B9%A0/"/>
    
    
    <category term="操作系统" scheme="https://outoflovenicoo.github.io/tags/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/"/>
    
  </entry>
  
  <entry>
    <title>MySQL如何存储数据</title>
    <link href="https://outoflovenicoo.github.io/posts/2025-03-09-MySQL%E5%A6%82%E4%BD%95%E5%AD%98%E5%82%A8%E6%95%B0%E6%8D%AE.html"/>
    <id>https://outoflovenicoo.github.io/posts/2025-03-09-MySQL%E5%A6%82%E4%BD%95%E5%AD%98%E5%82%A8%E6%95%B0%E6%8D%AE.html</id>
    <published>2025-03-09T10:19:03.000Z</published>
    <updated>2025-03-23T14:00:00.000Z</updated>
    
    <content type="html"><![CDATA[<h1 id="InnoDB存储引擎如何存储数据"><a href="#InnoDB存储引擎如何存储数据" class="headerlink" title="InnoDB存储引擎如何存储数据"></a>InnoDB存储引擎如何存储数据</h1><h2 id="思维导图："><a href="#思维导图：" class="headerlink" title="思维导图："></a><strong>思维导图：</strong></h2><p><img src="2025-03-09-MySQL如何存储数据/1.png" alt="img"></p><p>在MySQL数据库的世界里，InnoDB存储引擎堪称是数据存储的”心脏”。今天，我们就以一位数据库工程师的视角，揭开这个”心脏”的运作奥秘。准备好了吗？让我们沿着数据存储的脉络，开启一场技术探秘之旅！</p><h2 id="一、MySQL数据存储基石：InnoDB的精密设计"><a href="#一、MySQL数据存储基石：InnoDB的精密设计" class="headerlink" title="一、MySQL数据存储基石：InnoDB的精密设计"></a>一、MySQL数据存储基石：InnoDB的精密设计</h2><p>如果把数据库比作图书馆，InnoDB就是那个既懂分类又善管理的图书管理员。它通过精心设计的文件系统，将数据有序地存放在磁盘上。</p><h3 id="（一）磁盘文件里的”身份证”与”藏书阁”"><a href="#（一）磁盘文件里的”身份证”与”藏书阁”" class="headerlink" title="（一）磁盘文件里的”身份证”与”藏书阁”"></a>（一）磁盘文件里的”身份证”与”藏书阁”</h3><p><img src="2025-03-09-MySQL如何存储数据/2.png" alt="img"></p><p>当我们新建一个订单表<code>order</code>时，系统会悄悄生成几个关键文件：<br>• <strong>opt文件</strong>：就像是数据库的”身份证”，记录着默认的字符集（比如UTF-8）和校验规则。它确保中文不会变成乱码，数字比较时不会出错。<br>• <strong>frm文件</strong>：可以理解为”书架标签”，存储着表结构的定义。每次你DESC查看表结构时，系统其实就是在读取这个文件。<br>• <strong>idb文件</strong>：这才是真正的”藏书阁”。以<code>order.idb</code>为例，它存储着订单表的所有数据。就像现代图书馆的智能书架，MySQL 5.6.6之后默认每个表都有独立的.idb文件，这样要维护某个书架（表）时，再也不用搬动整个图书馆的藏书了。</p><p>举个真实案例：某电商平台发现订单表查询变慢，DBA通过<code>ALTER TABLE order ENGINE=InnoDB</code>重建表空间后，发现.idb文件体积缩小了30%，这正是独立表空间的优势体现。</p><h3 id="（二）表空间的俄罗斯套娃结构"><a href="#（二）表空间的俄罗斯套娃结构" class="headerlink" title="（二）表空间的俄罗斯套娃结构"></a>（二）表空间的俄罗斯套娃结构</h3><p>打开这个”藏书阁”，你会发现一个精妙的存储体系：</p><p><img src="2025-03-09-MySQL如何存储数据/3.png" alt="img"></p><figure class="highlight"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">表空间 → 段 → 区 → 页 → 行</span><br></pre></td></tr></table></figure><p>就像图书馆的分区管理：<br>• <strong>段（Segment）</strong>：类似图书馆的楼层分区（索引区、数据区）<br>• <strong>区（Extent）</strong>：每个楼层里的藏书区，由连续64个页组成（1MB）<br>• <strong>页（Page）</strong>：最基本的存储单元，相当于书架隔层（16KB）<br>• <strong>行（Row）</strong>：每本书就是一行数据</p><p>这种结构设计有个精妙之处：当需要新增数据时，InnoDB不是随意找个空位，而是整区整区地分配空间。就像图书馆扩建时直接增加整个书架区，而不是这里加一本那里塞一册。</p><h2 id="二、行格式"><a href="#二、行格式" class="headerlink" title="二、行格式"></a>二、行格式</h2><p>如果说表空间是图书馆，那么行格式就是书籍的排版规范。InnoDB支持多种行格式，我们以最常用的Compact格式为例，看看它是如何将数据”装订成册”的。</p><h3 id="（一）变长字段的"><a href="#（一）变长字段的" class="headerlink" title="（一）变长字段的"></a>（一）变长字段的</h3><p>假设我们有一张用户表：<br><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">CREATE TABLE</span> users (</span><br><span class="line">    id <span class="type">INT</span> <span class="keyword">NOT NULL</span>,</span><br><span class="line">    name <span class="type">VARCHAR</span>(<span class="number">20</span>),</span><br><span class="line">    email <span class="type">VARCHAR</span>(<span class="number">50</span>)</span><br><span class="line">);</span><br></pre></td></tr></table></figure><br>当插入一条记录：<br><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">INSERT INTO</span> users <span class="keyword">VALUES</span>(<span class="number">1</span>, <span class="string">&#x27;张三&#x27;</span>, <span class="string">&#x27;zhangsan@example.com&#x27;</span>);</span><br></pre></td></tr></table></figure><br>Compact行格式会先在数据行头部放置两把”尺子”：</p><ol><li><p><strong>变长字段长度列表</strong>：逆序记录每个变长字段的实际长度<br>• email长度23字节（ASCII每个字符1字节）<br>• name长度4字节（每个中文字符3字节？不！这里有个常见误区，实际存储长度取决于字符集）<br>• 存储方式：<code>[23,4]</code>的逆序十六进制<code>0x17 0x04</code></p></li><li><p><strong>NULL值标记位图</strong>：<br>• 三个字段都不允许NULL，所以这个列表不存在<br>• 如果允许NULL，会用位图标记哪些字段是NULL（1表示NULL）</p></li></ol><p>这里有个有趣的测试：将name字段改为CHAR(20)，实际存储长度会变成60字节（假设UTF8MB4字符集），而VARCHAR(20)实际存储长度根据内容变化。这就是CHAR类型在存储空间上的”以空间换时间”策略。</p><h3 id="（二）NULL值的存储"><a href="#（二）NULL值的存储" class="headerlink" title="（二）NULL值的存储"></a>（二）NULL值的存储</h3><p>当表中存在允许NULL的字段时，Compact行格式会施展它的”隐身术”：<br><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">CREATE TABLE</span> orders (</span><br><span class="line">    id <span class="type">INT</span> <span class="keyword">PRIMARY KEY</span>,</span><br><span class="line">    product <span class="type">VARCHAR</span>(<span class="number">100</span>),</span><br><span class="line">    buyer <span class="type">VARCHAR</span>(<span class="number">50</span>) <span class="keyword">NULL</span></span><br><span class="line">);</span><br></pre></td></tr></table></figure><br>假设插入：<br><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">INSERT INTO</span> orders <span class="keyword">VALUES</span>(<span class="number">1001</span>, <span class="string">&#x27;智能手机&#x27;</span>, <span class="keyword">NULL</span>);</span><br></pre></td></tr></table></figure><br>此时：</p><ol><li>NULL值列表用1字节表示：二进制<code>00000010</code>（逆序排列，第二位表示buyer为NULL）</li><li>实际数据区不存储NULL字段的值</li><li>省去了存储”NULL”字符串的空间</li></ol><p>根据统计，当表中存在多个可为NULL的字段时，这种设计可节省约5%的存储空间。某社交平台用户表优化后，仅NULL优化就减少了20GB的存储空间！</p><h2 id="三、当数据膨胀时的”分页存储术”"><a href="#三、当数据膨胀时的”分页存储术”" class="headerlink" title="三、当数据膨胀时的”分页存储术”"></a>三、当数据膨胀时的”分页存储术”</h2><p>想象一本百科全书太厚无法放入书架隔层，这时候就需要分册存放。InnoDB的行溢出机制就是这种智慧的数字版。</p><h3 id="（一）行溢出的临界点计算"><a href="#（一）行溢出的临界点计算" class="headerlink" title="（一）行溢出的临界点计算"></a>（一）行溢出的临界点计算</h3><p>每个页（16KB）能存储多少数据？我们通过公式计算：<br><figure class="highlight abnf"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">最大行长度 <span class="operator">=</span> 页大小(<span class="number">16384</span>) - 行头信息(约<span class="number">56</span>字节) ≈ <span class="number">16328</span>字节</span><br></pre></td></tr></table></figure><br>当某行数据超过这个阈值时，就会触发行溢出。比如一个包含10个TEXT字段的表，每条记录都可能需要溢出存储。</p><h3 id="（二）溢出页的”目录索引”"><a href="#（二）溢出页的”目录索引”" class="headerlink" title="（二）溢出页的”目录索引”"></a>（二）溢出页的”目录索引”</h3><p>当发生行溢出时，Compact行格式会：</p><ol><li>在原始页保留768字节的”书签”</li><li>剩余数据存入溢出页</li><li>用20字节的指针记录溢出页地址</li><li>多个溢出页通过链表连接</li></ol><p>这就像图书馆的书籍目录：<br>• 主书架存放目录页（包含各分册位置）<br>• 实际内容存放在多个分册书架</p><p>某论坛系统曾因大文本字段导致频繁行溢出，通过将大字段拆分到扩展表，查询性能提升了3倍。</p><h2 id="四、行格式设计"><a href="#四、行格式设计" class="headerlink" title="四、行格式设计"></a>四、行格式设计</h2><h3 id="（一）Compact-vs-Dynamic：选择的智慧"><a href="#（一）Compact-vs-Dynamic：选择的智慧" class="headerlink" title="（一）Compact vs Dynamic：选择的智慧"></a>（一）Compact vs Dynamic：选择的智慧</h3><p>MySQL 8.0默认使用Dynamic行格式，它在处理溢出时更激进：<br>• 仅保留20字节指针<br>• 所有变长字段数据优先存溢出页<br>• 更适合现代应用的大数据字段场景</p><p>选择建议：<br>• 频繁更新的大字段表 → Dynamic<br>• 需要兼容旧版本 → Compact<br>• 压缩需求 → Compressed</p><h3 id="（二）字符集的隐藏陷阱"><a href="#（二）字符集的隐藏陷阱" class="headerlink" title="（二）字符集的隐藏陷阱"></a>（二）字符集的隐藏陷阱</h3><p>当计算varchar(n)最大长度时，字符集的影响常被忽视：<br>• UTF8MB4字符集：每个字符最多4字节<br>• 实际最大n值 = (65535 - 长度列表 - NULL列表) / 4</p><p>例如允许NULL的单字段表：<br><figure class="highlight tap"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">(65535 -<span class="number"> 2 </span>- 1) /<span class="number"> 4 </span>≈ 16383字符</span><br></pre></td></tr></table></figure><br>某国际化电商就曾因未考虑字符集，导致地址字段被截断，损失百万订单。</p><h2 id="五、性能优化"><a href="#五、性能优化" class="headerlink" title="五、性能优化"></a>五、性能优化</h2><ol><li><strong>NULL值优化</strong>：将允许NULL的字段改为NOT NULL DEFAULT ‘’，可节省NULL列表空间</li><li><strong>大字段分离</strong>：将BLOB/TEXT字段拆分到扩展表</li><li><strong>行格式转换</strong>：<code>ALTER TABLE ... ROW_FORMAT=DYNAMIC</code></li><li><strong>页压缩</strong>：对历史数据表启用页压缩</li><li><strong>字符集选择</strong>：中文环境优先考虑UTF8MB4而非UTF8</li></ol><p>某金融系统通过上述优化组合拳，使核心交易表的TPS从1500提升到5200，效果显著。</p><h2 id="结语：存储之道的三重境界"><a href="#结语：存储之道的三重境界" class="headerlink" title="结语：存储之道的三重境界"></a>结语：存储之道的三重境界</h2><p>理解InnoDB的存储机制，就像修炼数据库的内功心法：</p><ol><li><strong>见山是山</strong>：看懂文件结构和行格式</li><li><strong>见山不是山</strong>：理解设计哲学与取舍权衡</li><li><strong>见山还是山</strong>：能根据业务特征定制存储方案</li></ol><p>当我们翻开InnoDB的存储宝典，看到的不仅是冷冰冰的数据结构，更是一群工程师对效率与可靠性的极致追求。下次当你执行一条SELECT语句时，不妨想象一下，这简单的查询背后，正有一支精密的”存储交响乐团”在为你演奏。</p><h1 id="参考博客："><a href="#参考博客：" class="headerlink" title="参考博客："></a>参考博客：</h1><p><a href="https://xiaolincoding.com/mysql/base/row_format.html#总结">MySQL 一行记录是怎么存储的？</a></p>]]></content>
    
    
    <summary type="html">🥧MySQL如何存储数据</summary>
    
    
    
    <category term="学习" scheme="https://outoflovenicoo.github.io/categories/%E5%AD%A6%E4%B9%A0/"/>
    
    
    <category term="MySQL" scheme="https://outoflovenicoo.github.io/tags/MySQL/"/>
    
  </entry>
  
  <entry>
    <title>联合索引学习笔记</title>
    <link href="https://outoflovenicoo.github.io/posts/2025-03-09-%E8%81%94%E5%90%88%E7%B4%A2%E5%BC%95%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0.html"/>
    <id>https://outoflovenicoo.github.io/posts/2025-03-09-%E8%81%94%E5%90%88%E7%B4%A2%E5%BC%95%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0.html</id>
    <published>2025-03-09T10:19:03.000Z</published>
    <updated>2025-03-23T14:00:00.000Z</updated>
    
    <content type="html"><![CDATA[<h1 id="联合索引底层以及内幕"><a href="#联合索引底层以及内幕" class="headerlink" title="联合索引底层以及内幕"></a>联合索引底层以及内幕</h1><p><a href="https://mp.weixin.qq.com/s/8qemhRg5MgXs1So5YCv0fQ">联合索引底层</a></p><p><a href="https://blog.csdn.net/wangye135/article/details/140389620">MySQL覆盖索引和索引跳跃扫描-CSDN博客</a></p><p><img src="2025-03-09-联合索引学习笔记/image-20250407160156273-4012927.png" alt="image-20250407160156273"></p><h3 id="被问到过一个面试题："><a href="#被问到过一个面试题：" class="headerlink" title="被问到过一个面试题："></a>被问到过一个面试题：</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">select a,c from t <span class="type">where</span> <span class="variable">a</span> <span class="operator">=</span> <span class="number">1</span> and b= <span class="number">2</span> order by c desc</span><br></pre></td></tr></table></figure><p>应该设置什么索引，c的升序和降序会有什么影响，哪个更快一点。</p><h3 id="升序索引与降序索引对查询性能的影响"><a href="#升序索引与降序索引对查询性能的影响" class="headerlink" title="升序索引与降序索引对查询性能的影响"></a>升序索引与降序索引对查询性能的影响</h3><h4 id="1-查询排序方向与索引排序方向一致"><a href="#1-查询排序方向与索引排序方向一致" class="headerlink" title="1. 查询排序方向与索引排序方向一致"></a>1. 查询排序方向与索引排序方向一致</h4><ul><li><strong>升序索引用于升序查询</strong>：当创建的索引是 <code>(a, b, c ASC)</code>（<code>ASC</code> 表示升序，可省略），并且查询语句是 <code>ORDER BY c ASC</code> 时，数据库可以直接按照索引中 <code>c</code> 列的顺序来返回结果，无需额外的排序操作，这样能显著提升查询效率。因为索引已经按照升序排列好了，数据库可以直接从索引中获取有序的数据。</li><li><strong>降序索引用于降序查询</strong>：如果创建的索引是 <code>(a, b, c DESC)</code>，而查询语句是 <code>ORDER BY c DESC</code>，数据库同样可以直接利用索引中 <code>c</code> 列的降序排列来返回结果，避免了额外的排序开销。</li></ul><h4 id="2-查询排序方向与索引排序方向不一致"><a href="#2-查询排序方向与索引排序方向不一致" class="headerlink" title="2. 查询排序方向与索引排序方向不一致"></a>2. 查询排序方向与索引排序方向不一致</h4><ul><li><strong>升序索引用于降序查询</strong>：当使用 <code>(a, b, c ASC)</code> 索引，而查询语句是 <code>ORDER BY c DESC</code> 时，数据库可能无法直接利用索引的顺序，需要对从索引中获取的数据进行额外的降序排序操作。这会增加查询的时间和资源消耗，尤其是在处理大量数据时，性能下降会更明显。</li><li><strong>降序索引用于升序查询</strong>：类似地，若使用 <code>(a, b, c DESC)</code> 索引，而查询是 <code>ORDER BY c ASC</code>，数据库也需要对数据进行额外的升序排序，导致性能降低。</li></ul><h3 id="哪个更快取决于具体场景"><a href="#哪个更快取决于具体场景" class="headerlink" title="哪个更快取决于具体场景"></a>哪个更快取决于具体场景</h3><ul><li><strong>如果查询中</strong> <strong><code>ORDER BY c</code></strong>的方向固定：<ul><li>若查询总是 <code>ORDER BY c ASC</code>，那么创建升序索引 <code>(a, b, c)</code> 会更快，因为可以直接利用索引的顺序。</li><li>若查询总是 <code>ORDER BY c DESC</code>，则创建降序索引 <code>(a, b, c DESC)</code> 更合适，能避免额外的排序操作。</li></ul></li><li><strong>如果查询中</strong> <strong><code>ORDER BY c</code></strong>的方向不固定：<ul><li>在某些数据库（如 MySQL 8.0 及以上版本）中，可以同时创建升序和降序索引，但这会增加索引维护的开销，因为每次插入、更新或删除数据时，都需要同时更新多个索引。</li><li>也可以考虑只创建一个升序索引，让数据库在需要降序排序时进行额外的排序操作。在数据量较小的情况下，这种额外排序的开销可能并不明显。</li></ul></li></ul><p><strong>示例代码</strong></p><p><strong>升序索引</strong></p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">-- 创建升序索引</span></span><br><span class="line"><span class="keyword">CREATE</span> INDEX idx_a_b_c_asc <span class="keyword">ON</span> t (a, b, c);</span><br><span class="line"></span><br><span class="line"><span class="comment">-- 升序查询</span></span><br><span class="line"><span class="keyword">SELECT</span> a, c <span class="keyword">FROM</span> t <span class="keyword">WHERE</span> a <span class="operator">=</span> <span class="number">1</span> <span class="keyword">AND</span> b <span class="operator">=</span> <span class="number">2</span> <span class="keyword">ORDER</span> <span class="keyword">BY</span> c <span class="keyword">ASC</span>;</span><br></pre></td></tr></table></figure><p><strong>降序索引</strong></p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">-- 创建降序索引</span></span><br><span class="line"><span class="keyword">CREATE</span> INDEX idx_a_b_c_desc <span class="keyword">ON</span> t (a, b, c <span class="keyword">DESC</span>);</span><br><span class="line"></span><br><span class="line"><span class="comment">-- 降序查询</span></span><br><span class="line"><span class="keyword">SELECT</span> a, c <span class="keyword">FROM</span> t <span class="keyword">WHERE</span> a <span class="operator">=</span> <span class="number">1</span> <span class="keyword">AND</span> b <span class="operator">=</span> <span class="number">2</span> <span class="keyword">ORDER</span> <span class="keyword">BY</span> c <span class="keyword">DESC</span>;</span><br></pre></td></tr></table></figure><p>综上所述，选择升序索引还是降序索引取决于查询中 <code>ORDER BY</code> 子句的排序方向。</p>]]></content>
    
    
    <summary type="html">🥧联合索引学习</summary>
    
    
    
    <category term="学习" scheme="https://outoflovenicoo.github.io/categories/%E5%AD%A6%E4%B9%A0/"/>
    
    
    <category term="MySQL" scheme="https://outoflovenicoo.github.io/tags/MySQL/"/>
    
  </entry>
  
  <entry>
    <title>Java基础面试题</title>
    <link href="https://outoflovenicoo.github.io/posts/2025-01-01-Java%E5%9F%BA%E7%A1%80.html"/>
    <id>https://outoflovenicoo.github.io/posts/2025-01-01-Java%E5%9F%BA%E7%A1%80.html</id>
    <published>2025-01-09T10:19:03.000Z</published>
    <updated>2025-03-23T14:00:00.000Z</updated>
    
    <content type="html"><![CDATA[<h1 id="2-Java"><a href="#2-Java" class="headerlink" title="2.Java"></a>2.Java</h1><p><img src="2025-01-01-Java基础/clip_image001.jpg" alt="img"></p><p>1.Java基础</p><p>1.1 BIO、NIO、AIO有什么区别</p><p><img src="2025-01-01-Java基础/clip_image003.jpg" alt="img"></p><p>1.2 Comparator与Comparable有什么区别</p><p><img src="2025-01-01-Java基础/clip_image005.jpg" alt="img"></p><p><img src="2025-01-01-Java基础/clip_image007.jpg" alt="img"></p><p><img src="2025-01-01-Java基础/clip_image009.jpg" alt="img"></p><p>1.3 说说你对Integer缓存的理解</p><p><img src="2025-01-01-Java基础/clip_image011.jpg" alt="img"></p><p>1.4 synchronized的实现原理</p><p>在JVM内部，每个Java对象都有头信息，其中包含了对象的一些元信息和状态标志。synchronized通过修改头信息的状态标志来实现锁的获取和释放。</p><p>当synchronized作用于某个对象时，它就会尝试获取这个对象的锁，如果锁没有被其他线程占用，则当前线程获取到锁，并可以执行同步代码块；如果锁已经被其他线程占用，那么当前线程就会阻塞在同步块之外，直到获取到锁才能进入同步块。</p><p>当 synchronized 作用于实例方法时，锁住的是当前实例对象（即 this）。当synchronized 作用于静态方法时，锁住的是当前类的 Class 对象。当 synchronized 作用于某个类时，此时它锁住的是整个类，而不是类的某个实例。在这种情况下，由于只有一个锁存在，所以所有使用该类的线程都需要等待锁的释放。</p><p>synchronized还支持可重入性，即在同一个线程中可以多次获取同一个锁，这样可以避免死锁问题。Java虚拟机会通过锁升级的方式来提升synchronized的效率，比如偏向锁、轻量级锁和重量级锁等机制，使得在竞争不激烈的情况下，synchronized的性能可以达到与非同步代码相当的水平。 </p><p>1.5⭐️ synchronized锁优化</p><p>轻量级锁和重量级锁的区别是轻量级锁会一直尝试获取锁，而重量级锁不会并且会阻塞</p><p>•     偏向锁：线程获取锁后在对象头记录线程标识，再次进入同步块无需额外加锁操作，提高性能。适用于锁基本无竞争场景，减少无竞争时加解锁开销。</p><p>•     轻量级锁：多个线程竞争同一锁时，JVM采用轻量级锁，以自旋方式尝试快速获取锁，不放弃CPU执行时间，避免线程阻塞和上下文切换开销。适用于短时间内锁竞争不激烈场景，自旋一段时间若未获取到锁，会升级为重量级锁。</p><p>•     重量级锁：线程对同一锁强烈竞争时，JVM将锁升级为重量级锁，此时线程进入阻塞状态等待锁释放。适用于竞争激烈场景，但因线程阻塞和上下文切换等操作，会带来较大性能开销。 </p><p>1.6 ⭐️讲讲你对ThreadLocal的理解</p><p><img src="2025-01-01-Java基础/clip_image013.jpg" alt="img"></p><p><img src="2025-01-01-Java基础/clip_image015.jpg" alt="img"></p><p>1.7 ✅JDK和JRE和JVM</p><p><img src="2025-01-01-Java基础/clip_image017.jpg" alt="img"></p><p>1.8 ✅什么是字节码？采用字节码的好处是什么？</p><p><img src="2025-01-01-Java基础/clip_image019.jpg" alt="img"></p><p>1.9 为什么不全部使用 AOT 呢？</p><p>使用AOT就是直接在运行前把字节码编译成机器码然后执行，但是这样就不能支持java的运行时动态特性了。</p><p><img src="2025-01-01-Java基础/clip_image021.jpg" alt="img"></p><p>1.10 ⭐️为什么说 Java 语言“编译与解释并存”？</p><p>答：java是编译型是指java代码要先编译成.Class字节码，jvm才能运行。此外，在jvm里面，热点代码通过JIT会直接编译成机器码然后执行。</p><p>Java是解释型语言是指，字节码在Jvm中的执行是通过解释器一句一句解释成机器码然后才能执行的。</p><p><img src="2025-01-01-Java基础/clip_image023.jpg" alt="img"></p><p><img src="2025-01-01-Java基础/clip_image025.jpg" alt="img"></p><p>1.11 基本类型和包装类型的区别？</p><p><img src="2025-01-01-Java基础/clip_image027.jpg" alt="img"></p><p>1.12 为什么浮点数运算的时候会有精度丢失的风险？</p><p><img src="2025-01-01-Java基础/clip_image029.jpg" alt="img"></p><p>1.13 面向对象三特征：封装、继承、多态</p><p><img src="2025-01-01-Java基础/clip_image031.jpg" alt="img"></p><p><img src="2025-01-01-Java基础/clip_image033.jpg" alt="img"></p><p>1.14 ⭐️向上转型，向下转型</p><p><img src="2025-01-01-Java基础/clip_image035.jpg" alt="img"></p><p>1.15 ✅为什么要有 hashCode？</p><p><img src="2025-01-01-Java基础/clip_image037.jpg" alt="img"></p><p>1.16 intern 方法有什么作用？</p><p>字符串常量池在堆里面。</p><p>运行时常量池在元空间（方法区）里面</p><p><img src="2025-01-01-Java基础/clip_image039.jpg" alt="img"></p><p>1.17 ✅Java异常体系</p><p><img src="2025-01-01-Java基础/clip_image041.jpg" alt="img"></p><p><img src="2025-01-01-Java基础/clip_image043.jpg" alt="img"></p><p>1.18 ⭐️注解的解析方法有哪几种？</p><p>Java中注解需被解析才生效，常见解析方法有：</p><p>•     编译期直接扫描：编译器编译Java代码时扫描并处理对应注解。如@Override注解，编译器会检测方法是否重写父类对应方法，用于在编译阶段进行语法和逻辑的检查，确保代码符合重写规范。</p><p>•     运行期通过反射处理：像Spring框架的@Value、@Component等框架自带注解，利用反射机制在运行时获取类、方法、字段等信息，并根据注解定义的规则进行相应处理，如依赖注入、组件注册等操作，增强了框架的灵活性和扩展性。 </p><p>2.Java集合</p><p>2.1 ArrayList怎么做的数组扩容</p><p><img src="2025-01-01-Java基础/clip_image045.jpg" alt="img"></p><p>2.2 什么是 fail-fast， 什么是 fail-safe</p><p><img src="2025-01-01-Java基础/clip_image047.jpg" alt="img"></p><p>2.3 如何实现数组和 List 之间的转换？</p><p><img src="2025-01-01-Java基础/clip_image049.jpg" alt="img"></p><p>2.4 ⭐️HashSet实现原理</p><p><img src="2025-01-01-Java基础/clip_image051.jpg" alt="img"></p><p>2.5 HashMap工作原理</p><p>HashMap基于哈希表工作，哈希表利用哈希函数将键映射到存储位置：</p><p>•     哈希映射：计算键的哈希值并转化为数组索引，以此快速定位键值对存储位置。理想状态下，哈希函数让键均匀分布，减少哈希冲突。</p><p>•     解决哈希冲突：</p><p>￮    Java 1.7：主要用链表解决，相同哈希值的键值对链接在一起。</p><p>￮    Java 1.8：当链表长度和数组长度超一定阈值，链表转换为红黑树。红黑树是自平衡二叉搜索树，在哈希冲突较多时，查找、插入和删除操作更快。</p><p>HashMap综合哈希表、链表和红黑树原理，实现高效的键值对存储与查找功能。 </p><p>2.6 ⭐️HashMap 的PUT工作流程？</p><p><img src="2025-01-01-Java基础/clip_image053.jpg" alt="img"></p><p>2.7 比较 HashSet、 LinkedHashSet 和 TreeSet 三者的异同</p><p><img src="2025-01-01-Java基础/clip_image055.jpg" alt="img"></p><p>2.8 ⭐️Queue 与 Deque 的区别</p><p><img src="2025-01-01-Java基础/clip_image057.jpg" alt="img"></p><p>2.9 在 Queue 中 poll()和 remove（）有什么区别？</p><p><img src="2025-01-01-Java基础/clip_image059.jpg" alt="img"></p><p>2.10 ⭐️ArrayDeque 与 LinkedList 的区别</p><p><img src="2025-01-01-Java基础/clip_image061.jpg" alt="img"></p><p>ArrayDeque： ArrayDeque 内部维护了一 个循环数组，通过两个指针 （front 和 rear）来标记队列的头部 和尾部。当向队列中添加元素 时，rear 指针向后移动；当从队 列中删除元素时，front 指针向 后移动。如果数组满了， ArrayDeque 会自动扩容。 ArrayDeque 的底层数组长度是2的幂次方，这样可以通 位运算来实现循环队列的操作， 提高性能。</p><p>LinkedList： LinkedList 内部使用双向链 表来存储元素。每个节点都包含 一个前驱节点和一个后继节点的 引用。通过这种方式， LinkedList 可以在任意位置高效 地插入和删除元素。 LinkedList 还有一个头结点 和尾节点的引用，分别表示链表 的头部和尾部。通过这两个引用，可以快速访问到链表的第一个和最后一个元素。</p><p>2.11 ⭐️HashMap 的长度为什么是2的幂次方</p><p><img src="2025-01-01-Java基础/clip_image063.jpg" alt="img"></p><p>2.12 ⭐️HashMap 多线程操作导致死循环问题</p><p><img src="2025-01-01-Java基础/clip_image065.jpg" alt="img"></p><p>2.13 ⭐️LinkedHashMap是什么？怎么买现的？</p><p><img src="2025-01-01-Java基础/clip_image067.jpg" alt="img"></p><p>2.14 ⭐️为什么 ConcurrentHashMap 比 HashTable 效率要高？</p><p><img src="2025-01-01-Java基础/clip_image069.jpg" alt="img"></p>]]></content>
    
    
    <summary type="html">🥧本人的Java基础面试总结</summary>
    
    
    
    <category term="面试题" scheme="https://outoflovenicoo.github.io/categories/%E9%9D%A2%E8%AF%95%E9%A2%98/"/>
    
    
    <category term="Java基础面试题" scheme="https://outoflovenicoo.github.io/tags/Java%E5%9F%BA%E7%A1%80%E9%9D%A2%E8%AF%95%E9%A2%98/"/>
    
  </entry>
  
  <entry>
    <title>MyBatis面试题</title>
    <link href="https://outoflovenicoo.github.io/posts/2025331p.html"/>
    <id>https://outoflovenicoo.github.io/posts/2025331p.html</id>
    <published>2025-01-09T10:19:03.000Z</published>
    <updated>2025-03-23T14:00:00.000Z</updated>
    
    <content type="html"><![CDATA[<h1 id="MyBatis"><a href="#MyBatis" class="headerlink" title="MyBatis"></a>MyBatis</h1><h2 id="1-什么是MyBatis"><a href="#1-什么是MyBatis" class="headerlink" title="1. 什么是MyBatis?"></a>1. 什么是MyBatis?</h2><p><img src="https://mcnfxurl5vzo.feishu.cn/space/api/box/stream/download/asynccode/?code=NWU3OGM0OWExNWVlYzY5MGJkNmNlZGU2NDZjN2YwODNfNXRjcUNzNWdDbEJBUDJINjhJejlxMEtEd1oyR3JHUmNfVG9rZW46Q1NmRGI0djBxb3BpVVd4cXROOGNuWXZ5blJiXzE3NDMzODkxNTM6MTc0MzM5Mjc1M19WNA" alt="img"></p><h2 id="2-Mybaits-的优点-amp-缺点"><a href="#2-Mybaits-的优点-amp-缺点" class="headerlink" title="2. Mybaits 的优点 &amp; 缺点"></a>2. Mybaits 的优点 &amp; 缺点</h2><p><img src="https://mcnfxurl5vzo.feishu.cn/space/api/box/stream/download/asynccode/?code=MzFlM2EzNDkzOWZiZjUxYmE4NWFkOTA2MzRjMjY3NDFfdEJMZm01TmFpZFY1b2xYUERoZmhsbWtKeW1uWWkweWFfVG9rZW46Q01wY2JnZnVab205b1N4THNvWGMyanB1bmZlXzE3NDMzODkxNTM6MTc0MzM5Mjc1M19WNA" alt="img"></p><h2 id="3-MyBatis的核心组件有哪些？"><a href="#3-MyBatis的核心组件有哪些？" class="headerlink" title="3. MyBatis的核心组件有哪些？"></a>3. MyBatis的核心组件有哪些？</h2><p><img src="https://mcnfxurl5vzo.feishu.cn/space/api/box/stream/download/asynccode/?code=ODAyNjFhYTJiYjllODY2YjYxNWE4Yjk0ODZiNGU1N2FfbUVvUXkzNnlhbnc2VXlkMWloWVJ6ZHBvVlFvYWRXRWRfVG9rZW46QVRpTWJncGdUbzVKN2J4OThCSWNlMlM3bjJlXzE3NDMzODkxNTM6MTc0MzM5Mjc1M19WNA" alt="img"></p><h2 id="4-⭐️MyBatis的工作流程是怎样的？"><a href="#4-⭐️MyBatis的工作流程是怎样的？" class="headerlink" title="4. ⭐️MyBatis的工作流程是怎样的？"></a>4. ⭐️MyBatis的工作流程是怎样的？</h2><p><img src="https://mcnfxurl5vzo.feishu.cn/space/api/box/stream/download/asynccode/?code=NjM5ODc0MjhiYmQ1YTc4OTU1YWE4YzkzNGVkMzBmYjJfbW4zYlJ3S1N5WnFqdGFja3dHa3F3dHNMem96Q2U0U0dfVG9rZW46SDBWWmI5TDRGbzVTOTB4VlVPZmNweWxkbjZkXzE3NDMzODkxNTM6MTc0MzM5Mjc1M19WNA" alt="img"></p><h2 id="5-⭐️MyBatis一二级缓存的区别？"><a href="#5-⭐️MyBatis一二级缓存的区别？" class="headerlink" title="5. ⭐️MyBatis一二级缓存的区别？"></a>5. ⭐️MyBatis一二级缓存的区别？</h2><p><img src="https://mcnfxurl5vzo.feishu.cn/space/api/box/stream/download/asynccode/?code=OTEyZjBjN2MyYjE2OGRhNGQ2ZDY5NDg2ZTZmNTRhYWFfazJieW5sazBkN1I5T2IwbGZ1V2xLeHR3dHN3VHF3NTRfVG9rZW46TkZTb2JaeWNOb1JuN1p4NFBUQWNWalRQbjFkXzE3NDMzODkxNTM6MTc0MzM5Mjc1M19WNA" alt="img"></p><h2 id="6-MyBatis如何处理延迟加载？"><a href="#6-MyBatis如何处理延迟加载？" class="headerlink" title="6.MyBatis如何处理延迟加载？"></a>6.MyBatis如何处理延迟加载？</h2><p><img src="https://mcnfxurl5vzo.feishu.cn/space/api/box/stream/download/asynccode/?code=NTk4ZGZkYWE4YTdlYjdhZjhkNDFiZmEyN2ViNjgxMTNfdTZ3bWEzZWY2N2ZtZEI2RG8yWWdzdk5Jekl1OXRVWHZfVG9rZW46RzQ2QmJJWFUwb1Q4emx4WHJmSmM2N2hTbmllXzE3NDMzODkxNTM6MTc0MzM5Mjc1M19WNA" alt="img"></p><h2 id="7-⭐️MyBatis中的动态SQL是什么？"><a href="#7-⭐️MyBatis中的动态SQL是什么？" class="headerlink" title="7. ⭐️MyBatis中的动态SQL是什么？"></a>7. ⭐️MyBatis中的动态SQL是什么？</h2><p><img src="https://mcnfxurl5vzo.feishu.cn/space/api/box/stream/download/asynccode/?code=N2Y1NGUzY2I5ZTYxZDMwNTEzMTdkOTQ3MmY1MjJhMzJfc2E1QmlhY004SkNpRjZrdHE3MU5QcFFGSkZvZkpKcnhfVG9rZW46QVdDUGIxamR4b0xkNjN4NEJiRmNDaUZTblliXzE3NDMzODkxNTM6MTc0MzM5Mjc1M19WNA" alt="img"></p><p><img src="https://mcnfxurl5vzo.feishu.cn/space/api/box/stream/download/asynccode/?code=NjUwODViOWZjYWEzNjRlZmUzMTY1YzVhMmE5MDhiNjdfanpSM3N0VWZqaGpzQWZMU1hnSmZQdTNFUnYzVGFQTXhfVG9rZW46S2dzN2JZQ3ZIb0hCQUV4VDdiUGNBdUpKblRkXzE3NDMzODkxNTM6MTc0MzM5Mjc1M19WNA" alt="img"></p><h2 id="8-⭐️MyBatis中XML映射有哪些标签？"><a href="#8-⭐️MyBatis中XML映射有哪些标签？" class="headerlink" title="8. ⭐️MyBatis中XML映射有哪些标签？"></a>8. ⭐️MyBatis中XML映射有哪些标签？</h2><p><img src="https://mcnfxurl5vzo.feishu.cn/space/api/box/stream/download/asynccode/?code=Njk0ZTQzYWVlZDk4MTM5MGQwMWY2MmZmMmRiMjdiNTdfOUdQTFZQYTV1ZWliMHRpVVJ6emJwRlRnWndDOE5YZXZfVG9rZW46QlZWV2JTWFNLbzY0elB4OTlUbmNJZkF0bkdoXzE3NDMzODkxNTM6MTc0MzM5Mjc1M19WNA" alt="img"></p><h2 id="9-模糊查询-like-语句该怎么写？"><a href="#9-模糊查询-like-语句该怎么写？" class="headerlink" title="9. 模糊查询 like 语句该怎么写？"></a>9. 模糊查询 like 语句该怎么写？</h2><p><img src="https://mcnfxurl5vzo.feishu.cn/space/api/box/stream/download/asynccode/?code=YjM1ODcxZGY3YjEyMmYyMWQyZjNjOGM2ODgxM2Y2ZjdfVzA0SWQxeXpIbVBvMXZWbHFtdHp4NlVFaG5oM01pYkpfVG9rZW46SElUb2J3NkV4bzVFSFJ4NkFFTGNRdWlXbk9iXzE3NDMzODkxNTM6MTc0MzM5Mjc1M19WNA" alt="img"></p><h2 id="10-⭐️-和-的区别是什么？"><a href="#10-⭐️-和-的区别是什么？" class="headerlink" title="10. ⭐️#{}和${}的区别是什么？"></a>10. ⭐️#{}和${}的区别是什么？</h2><p><img src="https://mcnfxurl5vzo.feishu.cn/space/api/box/stream/download/asynccode/?code=M2I2MmNlZmJmZTdjMmVkMTlmZmI2ZGU1N2NkNjc5ZGZfdWY5WnI3UmI0dXlrdmZtVkJXdzFRWmE2N1BIS05jakJfVG9rZW46UThwbGJMUXBwb3c3UWd4SlZubGNwak1ablNnXzE3NDMzODkxNTM6MTc0MzM5Mjc1M19WNA" alt="img"></p><p><img src="https://mcnfxurl5vzo.feishu.cn/space/api/box/stream/download/asynccode/?code=ODU3ZDNjNzAxZmUyYzBmM2U1MzcxMjdiMTE0YmZkNjhfcTFUcnlDQWdybWgyNXpoYVN1VXA1TmdHWEhwSlhSN2JfVG9rZW46THZVcmI4c3ppb2RyZVV4aXNYNGNwdkdlbmlnXzE3NDMzODkxNTM6MTc0MzM5Mjc1M19WNA" alt="img"></p><h2 id="11-讲讲MyBatis中二级缓存的缺点？"><a href="#11-讲讲MyBatis中二级缓存的缺点？" class="headerlink" title="11. 讲讲MyBatis中二级缓存的缺点？"></a>11. 讲讲MyBatis中二级缓存的缺点？</h2><p><img src="https://mcnfxurl5vzo.feishu.cn/space/api/box/stream/download/asynccode/?code=OGFiYjFhMTU0NzQ5MmZjYzlmZGFiYmMwZGJkMTBjZWFfbzVwWjFDaWlPYzdnNHJ4U05NWnlKc1JlMm1CN2VzRzVfVG9rZW46VEJWZmJKQ1pHbzRBTzJ4ZkNaVWN0bWw5bnRlXzE3NDMzODkxNTM6MTc0MzM5Mjc1M19WNA" alt="img"></p><h2 id="12-为什么说-Mybatis-是半ORM-映射工具？"><a href="#12-为什么说-Mybatis-是半ORM-映射工具？" class="headerlink" title="12. 为什么说 Mybatis 是半ORM 映射工具？"></a>12. 为什么说 Mybatis 是半ORM 映射工具？</h2><p><img src="https://mcnfxurl5vzo.feishu.cn/space/api/box/stream/download/asynccode/?code=Yjc0YWMzM2MzZjA3ODE0MTU3ODY2YzY1ZjQzMGRiMTBfV2I0NkJpN1g2ZTRhWXNhNnJDZjlEOHhIYXZzMGtkYTBfVG9rZW46UENyOGJlUTBvb2cwNkN4WWNCVWNLUEVKbmxiXzE3NDMzODkxNTM6MTc0MzM5Mjc1M19WNA" alt="img"></p><h2 id="13-⭐️如何在-MyBatis-中进行分页查询？"><a href="#13-⭐️如何在-MyBatis-中进行分页查询？" class="headerlink" title="13. ⭐️如何在 MyBatis 中进行分页查询？"></a>13. ⭐️如何在 MyBatis 中进行分页查询？</h2><p><img src="https://mcnfxurl5vzo.feishu.cn/space/api/box/stream/download/asynccode/?code=NjFlYzc3Zjc0MzJjODFkYWNjYjRmYTg1ZjIzZGQxZTFfakZCc0ZrNWdUR0Y0SlROMnJKZHJiZzZWdkRHMjFYUVlfVG9rZW46QWpGOGIyeGVmb3V0WlV4Nkxib2NHVTA5bmxlXzE3NDMzODkxNTM6MTc0MzM5Mjc1M19WNA" alt="img"></p><p><img src="https://mcnfxurl5vzo.feishu.cn/space/api/box/stream/download/asynccode/?code=YTJjZGQwZjc1M2U3YmYyN2ZkOWI3OTc2MjgxYWNjOTNfZXZNcm1GR0I3WllWRVJweDJjVVBJbWN0cG5LREk0YTFfVG9rZW46TGxyOGJvVmozb2F6STh4MWtIS2NhRlhYbmdoXzE3NDMzODkxNTM6MTc0MzM5Mjc1M19WNA" alt="img"></p><h2 id="14-Mybatis和Hibernate的区别是什么？"><a href="#14-Mybatis和Hibernate的区别是什么？" class="headerlink" title="14. Mybatis和Hibernate的区别是什么？"></a>14. Mybatis和Hibernate的区别是什么？</h2><p><img src="https://mcnfxurl5vzo.feishu.cn/space/api/box/stream/download/asynccode/?code=ZmM0N2E5YjUxZGQ0YzI3MTM4YzFiNWY0MmVmYzgzYjJfcVBXSlhhSmFCMXhKTjRQUlV6UzNmb3FnbDVIMWpNNXZfVG9rZW46RjVRNGJJY0xyb0Z6cEN4aEpGR2NNeW85bkJjXzE3NDMzODkxNTM6MTc0MzM5Mjc1M19WNA" alt="img"></p><h2 id="15-JDBC编程有哪些不足之处，MyBatis是如何解决这些问题的？"><a href="#15-JDBC编程有哪些不足之处，MyBatis是如何解决这些问题的？" class="headerlink" title="15. JDBC编程有哪些不足之处，MyBatis是如何解决这些问题的？"></a>15. JDBC编程有哪些不足之处，MyBatis是如何解决这些问题的？</h2><p><img src="https://mcnfxurl5vzo.feishu.cn/space/api/box/stream/download/asynccode/?code=ZjE1MTExMzkzODVjYzdhMTk5MGI0Mjc2MWNlMDMyZGNfNzlJV2NCd1dZUURwYW9ZU0ZobWxBcGlYb3BjeThieDFfVG9rZW46VzNrMmJXMlB2b3NrMzl4ZUk0OWNkUW1hbkFkXzE3NDMzODkxNTM6MTc0MzM5Mjc1M19WNA" alt="img"></p><h2 id="16-MyBatis编程步骤是什么样的？"><a href="#16-MyBatis编程步骤是什么样的？" class="headerlink" title="16. MyBatis编程步骤是什么样的？"></a>16. MyBatis编程步骤是什么样的？</h2><p><img src="https://mcnfxurl5vzo.feishu.cn/space/api/box/stream/download/asynccode/?code=ZTNjNTVkMTdiMTljZTg4MGNiZTc4M2ZjMTIxZWZlYzVfOHVubEdxQnVMczYwbnVhNk9weEU4YXdoaWtEZVRKV2FfVG9rZW46TXA1bmJSbDZ3b0pCN3p4RTNoQ2M5b2JXbnFmXzE3NDMzODkxNTM6MTc0MzM5Mjc1M19WNA" alt="img"></p><h2 id="17-Mybatis如何防止SQL注入？"><a href="#17-Mybatis如何防止SQL注入？" class="headerlink" title="17. Mybatis如何防止SQL注入？"></a>17. Mybatis如何防止SQL注入？</h2><p><img src="https://mcnfxurl5vzo.feishu.cn/space/api/box/stream/download/asynccode/?code=N2M0YjlkODM0MWNhYTNiZDMzNzg4ZmUwMTE0NzI3ZWZfbUJXMWtUZkh0elRTNmdNenVNbEU2OURObVNXbjM1OE9fVG9rZW46SlcyOWJSNjVlb0hDZHR4dW14VGM3UGhObk5nXzE3NDMzODkxNTM6MTc0MzM5Mjc1M19WNA" alt="img"></p><h2 id="⭐️18-Xml-映射文件中，除了常见的-select，insert，upcaeldelete-标签之外，还有哪些标签？"><a href="#⭐️18-Xml-映射文件中，除了常见的-select，insert，upcaeldelete-标签之外，还有哪些标签？" class="headerlink" title="⭐️18.Xml 映射文件中，除了常见的 select，insert，upcaeldelete 标签之外，还有哪些标签？"></a>⭐️18.Xml 映射文件中，除了常见的 select，insert，upcaeldelete 标签之外，还有哪些标签？</h2><p><img src="https://mcnfxurl5vzo.feishu.cn/space/api/box/stream/download/asynccode/?code=MDk5MTM5NzUwYzUyMDYwNTk0ODVjOWRmOWZmM2RlMDhfZ0gxRUJocG9EUjhtbkx0N0g2OGg5RmFSQ2dOU2E1dUxfVG9rZW46RFEwa2JZTmpBbzRjRzJ4bUx1UmN4Z2xFblBnXzE3NDMzODkxNTM6MTc0MzM5Mjc1M19WNA" alt="img"></p><p><img src="https://mcnfxurl5vzo.feishu.cn/space/api/box/stream/download/asynccode/?code=Yjk0ZGRiMjQxNzc4MDVmMDQ4NmQ2YThiNTZhMWZjMzRfaUxMaUlmUHFxSjE0RXdJb1VCYzRNaWFON2NEVURQNm9fVG9rZW46VW8ybWJkWDJ2b2JnblZ4MEw5c2NxN0lJblBlXzE3NDMzODkxNTM6MTc0MzM5Mjc1M19WNA" alt="img"></p><p><img src="https://mcnfxurl5vzo.feishu.cn/space/api/box/stream/download/asynccode/?code=ZDg5YTUwZmI1ZmZiZjliN2RhMmQ5MGE0MzcyNjNjOWVfYndDWlJaa2JmNG1Kb3pWQU8yWVA5RXlUZ3N5Q2dCeWlfVG9rZW46Vm4zZGJpeHE1b20wd214TVpBY2NPcFU3bkhmXzE3NDMzODkxNTM6MTc0MzM5Mjc1M19WNA" alt="img"></p><p><img src="https://mcnfxurl5vzo.feishu.cn/space/api/box/stream/download/asynccode/?code=OWQzMmQyNzczNzgwNTA3YmFmODlhYWY4MjQ4NzM0NDRfc2lBaWg5OFUwTE0zdnUyaXFDbmFxdHJSZHdlTVBYTnBfVG9rZW46RVVEeGI3QU93bzZ1ZG94N29PS2NzZVZRbjlnXzE3NDMzODkxNTM6MTc0MzM5Mjc1M19WNA" alt="img"></p><h2 id="19-Mybatis都有哪些Executor执行器？它们之间的区别是什么？"><a href="#19-Mybatis都有哪些Executor执行器？它们之间的区别是什么？" class="headerlink" title="19. Mybatis都有哪些Executor执行器？它们之间的区别是什么？"></a>19. Mybatis都有哪些Executor执行器？它们之间的区别是什么？</h2><p><img src="https://mcnfxurl5vzo.feishu.cn/space/api/box/stream/download/asynccode/?code=MWRhODk3MTMzZjZlNjEyN2I4OGI1MWMxM2ExN2QzNGZfMVdGOXZQdFJUVnVFVnJlaUpxVGR5aTN5MU1lNGx5d1VfVG9rZW46QU96MWJYd3Rvb0xGelJ4MndMdmNFQzEwbnVnXzE3NDMzODkxNTM6MTc0MzM5Mjc1M19WNA" alt="img"></p><p><img src="https://mcnfxurl5vzo.feishu.cn/space/api/box/stream/download/asynccode/?code=YWFjZjQzYzZiY2MwZWY0Mjk3YjQxMDJmMDUwZGVhMmJfRDBFdHFNVElkbTNGQUZXUHAwUDdjNlloOWxjeTVQUTFfVG9rZW46STdoWGJ1NzRqb2ZCa0F4WlJ0ZGNFRDFibkhTXzE3NDMzODkxNTM6MTc0MzM5Mjc1M19WNA" alt="img"></p><h2 id="20-⭐️MyBatis-工作原理是什么？"><a href="#20-⭐️MyBatis-工作原理是什么？" class="headerlink" title="20. ⭐️MyBatis 工作原理是什么？"></a>20. ⭐️MyBatis 工作原理是什么？</h2><p><img src="https://mcnfxurl5vzo.feishu.cn/space/api/box/stream/download/asynccode/?code=OTc4MzE0ZjAyZGU0ZTUwODg0OWVlOTc2N2Q1YTQxNGNfdDRnY1RZdkZ0MldsMUgzQThWVTBmMFpkNGZQZGQxYWZfVG9rZW46UUtTRmJEbHEzb1BBSkp4ZGNGSGNrbndybktnXzE3NDMzODkxNTM6MTc0MzM5Mjc1M19WNA" alt="img"></p><p><img src="https://mcnfxurl5vzo.feishu.cn/space/api/box/stream/download/asynccode/?code=MTZhOWY1YzJlMzBhYjJlZjg1OWI2MjVkMjNkMDBkM2ZfbXpoMmYwdXZTV3BSWXd6ZTBWV1pDUGNSMmVaczBPQVhfVG9rZW46Q2tKd2JwVmg2b1Y1MUV4R0lPM2NGQTdXblAyXzE3NDMzODkxNTM6MTc0MzM5Mjc1M19WNA" alt="img"></p><h2 id="21-⭐️Mybatis-能执行一对一、一对多的关联查询吗？"><a href="#21-⭐️Mybatis-能执行一对一、一对多的关联查询吗？" class="headerlink" title="21. ⭐️Mybatis 能执行一对一、一对多的关联查询吗？"></a>21. ⭐️Mybatis 能执行一对一、一对多的关联查询吗？</h2><p><img src="https://mcnfxurl5vzo.feishu.cn/space/api/box/stream/download/asynccode/?code=NmQ1NjI3ZDgzMDgwMzRjZDY2YmM4NjcwZWM5ZjQ3MDFfQkFQQlQ5bTEwdk95VVFPb053cDNhbXBqcmJyZENFRjVfVG9rZW46Q3J2cmI4cU9Ub2ZMa0x4cFZZdWNzWVBBbjVjXzE3NDMzODkxNTM6MTc0MzM5Mjc1M19WNA" alt="img"></p><p><img src="https://mcnfxurl5vzo.feishu.cn/space/api/box/stream/download/asynccode/?code=NWQ0NzU3YWQwODVhNjc5MDhiOTNjOGQxZjg3OGM3MmRfd04zUE5HVXJ4Q01ZOGlSektjUEdkZUZpWXRXSnl1VE5fVG9rZW46TEM1YmJqRnJJb01YVVZ4Y0ZyQ2Naajh0bkRkXzE3NDMzODkxNTM6MTc0MzM5Mjc1M19WNA" alt="img"></p><h2 id="22-⭐️-Mybatis-是否支持延迟加载？原理？"><a href="#22-⭐️-Mybatis-是否支持延迟加载？原理？" class="headerlink" title="22.⭐️ Mybatis 是否支持延迟加载？原理？"></a>22.⭐️ Mybatis 是否支持延迟加载？原理？</h2><p><img src="https://mcnfxurl5vzo.feishu.cn/space/api/box/stream/download/asynccode/?code=OTdmNTRiMDY0M2Q3Mjc2NjM2ZjI1OTI0Y2E3OGFiYzlfN2Q2NGw5R3l0Rk9VRWRjRVU1c0c5bnR4TjBxY3pRTWpfVG9rZW46VG1INWJrVFU1b3BJRUJ4OU1lYmNNQmFwbkJhXzE3NDMzODkxNTM6MTc0MzM5Mjc1M19WNA" alt="img"></p><h2 id="23-⭐️什么是MyBatis的接口绑定？有哪些实现方式？"><a href="#23-⭐️什么是MyBatis的接口绑定？有哪些实现方式？" class="headerlink" title="23. ⭐️什么是MyBatis的接口绑定？有哪些实现方式？"></a>23. ⭐️什么是MyBatis的接口绑定？有哪些实现方式？</h2><p><img src="https://mcnfxurl5vzo.feishu.cn/space/api/box/stream/download/asynccode/?code=OWZmNzdkZjU4NjIzYzQ4MGJiNGJhZjRjYjdhYjNiMDNfOExrZm5ueWZMVVJvYnlNSTh4eG5xbng2S0RKODZuT0RfVG9rZW46TENjUGJWeWM2b3g1VVh4U1ZYYmNVelJxbkdjXzE3NDMzODkxNTM6MTc0MzM5Mjc1M19WNA" alt="img"></p><h2 id="24-⭐️Mybatis是如何将sql执行结果封装为目标对象并返回的？都有哪些映射形式？"><a href="#24-⭐️Mybatis是如何将sql执行结果封装为目标对象并返回的？都有哪些映射形式？" class="headerlink" title="24. ⭐️Mybatis是如何将sql执行结果封装为目标对象并返回的？都有哪些映射形式？"></a>24. ⭐️Mybatis是如何将sql执行结果封装为目标对象并返回的？都有哪些映射形式？</h2><p><img src="https://mcnfxurl5vzo.feishu.cn/space/api/box/stream/download/asynccode/?code=OTY5ZjA2MmUxMGM2MjYwYjg1ODRhMjEyOTVlMzA4Y2NfU2N0ZW1VdURUMjlNTXBrZ3Q0ajRnZEpKdkM2MXFWMlZfVG9rZW46RDVxcGJuNXZGb1huYU94TEtuTWNJYnlUbmhoXzE3NDMzODkxNTM6MTc0MzM5Mjc1M19WNA" alt="img"></p><h2 id="25-⭐️-Mybatis的Xml映射文件中，不同的Xml映射文件，id是否可以重复？"><a href="#25-⭐️-Mybatis的Xml映射文件中，不同的Xml映射文件，id是否可以重复？" class="headerlink" title="25.⭐️ Mybatis的Xml映射文件中，不同的Xml映射文件，id是否可以重复？"></a>25.⭐️ Mybatis的Xml映射文件中，不同的Xml映射文件，id是否可以重复？</h2><p><img src="https://mcnfxurl5vzo.feishu.cn/space/api/box/stream/download/asynccode/?code=YzkwNjllNWE2ODE5MzIyMzU5NGMxNDgzOGU1NGI3YjRfR2dIdnoyUlZJTE9OVHJzc2IzeXlqOWdBT29SRkVPR05fVG9rZW46TTJoc2JJeEYxbzdDd0J4TEF2OWM0RTUzbkFiXzE3NDMzODkxNTM6MTc0MzM5Mjc1M19WNA" alt="img"></p><h2 id="26-⭐️MyBatis-如何执行批量操作？"><a href="#26-⭐️MyBatis-如何执行批量操作？" class="headerlink" title="26. ⭐️MyBatis 如何执行批量操作？"></a>26. ⭐️MyBatis 如何执行批量操作？</h2><p><img src="https://mcnfxurl5vzo.feishu.cn/space/api/box/stream/download/asynccode/?code=NTE0MTEyMGRmNmU3M2JiMDM1NTk2MmEwYzFhN2YzMGZfYlBMdVlyZkg4VnczMUpOVTNrbFlWdXlXYTk5TWVTcnpfVG9rZW46QjlMZGJWeDNZb2doMFl4Tk9RS2NLMDB5bklkXzE3NDMzODkxNTM6MTc0MzM5Mjc1M19WNA" alt="img"></p><p><img src="https://mcnfxurl5vzo.feishu.cn/space/api/box/stream/download/asynccode/?code=MzY2YWM1NjM0ODQ3YTkyYTgxYmM0MmY2ZmY4ZjdiNGJfd291dU9GN1RySjBpc2lwcGVkVnlCUzkwN0gzbno5ZURfVG9rZW46WHNtaGJDTjRCb1RkeU14QUpDeGNJTDRsbk5jXzE3NDMzODkxNTM6MTc0MzM5Mjc1M19WNA" alt="img"></p><p><img src="https://mcnfxurl5vzo.feishu.cn/space/api/box/stream/download/asynccode/?code=ZmYyMzIzMzU4M2ZkMzc0MTIzMTY2Yjk5Njg0ZWM2MTlfTlFocTM3amNkU2x2bVR0d0dBU0U5YTdwZjVvWW9nRG5fVG9rZW46SHhNcGIxUlhMb2dEa094aGszVWNnaDh3bmFmXzE3NDMzODkxNTM6MTc0MzM5Mjc1M19WNA" alt="img"></p><p><img src="https://mcnfxurl5vzo.feishu.cn/space/api/box/stream/download/asynccode/?code=MGQ5YWZlODVmNTgzZWQyNWVjMzliZDVkMmQwYzFhMTdfR2xGVWZXM1pMUnpMSXBxS1VXaDZHRDdKaGR1b3JiY29fVG9rZW46QW5TTGJKa1JOb2I4T0N4amZ0NGNoeWR5bkdlXzE3NDMzODkxNTM6MTc0MzM5Mjc1M19WNA" alt="img"></p><h2 id="27-⭐️在mapper-中如何传递多个参数？"><a href="#27-⭐️在mapper-中如何传递多个参数？" class="headerlink" title="27. ⭐️在mapper 中如何传递多个参数？"></a>27. ⭐️在mapper 中如何传递多个参数？</h2><p><img src="https://mcnfxurl5vzo.feishu.cn/space/api/box/stream/download/asynccode/?code=YTFkOTA0ZTc5ZTNiOTkwZTgxZjA4MjMzMzI0MzBiYjhfYUp2V0syblJjWjNiTWFSbElkUVJJTlpHbk9rNXdhOXBfVG9rZW46RVlUTmJQSlpFb2NjWWh4emNNM2NFNE5LbnBoXzE3NDMzODkxNTM6MTc0MzM5Mjc1M19WNA" alt="img"></p><p><img src="https://mcnfxurl5vzo.feishu.cn/space/api/box/stream/download/asynccode/?code=M2M4MDcwNjY4ZGMxYTA5ZGQyMTgxMTllMzZiY2ZjNjhfQ3NUcG5OYXZ5V1RyMXpEVnRPdVNJZzhWR1kzN0V1MUlfVG9rZW46VDlRc2JrRGF2b1NxQTF4UWdtOGNuSWZvbm5tXzE3NDMzODkxNTM6MTc0MzM5Mjc1M19WNA" alt="img"></p><p><img src="https://mcnfxurl5vzo.feishu.cn/space/api/box/stream/download/asynccode/?code=MzcwYzJjODg2ZTZiZjljY2YxNWUxMDkyOThhNDlmZWRfNEQ2eVpqSnBHYkZHdXZsMWJwZ3lQWU5kSURzd3BZaGdfVG9rZW46Skk4NmI4Z2tab2xQZXR4NlFSZmM0MzYzbnhoXzE3NDMzODkxNTM6MTc0MzM5Mjc1M19WNA" alt="img"></p><h2 id="28-⭐️简述Mybatis的插件运行原理，以及如何编写一个插件？"><a href="#28-⭐️简述Mybatis的插件运行原理，以及如何编写一个插件？" class="headerlink" title="28. ⭐️简述Mybatis的插件运行原理，以及如何编写一个插件？"></a>28. ⭐️简述Mybatis的插件运行原理，以及如何编写一个插件？</h2><p><img src="https://mcnfxurl5vzo.feishu.cn/space/api/box/stream/download/asynccode/?code=MDJjYmFlNjE1NzdiNTg2ZWYxZWY4NzBkZWIxY2I0NzdfQ3lJVFdzZXdmdjFRRjhaalo1UDFKZ1ViR085dmxKbXRfVG9rZW46RVN2UWJrTVdyb2xCdGt4Rnl0OWNhZTRrbkplXzE3NDMzODkxNTM6MTc0MzM5Mjc1M19WNA" alt="img"></p><h2 id="29-⭐️分页插件的原理是什么？"><a href="#29-⭐️分页插件的原理是什么？" class="headerlink" title="29. ⭐️分页插件的原理是什么？"></a>29. ⭐️分页插件的原理是什么？</h2><p><img src="https://mcnfxurl5vzo.feishu.cn/space/api/box/stream/download/asynccode/?code=ZWQxMjJlZDAzZjA3OWY1NGU0NGE1NWQ4M2E4MzMwMGVfeE94Z2NSbmY0MzNFTjZZUFlUQmk1ZTJnV0xBQXhIcURfVG9rZW46UGYwZ2JCOEFFb2NJeTR4M3I1RmM4WW9IbmdMXzE3NDMzODkxNTM6MTc0MzM5Mjc1M19WNA" alt="img"></p>]]></content>
    
    
    <summary type="html">🥧本人的MyBatis面试题总结</summary>
    
    
    
    <category term="面试题" scheme="https://outoflovenicoo.github.io/categories/%E9%9D%A2%E8%AF%95%E9%A2%98/"/>
    
    
    <category term="MyBatis" scheme="https://outoflovenicoo.github.io/tags/MyBatis/"/>
    
  </entry>
  
  <entry>
    <title>Rabbitmq面试题</title>
    <link href="https://outoflovenicoo.github.io/posts/2025331m.html"/>
    <id>https://outoflovenicoo.github.io/posts/2025331m.html</id>
    <published>2025-01-09T10:19:03.000Z</published>
    <updated>2025-03-23T14:00:00.000Z</updated>
    
    <content type="html"><![CDATA[<h1 id="PS"><a href="#PS" class="headerlink" title="PS:"></a>PS:</h1><p><strong>面试题总结自小林Coding，仅供个人学习使用，如有侵权可联系删除</strong></p><h1 id="概念："><a href="#概念：" class="headerlink" title="概念："></a>概念：</h1><h2 id="1-AMQP协议？"><a href="#1-AMQP协议？" class="headerlink" title="1. AMQP协议？"></a>1. AMQP协议？</h2><p>AMQP，即Advanced Message Queuing Protocol，高级消息队列协议，是应用层协议的开放标准，为面向消息的中间件设计。消息中间件用于组件解耦，发送者和使用者相互无感知。其主要特征包括面向消息、队列、路由、可靠性、安全性。RabbitMQ是开源的AMQP实现，服务器端用Erlang编写，支持多种客户端，用于分布式系统存储转发消息，在易用性等方面表现好。</p><p><strong>AMQP**</strong>三层协议**</p><ul><li><strong>Module Layer</strong>：最高层，定义客户端调用命令，用于实现业务逻辑。</li><li><strong>Session Layer</strong>：中间层，负责客户端命令与服务器应答传输，提供可靠性同步和错误处理。</li><li><strong>Transport Layer</strong>：最底层，传输二进制数据流，提供帧处理等功能。</li></ul><p><strong>AMQP**</strong>组件**</p><ul><li><strong>交换器**</strong>(Exchange)**：将消息路由到队列的组件。</li><li><strong>队列 (queue)</strong>：存储消息的数据结构，位于硬盘或内存。</li><li><strong>绑定 (Binding)</strong>：告知交换器消息投递队列的规则。</li></ul><h2 id="2-RabbitMQ包含哪些要素？"><a href="#2-RabbitMQ包含哪些要素？" class="headerlink" title="2. RabbitMQ包含哪些要素？"></a>2. RabbitMQ包含哪些要素？</h2><ul><li>生产者：消息队列创建者，发送消息到 MQ。</li><li>消费者：连接到 RabbitMQ，订阅到队列上，消费消息，支持持续订阅和单条订阅。</li><li>消息：包含有效载荷和标签，有效载荷指要传输的数据，标签描述有效载荷，RabbitMQ 用它决定谁获得消息，消费者只能拿到有效载荷，不知道生产者是谁。</li></ul><h2 id="3-RabbitMQ中消息可能有的几种状态？"><a href="#3-RabbitMQ中消息可能有的几种状态？" class="headerlink" title="3. RabbitMQ中消息可能有的几种状态？"></a>3. RabbitMQ中消息可能有的几种状态？</h2><ul><li>alpha：消息内容（包括消息体、属性和 headers）和消息索引都存储在内存。</li><li>beta：消息内容保存在磁盘中，消息索引保存在内存中。</li><li>gamma：消息内容保存在磁盘中，消息索引在磁盘和内存中都有。</li><li>delta：消息内容和索引都在磁盘中。</li></ul><h2 id="4-发送消息的过程？"><a href="#4-发送消息的过程？" class="headerlink" title="4. 发送消息的过程？"></a>4. 发送消息的过程？</h2><ul><li>生产者将消息发布到一个或多个交换器（Exchange）中。交换器根据路由键（Routing Key）将消息分配给特定的队列（Queue）。</li><li>交换器通过路由键将消息路由到一个或多个队列。若路由键为空，消息会被分配给所有绑定到该交换器的队列。</li><li>消息进入队列，等待被消费者接收。在队列中，消息会被存储在持久化存储中，以防服务器崩溃或重启时数据丢失。</li><li>消费者从队列中获取消息并处理。消费者可通过订阅一个或多个队列来接收消息。一旦消息被消费者接收，它将从队列中移除。</li></ul><h2 id="5-为什么要使用RabbitMQ？"><a href="#5-为什么要使用RabbitMQ？" class="headerlink" title="5. 为什么要使用RabbitMQ？"></a>5. 为什么要使用RabbitMQ？</h2><ul><li>在分布式系统下具备异步、削峰、负载均衡等一系列高级功能。</li><li>拥有持久化的机制，进程消息、队列中的信息也可以保存下来。</li><li>实现消费者和生产者之间的解耦。</li><li>对于高并发场景下，利用消息队列可以使得同步访问变为串行访问达到一定量的限流，利于数据库的操作。</li><li>可以使用消息队列达到异步下单的效果，排队中，后台进行逻辑下单。</li></ul><h2 id="6-Kafka、-ActiveMQ、-RabbitMQ、-RocketMQ有什么优缺点？"><a href="#6-Kafka、-ActiveMQ、-RabbitMQ、-RocketMQ有什么优缺点？" class="headerlink" title="6. Kafka、 ActiveMQ、 RabbitMQ、 RocketMQ有什么优缺点？"></a>6. Kafka、 ActiveMQ、 RabbitMQ、 RocketMQ有什么优缺点？</h2><p>一般的业务系统要引入 MQ，最早大家都用 ActiveMQ，但是现在确实大家用的不多了，没经过大规模吞吐量场景的验证，社区也不是很活跃，所以大家还是算了吧，我个人不推荐用这个了；</p><p>后来大家开始用 RabbitMQ，但是确实 erlang 语言阻止了大量的 Java 工程师去深入研究和掌控它，对公司而言，几乎处于不可控的状态，但是确实人家是开源的，比较稳定的支持，活跃度也高；</p><p>不过现在确实越来越多的公司会去用 RocketMQ，确实很不错，毕竟是阿里出品，但社区可能有突然黄掉的风险（目前 RocketMQ 已捐给，但 GitHub 上的活跃度其实不算高）对自己公司技术实力有绝对自信的，推荐用 RocketMQ，否则回去老老实实使用 RabbitMQ 吧，人家有活跃的开源社区，绝对不会黄；</p><p>所以中小型公司，技术实力较为一般，技术挑战不是特别高，用 RabbitMQ 是不错的选择；大型公司，基础架构研发实力较强，用 RocketMQ 是很好的选择；大数据领域的实时计算、日志采集等场景，使用 Kafka。</p><h1 id="应用："><a href="#应用：" class="headerlink" title="应用："></a>应用：</h1><h2 id="1-如何确保消息正确地发送至RabbitMQ？如何确保消息接收方消费了消息？"><a href="#1-如何确保消息正确地发送至RabbitMQ？如何确保消息接收方消费了消息？" class="headerlink" title="1. 如何确保消息正确地发送至RabbitMQ？如何确保消息接收方消费了消息？"></a>1. 如何确保消息正确地发送至RabbitMQ？如何确保消息接收方消费了消息？</h2><ul><li><strong>消息确认机制(**</strong>生产者确认<strong>**)</strong>：生产者在发送消息后，可通过消息确认机制（Confirm）确保消息正确发送至RabbitMQ。消息确认机制分为批量确认和单个确认两种方式，生产者可根据自身业务场景选择合适的方式。</li><li><strong>消息持久化</strong>：通过将消息设置为持久化的方式，可确保消息不会丢失。在RabbitMQ中，可将Exchange、Queue和Message都标记为持久化。在发送消息时，可以将消息的delivery - mode设置为2，表示消息需要持久化。</li><li><strong>连接超时设置（**</strong>生产者重连<strong>**）</strong>：在发送消息时，可通过设置连接超时时间，当超过指定时间后仍未收到发送消息响应，可以通过重发等方式确保消息正确地发送至RabbitMQ。</li><li><strong>消息**</strong>序列化<strong>**和反序列化</strong>：在发送和接收消息时，需要将消息对象序列化为二进制数据，再在接收方反序列化为对象类型。因此，需要确保消息的序列化和反序列化过程正确无误，可以采用JSON、Protobuf等常用的序列化框架。 </li></ul><h2 id="2-如何回答-消息队列-的丢失、重复与积压问题"><a href="#2-如何回答-消息队列-的丢失、重复与积压问题" class="headerlink" title="2. 如何回答**消息队列**的丢失、重复与积压问题"></a>2. <strong>如何回答**</strong>消息队列<strong>**的丢失、重复与积压问题</strong></h2><p><a href="https://learn.lianglianglee.com/专栏/架构设计面试精讲/08  MQ：如何回答消息队列的丢失、重复与积压问题.md">08 MQ:如何回答消息队列的丢失、重复与积压问题</a></p><ul><li><strong>消息确认机制</strong>：消费者处理消息后，向RabbitMQ发送消息确认（ACK），告知消息已正确处理。若未发送，RabbitMQ会将消息重新投到队列，造成重复消费。</li><li><strong>消息去重机制</strong>：可在应用程序中实现，比如用分布式缓存、数据库等存储系统记录已处理消息标识，下次处理时判断，若已处理则忽略，避免重复处理。</li><li><strong>消息幂等性处理（业务处理）</strong>：将消费者处理逻辑设计为幂等操作，即重复执行多次效果相同，防止因消息重复消费致业务数据错误。</li><li><strong>设置消息过期时间</strong>：发送消息时设置过期时间，过期后不再投递给消费者，避免重复消费。</li><li><strong>使用消息唯一标识符</strong>：在消息中添加如UUID这样的唯一标识符，保证每条消息有独一无二标识，避免重复消费和重复投递。 </li></ul><h2 id="3-如何保证消息持久化？"><a href="#3-如何保证消息持久化？" class="headerlink" title="3. 如何保证消息持久化？"></a>3. 如何保证消息持久化？</h2><ul><li><strong>消息的**</strong>delivery - mode<strong>**设置为2</strong>：在发送消息时，可以将消息的delivery - mode属性设置为2，表示消息需要被持久化。持久化的消息将会被写入磁盘，即使RabbitMQ重启或者崩溃，消息也仍然可以保留。</li><li><strong>队列的durable属性设置为true</strong>：在创建队列时，可以将队列的durable属性设置为true，表示队列是持久性的。持久化的队列将会在RabbitMQ重启或者崩溃后得到保留。</li><li><strong>将**</strong>交换器<strong>**的durable属性设置为true</strong>：在创建交换器时，可以将交换器的durable属性设置为true，表示交换器是持久性的。持久化的交换器将会在RabbitMQ重启或者崩溃后得到保留。</li><li><strong>使用事务机制</strong>：在发送消息时，可以使用事务机制来确保消息的持久性。通过开启事务，发送者可以将消息发送到RabbitMQ，然后等待RabbitMQ的确认，确认后再提交事务。使用事务机制可以确保消息的可靠性，但是会影响系统的性能。 </li></ul><h2 id="4-消息如何路由？"><a href="#4-消息如何路由？" class="headerlink" title="4. 消息如何路由？"></a>4. 消息如何路由？</h2><p> 消息的路由过程通过交换器（Exchange）实现。当消息被发送到 RabbitMQ 时，生产者将消息发布到交换器中，然后依据交换器的类型和绑定规则将消息路由到一个或多个队列中。</p><p> 消息路由的基本流程如下：</p><ul><li>生产者将消息发送到指定的交换器中。</li><li>交换器根据路由键（Routing Key）和绑定键（Binding Key）将消息发送到一个或多个队列中。路由键和绑定键可以是任意字符串，根据交换器的类型和绑定规则进行匹配。</li><li>若交换器类型为 direct，会根据路由键进行精确匹配，将消息发送到所有匹配的队列中。</li><li>若交换器类型为 fanout，会将消息发送到所有绑定到该交换器的队列中。</li><li>若交换器类型为 topic，会根据通配符匹配规则将消息发送到匹配的队列中。例如，路由键为 “foo.bar” 的消息可以匹配绑定键为 “*.bar” 或 “foo.#” 的队列。</li><li>若交换器类型为 headers，会根据消息的属性（headers）进行匹配，将消息发送到匹配的队列中。</li><li><p>如果没有匹配的队列，消息将被丢弃或返回给生产者，根据生产者的配置。</p><p>需注意，交换器和队列都需要进行绑定，否则消息将无法路由到队列中。另外，可根据需要在交换器和队列中配置各种属性，例如持久化、自动删除等，以满足不同的业务需求。</p></li></ul><h2 id="5．⭐️RabbitMQ的消息确认过程？"><a href="#5．⭐️RabbitMQ的消息确认过程？" class="headerlink" title="5．⭐️RabbitMQ的消息确认过程？"></a>5．⭐️RabbitMQ的消息确认过程？</h2><p><strong>消费者确认机制：</strong></p><p>为确认消费者是否成功处理消息，RabbitMQ 提供了消费者确认机制（Consumer Acknowledgement）。当消费者处理消息结束后，应向 RabbitMQ 发送一个回执，告知 RabbitMQ 自己的处理状态。回执有三种可选值：</p><ul><li>ack：成功处理消息，RabbitMQ 从队列中删除该消息。</li><li>nack：消息处理失败，RabbitMQ 需要再次投递消息。</li><li>reject：消息处理失败并拒绝该消息，RabbitMQ 从队列中删除该消息。</li></ul><p><img src="https://mcnfxurl5vzo.feishu.cn/space/api/box/stream/download/asynccode/?code=NzU2YmM3YmFkYTU4MGY3OThiZjVkNDkxMDkzNjNkYjlfZEtDMkh2N0FYbENvR2xEVm4wMnZJTjRWVWFKRElrYzlfVG9rZW46SUZQVWJLOUV4b3RmRVF4MWhPRWNHOEs3bmRkXzE3NDMzODg3ODE6MTc0MzM5MjM4MV9WNA" alt="img"></p><p>RabbitMQ的消息确认机制是指消费者在消费一条消息后，向RabbitMQ发送确认消息（ACK）的过程，以此告知RabbitMQ消息已被正确处理。<strong>该机制的作用是确保RabbitMQ能正确地将消息从队列中删除，避免重复投递和重复消费。</strong></p><p>消息确认机制的过程如下：</p><ul><li>消费者从RabbitMQ中获取消息并处理。</li><li>处理完成后，向RabbitMQ发送确认消息（ACK）。确认消息通常是一个简单的AMQP基本确认帧，带有消息的标识符（delivery tag）和是否批量确认的标记。</li><li>RabbitMQ收到确认消息后，将该消息从队列中删除。</li><li>如果消费者在一定时间内没有发送确认消息，RabbitMQ会认为消息未被正确处理，将会重新将消息投递到队列中，等待下一次消费。</li></ul><p>需要注意的是，在某些情况下，消费者可能无法正确处理消息，比如消费者崩溃或出现异常等。为避免这种情况导致消息丢失，<strong>RabbitMQ还提供了Nack</strong>（Negative Acknowledge）和Reject机制，可将消息标记为无法处理或无法路由的状态，使其重新回到队列中等待下一次投递。此外，可通过设置重试次数和重试时间间隔等参数，进行消息重试和延迟投递的配置，以满足不同的业务需求。 </p><h2 id="6-❓消息基于什么传输？"><a href="#6-❓消息基于什么传输？" class="headerlink" title="6. ❓消息基于什么传输？"></a>6. ❓消息基于什么传输？</h2><p><img src="https://mcnfxurl5vzo.feishu.cn/space/api/box/stream/download/asynccode/?code=NzJmYWVhZWU4ZmI4YWY2NDg4N2FjNmExZGYyOWNlY2RfZFhvUUFRZ1d0b1A5QkgzUjhDYWw4ZlZONU85c3k5OWhfVG9rZW46RWhMdmJ5YUJRb2hxSkd4MUQwT2NGYUtIbkdkXzE3NDMzODg3ODE6MTc0MzM5MjM4MV9WNA" alt="img"></p><h2 id="7-为什么不应该对所有的-message-都使用持久化机制？"><a href="#7-为什么不应该对所有的-message-都使用持久化机制？" class="headerlink" title="7. 为什么不应该对所有的 message 都使用持久化机制？"></a>7. 为什么不应该对所有的 message 都使用持久化机制？</h2><p>使用持久化机制会增加磁盘负担，尤其在高并发场景下，成本更高。若所有消息都用，会使RabbitMQ性能下降，影响系统性能。所以要依业务需求和消息重要性选择是否用。重要消息用它保可靠，临时消息可不用，减轻服务器负担。</p><p>若message设了persistent属性，但queue未设durable属性，queue的owner node异常时，在queue重建前，发往它的message将被阻塞；若message和queue都分别设了persistent和durable属性，queue的owner node异常且无法重启，queue无法在其他node重建，只能等其owner node重启后才能恢复使用，期间发送给该queue的消息也会被阻塞。</p><p>因此，是否对message持久化，需综合考量性能需求及可能问题。若想单RabbitMQ服务器达100000条/秒以上消息吞吐量，要么不用持久化保速度，用其他方式确保消息可靠；要么用持久化，且保证关键消息量不致性能瓶颈。 </p><h2 id="8-如何保证高可用的？RabbitMQ-的集群？"><a href="#8-如何保证高可用的？RabbitMQ-的集群？" class="headerlink" title="8. 如何保证高可用的？RabbitMQ 的集群？"></a>8. 如何保证高可用的？RabbitMQ 的集群？</h2><p><strong>普通集群模式</strong></p><p>普通集群模式是RabbitMQ最常见且最简单的集群模式。多台RabbitMQ服务器经网络连接成集群，共同管理消息队列，借节点间通信实现消息传递与路由。适用于多数应用场景，提供高可用性和可靠性。</p><p><strong>镜像集群模式</strong></p><p>一种高可用性集群模式，可提升RabbitMQ集群的可靠性与容错能力。每个节点有多个镜像节点，镜像节点自动复制主节点消息队列，主节点故障时接管消息队列处理。适用于对消息可靠性要求高的场景，但会增加网络带宽和存储成本</p><p><strong>Federated集群模式</strong></p><p>RabbitMQ的特殊集群模式，能将多个RabbitMQ集群组成逻辑整体，通过Federation插件实现集群间消息传递与路由。适用于需跨多数据中心或地理分布的场景，但会增加网络延迟和复杂度。 </p><h2 id="9-RabbitMQ上的一个queue中存放的message是否有数量限制？"><a href="#9-RabbitMQ上的一个queue中存放的message是否有数量限制？" class="headerlink" title="9. RabbitMQ上的一个queue中存放的message是否有数量限制？"></a>9. RabbitMQ上的一个queue中存放的message是否有数量限制？</h2><ul><li><strong>队列的大小限制</strong>：队列可通过配置参数限制大小，当队列大小达到限制，新消息无法入队。该限制能通过RabbitMQ的管理界面或者AMQP协议设置。</li><li><strong>内存**</strong>限制**：RabbitMQ中的消息队列保存在内存中，若队列中消息数量过多，会占用大量内存空间，可能致使系统性能下降甚至崩溃。所以，系统内存大小是队列存放消息数量的限制因素之一。 </li><li><strong>磁盘限制</strong>：当RabbitMQ的磁盘空间不足时，也会对队列中存放消息的数量形成限制。 </li></ul><h2 id="10-⭐️在单node系统和多node构成的cluster系统中声明queue，exchange，以及进行binding会有什么不同？"><a href="#10-⭐️在单node系统和多node构成的cluster系统中声明queue，exchange，以及进行binding会有什么不同？" class="headerlink" title="10. ⭐️在单node系统和多node构成的cluster系统中声明queue，exchange，以及进行binding会有什么不同？"></a>10. ⭐️在单node系统和多node构成的cluster系统中声明queue，exchange，以及进行binding会有什么不同？</h2><p>当你在单node上声明queue时，只要该node上相关元数据进行了变更，你就会得到Queue.Declare - ok回应；而在cluster上声明queue，则要求cluster上的全部node都要进行元数据成功更新，才会得到Queue.Declare - ok回应。另外，若node类型为RAM node则变更的数据仅保存在内存中，若类型为disk node则还要变更保存在磁盘上的数据。</p><p><strong>客户端连接到cluster中的任意node上是否都能正常工作？</strong></p><p>是的，客户端感觉不到不同。</p><p><strong>若cluster中拥有某个queue的owner node失效了，且该queue被声明具有durable属性，是否能够成功从其他node上重新声明该queue？</strong></p><p>不能，在这种情况下，将得到404 NOT FOUND错误。只能等queue所属的node恢复后才能使用该queue。但若该queue本身不具有durable属性，则可在其他node上重新声明。 </p><h2 id="11-向不存在的exchange发publish消息会发生什么？向不存在的queue执行consume动作会发生什么？"><a href="#11-向不存在的exchange发publish消息会发生什么？向不存在的queue执行consume动作会发生什么？" class="headerlink" title="11. 向不存在的exchange发publish消息会发生什么？向不存在的queue执行consume动作会发生什么？"></a>11. 向不存在的exchange发publish消息会发生什么？向不存在的queue执行consume动作会发生什么？</h2><p>都会收到 Channel.Close 信令告之不存在（内含原因 404 NOT FOUND）</p><h2 id="12-为什么说保证message被可靠持久化的条件是queue和exchange具有durable属性，同时message具有-persistent属性才行？"><a href="#12-为什么说保证message被可靠持久化的条件是queue和exchange具有durable属性，同时message具有-persistent属性才行？" class="headerlink" title="12. 为什么说保证message被可靠持久化的条件是queue和exchange具有durable属性，同时message具有 persistent属性才行？"></a>12. 为什么说保证message被可靠持久化的条件是queue和exchange具有durable属性，同时message具有 persistent属性才行？</h2><p>binding 关系可以表示为 exchange - binding - queue。从文档中我们知道，若要求投递的 message 能够不丢失，要求 message 本身设置 persistent 属性，要求 exchange 和 queue 都设置 durable 属性。其实这问题可以这么想，若 exchange 或 queue 未设置 durable 属性，则在其 crash 之后就会无法恢复，那么即使 message 设置了 persistent 属性，仍然存在 message 虽然能恢复但却无处容身的问题；同理，若 message 本身未设置 persistent 属性，则 message 的持久化更无从谈起。</p><h2 id="13-死信队列和延迟队列的使用？"><a href="#13-死信队列和延迟队列的使用？" class="headerlink" title="13. 死信队列和延迟队列的使用？"></a>13. 死信队列和延迟队列的使用？</h2><p> <strong>死信队列</strong></p><p> 当消息无法被正确处理时，可将其转发到死信队列，以便进一步处理。通过使用死信队列，能统一存储和管理无法处理的消息，并借助设置合适的TTL（存活时间）和DLX（死信交换器）等参数，灵活控制消息的转发和重新处理。</p><p> 使用死信队列的主要步骤：</p><ul><li>创建一个普通队列和一个死信交换器；</li><li>将普通队列绑定到死信交换器，并指定死信队列的路由键；</li><li><p>发送消息时，可将消息的TTL设为较小值，当消息未被消费者处理时，会转发到死信队列。</p><p>当需在一段时间后才能处理某个消息时，可使用延迟队列。通过设置消息的TTL和DLX等参数，能将消息转发到指定队列，以便在一定时间后再进行处理。适用于订单超时处理、提醒任务等场景。</p><p>使用延迟队列的主要步骤：</p></li><li><p>创建一个普通队列和一个交换器；</p></li><li>在交换器中设置消息的TTL和DLX等参数，将消息转发到指定队列；</li><li>在指定队列中处理消息。 </li></ul><h2 id="14-什么情况下producer不主动创建queue是安全的？"><a href="#14-什么情况下producer不主动创建queue是安全的？" class="headerlink" title="14. 什么情况下producer不主动创建queue是安全的？"></a>14. 什么情况下producer不主动创建queue是安全的？</h2><p>message是允许丢失的；实现了针对未处理消息的republish功能。</p><h2 id="15-如何保证消息的顺序性？"><a href="#15-如何保证消息的顺序性？" class="headerlink" title="15. 如何保证消息的顺序性？"></a>15. 如何保证消息的顺序性？</h2><p>只有一个队列仅有一个消费者的情况下才能保证顺序，否则只能通过全局 ID 实现（每条消息都有一个 msgId，关联的消息拥有一个 parentMsgId。可以在消费端实现前一条消息未消费，不处理下一条消息；也可以在生产端实现前一条消息未处理完不发下一条消息。</p><h2 id="16-消息什么时候会变成死信？"><a href="#16-消息什么时候会变成死信？" class="headerlink" title="16. 消息什么时候会变成死信？"></a>16. 消息什么时候会变成死信？</h2><p>消息拒绝并且没有设置重新入队；消息过期；消息堆积，并且队列达到最大长度，先入队的消息会变成 DL（死信）。</p><h2 id="17-⭐️-RabbitMQ事务机制："><a href="#17-⭐️-RabbitMQ事务机制：" class="headerlink" title="17.⭐️ RabbitMQ事务机制："></a>17.⭐️ RabbitMQ事务机制：</h2><p>RabbitMQ 支持事务机制，用于在发送消息时保证事务的原子性。事务机制允许在多个 RabbitMQ 操作中声明事务，并在最终确认消息被完全处理之前，将多个操作打包为一个原子操作。</p><p>在 RabbitMQ 中，事务机制的使用流程如下：</p><ul><li>开启事务：在发送消息之前，使用 txSelect 方法开启事务；</li><li>发送消息：使用 basicPublish 方法发送消息；</li><li>提交事务：使用 txCommit 方法提交事务，如果提交成功，则消息会被 RabbitMQ 确认，否则消息会被回滚；</li><li>回滚事务：使用 txRollback 方法回滚事务，如果回滚成功，则之前发送的消息会被撤销，否则消息会被继续处理。</li></ul><p>需要注意的是，使用事务机制会对 RabbitMQ 的性能产生一定的影响，因此建议在必要的情况下使用，例如在消息的可靠性要求非常高的场景下。在消息量较大的场景下，可以使用事务机制的替代方案，如消息确认机制（ACK 机制）等，以保证系统的高性能和可靠性。</p>]]></content>
    
    
    <summary type="html">🥧本人的Rabbitmq面试题总结</summary>
    
    
    
    <category term="面试题" scheme="https://outoflovenicoo.github.io/categories/%E9%9D%A2%E8%AF%95%E9%A2%98/"/>
    
    
    <category term="MQ" scheme="https://outoflovenicoo.github.io/tags/MQ/"/>
    
  </entry>
  
  <entry>
    <title>JVM基础面试题</title>
    <link href="https://outoflovenicoo.github.io/posts/2025-01-09-JVM%E5%9F%BA%E7%A1%80%E9%9D%A2%E8%AF%95%E9%A2%98.html"/>
    <id>https://outoflovenicoo.github.io/posts/2025-01-09-JVM%E5%9F%BA%E7%A1%80%E9%9D%A2%E8%AF%95%E9%A2%98.html</id>
    <published>2025-01-09T10:19:03.000Z</published>
    <updated>2025-03-23T14:00:00.000Z</updated>
    
    <content type="html"><![CDATA[<p><img src="2025-01-09-JVM基础面试题/diagram.png" alt=""></p><h1 id="Java内存区域"><a href="#Java内存区域" class="headerlink" title="Java内存区域"></a>Java内存区域</h1><h2 id="1-⭐️说说JMM"><a href="#1-⭐️说说JMM" class="headerlink" title="1.⭐️说说JMM"></a>1.⭐️说说JMM</h2><p><strong>主要概念</strong></p><ol><li><p><strong>内存可见性</strong>：指一个线程对共享变量的修改对其他线程的可见性。JMM（Java内存模型）确保一个线程对共享变量的更新能被其他线程及时看到。为实现内存可见性，JMM引入“主内存”和“工作内存”概念，线程对共享变量的操作先在工作内存中进行，然后通过执行顺序符合程序逻辑的规则同步到主内存。</p></li><li><p><strong>线程间的操作顺序</strong>：JMM定义了线程操作的顺序规则，包括程序顺序规则、锁规则、volatile规则等。程序顺序规则保证在一个线程内操作按代码顺序执行；锁规则保证获取和释放锁的顺序性；volatile规则确保volatile变量的读写操作有一定的可见性和顺序性。</p></li><li><p><strong>原子性</strong>：原子性保证了操作的不可分割性。JMM规定了哪些操作是原子的，在执行这些操作时，不会被其他线程打断。在Java中，基本数据类型的读取和写入（如int、long）是原子的，但对于复合操作（如i++）则不是原子的。为保证原子性，通常需要使用同步机制或原子类（如AtomicInteger）。</p></li><li><p><strong>内存屏障</strong>：内存屏障（Memory Barriers）是JMM使用的一种机制，用于实现内存可见性和操作顺序规则。屏障的作用是阻止编译器和处理器对指令的重排序，确保代码执行顺序符合程序的预期。</p></li></ol><p><strong>关键概念和规则</strong></p><ul><li><p><strong>volatile关键字</strong>：volatile修饰的变量会被直接读写于主内存，避免了线程对变量的缓存，从而保证了内存的可见性。此外，volatile变量的读操作具有一定的顺序性，即保证在volatile变量的写操作之前发生的操作一定在写操作之后对其他线程可见。</p></li><li><p><strong>synchronized关键字</strong>：synchronized关键字用于实现同步，它不仅保证了内存可见性，还保证了操作的原子性。每次获取和释放锁时，都会强制刷新工作内存中的变量到主内存，并且强制使主内存中的变量更新到工作内存中，以确保其他线程能看到这些修改。</p></li><li><p><strong>happens-before原则</strong>：JMM中的happens-before原则用于描述操作之间的先后顺序。若操作A happens-before操作B，则操作A的结果对操作B可见。这个原则用于确定多线程程序中不同操作的执行顺序。</p></li></ul><p>Java内存模型通过定义一套规则，确保多线程环境下的内存访问行为是有序和一致的。通过使用volatile、synchronized和原子类等机制，程序员可以更好地控制和协调代码执行，确保代码在多线程环境下的正确性 。&#x20;</p><h2 id="2-字符串常量池的作用了解吗"><a href="#2-字符串常量池的作用了解吗" class="headerlink" title="2.字符串常量池的作用了解吗"></a>2.字符串常量池的作用了解吗</h2><p><img src="2025-01-09-JVM基础面试题/image-14.png" alt=""></p><h2 id="3-说下对JVM内存模型的理解"><a href="#3-说下对JVM内存模型的理解" class="headerlink" title="3.说下对JVM内存模型的理解"></a>3.说下对JVM内存模型的理解</h2><p>首先<strong>JVM本质上是运行在操作系统之上的程序</strong>。我们编写的Java代码，经由 <code>javac</code> 编译器编译为二进制字节码。操作系统底层只能执行机器码指令，像C语言这类底层语言，经编译后直接生成机器码，因此执行效率较高。然而，C语言程序无法跨平台运行，需针对每个平台分别编译。与之不同，<strong>JVM充当了字节码与机器码之间的桥梁</strong>，通过在不同平台安装JVM，Java实现了跨平台特性。</p><p><strong>Java的内存结构主要由类加载器、运行时数据区、执行引擎和本地方法接口等部分组成。</strong></p><p>类加载器负责将字节码文件加载到Java的运行时数据区中。运行时数据区是Java程序运行时使用的内存区域，<strong>从线程角度可划分为线程私有和线程共享两部分</strong>。线程私有部分包含栈、本地方法栈和程序计数器。栈用于存储方法调用相关信息，本地方法栈则为本地方法服务，程序计数器记录当前线程执行的字节码指令地址。线程共享部分主要有方法区和堆内存。通常，我们创建的对象都存储在堆内存中；而<strong>方法区存储类的元数据、字节码以及常量池等信息</strong>。在不同的JDK版本中，方法区有诸多变化，<strong>例如在JDK 8中，方法区被称为元空间，它不再使用堆内存，而是采用本地内存来存储类相关数据，这主要是因为当下框架大量使用反射机制</strong>，运行时会动态加载众多类，若方法区仍在堆内存中，易导致堆内存难以控制。</p><p><strong>执行引擎具备重要功能</strong>，它能够将字节码解释为机器码，同时采用JIT（即时编译）技术，将热点代码编译为机器码，以提升执行效率。此外，虽然执行引擎并不直接负责垃圾回收，但它与垃圾回收机制紧密协作，确保内存的有效管理与回收。</p><p>本地方法接口是Java与本地代码（如C、C++）交互的桥梁。Java通过本地方法接口，可<strong>以调用本地代码实现一些Java本身难以完成的功能，如访问操作系统底层资源、提高性能敏感代码的执行效率等。</strong>&#x5F53;Java程序调用本地方法时，JVM会在本地方法栈中为该方法创建栈帧，并通过JNI（Java Native Interface）规范来处理Java与本地代码之间的数据传递和方法调用。例如，在开发涉及硬件操作、图形处理等应用时，常借助本地方法调用C或C++编写的高效代码来实现复杂功能。本地方法在拓展Java功能边界，提升系统性能方面发挥着重要作用。&#x20;</p><p><img src="2025-01-09-JVM基础面试题/image-13.png" alt=""></p><p><img src="2025-01-09-JVM基础面试题/image-12.png" alt=""></p><h2 id="4-内存溢出与内存泄漏的区别"><a href="#4-内存溢出与内存泄漏的区别" class="headerlink" title="4.内存溢出与内存泄漏的区别"></a>4.内存溢出与内存泄漏的区别</h2><p><img src="2025-01-09-JVM基础面试题/image.png" alt=""></p><h2 id="5-对象分配规则"><a href="#5-对象分配规则" class="headerlink" title="5.对象分配规则"></a>5.对象分配规则</h2><p><img src="2025-01-09-JVM基础面试题/image-1.png" alt=""></p><h2 id="6-⭐️JVM为什么使用元空间替换了永久代"><a href="#6-⭐️JVM为什么使用元空间替换了永久代" class="headerlink" title="6.⭐️JVM为什么使用元空间替换了永久代"></a>6.⭐️JVM为什么使用元空间替换了永久代</h2><p>虚拟机使用元空间替代永久代的原因如下：</p><ol><li><p>内存管理：永久代由虚拟机自身控制内存管理，无法动态调整；元空间用本地内存管理，可按需动态分配和释放内存，提高利用率。</p></li><li><p>永久代内存溢出：永久代存储类元数据等，应用加载大量类或用大量字符串常量时可能溢出；元空间无固定大小限制，可自动扩展。</p></li><li><p>类的卸载：永久代类卸载机制复杂，难完全卸载；元空间用本地内存，更易实现类卸载，减少内存占用。</p></li><li><p>性能优化：元空间采用更高效数据结构和算法，如指针碰撞分配内存，减少碎片化，提高分配效率；还支持并发类加载和卸载操作，提升性能。</p></li></ol><p>综上，元空间内存管理更好、性能更高、特性更灵活，能更好满足现代应用程序需求，所以虚拟机选择用元空间替代永久代。&#x20;</p><h2 id="7-说一下堆和栈的区别？"><a href="#7-说一下堆和栈的区别？" class="headerlink" title="7.说一下堆和栈的区别？"></a>7.说一下堆和栈的区别？</h2><ol><li><p>堆的物理地址分配是不连续的，性能较慢；栈的物理地址分配是连续的，性能相对较快。</p></li><li><p>堆存放的是对象的实例和数组；栈存放的是局部变量，操作数栈，返回结果等。</p></li><li><p>堆是线程共享的；栈是线程私有的。</p></li></ol><h2 id="8-栈溢出的原因？"><a href="#8-栈溢出的原因？" class="headerlink" title="8.栈溢出的原因？"></a>8.栈溢出的原因？</h2><p>由于 HotSpot 不区分虚拟机和本地方法栈，设置本地方法栈大小的参数没有意义，栈容量只能由 -Xss 参数来设定，存在两种异常：</p><ul><li><p>StackOverflowError：如果线程请求的栈深度大于虚拟机所允许的深度，将抛出 StackOverflowError，例如一个递归方法不断调用自己。该异常有明确错误堆栈可供分析，容易定位到问题所在。</p></li><li><p>OutOfMemoryError：如果 JVM 栈可以动态扩展，当扩展无法申请到足够内存时会抛出 OutOfMemoryError。HotSpot 不支持虚拟机栈扩展，所以除非在创建线程申请内存时就因无法获得足够内存而出现 OOM，否则在线程运行时是不会因为扩展而导致溢出的。</p></li></ul><h2 id="9-运行时常量池溢出的原因？"><a href="#9-运行时常量池溢出的原因？" class="headerlink" title="9.运行时常量池溢出的原因？"></a>9.运行时常量池溢出的原因？</h2><p>String 的 intern 方法是一个本地方法，作用是如果字符串常量池中已包含一个等于此 String 对象的字符串，则返回池中这个字符串的 String 对象的引用，否则将此 String 对象包含的字符串添加进池中，因此可以通过引用返回。</p><p>在 JDK6 及之前常量池分配在永久代，可通过 -XX:PermSize 和 -XX:MaxPermSize 限制永久代大小，间接限制常量池。在 while 死循环中调用 intern 方法导致运行时常量池溢出。在 JDK7 后不会出现该问题，因为存放在永久代的字符串常量池已经被移至堆中。</p><h2 id="10-方法区溢出的原因？"><a href="#10-方法区溢出的原因？" class="headerlink" title="10.方法区溢出的原因？"></a>10.方法区溢出的原因？</h2><p>方法区主要存放<strong>类型信息，如类名、访问修饰符、常量池、字段描述、方法描述</strong>等。只要不断在运行时产生大量类，方法区就会溢出。例如使用 JDK 反射或 CGLib 直接操作字节码在运行时生成大量的类。很多框架如 Spring、Hibernate 等对类增强时都会使用 CGLib 这类字节码技术，增强的类越多就需要越大的方法区保证动态生成的新类型可以载入内存，也就更容易导致方法区溢出。</p><p>JDK8 使用元空间取代永久代，HotSpot 提供了一些参数作为元空间防御措施，例如 -XX:MetaspaceSize 指定元空间初始大小，达到该值会触发 GC 进行类型卸载，同时收集器会对该值进行调整，如果释放大量空间就适当降低该值，如果释放很少空间就适当提高。</p><h1 id="类加载机制"><a href="#类加载机制" class="headerlink" title="类加载机制"></a>类加载机制</h1><h2 id="1-说下类加载器机制与双亲委派"><a href="#1-说下类加载器机制与双亲委派" class="headerlink" title="1.说下类加载器机制与双亲委派"></a>1.说下类加载器机制与双亲委派</h2><p>首先<strong>类加载器</strong>主要是复杂从各种渠道将我们的字节码文件加载到我们的内存中，然后底层会调用native方法将我们的类相关信息写入到我们<strong>元空间</strong>中，主要保存我们类的所有信息，然后会在方法区创建当前类的class对象，方便我们后续通过java代码获取类信息，里面会持有一个指向元空间中类的指针。</p><p>类加载器主要有四大种，<strong>系统、扩展、应用以及自定义类加载器</strong>，内部类加载的机制采用的是双亲委派机制，主要目的是<strong>防止我们的核心类库被修改</strong>，以及我们的类被重复加载，底层原理就是加载类的时候层层向上委托，到顶层类加载器判断有没有加载过这个类，若没有尝试加载，如果加载不到再层层向下委托重复上述步骤。例如我们自定义一个包名和类名完全相同的String，它会层层向上传递给系统类加载器，发现没有加载过就尝试加载，结果一下子加载到了，那就用它加载的。底层的实现是在我们defineclass方法中实现的，当然我们也可以<strong>通过实现Classloader来实现我们自定义的类加载逻辑</strong>，甚至打破双亲委派机制，比如：我们可以使用类加载器对我们的字节码进行加解密等。&#x20;</p><h2 id="2-什么是类加载？类加载的过程？"><a href="#2-什么是类加载？类加载的过程？" class="headerlink" title="2.什么是类加载？类加载的过程？"></a>2.什么是类加载？类加载的过程？</h2><p><img src="../../../../../../../images/image-10.png" alt=""></p><p>类加载流程，有加载、验证、准备、解析、初始化这几个步骤。</p><ul><li><p>加载：</p><ol><li><p>通过类的全限定名获取定义此类的二进制字节流。</p></li><li><p>将字节流所代表的静态存储结构转换为方法区的运行时数据结构。</p></li><li><p>在<strong>内存中生成一个代表该类的 Class 对象，作为方法区类信息的访问入口</strong>。</p></li></ol></li><li><p>验证：<strong>确保 Class 文件的字节流中包含的信息符合虚拟机规范，保证在运行后不会危害虚拟机自身的安全。</strong>&#x4E3B;要包括四种验证：文件格式验证，元数据验证，字节码验证，符号引用验证。</p><ul><li><p>文件格式验证：验证读进来的字节流是否符合 Class 标准格式。</p></li><li><p>元数据验证：格式对了之后，验证一下里边的数据合不合理。比如：这个类是否有父类（除了 java.lang.Object 之外，所有的类都应当有父类）。</p></li><li><p>字节码验证：分析类的方法体（Class 文件中的 Code 属性），确保方法在运行时不会危害虚拟机。</p></li><li><p>符号引用验证（发生在解析阶段）：检查常量池中引用的外部类是否存在，是否可以正常访问。</p></li></ul></li><li><p>准备：为类变量分配内存并设置类变量初始值的阶段。其中如果是 final 修饰的，意味着在 Class 文件中，该字段的属性表中存在 ConstantValue 属性，此时初值设置为代码里写的。如果不是，就设置为零值，等到初始化阶段再赋值。</p></li><li><p>解析：虚拟机将常量池内的符号引用替换为直接引用的过程。符号引用用于描述目标，直接引用直接指向目标的地址。</p></li><li><p>初始化：开始执行类中定义的 Java 代码，初始化阶段是调用类构造器的过程。</p></li></ul><h2 id="3-什么是类加载器，类加载器有哪些？"><a href="#3-什么是类加载器，类加载器有哪些？" class="headerlink" title="3.什么是类加载器，类加载器有哪些？"></a>3.什么是类加载器，类加载器有哪些？</h2><p><img src="../../../../../../../images/image-11.png" alt=""></p><p>实现通过类的全限定名获取该类的二进制字节流的代码块叫做类加载器。</p><p>主要有以下四种类加载器：</p><ul><li><p>启动类加载器（bootstrap class loader）：用来加载 Java 核心类库，无法被 Java 程序直接引用。</p></li><li><p>扩展类加载器（extensions class loader）：它用来加载 Java 的扩展库。Java 虚拟机的实现会提供一个扩展库目录。该类加载器在此目录里面查找并加载 Java 类。</p></li><li><p>系统类加载器（app class loader）：它根据应用的类路径来加载 Java 类。可通过 ClassLoader.getSystemClassLoader () 获取它。</p></li><li><p>自定义类加载器（custom class loader）：通过继承 java.lang.ClassLoader 类的方式实现。</p></li></ul><h2 id="4-什么是双亲委派模型？"><a href="#4-什么是双亲委派模型？" class="headerlink" title="4.什么是双亲委派模型？"></a>4.什么是双亲委派模型？</h2><p><strong>一个类加载器收到一个类的加载请求时，它首先不会自己尝试去加载它，而是把这个请求委派给父类加载器去完成</strong>，这样层层委派，因此所有的加载请求最终都会传送到顶层的启动类加载器中，只有当父类加载器反馈自己无法完成这个加载请求时，子加载器才会尝试自己去加载。</p><p>双亲委派模型的具体实现代码在 java.lang.ClassLoader 中，此类的 loadClass () 方法运行过程如下：先检查类是否已经加载过，如果没有则让父类加载器去加载。当父类加载器加载失败时抛出 ClassNotFoundException，此时尝试自己去加载。</p><h2 id="5-为什么需要双亲委派模型？"><a href="#5-为什么需要双亲委派模型？" class="headerlink" title="5.为什么需要双亲委派模型？"></a>5.为什么需要双亲委派模型？</h2><p>双亲委派模型的好处：如果没有双亲委派模型而是由各个类加载器自行加载的话，如果用户编写了一<strong>个 java.lang.Object 的同名类并放在 ClassPath&#x20;</strong>&#x4E2D;，多个类加载器都去加载这个类到内存中，系统中将会出现多个不同的 Object 类，那么类之间的比较结果及类的唯一性将无法保证。</p><h2 id="6-如何判断两个类是否相等？"><a href="#6-如何判断两个类是否相等？" class="headerlink" title="6.如何判断两个类是否相等？"></a>6.如何判断两个类是否相等？</h2><p>任意一个类都必须由类加载器和这个类本身共同确立其在虚拟机中的唯一性。</p><p>两个类只有由同一类加载器加载才有比较意义，否则即使两个类来源于同一个 Class 文件，被同一个 JVM 加载，只要类加载器不同，这两个类就必定不相等。</p><p><strong>同一个类：相同类加载器加载 + 相同类限定名</strong></p><h2 id="7-类的实例化顺序？"><a href="#7-类的实例化顺序？" class="headerlink" title="7.类的实例化顺序？"></a>7.类的实例化顺序？</h2><ol><li><p>父类中的 static 代码块，当前类的 static 代码块</p></li><li><p>父类的普通代码块</p></li><li><p>父类的构造函数</p></li><li><p>当前类普通代码块</p></li><li><p>当前类的构造函数</p></li></ol><h1 id="垃圾回收器与内存分配策略"><a href="#垃圾回收器与内存分配策略" class="headerlink" title="垃圾回收器与内存分配策略"></a>垃圾回收器与内存分配策略</h1><h2 id="1-新生代GC和老年代GC有什么区别"><a href="#1-新生代GC和老年代GC有什么区别" class="headerlink" title="1.新生代GC和老年代GC有什么区别"></a>1.新生代GC和老年代GC有什么区别</h2><p><img src="2025-01-09-JVM基础面试题/image-6.png" alt=""></p><h2 id="2-垃圾回收算法有哪些？"><a href="#2-垃圾回收算法有哪些？" class="headerlink" title="2.垃圾回收算法有哪些？"></a>2.垃圾回收算法有哪些？</h2><blockquote><p><a href="https://javaguide.cn/java/jvm/jvm-garbage-collection.html">JVM垃圾回收详解（重点）</a></p></blockquote><p>垃圾回收算法有四种，分别是标记清除法、标记整理法、复制算法、分代收集算法。</p><ul><li><p><strong>标记清除算法</strong>：首先利用可达性去遍历内存，把垃圾对象进行标记。标记结束后统一将所有垃圾对象回收掉。这种垃圾回收算法效率较低，并且会产生大量不连续的空间碎片。</p></li><li><p><strong>复制算法</strong>：半区复制，用于新生代垃圾回收。将内存分为大小相同的两块，每次使用其中的一块。当这一块的内存使用完后，就将还存活的对象复制到另一块去，然后再把使用的空间一次清理掉。特点：实现简单，运行高效，但可用内存缩小为了原来的一半，浪费空间。</p></li><li><p><strong>标记整理算法</strong>：根据老年代的特点提出的一种标记算法，标记过程仍然与标记 - 清除算法一样，但后续步骤不是直接对可回收对象进行清理，而是让所有存活的对象都向一端移动，然后直接清理掉边界以外的内存。</p></li><li><p><strong>分代收集算法</strong>：根据各个年代的特点采用最适当的收集算法。一般将堆分为新生代和老年代。</p><ul><li><p>新生代使用复制算法。</p></li><li><p>老年代使用标记清除算法或者标记整理算法。在新生代中，每次垃圾收集时都有大批对象死去，只有少量存活，使用复制算法比较合适，只需要付出少量存活对象的复制成本就可以完成收集。老年代对象存活率高，适合使用标记 - 清理或者标记 - 整理算法进行垃圾回收。</p></li></ul></li></ul><h2 id="3-有哪些垃圾回收器？"><a href="#3-有哪些垃圾回收器？" class="headerlink" title="3.有哪些垃圾回收器？"></a>3.有哪些垃圾回收器？</h2><blockquote><p><a href="https://mcnfxurl5vzo.feishu.cn/wiki/Lp6uws3rFiEDjXkkyGGchQWQnVH#share-SO1ldvaSRou7kDxqb6ycHGbMnrc"> 博客</a></p></blockquote><p><img src="2025-01-09-JVM基础面试题/image-9.png" alt=""></p><p>垃圾收集器（GC，Garbage Collector）和具体 JVM 实现紧密相关，不同厂商（IBM、Oracle ）、不同版本的 JVM 提供的选择不同，主要介绍 Oracle JDK 的垃圾收集器：</p><ul><li><p><strong>Serial GC：</strong>&#x6700;古老的垃圾收集器，收集工作单线程，垃圾收集时会进入 “Stop - The - World” 状态。单线程设计意味着精简的 GC 实现，无需维护复杂数据结构，初始化简单，是 Client 模式下 JVM 的默认选项。老年代实现为 Serial Old，采用标记 - 整理（Mark Compact）算法，区别于新生代复制算法。对应 JVM 参数：-XX:+UseSerialGC。</p></li><li><p>ParNew GC：新生代 GC 实现，是 Serial GC 的多线程版本，常见应用场景是配合老年代的 CMS GC 工作。对应参数：-XX:+UseConcMarkSweepGC -XX:+UseParNewGC。</p></li><li><p><strong>CMS</strong>（Concurrent Mark Sweep）GC：基于标记 - 清除（Mark - Sweep）算法，设计目标是尽量减少停顿时间，对 Web 等反应时间敏感的应用重要。存在内存碎片化问题，难以避免长时间运行下发生 full GC 导致恶劣停顿，且会占用更多 CPU 资源，和用户线程争抢。</p></li><li><p><strong>Parallel GC</strong>：早期 JDK 8 等版本中，是 server 模式 JVM 的默认 GC 选择，吞吐量优先。算法和 Serial GC 相似但实现更复杂，新生代和老年代 GC 并行进行，在常见服务器环境中更高效。开启选项：-XX:+UseParallelGC。引入开发者友好配置项，可设置暂停时间或吞吐量等目标，JVM 自动适应性调整，如 -XX:MaxGCPauseMillis=value 、-XX:GCTimeRatio=N（GC 时间和用户时间比例 = 1 / (N + 1)） 。</p></li><li><p><strong>G1 GC：</strong>&#x517C;顾吞吐量和停顿时间的 GC 实现，是 Oracle JDK 9 以后的默认 GC 选项。可直观设定停顿时间目标，相比 CMS GC，最差情况表现更好。仍存在年代概念，但内存结构是类似棋盘的一个个 region。Region 之间是复制算法，整体可看作标记 - 整理（Mark - Compact）算法，能有效避免内存碎片，Java 堆很大时优势更明显。吞吐量和停顿表现不错且不断完善，CMS 在 JDK 9 中被标记为废弃（deprecated）。</p></li></ul><h2 id="4-说下JVM中一次完整的-GC-流程"><a href="#4-说下JVM中一次完整的-GC-流程" class="headerlink" title="4.说下JVM中一次完整的 GC 流程"></a>4.说下JVM中一次完整的 GC 流程</h2><p>JVM中垃圾回收（GC）流程一般步骤如下：</p><ol><li><p><strong>标记阶段</strong>：从根对象（如活动线程栈帧中局部变量、静态变量、JNI引用等）出发，通过引用链标记所有可达对象。</p></li><li><p><strong>垃圾标记</strong>：标记阶段后确定不可达对象为垃圾对象，将被回收。</p></li><li><p><strong>垃圾回收</strong>：执行回收操作，回收被标记垃圾对象占用内存空间，回收方式有标记 - 清除、复制、标记 - 整理等算法。</p></li><li><p><strong>内存整理</strong>：回收后可能产生内存碎片，为提高利用率，GC可能对内存空间整理，紧凑排列存活对象，便于分配新对象。</p></li><li><p><strong>内存分配</strong>：回收和整理完成后，GC为新对象分配内存空间，分配方式有指针碰撞、空闲列表等算法。</p></li><li><p><strong>重新分配对象引用</strong>：回收和内存分配完成后，GC更新对象间引用关系，确保引用指向正确对象。</p></li></ol><p>不同GC算法和实现有差异，但整体流程大致相同，<strong>目标是回收垃圾对象、释放内存空间，并尽量减少对应用程序影响，保证程序正常运行。</strong>&#x20;</p><h2 id="5-什么是指针碰撞"><a href="#5-什么是指针碰撞" class="headerlink" title="5.什么是指针碰撞"></a>5.什么是指针碰撞</h2><p>在 Java 中，指针碰撞是一种垃圾收集算法中用于分配内存的一种方式。它通常用于实现停顿时间较短的垃圾收集器，如<strong>复制算法和标记 - 整理算法</strong>。</p><p>指针碰撞的基本思想是将堆内存分为两个区域：<strong>一个是已分配的对象区域，另一个是未分配的空闲区域。</strong>&#x901A;过一个指针来分隔这两个区域。当需要分配对象时，垃圾收集器将对象的大小与空闲区域的大小进行比较，如果空闲区域足够容纳对象，则将指针碰撞指针向前移动对象的大小，并返回指针碰撞指针的旧值作为对象的起始地址。如果空闲区域不足以容纳对象，则进行垃圾回收操作，释放一些内存后再进行分配。</p><p>指针碰撞的优点是分配内存的速度很快，只需简单地移动一个指针即可完成。而且由于已分配的对象区域和未分配的空闲区域是连续的，所以内存的利用率也比较高。</p><p>然而，指针碰撞算法的<strong>缺点是需要保证堆内存的连续性，即堆内存必须是一块连续的内存空间。</strong>&#x8FD9;对于某些情况下的内存分配来说可能是一个限制，因为连续的内存空间可能会受到碎片化的影响，导致无法分配足够大的对象。因此，在实际应用中，指针碰撞算法通常与其他内存分配算法结合使用，以克服其局限性。</p><h2 id="6-什么是三色标记"><a href="#6-什么是三色标记" class="headerlink" title="6.什么是三色标记"></a>6.什么是三色标记</h2><p>三色标记是一种用于并发垃圾收集的算法，常用于分代垃圾收集器中的老年代的垃圾回收过程。它基于对象的可达性来判断对象是否存活，并标记出存活对象。</p><p>三色标记算法将对象分为三种状态：白色、灰色和黑色。</p><ul><li><p>白色表示对象尚未被扫描，即未被标记为存活对象。</p></li><li><p>灰色表示对象已经被扫描，但其引用的其他对象尚未被扫描。</p></li><li><p>黑色表示对象已经被扫描，并且其引用的其他对象也已经被扫描。</p></li></ul><p>垃圾收集器在开始垃圾回收时，将所有对象标记为白色。然后从根对象开始，递归地遍历对象图，将遇到的对象标记为灰色，并将其引用的对象添加到待扫描队列中。接着，垃圾收集器从待扫描队列中取出对象，将其标记为黑色，并将其引用的对象添加到待扫描队列中。这个过程会一直进行，直到待扫描队列为空。最后，所有未被标记为黑色的对象即为垃圾对象，可以被回收。</p><p>三色标记算法的优点是可以在并发执行的情况下进行垃圾回收，减少停顿时间。它通过将对象分为三种状态，避免了在并发执行过程中的同时修改和访问对象的冲突。然而，三色标记算法也有一些缺点，如可能存在标记漏标和标记误标的情况，需要额外的处理来解决这些问题。</p><h2 id="7-Java对象的定位方式"><a href="#7-Java对象的定位方式" class="headerlink" title="7. Java对象的定位方式"></a>7. Java对象的定位方式</h2><p>Java 程序通过栈上的 reference 数据来操作堆上的具体对象。对象的访问方式由虚拟机实现而定，目前主流的访问方式有使用句柄和直接指针两种：</p><ul><li><p>如果使用句柄的话，那么 Java 堆中将会划分出一块内存作为句柄池，reference 中存储的就是对象的句柄地址，<strong>而句柄中包含了对象实例数据与类型数据各自的具体地址信息</strong>。使用句柄来访问的最大好处是 reference 中存储的是稳定的句柄地址，在对象被移动时只会改变句柄中的实例数据指针，而 reference 本身不需要修改。</p></li><li><p>直接指针：reference 中存储的直接就是对象的地址。对象包含到对象类型数据的指针，通过这个指针可以访问对象类型数据。使用直接指针访问方式最大的好处就是访问对象速度快，它节省了一次指针定位的时间开销，虚拟机 hotspot 主要是使用直接指针来访问对象。</p></li></ul><p><img src="2025-01-09-JVM基础面试题/image-8.png" alt=""></p><h2 id="8-如何判断一个对象是否存活？"><a href="#8-如何判断一个对象是否存活？" class="headerlink" title="8.如何判断一个对象是否存活？"></a>8.如何判断一个对象是否存活？</h2><p>对堆垃圾回收前的第一步就是要判断哪些对象已经死亡（即不再被任何途径引用的对象）。判断对象是否存活有两种方法：引用计数法和可达性分析。</p><p><strong>引用计数法</strong>：</p><p>给对象中添加一个引用计数器，每当有一个地方引用它，计数器就加1；当引用失效，计数器就减1；任何时候计数器为0的对象就是不可能再被使用的。这种方法很难解决对象之间相互循环引用的问题。比如下面的代码，obj1和obj2互相引用，这种情况下，引用计数器的值都是1，不会被垃圾回收。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">ReferenceCount</span> &#123;</span><br><span class="line">    <span class="type">Object</span> <span class="variable">instance</span> <span class="operator">=</span> <span class="literal">null</span>;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">        <span class="type">ReferenceCount</span> <span class="variable">obj1</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">ReferenceCount</span>();</span><br><span class="line">        <span class="type">ReferenceCount</span> <span class="variable">obj2</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">ReferenceCount</span>();</span><br><span class="line">        obj1.instance = obj2;</span><br><span class="line">        obj2.instance = obj1;</span><br><span class="line">        obj1 = <span class="literal">null</span>;</span><br><span class="line">        obj2 = <span class="literal">null</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong>可达性分析</strong>：</p><p>通过GC Root对象为起点，从这些节点向下搜索，搜索所走过的路径叫引用链，当一个对象到GC Root没有任何的引用链相连时，说明这个对象是不可用的。</p><h2 id="9-可作为GC-Roots的对象有哪些？"><a href="#9-可作为GC-Roots的对象有哪些？" class="headerlink" title="9.可作为GC Roots的对象有哪些？"></a>9.可作为GC Roots的对象有哪些？</h2><ul><li><p>在虚拟机栈中引用的对象，例如各个线程被调用的方法堆栈中使用到的参数、局部变量、临时变量等。</p></li><li><p>在方法区中类静态属性引用的对象，例如 Java 类的引用类型静态变量。</p></li><li><p>在方法区中常量引用的对象，例如字符串常量池 (String Table) 里的引用。</p></li><li><p>在本地方法栈中 Native 方法引用的对象。</p></li><li><p>Java 虚拟机内部的引用，如基本数据类型对应的 Class 对象，一些常驻的异常对象 (比如 NullPointExcepiton、OutOfMemoryError) 等，还有系统类加载器。</p></li><li><p>所有被同步锁 (synchronized 关键字) 持有的对象。</p></li><li><p>反映 Java 虚拟机内部情况的 JMXBean、JVMTI 中注册的回调、本地代码缓存等。</p></li></ul><h2 id="10-什么情况下类会被卸载？"><a href="#10-什么情况下类会被卸载？" class="headerlink" title="10.什么情况下类会被卸载？"></a>10.什么情况下类会被卸载？</h2><p>需要同时满足以下 3 个条件类才可能会被卸载：</p><ul><li><p>该类所有的实例都已经被回收。</p></li><li><p>加载该类的类加载器已经被回收。</p></li><li><p>该类对应的 java.lang.Class 对象没有在任何地方被引用，无法在任何地方通过反射访问该类的方法。</p></li></ul><p>虚拟机可以对满足上述 3 个条件的类进行回收，但不一定会进行回收。</p><h2 id="11-强引用、软引用、弱引用、虚引用是什么，有什么区别？"><a href="#11-强引用、软引用、弱引用、虚引用是什么，有什么区别？" class="headerlink" title="11.强引用、软引用、弱引用、虚引用是什么，有什么区别？"></a>11.强引用、软引用、弱引用、虚引用是什么，有什么区别？</h2><p><strong>强引用</strong>：在程序中普遍存在的引用赋值，类似Object obj = new Object()这种引用关系。只要强引用关系还存在，垃圾收集器就永远不会回收被引用的对象。</p><p><strong>软引用</strong>：如果内存空间足够，垃圾回收器就不会回收它，如果内存空间不足了，就会回收这些对象的内存。示例代码：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//软引用</span></span><br><span class="line">SoftReference&lt;String&gt; softRef = <span class="keyword">new</span> <span class="title class_">SoftReference</span>&lt;String&gt;(str);</span><br></pre></td></tr></table></figure><p><strong>弱引用</strong>：在进行垃圾回收时，不管当前内存空间足够与否，都会回收只具有弱引用的对象。示例代码：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//弱引用</span></span><br><span class="line">WeakReference&lt;String&gt; weakRef = <span class="keyword">new</span> <span class="title class_">WeakReference</span>&lt;String&gt;(str);</span><br></pre></td></tr></table></figure><p><strong>虚引用</strong>：虚引用并不会决定对象的生命周期。如果一个对象仅持有虚引用，那么它就和没有任何引用一样，在任何时候都可能被垃圾回收。虚引用主要是为了能在对象被收集器回收时收到一个系统通知。虚引用创建时必须搭配ReferenceQueue。示例代码：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">ReferenceQueue&lt;Object&gt; queue = <span class="keyword">new</span> <span class="title class_">ReferenceQueue</span>&lt;&gt;();</span><br><span class="line">PhantomReference&lt;Object&gt; phantom = <span class="keyword">new</span> <span class="title class_">PhantomReference</span>&lt;Object&gt;(<span class="keyword">new</span> <span class="title class_">Object</span>(), queue);</span><br></pre></td></tr></table></figure><p>一个对象如果被引用，且最高级别是虚引用，就等于没有被引用，发生gc时不管内存够不够都会被回收。虚引用看起来和弱引用没啥区别，只是必须搭配ReferenceQueue。用虚引用的目的一般是跟踪对象被回收的活动。</p><p>不同的引用类型，主要体现的是对象不同的可达性（reachable）状态和对垃圾收集的影响。</p><ul><li><p>强引用：就是我们最常见的普通对象引用，只要还有强引用指向一个对象，就能表明对象还 “活着”，垃圾收集器不会碰这种对象。对于一个普通的对象，如果没有其他的引用关系，只要超过了引用的作用域或者显式地将相应（强）引用赋值为 null，就是可以被垃圾收集的了，当然具体回收时机还是要看垃圾收集策略。</p></li><li><p>软引用：是一种相对强引用弱化一些的引用，可以让对象豁免一些垃圾收集，只有当 JVM 认为内存不足时，才会去试图回收软引用指向的对象。JVM 会确保在抛出 OutOfMemoryError 之前，清理软引用指向的对象。软引用通常用来实现内存敏感的缓存，如果还有空闲内存，就可以暂时保留缓存，当内存不足时清理掉，这样就保证了使用缓存的同时，不会耗尽内存。</p></li><li><p>弱引用：并不能使对象豁免垃圾收集，仅仅是提供一种访问在弱引用状态下对象的途径。这就可以用来构建一种没有特定约束的关系，比如，维护一种非强制性的映射关系，如果试图获取时对象还在，就使用它，否则重现实例化。</p></li><li><p>虚引用：虚引用并不会决定对象的生命周期，如果一个对象仅持有虚引用，那么它就和没有任何引用一样，在任何时候都可能被垃圾回收，也无法通过虚引用來获取对象实例。虚引用<strong>主要是为了能在对象被收集器回收时收到一个系统通知，这样可以跟踪对象被垃圾回收的活动。</strong></p></li></ul><h2 id="12-聊聊-Java-中的-GC，分别作用在什么范围"><a href="#12-聊聊-Java-中的-GC，分别作用在什么范围" class="headerlink" title="12.聊聊 Java 中的 GC，分别作用在什么范围"></a>12.聊聊 Java 中的 GC，分别作用在什么范围</h2><ul><li><p>新生代收集（Minor GC / Young GC）只是新生代的垃圾收集</p></li><li><p>老年代收集（Major GC / Old GC）只是老年代的垃圾收集</p></li><li><p>整堆收集（Full GC）收集整个堆的垃圾</p></li><li><p>混合收集（Mixed GC）收集整个新生代以及部分老年代的垃圾收集（目前只有 G1 GC 会有这种行为）</p></li></ul><h2 id="13-内存的分配策略？"><a href="#13-内存的分配策略？" class="headerlink" title="13.内存的分配策略？"></a>13.内存的分配策略？</h2><ol><li><p>对象优先在 Eden 分配：大多数情况下，对象在新生代 Eden 上分配，当 Eden 空间不够时，触发 Minor GC。</p></li><li><p>大对象直接进入老年代：大对象是指需要连续内存空间的对象，最典型的大对象有长字符串和大数组。可以设置 JVM 参数 -XX:PretenureSizeThreshold，大于此值的对象直接在老年代分配。</p></li><li><p>长期存活的对象进入老年代：通过参数 -XX:MaxTenuringThreshold 可以设置对象进入老年代的年龄阈值。对象在 Survivor 区每经过一次 Minor GC，年龄就增加 1 岁，当它的年龄增加到一定程度，就会被晋升到老年代中。</p></li><li><p>动态对象年龄判定：并非对象的年龄必须达到 MaxTenuringThreshold 才能晋升老年代，如果在 Survivor 中相同年龄所有对象大小的总和大于 Survivor 空间的一半，则年龄大于或等于该年龄的对象可以直接进入老年代，无需达到 MaxTenuringThreshold 年龄阈值。</p></li><li><p>空间分配担保：在发生 Minor GC 之前，虚拟机先检查老年代最大可用的连续空间是否大于新生代所有对象总空间，如果条件成立的话，那么 Minor GC 是安全的。如果不成立的话虚拟机会查看 HandlePromotionFailure 的值是否允许担保失败。如果允许，那么就会继续检查老年代最大可用的连续空间是否大于历次晋升到老年代对象的平均大小，如果大于，将尝试着进行一次 Minor GC；如果小于，或者 HandlePromotionFailure 的值为不允许担保失败，那么就要进行一次 Full GC。</p></li></ol><h2 id="14-对象头了解吗？"><a href="#14-对象头了解吗？" class="headerlink" title="14.对象头了解吗？"></a>14.对象头了解吗？</h2><p>Java 内存中的对象由以下三部分组成：对象头、实例数据和对齐填充字节。</p><ul><li><p>对象头由以下三部分组成：mark word、指向类信息的指针和数组长度（数组才有）。mark word 包含：对象的哈希码、分代年龄和锁标志位。</p></li><li><p>对象的实例数据就是 Java 对象的属性和值。</p></li><li><p>对齐填充字节：因为 JVM 要求对象占的内存大小是 8byte 的倍数，因此后面有几个字节用于把对象的大小补齐至 8byte 的倍数。<br>内存对齐的主要作用是：</p></li></ul><ol><li><p>平台原因：不是所有的硬件平台都能访问任意地址上的任意数据的；某些硬件平台只能在某些地址处取某些特定类型的数据，否则抛出硬件异常。</p></li><li><p>性能原因：经过内存对齐后，CPU 的内存访问速度大大提升。</p></li></ol><h2 id="15-main方法执行过程"><a href="#15-main方法执行过程" class="headerlink" title="15.main方法执行过程"></a>15.main方法执行过程</h2><p><img src="2025-01-09-JVM基础面试题/image-7.png" alt=""></p><p>执行 main 方法的过程如下：</p><ol><li><p>编译 Application.java 后得到 Application.class 后，执行这个 class 文件，系统会启动一个 JVM 进程，从类路径中找到一个名为 Application.class 的二进制文件，将 Application 类信息加载到运行时数据区的方法区内，这个过程叫做类的加载。</p></li><li><p>JVM 找到 Application 的主程序入口，执行 main 方法。</p></li><li><p>main 方法的第一条语句为 Person p = new Person (“大彬”)，就是让 JVM 创建一个 Person 对象，但是这个时候方法区中是没有 Person 类的信息的，所以 JVM 马上加载 Person 类，把 Person 类的信息放到方法区中。</p></li><li><p>加载完 Person 类后，JVM 在堆中分配内存给 Person 对象，然后调用构造函数初始化 Person 对象，这个 Person 对象持有指向方法区中的 Person 类的类型信息的引用。</p></li><li><p>执行 p.getName () 时，JVM 根据 p 的引用找到 p 所指向的对象，然后根据此对象持有的引用定位到方法区中 Person 类的类型信息的方法表，获得 getName () 的字节码地址。</p></li><li><p>执行 getName () 方法。</p></li></ol><h2 id="16-对象创建过程"><a href="#16-对象创建过程" class="headerlink" title="16.对象创建过程"></a>16.对象创建过程</h2><p><img src="2025-01-09-JVM基础面试题/image-5.png" alt=""></p><p>图片展示了 Java 中对象创建过程，包含类加载检查、分配内存、初始化零值、设置对象头、执行 init 方法五个步骤，并有各步骤详细说明：</p><ol><li><p><strong>类加载检查：</strong>&#x4A;VM 遇到 new 指令时，先检查能否在常量池中定位到该类的符号引用，并检查符号引用代表的类是否已被加载、解析和初始化，未完成则先进行类加载，已加载则通过检查。</p></li><li><p><strong>分配内存：</strong>&#x7C7B;加载检查通过后 JVM 为新对象分配内存，对象所需内存大小在类加载完成后确定，JVM 会在堆中按指针碰撞或空闲列表方式为对象划分空间，选择方式依垃圾收集器算法而定。内存分配要保证线程安全，<strong>JVM 采用 CAS + 失败重试或 TLAB 方式保证。</strong>&#x5176;中，CAS + 失败重试是乐观锁的一种实现，每次占用资源不加锁，而是不断尝试占用；TLAB 是线程创建时预先在堆中给线程分配一块内存，专门存放该线程运行过程中创建的对象，TLAB 满时，采用 CAS 在堆的其它内存中分配。</p></li><li><p>初始化：分配到的内存空间都初始化为零值，保证对象字段可不赋初始值就直接使用，程序能访问到对应零值。</p></li><li><p>设置对象头：在对象头中设置对象所属类、类元数据信息获取方式、对象哈希码、GC 分代年龄、是否启用偏向锁等信息。</p></li><li><p>执行 init 方法：按照程序员编写的构造方法对对象进行初始化。</p></li></ol><h1 id="JVM调优与故障问题排查"><a href="#JVM调优与故障问题排查" class="headerlink" title="JVM调优与故障问题排查"></a>JVM调优与故障问题排查</h1><h2 id="1-⭐️Full-GC-的触发条件？"><a href="#1-⭐️Full-GC-的触发条件？" class="headerlink" title="1.⭐️Full GC 的触发条件？"></a>1.⭐️Full GC 的触发条件？</h2><p>对于 Minor GC，其触发条件比较简单，当 Eden 空间满时，就将触发一次 Minor GC。而 Full GC 触发条件相对复杂，有以下情况会发生 full GC：</p><ul><li><p>调用 System.gc ()：只是建议虚拟机执行 Full GC，但是虚拟机不一定真正去执行。不建议使用这种方式，而是让虚拟机管理内存。</p></li><li><p>老年代空间不足：老年代空间不足的常见场景为前文所讲的大对象直接进入老年代、长期存活的对象进入老年代等。为了避免以上原因引起的 Full GC，应当尽量不要创建过大的对象以及数组。除此之外，可以通过 -Xmn 参数调大新生代的大小，让对象尽量在新生代被回收掉，不进入老年代。还可以通过 -XX:MaxTenuringThreshold 调大对象进入老年代的年龄，让对象在新生代多存活一段时间。</p></li><li><p>空间分配担保失败：使用复制算法的 Minor GC 需要老年代的内存空间作担保，如果担保失败会执行一次 Full GC。</p></li><li><p>JDK 1.7 及以前的永久代空间不足：在 JDK 1.7 及以前，HotSpot 虚拟机中的方法区是用永久代实现的，永久代中存放的为一些 Class 的信息、常量、静态变量等数据。当系统中要加载的类、反射的类和调用的方法较多时，永久代可能会被占满，在未配置为采用 CMS GC 的情况下也会执行 Full GC。如果经过 Full GC 仍然回收不了，那么虚拟机会抛出 java.lang.OutOfMemoryError。</p></li></ul><h2 id="2-常用的JVM启动参数有哪些"><a href="#2-常用的JVM启动参数有哪些" class="headerlink" title="2.常用的JVM启动参数有哪些"></a>2.常用的JVM启动参数有哪些</h2><p>JVM（Java虚拟机）的启动参数用于配置和调整Java应用程序的运行时行为。以下是一些常用的JVM启动参数：</p><ol><li><p>-Xmx：指定Java堆内存的最大限制，如“-Xmx512m”表示最大堆内存为512兆字节。</p></li><li><p>-Xms：指定Java堆内存的初始大小，如“-Xms256m”表示初始堆内存为256兆字节。</p></li><li><p>-Xss：指定每个线程的堆栈大小，如“-Xss256k”表示每个线程的堆栈大小为256千字节。</p></li><li><p>-XX:MaxPermSize（Java 7及之前版本）或 -XX:MaxMetaspaceSize（Java 8及以后版本）：指定永久代（Java 7及之前）或元空间（Java 8及以后）的最大大小。</p></li><li><p>-XX:PermSize（Java 7及之前版本）或 -XX:MetaspaceSize（Java 8及以后版本）：指定永久代（Java 7及之前）或元空间（Java 8及以后）的初始大小。&#x20;</p></li><li><p>-Xmn：指定年轻代的大小，如“-Xmn256m”表示年轻代大小为256兆字节。</p></li><li><p>-XX:SurvivorRatio：指定年轻代中Eden区与Survivor区的大小比例，如“-XX:SurvivorRatio=8”表示Eden区与每个Survivor区的大小比例为8:1。&#x20;</p></li><li><p>-XX:NewRatio：指定年轻代与老年代的大小比例，如“-XX:NewRatio=2”表示年轻代和老年代的比例为1:2。&#x20;</p></li><li><p>-XX:MaxGCPauseMillis：设置垃圾回收的最大暂停时间目标，如“-XX:MaxGCPauseMillis=100”表示垃圾回收的最大暂停时间目标为100毫秒。&#x20;</p></li><li><p>-XX:ParallelGCThreads：指定并行垃圾回收线程的数量，如“-XX:ParallelGCThreads=4”表示使用4个线程进行并行垃圾回收。&#x20;</p></li><li><p>-XX:+UseConcMarkSweepGC：启用并发标记清除垃圾回收器。&#x20;</p></li><li><p>-XX:+UseG1GC：启用G1（Garbage First）垃圾回收器。&#x20;</p></li><li><p>-Dproperty=value：设置Java系统属性，可在应用程序中用System.getProperty(“property”)获取这些属性的值。&#x20;</p></li></ol><h2 id="3-常用的-JVM-调优的命令都有哪些？"><a href="#3-常用的-JVM-调优的命令都有哪些？" class="headerlink" title="3.常用的 JVM 调优的命令都有哪些？"></a>3.常用的 JVM 调优的命令都有哪些？</h2><p><img src="2025-01-09-JVM基础面试题/image-4.png" alt=""></p><p><img src="2025-01-09-JVM基础面试题/image-3.png" alt=""></p><p><img src="2025-01-09-JVM基础面试题/image-2.png" alt=""></p><p><img src="2025-01-09-JVM基础面试题/image-15.png" alt=""></p><p><img src="2025-01-09-JVM基础面试题/image-16.png" alt=""></p><h2 id="4-如何排查-OOM-的问题？"><a href="#4-如何排查-OOM-的问题？" class="headerlink" title="4.如何排查 OOM 的问题？"></a>4.如何排查 OOM 的问题？</h2><p>排查 OOM（OutOfMemoryError，内存溢出）的方法：</p><ul><li><p>增加 JVM 参数 -XX:+HeapDumpOnOutOfMemoryError 和 -XX:HeapDumpPath=/tmp/heapdump.hprof，当 OOM 发生时自动 dump 堆内存信息到指定目录；</p></li><li><p>jstat 查看监控 JVM 的内存和 GC 情况，评估问题大概在什么区域；</p></li><li><p>使用 MAT 工具载入 dump 文件，分析大对象的占用情况 。</p></li></ul><h2 id="5-如何诊断java线程死锁？jstack"><a href="#5-如何诊断java线程死锁？jstack" class="headerlink" title="5.如何诊断java线程死锁？jstack"></a>5.如何诊断java线程死锁？jstack</h2><blockquote><h3 id="使用jstack进行死锁诊断的详细步骤："><a href="#使用jstack进行死锁诊断的详细步骤：" class="headerlink" title="使用jstack进行死锁诊断的详细步骤："></a>使用jstack进行死锁诊断的详细步骤：</h3><h4 id="步骤1-确认进程ID-PID"><a href="#步骤1-确认进程ID-PID" class="headerlink" title="步骤1: 确认进程ID (PID)"></a>步骤1: 确认进程ID (PID)</h4><ol><li><p>使用ps查找进程：</p><ul><li><p>打开终端，并运行以下命令以列出所有Java进程。</p></li><li><p>找到目标Java应用的PID。</p></li></ul></li></ol><h4 id="步骤2-生成线程堆栈信息"><a href="#步骤2-生成线程堆栈信息" class="headerlink" title="步骤2: 生成线程堆栈信息"></a>步骤2: 生成线程堆栈信息</h4><ul><li><p>运行jstack命令：</p><ul><li><p>使用以上命令生成线程栈信息：</p></li><li><p>替换\<PID> 为实际的进程ID。这个命令会把线程信息输出到thread_dump.txt文件中。</p></li></ul></li></ul><h4 id="步骤3-分析线程堆栈信息"><a href="#步骤3-分析线程堆栈信息" class="headerlink" title="步骤3: 分析线程堆栈信息"></a>步骤3: 分析线程堆栈信息</h4><ul><li><p>打开文件：</p><ul><li>使用文本编辑器打开thread_dump.txt文件。</li></ul></li><li><p>查找线程状态：</p><ul><li><p>在文件中查找BLOCKED和WAITING关键字，寻找被阻塞或等待的线程。</p></li><li><p>每个线程的信息通常以 “\n” 分隔。</p></li></ul></li><li><p>定位锁信息：</p><ul><li><p>对于BLOCKED状态的线程，检查线程正在等待的锁，通常在输出的最后部分。</p></li><li><p>对于每个WAITING状态的线程，检查它们的等待来源。</p></li></ul></li></ul><h4 id="步骤4-确定死锁"><a href="#步骤4-确定死锁" class="headerlink" title="步骤4: 确定死锁"></a>步骤4: 确定死锁</h4><ul><li><p>识别循环依赖：</p><ul><li>检查是否有两个或多个线程相互等待对方持有的锁。确认这种依赖关系之后，您可以判断存在死锁。</li></ul></li></ul><h4 id="步骤5-解决死锁"><a href="#步骤5-解决死锁" class="headerlink" title="步骤5: 解决死锁"></a>步骤5: 解决死锁</h4><ul><li><p>修改代码：</p><ul><li><p>确保所有线程获取锁的顺序一致，避免循环依赖。</p></li><li><p>考虑使用锁超时（比如tryLock()方法）。</p></li></ul></li></ul><h3 id="其他诊断死锁的方式"><a href="#其他诊断死锁的方式" class="headerlink" title="其他诊断死锁的方式"></a>其他诊断死锁的方式</h3><p>JVisualVM、JConsole等都可以有效诊断Java中的线程死锁问题。&#x20;</p></blockquote>]]></content>
    
    
    <summary type="html">🥧JVM基础面试题总结</summary>
    
    
    
    <category term="面试题" scheme="https://outoflovenicoo.github.io/categories/%E9%9D%A2%E8%AF%95%E9%A2%98/"/>
    
    
    <category term="JVM面试题" scheme="https://outoflovenicoo.github.io/tags/JVM%E9%9D%A2%E8%AF%95%E9%A2%98/"/>
    
  </entry>
  
  <entry>
    <title>JUC基础面试题</title>
    <link href="https://outoflovenicoo.github.io/posts/2025-01-09-JUC%E5%9F%BA%E7%A1%80%E9%9D%A2%E8%AF%95%E9%A2%98.html"/>
    <id>https://outoflovenicoo.github.io/posts/2025-01-09-JUC%E5%9F%BA%E7%A1%80%E9%9D%A2%E8%AF%95%E9%A2%98.html</id>
    <published>2025-01-09T10:19:03.000Z</published>
    <updated>2025-03-23T14:00:00.000Z</updated>
    
    <content type="html"><![CDATA[<h1 id="学习"><a href="#学习" class="headerlink" title="学习"></a>学习</h1><h2 id="1-Future"><a href="#1-Future" class="headerlink" title="1.Future"></a>1.Future</h2><blockquote><p><a href="https://javaguide.cn/java/concurrent/java-concurrent-questions-03.html#future-%E7%B1%BB%E6%9C%89%E4%BB%80%E4%B9%88%E7%94%A8">Future 类有什么用？</a></p><p><a href="https://juejin.cn/post/6844904199625375757">Java是如何实现Future模式的?万字详解!</a></p></blockquote><p><img src="2025-01-09-JUC基础面试题/diagram.png" alt=""></p><h2 id="（1）Future的用法"><a href="#（1）Future的用法" class="headerlink" title="（1）Future的用法"></a>（1）Future的用法</h2><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// DaHuoGuo.java</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">DaHuoGuo</span> &#123;</span><br><span class="line">        <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> Exception &#123;</span><br><span class="line">                FutureTask&lt;String&gt; futureTask = <span class="keyword">new</span> <span class="title class_">FutureTask</span>&lt;&gt;(<span class="keyword">new</span> <span class="title class_">Callable</span>&lt;String&gt;() &#123;</span><br><span class="line">                        <span class="meta">@Override</span></span><br><span class="line">                        <span class="keyword">public</span> String <span class="title function_">call</span><span class="params">()</span> <span class="keyword">throws</span> Exception &#123;</span><br><span class="line">                                System.out.println(Thread.currentThread().getName() + <span class="string">&quot;:&quot;</span> + <span class="string">&quot;开始烧开水...&quot;</span>);</span><br><span class="line">                                <span class="comment">// 模拟烧开水耗时</span></span><br><span class="line">                                Thread.sleep(<span class="number">2000</span>);</span><br><span class="line">                                System.out.println(Thread.currentThread().getName() + <span class="string">&quot;:&quot;</span>  + <span class="string">&quot;开水已经烧好了...&quot;</span>);</span><br><span class="line">                                <span class="keyword">return</span> <span class="string">&quot;开水&quot;</span>;</span><br><span class="line">                        &#125;</span><br><span class="line">                &#125;);</span><br><span class="line"></span><br><span class="line">                <span class="type">Thread</span> <span class="variable">thread</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Thread</span>(futureTask);</span><br><span class="line">                thread.start();</span><br><span class="line"></span><br><span class="line">                <span class="comment">// do other thing</span></span><br><span class="line">                System.out.println(Thread.currentThread().getName() + <span class="string">&quot;:&quot;</span>  + <span class="string">&quot; 此时开启了一个线程执行future的逻辑（烧开水），此时我们可以干点别的事情（比如准备火锅食材）...&quot;</span>);</span><br><span class="line">                <span class="comment">// 模拟准备火锅食材耗时</span></span><br><span class="line">                Thread.sleep(<span class="number">3000</span>);</span><br><span class="line">                System.out.println(Thread.currentThread().getName() + <span class="string">&quot;:&quot;</span>  + <span class="string">&quot;火锅食材准备好了&quot;</span>);</span><br><span class="line">                <span class="type">String</span> <span class="variable">shicai</span> <span class="operator">=</span> <span class="string">&quot;火锅食材&quot;</span>;</span><br><span class="line"></span><br><span class="line">                <span class="comment">// 开水已经稍好，我们取得烧好的开水</span></span><br><span class="line">                <span class="type">String</span> <span class="variable">boilWater</span> <span class="operator">=</span> futureTask.get();</span><br><span class="line"></span><br><span class="line">                System.out.println(Thread.currentThread().getName() + <span class="string">&quot;:&quot;</span>  + boilWater + <span class="string">&quot;和&quot;</span> + shicai + <span class="string">&quot;已经准备好，我们可以开始打火锅啦&quot;</span>);</span><br><span class="line">        &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure><h2 id="（2）CompletableFuture的用法"><a href="#（2）CompletableFuture的用法" class="headerlink" title="（2）CompletableFuture的用法"></a>（2）CompletableFuture的用法</h2><p>见代码CFUser</p><p>原理：</p><p><a href="https://mcnfxurl5vzo.feishu.cn/wiki/Lp6uws3rFiEDjXkkyGGchQWQnVH#share-YTvbd2a9qoU8qRx7RU4cl8kencd"> 博客</a></p><hr><h1 id="面试题目"><a href="#面试题目" class="headerlink" title="面试题目"></a>面试题目</h1><h2 id="并发基础"><a href="#并发基础" class="headerlink" title="并发基础"></a>并发基础</h2><h3 id="1-线程状态如何流转"><a href="#1-线程状态如何流转" class="headerlink" title="1.线程状态如何流转"></a>1.线程状态如何流转</h3><p><img src="2025-01-09-JUC基础面试题/image-6.png" alt=""></p><h3 id="2-Java创建线程的方式"><a href="#2-Java创建线程的方式" class="headerlink" title="2.Java创建线程的方式"></a>2.Java创建线程的方式</h3><p><img src="2025-01-09-JUC基础面试题/image.png" alt=""></p><p><a href="https://blog.csdn.net/longshengguoji/article/details/41126119">java创建线程的三种方式及其对比_创建线程有哪几种方式-CSDN博客</a></p><h3 id="3-⭐️启动线程为何调用start而不是run方法"><a href="#3-⭐️启动线程为何调用start而不是run方法" class="headerlink" title="3. ⭐️启动线程为何调用start而不是run方法"></a>3. ⭐️启动线程为何调用start而不是run方法</h3><p><strong>调用start()方法会告诉jvm创建一个新的线程</strong>，并在这个新线程中执行与run()方法相关联的代码块。这个过程允许多个线程同时运行，每个线程都拥有独立的执行上下文，这意味着它们可以在互不相干的情况下执行任务。</p><p>与此不同，<strong>如果直接调用run()方法</strong>，它仅仅是一个普通的方法调用，不会创建新的线程。相反，它会在当前线程的上下文中执行run()方法中的代码。这将导致代码的顺序执行，没有并行性可言，因为它们都在同一个线程内执行。</p><p>这种区别非常重要，因为多线程编程的一个主要目标是实现并行性，从而提高程序的性能和响应能力。通过调用start()方法，可以利用多核处理器的优势，同时执行多个线程，以更有效地完成任务。而直接调用run()方法只是按照一般的方法顺序执行代码，无法发挥多线程的潜力。因此，使用start()方法来启动线程是实现并行性的关键。&#x20;</p><h3 id="4-wait-、notify-和-notifyAll-、sleep-、yield"><a href="#4-wait-、notify-和-notifyAll-、sleep-、yield" class="headerlink" title="4. wait()、notify()和 notifyAll()、sleep()、yield()"></a>4. wait()、notify()和 notifyAll()、sleep()、yield()</h3><ul><li><p>sleep是让线程自己拿着锁休眠，但是不释放锁，暂停线程的执行</p></li><li><p>wait是A线程通过对象的方法来释放自己持有的该对象的锁,并处于等待状态。Java中每一个对象都包含一个监视器锁，wait方法是当前持有锁的线程 【主动】 放弃锁并等待；wait 不是等锁，而是等一个条件，这个条件要嘛是定时时间到了，要嘛是别人notify。等到条件满足之后，才有资格去竞争锁，后续就走正常锁竞争流程了。  例如B没有释放，那确实得等B用完释放了才能获取到锁。</p></li><li><p><code>notifyAll()</code>：会唤醒所有在该对象的等待队列中等待的线程。</p></li><li><p><code>notify()</code>：只会随机唤醒一个在该对象的等待队列中等待的线程。</p></li><li><p>yield()方法只会给相同优先级或更高优先级的线程以运行的机会；sleep()方法给其他线程运行机会时不考虑线程的优先级，因此会给低优先级的线程以运行的机会； 线程执行 sleep()方法后转入阻塞（超时等待状态），而执行 yield()方法后转入就绪（ready）状态；扩展：</p></li></ul><p>为什么wait()、notify()和 notifyAll()要定义在类里</p><p>对象才是共享资源的单位，每一个对象都可能成为共享资源，wait方法定义在Object中是为了让每一个对象都可以方便的共享。</p><p>为什么 wait(), notify()和 notifyAll()必须在同步方法或者同步块中被调用？</p><p>共享资源时不需要关注线程，对象才是需要互斥访问的资源，因此对象的wait()方法必须在持有锁之后调用；</p><p>同理，notify()方法也必须在持有锁之后调用，类似于告诉别人我马上用完了，你可以过来排队等着</p><p>很少需要直接控制一个线程的等待状态，主要还是等待共享资源的访问权，相比控制线程本身，控制资源访问权限更符合直觉。</p><h3 id="5-Java-中-interrupted-和-isInterrupted-方法的区别？"><a href="#5-Java-中-interrupted-和-isInterrupted-方法的区别？" class="headerlink" title="5.Java 中 interrupted 和 isInterrupted 方法的区别？"></a>5.Java 中 interrupted 和 isInterrupted 方法的区别？</h3><blockquote><p>interrupt：用于中断线程。调用该方法的线程的状态为将被置为”中断”状态。</p><p>&#x20;注意：线程中断仅仅是置线程的中断状态位，不会停止线程。需要用户自己去监视线程的状态为并做处理。支持线程中断的方法（也就是线程中断后会抛出interruptedException 的方法）就是在监视线程的中断状态，一旦线程的中断状态被置为“中断状态”，就会抛出中断异常。</p><p>&#x20;interrupted：是静态方法，查看当前中断信号是true还是false并且清除中断信号。如果一个线程被中断了，第一次调用 interrupted 则返回 true，第二次和后面的就返回 false 了。</p><p>isInterrupted：是可以返回当前中断信号是true还是false，与interrupted最大的差别是，isInterruputed不会清除中断信号，而interrupted会清除中断信号“。</p></blockquote><h3 id="6-同步方法和同步块，哪个是更好的选择"><a href="#6-同步方法和同步块，哪个是更好的选择" class="headerlink" title="6. 同步方法和同步块，哪个是更好的选择?"></a>6. 同步方法和同步块，哪个是更好的选择?</h3><p><strong>参考回答</strong>：</p><ul><li><p>同步块是更好的选择，因为它不会锁住整个对象（当然你也可以让它锁住整个对象）。同步方法会锁住整个对象，哪怕这个类中有多个不相关联的同步块，通常会导致它们停止执行并需要等待获得这个对象上的锁。</p></li><li><p>同步块更符合开放调用的原则，只在需要锁住的代码块锁住相应的对象，这样从侧面来说也可以避免死锁。</p></li></ul><p>请知道一条原则：同步的范围越小越好。&#x20;</p><h3 id="7-什么是线程同步和线程互斥，有哪几种实现方式？"><a href="#7-什么是线程同步和线程互斥，有哪几种实现方式？" class="headerlink" title="7.什么是线程同步和线程互斥，有哪几种实现方式？"></a>7.什么是线程同步和线程互斥，有哪几种实现方式？</h3><p><strong>实现线程同步的方法</strong></p><ul><li><p>同步代码方法：synchronized关键字修饰的方法</p></li><li><p>同步代码块：synchronized关键字修饰的代码块</p></li><li><p>使用特殊变量域volatile实现线程同步：volatile关键字为域变量的访问提供了一种免锁机制</p></li><li><p>使用重入锁实现线程同步：reentrantlock类是可重入、互斥、实现了lock接口的锁，它与synchronized方法具有相同的基本行为和语义&#x20;</p></li></ul><h3 id="8-在监视器-Monitor-内部，是如何做线程同步的？程序应该做哪种级别的同步？"><a href="#8-在监视器-Monitor-内部，是如何做线程同步的？程序应该做哪种级别的同步？" class="headerlink" title="8.在监视器(Monitor)内部，是如何做线程同步的？程序应该做哪种级别的同步？"></a>8.在监视器(Monitor)内部，是如何做线程同步的？程序应该做哪种级别的同步？</h3><blockquote><p>在 java 虚拟机中，监视器和锁在Java虚拟机中是一块使用的。监视器监视一块同步代码块，确保一次只有一个线程执行同步代码块。每一个监视器都和一个对象引用相关联。线程在获取锁之前不允许执行同步代码。&#x20;</p><p>一旦方法或者代码块被 synchronized 修饰，那么这个部分就放入了监视器的监视区域，确保一次只能有一个线程执行该部分的代码，线程在获取锁之前不允许执行该部分的代码</p><p>另外 java 还提供了显式监视器( Lock )和隐式监视器( synchronized )两种锁方案</p></blockquote><h3 id="9-如果你提交任务时，核心线程数已达到配置的数量，这时会发生什么"><a href="#9-如果你提交任务时，核心线程数已达到配置的数量，这时会发生什么" class="headerlink" title="9.如果你提交任务时，核心线程数已达到配置的数量，这时会发生什么"></a>9.如果你提交任务时，核心线程数已达到配置的数量，这时会发生什么</h3><blockquote><p>有俩种可能：</p><ul><li>(1) 如果使用的是无界队列</li></ul><p>LinkedBlockingQueue，也就是无界队列的话，没关系，继续添加任务到阻塞队列中等待执行，因为LinkedBlockingQueue可以近乎认为是一个无穷大的队列，可以无限存放任务。</p><ul><li>(2) 如果使用的是有界队列比如</li></ul><p>ArrayBlockingQueue，任务首先会被添加到ArrayBlockingQueue中，ArrayBlockingQueue满了，会根据maximumPoolSize的值增加线程数量，如果增加了线程数量还是处理不过来，ArrayBlockingQueue继续满，那么则会使用拒绝策略RejectedExecutionHandler处理满了的任务，默认是AbortPolicy&#x20;</p></blockquote><h3 id="10-在-Java-程序中怎么保证多线程的运行安全？"><a href="#10-在-Java-程序中怎么保证多线程的运行安全？" class="headerlink" title="10.在 Java 程序中怎么保证多线程的运行安全？"></a>10.在 Java 程序中怎么保证多线程的运行安全？</h3><blockquote><p><strong>方法一</strong>：使用安全类，比如java.util.concurrent下的类，使用原子类AtomicInteger</p><p><strong>方法二</strong>：使用自动锁synchronized。</p><p><strong>方法三</strong>：使用手动锁Lock。手动锁Java示例代码如下：</p></blockquote><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">  Lock lock = new ReentrantLock();</span><br><span class="line">  lock.lock();</span><br><span class="line">  try &#123;</span><br><span class="line">      System.out.println(&quot;获得锁&quot;);</span><br><span class="line">  &#125; catch (Exception e) &#123;</span><br><span class="line">      // TODO: handle exception</span><br><span class="line">    &#125; finally &#123;</span><br><span class="line">     System.out.println(&quot;释放锁&quot;);</span><br><span class="line">      lock.unlock();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="11-线程类的构造方法、静态块是被哪个线程调用的"><a href="#11-线程类的构造方法、静态块是被哪个线程调用的" class="headerlink" title="11.线程类的构造方法、静态块是被哪个线程调用的"></a>11.线程类的构造方法、静态块是被哪个线程调用的</h3><blockquote><p>这是一个非常刁钻和狡猾的问题。请记住：线程类的构造方法、静态块是被new这个线程类所在的线程所调用的，而run方法里面的代码才是被线程自身所调用的。</p><p>如果说上面的说法让你感到困惑，那么我举个例子，假设Thread2中new了Thread1，main函数中new了Thread2，那么：</p><ul><li><p>(1) Thread2的构造方法、静态块是main线程调用的，Thread2的run()方法是Thread2自己调用的</p></li><li><p>(2) Thread1的构造方法、静态块是Thread2调用的，Thread1的run()方法是Thread1自己调用的&#x20;</p></li></ul></blockquote><h3 id="12-Java中怎么获取一份线程dump文件？你如何在Java中获取线程堆栈？"><a href="#12-Java中怎么获取一份线程dump文件？你如何在Java中获取线程堆栈？" class="headerlink" title="12. Java中怎么获取一份线程dump文件？你如何在Java中获取线程堆栈？"></a>12. Java中怎么获取一份线程dump文件？你如何在Java中获取线程堆栈？</h3><p><strong>参考回答</strong>：</p><blockquote><p>Dump文件是进程的内存镜像。可以把程序的执行状态通过调试器保存到dump文件中。</p><p>在Linux下，你可以通过命令jstack -l PID（Java进程的进程ID）来获取Java应用的dump文件。</p><p>在Windows下，你可以按下Ctrl + Break来获取，这样JVM就会将线程的dump文件打印到标准输出或错误文件中，它可能打印在控制台或者日志文件中，具体位置依赖应用的配置。</p></blockquote><h3 id="13-一个线程运行时发生异常会怎样？"><a href="#13-一个线程运行时发生异常会怎样？" class="headerlink" title="13. 一个线程运行时发生异常会怎样？"></a>13. 一个线程运行时发生异常会怎样？</h3><blockquote><p><strong>参考回答</strong>：</p><p>如果异常没有被捕获该线程将会停止执行。</p><p>Thread.UncaughtExceptionHandler是用于处理未捕获异常造成线程突然中断情况的一个内嵌接口。当一个未捕获异常将造成线程中断的时候，JVM会使用Thread.getUncaughtExceptionHandler()来查询线程的UncaughtExceptionHandler，并将线程和异常作为参数传递给handler的uncaughtException()方法进行处理。&#x20;</p></blockquote><h3 id="14-多线程的常用方法"><a href="#14-多线程的常用方法" class="headerlink" title="14.多线程的常用方法"></a>14.多线程的常用方法</h3><div class="table-container"><table><thead><tr><th>方法名</th><th>描述</th></tr></thead><tbody><tr><td>sleep()isAlive()join()activeCount()enumerate()currentThread()isDaemon()setDaemon()setName()wait()notify()setPriority()</td><td>强迫一个线程睡眠N毫秒判断一个线程是否存活。等待线程终止。程序中活跃的线程数。枚举程序中的线程。得到当前线程。一个线程是否为守护线程。设置一个线程为守护线程。为线程设置一个名称。强迫一个线程等待。通知一个线程继续运行。设置一个线程的优先级。</td></tr></tbody></table></div><h3 id="15-❓介绍一下-ThreadLocal"><a href="#15-❓介绍一下-ThreadLocal" class="headerlink" title="15.❓介绍一下 ThreadLocal"></a>15.❓介绍一下 ThreadLocal</h3><blockquote><p>Thread类有两个变量：threadLocals和inheritableThreadLocals。</p><p>这两个变量默认为null，只有当该线程调用了ThreadLocal类的get/set方法时才会创建他们，而调用ThreadLocal的get/set实际上是调用ThreadLocalMap的get/set。</p><p>ThreadLocalMap可理解成给ThreadLocal定制化的HashMap。</p><p>最终的变量放在了线程的ThreadLocalMap中，而不是ThreadLocal中，ThreadLocal只是对其进行封装，向其传递变量值。</p><p>用一个场景分析ThreadLocal的get/set流程：</p><p>首先在所有线程外部创建一个共享的ThreadLocal对象，记为TL1。在一个线程中调用TL1.get()时，首先获取到当前线程对象，记为t，然后判断t.threadLocals是否为null，如果为null，就在t中创建一个新的ThreadLocalMap对象赋值给t.threadLocals，并将\<TL1,null>插入其中，最后get方法返回null；如果不为null，则尝试获取threadLocals中TL1所在的键值对，如果该键值对为null，则向threadLocals中通过set方法插入\<TL1,null>，最后返回null，如果键值对不为null，则返回键值对中的值。</p><p>调用set方法时，流程和get基本一致，只是从读变成了写。</p><p>这样就可以实现不同线程访问同一个ThreadLocal（TL1）能拿到各自向其中存放的值。&#x20;</p></blockquote><p><img src="2025-01-09-JUC基础面试题/image-5.png" alt=""></p><h3 id="16-ThreadLocal-内存泄露问题了解吗"><a href="#16-ThreadLocal-内存泄露问题了解吗" class="headerlink" title="16.ThreadLocal 内存泄露问题了解吗"></a>16.ThreadLocal 内存泄露问题了解吗</h3><p><img src="2025-01-09-JUC基础面试题/image-3.png" alt=""></p><p><strong>分析</strong></p><p>ThreadLocal 内存泄露也是个老生常谈的问题了，网上部分资料，包括好多面试官都把这个问题出现的主要原因归结为 ThreadLocalMaps 里 Entry Key（ThreadLocal 对象本身）使用了弱引用导致的，但是我们仔细看看引用结构，脑补一下内存泄露的场景就不难发现，真正导致内存泄露的主要原因，其实是 Thread 强引用 ThreadLocalMaps，如果 Thread 一直存在，ThreadLocalMaps Entry 中的 value 这个强引用一直存在，不被回收才是导致发生内存泄露的真正原因</p><blockquote><p>因为 ThreadLocal 本身不存储对象，是调用 Thread 中的 ThreadLocalMaps 来保存，而 Thread 强引用 ThreadLocalMaps 对象，如果 Thread 对象生命周期过长，不能及时被回收，就会导致 ThreadLocalMaps 对象里 Entry 的 value 存在内存泄露的可能。</p><p>当然 ThreadLocalMaps 在设计的时候也考虑过这个问题，所以 ThreadLocalMaps Key 采用了弱引用的方式，并且在 set、remove、rehash 的时候会主动清理 ThreadLocalMaps 中 Key 为 Null 的 value，但是如果 ThreadLocal 已经不被使用了 set、remove、rehash 方法也不会被调用，与此同时，如果这个线程又一直存活、不终止的话，那么一ThreadLocalMaps 中的 Value 强引用就会一直存在，也就避免不了 Value 的内存泄漏</p></blockquote><p><a href="https://learn.lianglianglee.com/%E4%B8%93%E6%A0%8F/Java%20%E5%B9%B6%E5%8F%91%E7%BC%96%E7%A8%8B%2078%20%E8%AE%B2-%E5%AE%8C/47%20%E5%86%85%E5%AD%98%E6%B3%84%E6%BC%8F%E2%80%94%E2%80%94%E4%B8%BA%E4%BD%95%E6%AF%8F%E6%AC%A1%E7%94%A8%E5%AE%8C%20ThreadLocal%20%E9%83%BD%E8%A6%81%E8%B0%83%E7%94%A8%20remove\(\">47 内存泄漏——为何每次用完 ThreadLocal 都要调用 remove()?</a>%EF%BC%9F.md)</p><h3 id="17-为什么用ThreadLocal不用线程成员变量"><a href="#17-为什么用ThreadLocal不用线程成员变量" class="headerlink" title="17.为什么用ThreadLocal不用线程成员变量?"></a>17.为什么用ThreadLocal不用线程成员变量?</h3><p><strong>参考回答</strong>：</p><blockquote><p>如果用成员变量，那么成员变量必须在Thread里，不能在Runnable里，因为一个Runnable对象可以被多个Thread执行。</p><p>而如果在Thread中添加成员变量，就要加强Thread和Runnable的耦合，将Thread作为Runnable的成员变量，并在Runnable中调用具体的Thread变量，如果执行Runnable的Thread可能有很多子类，不同子类有不同的成员变量，则要在run方法中进行复杂处理，扩展性较低，不利于维护。而ThreadLocal就是将成员变量统一为一个Map放到线程里。&#x20;</p></blockquote><h2 id="⭐️Java并发理论（Volatile-Synchronized-CAS）"><a href="#⭐️Java并发理论（Volatile-Synchronized-CAS）" class="headerlink" title="⭐️Java并发理论（Volatile/Synchronized/CAS）"></a>⭐️Java并发理论（Volatile/Synchronized/CAS）</h2><h3 id="1-线程之间如何通信及线程之间如何同步"><a href="#1-线程之间如何通信及线程之间如何同步" class="headerlink" title="1. 线程之间如何通信及线程之间如何同步"></a>1. 线程之间如何通信及线程之间如何同步</h3><p><strong>参考回答</strong>：</p><blockquote><p>- 在并发编程中，我们需要处理两个关键问题：线程之间如何通信及线程之间如何同步。通信是指线程之间以如何来交换信息。一般线程之间的通信机制有两种：共享内存和消息传递。同步是指程序中用于控制不同线程间操作发生相对顺序的机制。</p><p>- Java的并发采用的是共享内存模型，Java线程之间的通信总是隐式进行，整个通信过程对程序员完全透明。如果编写多线程程序的Java程序员不理解隐式进行的线程之间通信的工作机制，很可能会遇到各种奇怪的内存可见性问题。</p><p>- 在共享内存并发模型里，同步是显式进行的。程序员必须显式指定某个方法或者某段代码需要在线程之间互斥执行。&#x20;</p></blockquote><h3 id="2-Java内存模型（JMM）"><a href="#2-Java内存模型（JMM）" class="headerlink" title="2.Java内存模型（JMM）"></a>2.Java内存模型（JMM）</h3><p><img src="2025-01-09-JUC基础面试题/image-4.png" alt=""></p><p><a href="https://blog.csdn.net/Your_heart_private/article/details/105566207">Jvm内存模型和JMM模型结构图_java jmm模型图-CSDN博客</a></p><p><a href="https://pdai.tech/md/java/jvm/java-jvm-x-introduce.html">JVM 基础 - Java 内存模型引入</a></p><p><a href="https://zhuanlan.zhihu.com/p/29881777">https://zhuanlan.zhihu.com/p/29881777</a></p><h3 id="3-Happens-Before-原则"><a href="#3-Happens-Before-原则" class="headerlink" title="3.Happens-Before 原则"></a>3.Happens-Before 原则</h3><p><strong>分析</strong></p><p>理解JMM模型如何保证并发安全性，知道指令重排，理解happens-before原则</p><p><strong>回答</strong></p><blockquote><p>happens-before 字面意思就是先行发生，你可以理解为A happens before B，就是A发生在B之前。</p><p>happens-before（HB）是在JMM中的一个很重要的规则，即一个操作的结果对于另一个操作是可见的，用来指定两个操作之间的执行顺序。&#x20;</p></blockquote><p><a href="https://blog.51cto.com/u_11812862/3002287">阿里面试题:Java 并发编程之 happens-before 规则_51CTO博客_java happens-before原则</a></p><h3 id="4-Java-怎么进行并发控制？"><a href="#4-Java-怎么进行并发控制？" class="headerlink" title="4.Java 怎么进行并发控制？"></a>4.Java 怎么进行并发控制？</h3><blockquote><p>并发控制中的锁一般有两种，悲观锁和乐观锁，一般来说悲观锁是基于Monitor实现的，这在Java中分别对应synchronized关键字和AQS。乐观锁是基于CAS+自旋来实现的，Java中用的比较多的是并发原子类。</p><p><strong>synchronized</strong></p><p>synchronized修饰的方法或代码块同一时间只能被一个线程执行。</p><p>一般有三种使用方法：</p><ol><li><p>修饰实例方法：调用某对象的该方法前获取该对象实例的锁。</p></li><li><p>修饰静态方法：调用某对象的该方法前获取该类的锁。</p></li><li><p>两个线程分别执行同一个对象synchronized修饰的实例方法和静态方法时不会发生互斥，因为锁的资源不同，一个锁了对象实例，一个锁了类。</p></li><li><p>锁对象，修饰代码块：synchronized(对象的引用)锁的是对象实例，synchronized(类.class)锁的是类。</p></li></ol><p>尽量不要使用synchronized(String a)因为JVM中，字符串常量池具有缓存功能！</p><p>synchronized不能修饰构造方法，也没必要修饰，构造方法本身就是线程安全的。</p><p>底层原理：尝试获取对象的monitor，monitor已被其他线程占用时，获取失败，该线程进入EntrySet。占有monitor时调用wait()进入WaitSet。调用notify()时从WaitSet里随机选一个线程唤醒，调用notifyAll时唤醒WaitSet里所有线程。</p><p><strong>&#x20;AQS</strong></p><p>AQS全称是AbstractQueuedSynchronizer，它是Java中用来构建锁和同步器的基础框架，可以用于实现诸如ReentrantLock、Semaphore、CountDownLatch等多种同步工具。</p><p>AQS主要依赖于一个双向链表和一个volatile类型的整数state来实现同步控制。该整数state用来表示同步状态，一般情况下，state=0表示没有线程占用同步资源，state&gt;0表示有线程占用同步资源，比如ReentrantLock可以允许一个线程多次获得锁，每次state值加一。</p><p>AQS的主要方法有下面几个：</p><ul><li><p>acquire()：该方法用来获取同步状态，如果同步状态被占用，则线程将被加入等待队列中。</p></li><li><p>acquireInterruptibly()：与acquire()类似，但是该方法允许中断操作。</p></li><li><p>tryAcquire()：该方法用来尝试获取同步状态，如果成功则返回true，否则返回false。</p></li><li><p>release()：该方法用来释放同步状态，并唤醒等待队列中的线程。</p></li><li><p>acquireShared()：该方法用来获取共享式同步状态，如果同步状态被占用，则线程将被加入等待队列中。</p></li><li><p>releaseShared()：该方法用来释放共享式同步状态，并唤醒等待队列中的线程。</p></li></ul><p>AQS实现同步的关键在于，它提供了一个基于FIFO队列的等待队列，通过将等待线程加入等待队列中，然后在释放同步状态的时候，从等待队列中唤醒等待线程，从而实现了同步机制。&#x20;</p><p>AQS的实现主要有两种方式：独占式（Exclusive）和共享式（Shared）。独占式是指只有一个线程可以占用同步资源，比如ReentrantLock，而共享式是指多个线程可以同时占用同步资源，比如CountDownLatch。在AQS中，这两种方式的实现是基本相同的，区别在于获取和释放同步状态的方式不同。</p><p>以上是AQS的基本实现方式，它是Java中构建锁和同步器的核心框架，为各种同步工具的实现提供了强大的基础支持。&#x20;</p></blockquote><p><a href="https://ls8sck0zrg.feishu.cn/wiki/Y6jkwwaHPiJw6skxQsfctlVVnMb#share-WZDZdVZqWobjF0xwtjocNSOqnQd">https://ls8sck0zrg.feishu.cn/wiki/Y6jkwwaHPiJw6skxQsfctlVVnMb#share-WZDZdVZqWobjF0xwtjocNSOqnQd</a></p><h3 id="5-synchronized关键字"><a href="#5-synchronized关键字" class="headerlink" title="5. synchronized关键字"></a>5. synchronized关键字</h3><p><strong>分析</strong></p><p>回答synchronized作用、特性、实现方式，可以适当画图或者举例。</p><p><strong>回答</strong></p><blockquote><p>synchronized关键字是Java用来解决多个线程共享资源竞争问题，synchronized同步语句块实现是先执行monitorenter指令，该指令会尝试获取对象的monitor，指令指向同步代码块的开始位置，monitorexit指令则同步代码块的结束位置，synchronized关键字可以保证被它修饰的方法或者代码块在任意时刻只有一个线程执行。</p><p>早期的synchronized依赖操作系统实现，属于重量锁，JDK 1.6以后对其进行了大量的优化。&#x20;</p></blockquote><p><a href="https://pdai.tech/md/java/thread/java-thread-x-key-synchronized.html">关键字: synchronized详解</a></p><h3 id="6-说说自己是怎么使用synchronized关键字，在项目中用到了吗"><a href="#6-说说自己是怎么使用synchronized关键字，在项目中用到了吗" class="headerlink" title="6. 说说自己是怎么使用synchronized关键字，在项目中用到了吗"></a>6. 说说自己是怎么使用synchronized关键字，在项目中用到了吗</h3><p><strong>参考回答</strong>：</p><blockquote><p>synchronized关键字最主要的三种使用方式：</p><ul><li><p>修饰实例方法：作用于当前对象实例加锁，进入同步代码前要获得当前对象实例的锁。</p></li><li><p>修饰静态方法：也就是给当前类加锁，会作用于类的所有对象实例，因为静态成员不属于任何一个实例对象，是类成员（static表明这是该类的一个静态资源，不管new了多少个对象，只有一份）。所以如果一个线程A调用一个实例对象的非静态synchronized方法，而线程B需要调用这个实例对象所属类的静态synchronized方法，是允许的，不会发生互斥现象，因为访问静态synchronized方法占用的锁是当前类的锁，而访问非静态synchronized方法占用的锁是当前实例对象锁。&#x20;</p></li><li><p>修饰代码块：指定加锁对象，对给定对象加锁，进入同步代码库前要获得给定对象的锁。</p></li></ul><p>总结：synchronized关键字加到static静态方法和synchronized(class)代码块上都是给Class类上锁。synchronized关键字加到实例方法上是给对象实例上锁。尽量不要使用synchronized(String a)因为JVM中，字符串常量池具有缓存功能！&#x20;</p></blockquote><h3 id="7-说一下synchronized底层实现原理"><a href="#7-说一下synchronized底层实现原理" class="headerlink" title="7. 说一下synchronized底层实现原理?"></a>7. 说一下synchronized底层实现原理?</h3><p><strong>参考回答</strong>：</p><blockquote><p>Synchronized的语义底层是通过一个monitor（监视器锁）的对象来完成，每个对象有一个监视器锁(monitor)。每个Synchronized修饰过的代码当它的monitor被占用时就会处于锁定状态并且尝试获取monitor的所有权 ，过程：</p><p>1、如果monitor的进入数为0，则该线程进入monitor，然后将进入数设置为1，该线程即为monitor的所有者。</p><p>2、如果线程已经占有该monitor，只是重新进入，则进入monitor的进入数加1.</p><p>3、如果其他线程已经占用了monitor，则该线程进入阻塞状态，直到monitor的进入数为0，再重新尝试获取monitor的所有权。</p><p><code>synchronized是可以通过 反汇编指令javap命令，查看相应的字节码文件。</code></p></blockquote><h3 id="8-synchronized可重入的原理"><a href="#8-synchronized可重入的原理" class="headerlink" title="8. synchronized可重入的原理"></a>8. synchronized可重入的原理</h3><p><strong>参考回答</strong>：</p><blockquote><p>重入锁是指一线程获取到该锁之后，该线程可以继续获得该锁。底层原理维护一个计数器，当线程获取该锁时，计数器加一，再次获得该锁时继续加一，释放锁时，计数器减一，当计数器值为0时，表明该锁未被任何线程所持有，其它线程可以竞争获取锁。</p></blockquote><h3 id="9-什么是自旋"><a href="#9-什么是自旋" class="headerlink" title="9. 什么是自旋"></a>9. 什么是自旋</h3><blockquote><p><strong>参考回答</strong>：</p><ul><li><p>很多synchronized里面的代码只是一些很简单的代码，执行时间非常快，此时等待的线程都阻塞可能是一种不太值得的操作，因为线程阻塞涉及到用户态和内核态切换的问题。既然synchronized里面的代码执行得非常快，不妨让等待锁的线程不要被阻塞，而是在 线程的边界忙循环，这就是自旋。如果做了多次循环发现还没有获得锁，再阻塞，这样可能是一种更好的策略。</p></li><li><p>忙循环：就是程序员用循环让一个线程等待，不像传统方法wait(),sleep() 或yield() 它们都放弃了CPU控制，而忙循环不会放弃CPU，它就是在运行一个空循环。这么做的目的是为了保留CPU缓存，在多核系统中，一个等待线程醒来的时候可能会在另一个内核运行，这样会重建缓存。为了避免重建缓存和减少等待重建的时间就可以使用它了。&#x20;</p></li></ul><p>在Java中，自旋（Spinning）是一种线程同步技术，用于在多线程编程中实现锁机制。当一个线程试图获取一个已经被其他线程持有的锁时，该线程不会放弃CPU时间片，而是进行循环（通常是一个忙等待循环），不断检查锁是否可用。这种机制旨在减少线程上下文切换的开销，提高响应速度，但也可能浪费大量的CPU时间。</p><p>自旋锁是Java并发编程中的一个重要概念，通过允许线程在锁不可用时持续尝试获取锁，它可以避免线程上下文切换的开销。然而，如果锁持有时间过长，自旋线程会浪费大量CPU时间，导致性能下降。因此，自旋锁需要谨慎使用，依据具体的应用场景和需求进行选择和优化。</p></blockquote><h3 id="10-多线程中synchronized锁升级的原理是什么"><a href="#10-多线程中synchronized锁升级的原理是什么" class="headerlink" title="10. 多线程中synchronized锁升级的原理是什么?"></a>10. 多线程中synchronized锁升级的原理是什么?</h3><p><strong>参考回答</strong>：</p><blockquote><p>synchronized锁升级原理：在锁对象的对象头里面有一个threadid字段，在第一次访问的时候threadid为空，jvm让其持有偏向锁，并将threadid设置为其线程id，再次进入的时候会先判断threadid是否与其线程id一致，如果一致则可以直接使用此对象，如果不一致，则升级偏向锁为轻量级锁，通过自旋循环一定次数来获取锁，执行一定次数之后，如果还没有正常获取到要使用的对象，此时就会把锁从轻量级升级为重量级锁，此过程就构成了synchronized锁的升级。&#x20;</p><p><code>锁的升级的目的：锁升级是为了减低了锁带来的性能消耗。在Java 6之后优化synchronized的实现方式，使用了偏向锁升级为轻量级锁再升级到重量级锁的方式，从而减低了锁带来的性能消耗。</code></p><ul><li><p>偏向锁，顾名思义，它会偏向于第一个访问锁的线程，如果在运行过程中同步锁只有一个线程访问，不存在多线程争用的情况，则线程是不需要触发同步的，减少加锁 / 解锁的一些CAS操作（比如等待队列的一些CAS操作），这种情况下，就会给线程加一个偏向锁。如果在运行过程中，遇到了其他线程抢占锁，则持有偏向锁的线程会被挂起，JVM会消除它身上的偏向锁，将锁恢复到标准的轻量级锁。</p></li><li><p>轻量级锁是由偏向所升级来的，偏向锁运行在一个线程进入同步块的情况下，当第二个线程加入锁争用的时候，偏向锁就会升级为轻量级锁；&#x20;</p></li><li><p>重量级锁是synchronized，是Java虚拟机中最为基础的锁实现。在这种状态下，Java虚拟机会阻塞加锁失败的线程，并且在目标锁被释放的时候，唤醒这些线程。&#x20;</p></li></ul></blockquote><p><a href="https://learn.lianglianglee.com/%E4%B8%93%E6%A0%8F/Java%20%E6%A0%B8%E5%BF%83%E6%8A%80%E6%9C%AF%E9%9D%A2%E8%AF%95%E7%B2%BE%E8%AE%B2/16%20%20synchronized%E5%BA%95%E5%B1%82%E5%A6%82%E4%BD%95%E5%AE%9E%E7%8E%B0%EF%BC%9F%E4%BB%80%E4%B9%88%E6%98%AF%E9%94%81%E7%9A%84%E5%8D%87%E7%BA%A7%E3%80%81%E9%99%8D%E7%BA%A7%EF%BC%9F-%E6%9E%81%E5%AE%A2%E6%97%B6%E9%97%B4.md">16 synchronized底层如何实现?什么是锁的升级、降级?-极客时间</a></p><blockquote><h3 id="11-线程B怎么知道线程A修改了变量"><a href="#11-线程B怎么知道线程A修改了变量" class="headerlink" title="11. 线程B怎么知道线程A修改了变量"></a>11. 线程B怎么知道线程A修改了变量</h3><p><strong>参考回答</strong>：</p><p>(1) volatile修饰变量</p><p>(2) synchronized修饰修改变量的方法</p><p>(3) wait/notify</p></blockquote><h3 id="12-当一个线程进入一个对象的synchronized方法A之后，其它线程是否可进入此对象的synchronized方法B"><a href="#12-当一个线程进入一个对象的synchronized方法A之后，其它线程是否可进入此对象的synchronized方法B" class="headerlink" title="12. 当一个线程进入一个对象的synchronized方法A之后，其它线程是否可进入此对象的synchronized方法B?"></a>12. 当一个线程进入一个对象的synchronized方法A之后，其它线程是否可进入此对象的synchronized方法B?</h3><blockquote><p><strong>参考回答</strong>：</p><p>不能。其它线程只能访问该对象的非同步方法，同步方法则不能进入。因为非静态方法上的synchronized修饰符要求执行方法时要获得对象的锁，如果已经进入A方法说明对象锁已经被取走，那么试图进入B方法的线程就只能在等锁池（注意不是等待池哦）中等待对象的锁。</p></blockquote><h3 id="13-synchronized、volatile、CAS比较"><a href="#13-synchronized、volatile、CAS比较" class="headerlink" title="13. synchronized、volatile、CAS比较"></a>13. synchronized、volatile、CAS比较</h3><blockquote><p><strong>参考回答</strong>：</p><p>(1) synchronized是悲观锁，属于抢占式，会引起其他线程阻塞。</p><p>(2) volatile提供多线程共享变量可见性和禁止指令重排序优化。&#x20;</p><p>(3) CAS是基于冲突检测的乐观锁（非阻塞）&#x20;</p></blockquote><p><a href="https://refblogs.com/article/582">并发编程中的synchronized、volatile和CAS操作详解 - 搬砖的码农</a></p><h3 id="14-synchronized和Lock有什么区别"><a href="#14-synchronized和Lock有什么区别" class="headerlink" title="14. synchronized和Lock有什么区别?"></a>14. synchronized和Lock有什么区别?</h3><blockquote><p><strong>参考回答</strong>：</p><ul><li><p>首先synchronized是Java内置关键字，在JVM层面，Lock是个接口；</p></li><li><p>原理区别：synchronized是内置锁，由JVM实现获取锁和释放锁的原理，还分为偏向锁、轻量级锁、重量级锁。Lock根据实现不同，有不同的原理，例如ReentrantLock内部是通过AQS来获取和释放锁的。</p></li><li><p>用法区别：synchronized可以给类、方法、代码块加锁；而lock只能给代码块加锁。synchronized不需要手动获取锁和释放锁，使用简单，发生异常会自动释放锁，不容易造成死锁；而lock需要自己加锁和释放锁，如果使用不当没有unLock()去释放锁就会造成死锁。</p></li><li><p>synchronized锁只能同时被一个线程拥有，但是Lock锁没有这个限制，例如在读写锁中的读锁，是可以同时被多个线程持有的，可是synchronized做不到。</p></li><li><p>synchronized锁不够灵活，一旦synchronized锁已经被某个线程获得了，此时其他线程如果还想获得，那它只能被阻塞，直到持有锁的线程运行完毕或者发生异常从而释放这个锁。如果持有锁的线程持有很长时间才释放，那么整个程序的运行效率就会降低，而且如果持有锁的线程永远不释放锁，那么尝试获取锁的线程只能永远等下去。相比之下，Lock类在等锁的过程中，如果使用的是lockInterruptibly方法，那么如果觉得等待的时间太长了不想再继续等待，可以中断退出，也可以用tryLock()等方法尝试获取锁，如果获取不到锁也可以做别的事，更加灵活。&#x20;</p></li><li><p>性能区别：在Java 5以及之前，synchronized的性能比较低，但是到了Java 6以后发生了变化，因为JDK对synchronized进行了很多优化，比如自适应自旋、锁消除、锁粗化、轻量级锁、偏向锁等，所以后期的Java版本里的synchronized的性能并不比Lock差。&#x20;</p></li></ul></blockquote><h3 id="15-synchronized和Lock如何选择"><a href="#15-synchronized和Lock如何选择" class="headerlink" title="15. synchronized和Lock如何选择?"></a>15. synchronized和Lock如何选择?</h3><p><strong>参考回答</strong>：</p><blockquote><ol><li><p>如果能不用最好既不使用Lock也不使用synchronized。因为在许多情况下你可以使用java.util.concurrent包中的机制，它会为你处理所有的加锁和解锁操作，也就是推荐优先使用工具类来加解锁。</p></li><li><p>如果synchronized关键字适合你的程序，那么请尽量使用它，这样可以减少编写代码的数量，减少出错的概率。因为一旦忘记在finally里unlock，代码可能会出很大的问题，而使用synchronized更安全。</p></li><li><p>如果特别需要Lock的特殊功能，比如尝试获取锁、可中断、超时功能等，才使用Lock。</p></li></ol></blockquote><p><a href="https://learn.lianglianglee.com/%E4%B8%93%E6%A0%8F/Java%20%E5%B9%B6%E5%8F%91%E7%BC%96%E7%A8%8B%2078%20%E8%AE%B2-%E5%AE%8C/22%20synchronized%20%E5%92%8C%20Lock%20%E5%AD%B0%E4%BC%98%E5%AD%B0%E5%8A%A3%EF%BC%8C%E5%A6%82%E4%BD%95%E9%80%89%E6%8B%A9%EF%BC%9F.md">22 synchronized 和 Lock 孰优孰劣，如何选择?</a></p><h3 id="16-synchronized和ReentrantLock区别是什么"><a href="#16-synchronized和ReentrantLock区别是什么" class="headerlink" title="16. synchronized和ReentrantLock区别是什么?"></a>16. synchronized和ReentrantLock区别是什么?</h3><p><strong>参考回答</strong>：</p><blockquote><p>synchronized和ReentrantLock都是Java中提供的可重入锁，二者的主要区别有以下5个：</p><ul><li><p>用法不同：synchronized可以用来修饰普通方法、静态方法和代码块，而ReentrantLock只能用于代码块。</p></li><li><p>获取锁和释放锁的机制不同：synchronized是自动加锁和释放锁的，而ReentrantLock需要手动加锁和释放锁。</p></li><li><p>锁类型不同：synchronized是非公平锁，而ReentrantLock默认为非公平锁，也可以手动指定为公平锁。&#x20;</p></li><li><p>响应中断不同：ReentrantLock可以响应中断，解决死锁的问题，而synchronized不能响应中断。</p></li><li><p>底层实现不同：synchronized是JVM层面通过监视器实现的，而ReentrantLock是基于AQS</p></li></ul></blockquote><p><a href="https://www.51cto.com/article/707239.html">https://www.51cto.com/article/707239.html</a></p><h3 id="17-volatile关键字的作用"><a href="#17-volatile关键字的作用" class="headerlink" title="17. volatile关键字的作用"></a>17. volatile关键字的作用</h3><blockquote><p><strong>参考回答</strong>：</p><ul><li><p>对于可见性，Java提供了volatile关键字来保证可见性和禁止指令重排。volatile确保一个线程的修改能对其他线程是可见的。当一个共享变量被volatile修饰时，它会保证修改的值会立即被更新到主内存中，当有其他线程需要读取时，它会去内存中读取新值。</p></li><li><p>从实践角度而言，volatile的一个重要作用就是和CAS结合，保证了原子性，详细的可以参见java.util.concurrent.atomic包下的类，比如AtomicInteger。</p></li></ul></blockquote><h3 id="18-Java中能创建volatile数组吗"><a href="#18-Java中能创建volatile数组吗" class="headerlink" title="18. Java中能创建volatile数组吗?"></a>18. Java中能创建volatile数组吗?</h3><p><strong>参考回答</strong>：</p><blockquote><p>能，Java中可以创建volatile类型数组，不过只是一个指向数组的引用，而不是整个数组。意思是，如果改变引用指向的数组，将会受到volatile的保护，但是如果多个线程同时改变数组的元素，volatile标示符就不能起到之前的保护作用了。&#x20;</p></blockquote><h3 id="19-volatile能使得一个非原子操作变成原子操作吗"><a href="#19-volatile能使得一个非原子操作变成原子操作吗" class="headerlink" title="19. volatile能使得一个非原子操作变成原子操作吗?"></a>19. volatile能使得一个非原子操作变成原子操作吗?</h3><blockquote><p><strong>参考回答</strong>：</p><ul><li><p>关键字volatile的主要作用是使变量在多个线程间可见，但无法保证原子性，对于多个线程访问同一个实例变量需要加锁进行同步。</p></li><li><p>虽然volatile只能保证可见性不能保证原子性，但用volatile修饰long和double可以保证其操作原子性。（<a href="https://blog.csdn.net/tian2342/article/details/122665957）">https://blog.csdn.net/tian2342/article/details/122665957）</a></p></li></ul></blockquote><h3 id="20-synchronized和volatile的区别是什么"><a href="#20-synchronized和volatile的区别是什么" class="headerlink" title="20. synchronized和volatile的区别是什么?"></a>20. synchronized和volatile的区别是什么?</h3><p><strong>参考回答</strong>：</p><blockquote><ul><li><p>synchronized表示只有一个线程可以获取作用对象的锁，执行代码，阻塞其他线程。</p></li><li><p>volatile表示变量在CPU的寄存器中是不确定的，必须从主存中读取。保证多线程环境下变量的可见性；禁止指令重排序。</p></li></ul><p><strong>区别</strong></p><ul><li><p>volatile是变量修饰符；synchronized可以修饰方法，代码块。</p></li><li><p>volatile仅能实现变量的修改可见性，不能保证原子性；而synchronized则可以保证变量的修改可见性和原子性。&#x20;</p></li><li><p>volatile不会造成线程的阻塞；synchronized可能会造成线程的阻塞。</p></li><li><p>volatile标记的变量不会被编译器优化；synchronized标记的变量可以被编译器优化。</p></li><li><p>volatile关键字是线程同步的轻量级实现，所以volatile性能肯定比synchronized关键字要好。但是volatile关键字只能用于变量而synchronized关键字可以修饰方法以及代码块。synchronized关键字在JavaSE1.6之后进行了主要包括为了减少获得锁和释放锁带来的性能消耗而引入的偏向锁和轻量级锁以及其它各种优化之后执行效率有了显著提升，实际开发中使用synchronized关键字的场景还是更多一些。&#x20;</p></li></ul></blockquote><h3 id="21-说下你对volatile的理解"><a href="#21-说下你对volatile的理解" class="headerlink" title="21. 说下你对volatile的理解"></a>21. 说下你对volatile的理解</h3><blockquote><p>volatile是Java虚拟机提供的轻量级的同步机制，具有以下特点：</p><ol><li><p>保证可见性：volatile保证了多个线程对共享变量的操作是可见的。当一个线程修改了共享变量的值，其他线程会立即看到这个改变。</p></li><li><p>禁止指令重排：volatile通过禁止指令重排来保证顺序性。在多线程环境下，为了提高程序执行效率，编译器和处理器可能会对指令进行重新排序。但是，如果一个变量被volatile修饰，就禁止了指令重排，确保每个线程都能看到正确的操作顺序。</p></li></ol><p>总的来说，volatile可以确保多个线程对共享变量的操作一致，避免了数据不一致的问题。<strong>但是它不能保证原子性，因此对于需要保证原子性的操作还需要使用其他同步机制，如synchronized关键字或java.util.concurrent.atomic包中的原子类。&#x20;</strong></p><p><strong>volatile关键字</strong>通过以下方式禁止指令重排：</p><ol><li><p>内存屏障（Memory Barrier）：当编译器或处理器看到volatile修饰的变量时，它会在该变量前后插入内存屏障。内存屏障可以保证在该屏障之前的所有读写操作都必须在屏障之后的读写操作之前完成。这实际上就禁止了指令重排。</p></li><li><p>强制立即刷新到主内存：当一个线程向被volatile关键字修饰的变量写入数据时，虚拟机会强制这个值被立即刷新到主内存中。这确保了其他线程可以立即看到这个修改。</p></li><li><p>强制从主内存读取：当一个线程读取被volatile关键字修饰的变量时，虚拟机会强制要求它从主内存中读取这个值，而不是从该线程的本地缓存中读取。这确保了该线程可以立即看到其他线程对这个变量的修改。&#x20;</p></li></ol></blockquote><h2 id="线程池"><a href="#线程池" class="headerlink" title="线程池"></a>线程池</h2><h3 id="1-什么是线程池？为什么要用线程池"><a href="#1-什么是线程池？为什么要用线程池" class="headerlink" title="1. 什么是线程池？为什么要用线程池?"></a>1. 什么是线程池？为什么要用线程池?</h3><p><strong>参考回答</strong>：</p><blockquote><p>答：Java中的线程池是运用场景最多的并发框架，几乎所有需要异步或并发执行任务的程序都可以使用线程池。在开发过程中，合理地使用线程池能够带来许多好处。</p><ul><li><p>降低资源消耗。通过重复利用已创建的线程，降低线程创建和销毁造成的消耗。</p></li><li><p>提高响应速度。当任务到达时，任务可以不需要等到线程创建就能立即执行。</p></li><li><p>提高线程的可管理性。线程是稀缺资源，如果无限制地创建，不仅会消耗系统资源，还会降低系统的稳定性，使用线程池可以进行统一分配、调优和监控。但是，要做到合理利用 。&#x20;</p></li></ul></blockquote><h3 id="2-核心参数有哪些"><a href="#2-核心参数有哪些" class="headerlink" title="2. 核心参数有哪些?"></a>2. 核心参数有哪些?</h3><p><strong>分析</strong>：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="title function_">ThreadPoolExecutor</span><span class="params">(<span class="type">int</span> corePoolSize,</span></span><br><span class="line"><span class="params">                          <span class="type">int</span> maximumPoolSize,</span></span><br><span class="line"><span class="params">                          <span class="type">long</span> keepAliveTime,</span></span><br><span class="line"><span class="params">                          TimeUnit unit,</span></span><br><span class="line"><span class="params">                          BlockingQueue&lt;Runnable&gt; workQueue,</span></span><br><span class="line"><span class="params">                          ThreadFactory threadFactory,</span></span><br><span class="line"><span class="params">                          RejectedExecutionHandler handler)</span> &#123;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><blockquote><p><strong>参考回答</strong>：</p><p>线程池的构造函数有7个参数：</p><ul><li><p>corePoolSize：核心线程数</p></li><li><p>maximumPoolSize：线程池能创建线程的最大个数</p></li><li><p>keepAliveTime：空闲线程存活时间</p></li><li><p>unit：时间单位，为keepAliveTime指定时间单位</p></li><li><p>workQueue：阻塞队列，用于保存任务的阻塞队列</p></li><li><p>threadFactory：创建线程的工程类</p></li><li><p>handler：饱和策略（拒绝策略）&#x20;</p></li></ul></blockquote><h3 id="3-线程池的种类，区别和使用场景"><a href="#3-线程池的种类，区别和使用场景" class="headerlink" title="3. 线程池的种类，区别和使用场景"></a>3. 线程池的种类，区别和使用场景</h3><p><strong>分析</strong></p><blockquote><p><strong>参考回答</strong>：</p><ol><li>newCachedThreadPool</li></ol><p>newCachedThreadPool创建一个可缓存线程池，如果当前线程池的长度超过了处理的需要时，它可以灵活的回收空闲的线程，当需要增加时，它可以灵活的添加新的线程，而不会对池的长度作任何限制。</p><p>使用场景：执行很多短期异步的小程序。</p><ul><li>newFixedThreadPool</li></ul><p>创建一个定长线程池，可控制线程最大并发数，超出的线程会在队列中等待。定长线程池的大小最好根据系统资源进行设置。</p><p>使用场景：执行长期的任务，性能好很多。</p><ul><li>newScheduledThreadPool</li></ul><p>创建一个固定长度的线程池，而且支持定时的以及周期性的任务执行。</p><p>使用场景：周期性执行任务的场景。</p><ul><li>newSingleThreadExecutor</li></ul><p>创建一个单线程化的线程池，它只会用唯一的工作线程来执行任务，如果这个唯一的线程因为异常结束，那么会有一个新的线程来替代它，必须保证前一项任务执行完毕后才能执行后一项。保证所有任务按照指定顺序执行。</p><p>使用场景：适合多个任务顺序执行的场景，不需要考虑并发问题。&#x20;</p></blockquote><p><a href="https://www.cnblogs.com/sachen/p/7401959.html">博客园</a></p><h3 id="4-线程池的拒绝策略有哪些"><a href="#4-线程池的拒绝策略有哪些" class="headerlink" title="4. 线程池的拒绝策略有哪些"></a>4. 线程池的拒绝策略有哪些</h3><p><strong>分析</strong></p><blockquote><p><strong>参考回答</strong>：</p><ul><li>AbortPolicy, 默认</li></ul><p>该策略是线程池的默认策略。使用该策略时，如果线程池队列满了丢掉这个任务并且抛出RejectedExecutionException异常。</p><ul><li>DiscardPolicy</li></ul><p>这个策略和AbortPolicy的silent版本，如果线程池队列满了，会直接丢掉这个任务并且不会有任何异常。</p><ul><li>DiscardOldestPolicy</li></ul><p>这个策略从字面上也很好理解，丢弃最老的。也就是说如果队列满了，会将最早进入队列的任务删掉腾出空间，再尝试加入队列。因为队列是队尾进，队头出，所以队头元素是最老的，因此每次都是移除队头元素后再尝试入队。</p><ul><li>CallerRunsPolicy</li></ul><p>使用此策略，如果添加到线程池失败，那么调用线程会自己去执行该任务，不会等待线程池中的线程去执行。就像是个急脾气的人，我等不到别人来做这件事就干脆自己干。&#x20;</p></blockquote><h3 id="5-在Java中Executor和Executors的区别"><a href="#5-在Java中Executor和Executors的区别" class="headerlink" title="5. 在Java中Executor和Executors的区别?"></a>5. 在Java中Executor和Executors的区别?</h3><p><strong>参考回答</strong>：</p><blockquote><p>Executors工具类的不同方法按照我们的需求创建了不同的线程池，来满足业务的需求。</p><p>Executor接口对象能执行我们的线程任务。</p><p>ExecutorService接口继承了Executor接口并进行了扩展，提供了更多的方法我们能获得任务执行的状态并且可以获取任务的返回值。&#x20;</p></blockquote><h3 id="6-线程池都有哪些状态"><a href="#6-线程池都有哪些状态" class="headerlink" title="6.线程池都有哪些状态"></a>6.线程池都有哪些状态</h3><p><img src="2025-01-09-JUC基础面试题/image-1.png" alt=""></p><p><strong>参考回答</strong>：</p><blockquote><ul><li><p>RUNNING：这是最正常的状态，接受新的任务，处理等待队列中的任务。</p></li><li><p>SHUTDOWN：不接受新的任务提交，但是会继续处理等待队列中的任务。</p></li><li><p>STOP：不接受新的任务提交，不再处理等待队列中的任务，中断正在执行任务的线程。</p></li><li><p>TIDYING：所有的线程都销毁了，workerCount为0，线程池的状态转换为TIDYING状态时，会执行钩子方法terminated()。</p></li><li><p>TERMINATED：terminated()方法结束后，线程池的状态就会变成这个。</p></li></ul></blockquote><h3 id="7-线程池中submit-和execute-方法有什么区别"><a href="#7-线程池中submit-和execute-方法有什么区别" class="headerlink" title="7. 线程池中submit()和execute()方法有什么区别?"></a>7. 线程池中submit()和execute()方法有什么区别?</h3><blockquote><p><strong>参考回答</strong>：</p><ul><li><p>相同点：</p><ul><li>相同点就是都可以开启线程执行池中的任务。</li></ul></li><li><p>不同点：</p><ul><li><p>接收参数：execute()只能执行Runnable类型的任务。submit()可以执行Runnable和Callable类型的任务。</p></li><li><p>返回值：submit()方法可以返回持有计算结果的Future对象，而execute()没有。</p></li><li><p>异常处理：submit()方便Exception处理。&#x20;</p></li></ul></li></ul></blockquote><h3 id="8-分析线程池的实现原理和线程的调度过程"><a href="#8-分析线程池的实现原理和线程的调度过程" class="headerlink" title="8. 分析线程池的实现原理和线程的调度过程"></a>8. 分析线程池的实现原理和线程的调度过程</h3><p><strong>分析</strong></p><p><strong>参考回答</strong>：</p><blockquote><p>提交一个任务到线程池中，线程池的处理流程如下：</p><ol><li><p>如果当前运行的线程数小于核心线程数，那么就会新建一个线程来执行任务。</p></li><li><p>如果当前运行的线程数等于或大于核心线程数，并且任务队列没满，那么就把该任务放入到任务队列里等待执行。</p></li><li><p>如果任务队列满了，但是当前运行的线程数小于最大线程数的，就新建一个线程来执行任务。</p></li><li><p>如果当前运行的线程数已经等同于最大线程数了，新建线程将会使当前运行的线程超出最大线程数，那么当前任务会被拒绝，调用拒绝策略方法。</p></li></ol></blockquote><h3 id="9-线程池的最大线程数目根据什么确定"><a href="#9-线程池的最大线程数目根据什么确定" class="headerlink" title="9. 线程池的最大线程数目根据什么确定"></a>9. 线程池的最大线程数目根据什么确定</h3><p><strong>分析</strong></p><p><strong>参考回答</strong>：</p><blockquote><p>线程池用来执行CPU密集型任务时，设置线程数为cpu核心数+1，这样可以使得每个线程都在执行任务。用来执行IO密集型任务时，大部分线程都阻塞，所以设置线程数为2*cpu核数。&#x20;</p></blockquote><h3 id="10-线程池如何调优"><a href="#10-线程池如何调优" class="headerlink" title="10. 线程池如何调优"></a>10. 线程池如何调优</h3><p><strong>分析</strong></p><blockquote><p><strong>参考回答</strong>：</p><ol><li><p>CPU密集型任务配置尽可能小的线程，cpu核数+1。</p></li><li><p>IO密集型任务则由于线程并不是一直在执行任务，则配置尽可能多的线程，如2*cpu核数。</p></li><li><p>混合型任务，如果可以拆分，则将其拆分成一个CPU密集型任务和一个IO密集型任务。只要这两个任务执行的时间相差不是太大，那么分解后并发执行的吞吐率高于串行执行的吞吐率；如果这两个任务执行时间相差太大，则没必要进行分解。</p></li><li><p>优先级不同的任务可以使用优先级队列PriorityBlockingQueue来处理，它可以让优先级高的任务先得到执行。</p></li><li><p>执行时间不同的任务可以交给不同线程池来处理，或者也可以使用优先级队列，让执行时间短的任务先执行。</p></li><li><p>依赖数据库连接池的任务，因为线程提交SQL后需要等待数据库返回结果，线程数应该设置得较大，这样才能更好的利用CPU。</p></li><li><p>建议使用有界队列，有界队列能增加系统的稳定性和预警能力。可以根据需要设大一点，比如几千。使用无界队列，线程池的队列就会越来越大，有可能会撑满内存，导致整个系统不可用。&#x20;</p></li></ol></blockquote><h3 id="11-线程池如何实现动态修改"><a href="#11-线程池如何实现动态修改" class="headerlink" title="11. 线程池如何实现动态修改?"></a>11. 线程池如何实现动态修改?</h3><p><strong>参考回答</strong>：</p><blockquote><ol><li>首先线程池提供了部分setter方法可以设置线程池的参数；</li></ol><p>&#x20;a. 修改核心线程数，最大线程数，空闲线程停留时间，拒绝策略等。</p><p>&#x20;b. 可以将线程池的配置参数放入配置中心，当需要调整的时候，去配置中心修改就行。</p><ul><li>什么时候修改呢?</li></ul><p>&#x20;a. 这里需要监控报警策略，获取线程池状态指标，当指标判定为异常之后进行报警。</p><p>&#x20;b. 分析指标异常原因，评估处理策略，最后通过上述线程池提供的接口进行动态修改。(可以将动态配置)</p></blockquote><p><strong>推荐学习</strong>：</p><p><a href="https://tech.meituan.com/2020/04/02/java-pooling-pratice-in-meituan.html">Java线程池实现原理及其在美团业务中的实践</a></p><h3 id="12-使用无界队列的线程池会导致什么问题"><a href="#12-使用无界队列的线程池会导致什么问题" class="headerlink" title="12. 使用无界队列的线程池会导致什么问题?"></a>12. 使用无界队列的线程池会导致什么问题?</h3><p><strong>参考回答</strong>：</p><blockquote><p>例如newFixedThreadPool使用了无界的阻塞队列LinkedBlockingQueue，如果线程获取一个任务后，任务的执行时间比较长，会导致队列的任务越积越多，导致机器内存使用不停飙升，最终导致OOM。&#x20;</p></blockquote><h3 id="13-线程池的问题，如果线程池当前处于空闲的状态，核心线程数量是不会被销毁的，那这几个核心线程处于什么状态？为什么处于这个状态"><a href="#13-线程池的问题，如果线程池当前处于空闲的状态，核心线程数量是不会被销毁的，那这几个核心线程处于什么状态？为什么处于这个状态" class="headerlink" title="13. 线程池的问题，如果线程池当前处于空闲的状态，核心线程数量是不会被销毁的，那这几个核心线程处于什么状态？为什么处于这个状态?"></a>13. 线程池的问题，如果线程池当前处于空闲的状态，核心线程数量是不会被销毁的，那这几个核心线程处于什么状态？为什么处于这个状态?</h3><p><strong>分析</strong></p><p>这里面面试官其实想问你线程复用的逻辑，以及对线程状态机的理解，知不知道都要有一个分析思考的过程，不要一上来就回答答案或者说不知道，瞎猜。</p><p><strong>参考回答</strong></p><blockquote><p>首先线程本身创建和销毁都是成本比较高的，那就排除new和terminated状态，没有任务运行排除runnable状态，剩下阻塞和等待，因为线程不会销毁需要一直等待执行任务，超时等待也不太可能，最后同步锁才会进入阻塞状态，所以我猜是一直等待。&#x20;</p></blockquote><p><img src="2025-01-09-JUC基础面试题/image-2.png" alt=""></p><h3 id="14-如果不允许线程池丢弃任务，应该选择哪个拒绝策略？"><a href="#14-如果不允许线程池丢弃任务，应该选择哪个拒绝策略？" class="headerlink" title="14. 如果不允许线程池丢弃任务，应该选择哪个拒绝策略？"></a>14. 如果不允许线程池丢弃任务，应该选择哪个拒绝策略？</h3><p>大家应该都知道，线程池的核心线程满了，就会放在阻塞队列，阻塞队列满了会创建临时线程，如果超过最大线程数，就会触发拒绝策略。那很多人都是用直接拒绝的策略，这样任务就直接丢了。&#x20;</p><p>但是如果任务很重要，不允许丢弃你会怎么做呢？那大家可以把工作中用到的方案发在评论区，我给你提供几种：</p><ol><li><p>用CallerRunsPolicy，它会采用主线程执行任务，但是如果任务非常耗时会阻塞主线程，在高并发场景慎用！</p></li><li><p>将任务进行持久化，可以采用mysql、redis、或者mq异步等方案持久化，后续再对任务进行补偿执行。</p></li><li><p>&#x20; 也可以参考netty：它会再创建新的一个异步线程处理任务。&#x20;</p></li></ol><p><img src="2025-01-09-JUC基础面试题/image76.png" alt=""></p><h3 id="15-Callable和Runnable接口有什么区别？"><a href="#15-Callable和Runnable接口有什么区别？" class="headerlink" title="15. Callable和Runnable接口有什么区别？"></a>15. Callable和Runnable接口有什么区别？</h3><blockquote><p>Callable和Runnable接口都是用于在Java中实现多线程的接口，但它们之间有一些区别：</p><ol><li><p><strong>返回值</strong>：</p><ul><li><p>Runnable接口的run()方法没有返回值，它通常用于执行一些不需要返回结果的任务。</p></li><li><p>Callable接口的call()方法可以返回一个结果，它允许线程执行任务并返回结果，可以通过Future对象获取。</p></li></ul></li><li><p><strong>抛出异常</strong>：</p><ul><li><p>Runnable接口的run()方法不能抛出受检异常，只能抛出未检查异常。</p></li><li><p>Callable接口的call()方法可以抛出受检异常。</p></li></ul></li><li><p><strong>泛型</strong>：</p><ul><li><p>Callable接口使用了泛型，可以指定call()方法的返回类型。</p></li><li><p>Runnable接口没有使用泛型。</p></li></ul></li><li><p><strong>线程池支持</strong>：</p><ul><li><p>Callable接口通常与Executor框架一起使用，可以提交给ExecutorService的线程池执行。</p></li><li><p>Runnable接口同样可以与Executor框架一起使用，但是Callable接口提供了更丰富的功能，如取消任务、获取执行结果等。&#x20;</p></li></ul></li></ol></blockquote><h3 id="16-线程池中线程异常后：销毁还是复用？"><a href="#16-线程池中线程异常后：销毁还是复用？" class="headerlink" title="16. 线程池中线程异常后：销毁还是复用？"></a>16. 线程池中线程异常后：销毁还是复用？</h3><blockquote><p>第一个线程池拒绝策略是：</p><p><strong>执行策略为AbortPolicy</strong>：执行任务出现异常，向提交任务线程，即调用线程会抛出RejectedExecutionException异常，并会创建一个新的线程继续执行后续任务。</p><p><strong>执行策略为DiscardPolicy</strong>：内部会把异常信息吞掉，既不会把异常抛给这个线程池线程，也不会创建新的线程加入到线程池中。</p><p>这两种执行方式，都不会影响线程池里面其他线程的正常执行，更便于线程池的资源管理，可以防止资源被滥用，如果程序有默认处&#x20;</p></blockquote><h3 id="17-线程池阻塞队列类型"><a href="#17-线程池阻塞队列类型" class="headerlink" title="17.线程池阻塞队列类型"></a>17.线程池阻塞队列类型</h3><blockquote><p>线程池常用的阻塞队列类型主要有以下几种：</p><ol><li><p><code>ArrayBlockingQueue</code>：基于数组实现的有界阻塞队列。其容量在创建时指定，一旦达到容量上限，新的入队操作会阻塞等待。</p></li><li><p><code>LinkedBlockingQueue</code>：基于链表实现的阻塞队列。默认情况下，其容量没有上限，可以看作是无界的，但也可以在创建时指定容量。</p></li><li><p><code>PriorityBlockingQueue</code>：无界的优先级阻塞队列，元素按照自定义的优先级规则进行排序。</p></li><li><p><code>SynchronousQueue</code>：不存储元素的阻塞队列，入队操作必须等待出队操作，反之亦然，常用于实现线程之间的直接传递。</p></li><li><p><code>DelayQueue</code>：无界的延迟阻塞队列，元素只有在指定的延迟时间到期后才能被取出。</p></li><li><p><code>LinkedTransferQueue</code>：无界的阻塞队列，具有高效的元素传递特性。</p></li><li><p><code>LinkedBlockingDeque</code>：基于链表实现的双向阻塞队列，可以从队列的头部和尾部进行插入和删除操作。</p></li></ol></blockquote><h2 id="Java中的锁"><a href="#Java中的锁" class="headerlink" title="Java中的锁"></a>Java中的锁</h2><h3 id="1-Lock接口和synchronized对比同步它有什么优势"><a href="#1-Lock接口和synchronized对比同步它有什么优势" class="headerlink" title="1. Lock接口和synchronized对比同步它有什么优势?"></a>1. Lock接口和synchronized对比同步它有什么优势?</h3><p><strong>参考回答</strong>：</p><blockquote><p>Lock接口比同步方法和同步块提供了更具扩展性的锁操作。它们允许更灵活的结构，可以具有完全不同的性质，并且可以支持多个相关类的条件对象。</p><p>它的优势有：</p><ul><li><p><strong>(1) 可以使锁更公平。</strong></p></li><li><p><strong>(2) 可以使线程在等待锁的时候响应中断。</strong></p></li><li><p><strong>(3) 可以让线程尝试获取锁，并在无法获取锁的时候立即返回或者等待一段时间。</strong></p></li><li><p><strong>(4) 可以在不同的范围，以不同的顺序获取和释放锁。</strong></p></li></ul><p>整体上来说Lock是synchronized的扩展版，Lock提供了无条件的、可轮询的(tryLock方法)、定时的(tryLock带参方法)、可中断的(lockInterruptibly)、可多条件队列的(newCondition方法)锁操作。另外Lock的实现类基本都支持非公平锁(默认)和公平锁，synchronized只支持非公平锁，当然，在大部分情况下，非公平锁是高效的选择。&#x20;</p></blockquote><h3 id="2-乐观锁和悲观锁的理解及如何实现，有哪些实现方式"><a href="#2-乐观锁和悲观锁的理解及如何实现，有哪些实现方式" class="headerlink" title="2. 乐观锁和悲观锁的理解及如何实现，有哪些实现方式?"></a>2. 乐观锁和悲观锁的理解及如何实现，有哪些实现方式?</h3><p><strong>参考回答</strong>：</p><blockquote><ul><li><p><strong>悲观锁：</strong>&#x603B;是假设最坏的情况，每次去拿数据的时候都认为别人会修改，所以每次在拿数据的时候都会上锁，这样别人想拿这个数据就会阻塞直到它拿到锁。传统的关系型数据库里边就用到了很多这种锁机制，比如行锁，表锁等，读锁，写锁等，都是在做操作之前先上锁。再比如Java里面的同步原语synchronized关键字的实现也是悲观锁。</p></li><li><p><strong>乐观锁：</strong>&#x987E;名思义，就是很乐观，每次去拿数据的时候都认为别人不会修改，所以不会上锁，但是在更新的时候会判断一下在此期间别人有没有去更新这个数据，可以使用版本号等机制。乐观锁适用于多读的应用类型，这样可以提高吞吐量，像数据库提供的类似于write_condition机制，其实都是提供的乐观锁。在Java中java.util.concurrent.atomic包下面的原子变量类就是使用了乐观锁的一种实现方式CAS实现的。&#x20;</p></li></ul></blockquote><h3 id="3-什么是CAS"><a href="#3-什么是CAS" class="headerlink" title="3. 什么是CAS"></a>3. 什么是CAS</h3><p><strong>分析</strong></p><p>回答出CAS操作的原子性，系统硬件级别提供支持</p><p><strong>回答</strong></p><blockquote><p>CAS即CompareAndSwap，Java中可以通过CAS操作来保证原子性，原子性就是不可被中断的一系列操作或者一个操作，简单来说就是一系列操作要么全部完成，要么失败，不能被中断。</p><p>CAS主要包含三个参数（V，expect，update），V表示要更新的变量（内存值）、expect表示预期值（旧值）、update表示新值。算法流程是首先比较V和expect的值，如果相等，将update值赋值给V，如果不相等说明有其他线程对该变量做了更新。这个参数有的地方也会用（V，A，B）表示，其中A表示预期值，B表示新值。</p><p>当多个线程同时操作一个共享变量时，只有一个线程可以对变量进行成功更新，其他线程均会失败，但是失败并不会被挂起，进行再次尝试，也就是自旋。Java中的自旋锁就是利用CAS来实现的。&#x20;</p></blockquote><p><a href="https://www.cnblogs.com/huansky/p/15746624.html">Java CAS 原理详解 - huansky - 博客园</a></p><h3 id="4-CAS的会产生什么问题"><a href="#4-CAS的会产生什么问题" class="headerlink" title="4. CAS的会产生什么问题?"></a>4. CAS的会产生什么问题?</h3><p><strong>参考回答</strong>：</p><blockquote><p><strong>1、ABA问题：</strong></p><p>比如说一个线程one从内存位置V中取出A，这时候另一个线程two也从内存中取出A，并且two进行了一些操作变成了B，然后two又将V位置的数据变成A，这时候线程one进行CAS操作发现内存中仍然是A，然后one操作成功。尽管线程one的CAS操作成功，但可能存在潜藏的问题。从Java1.5开始JDK的atomic包里提供了一个类AtomicStampedReference来解决ABA问题。</p><p><strong>2、循环时间长开销大：</strong></p><p>对于资源竞争严重（线程冲突严重）的情况，CAS自旋的概率会比较大，从而浪费更多的CPU资源，效率低于synchronized。</p><p><strong>3、只能保证一个共享变量的原子操作：</strong></p><p>当对一个共享变量执行操作时，我们可以使用循环CAS的方式来保证原子操作，但是对多个共享变量操作时，循环CAS就无法保证操作的原子性，这个时候就可以用锁。&#x20;</p></blockquote><h3 id="5-什么是原子类"><a href="#5-什么是原子类" class="headerlink" title="5. 什么是原子类"></a>5. 什么是原子类</h3><blockquote><p><strong>参考回答</strong>：</p><ul><li><p>java.util.concurrent.atomic包：是原子类的小工具包，支持在单个变量上解解锁的线程安全编程。原子变量类相当于一种泛化的volatile变量，能够支持原子的和有条件的读-改-写操作。</p></li><li><p>比如：AtomicInteger表示一个int类型的值，并提供了get和set方法，这些Volatile类型的int变量在读取和写入上有着相同的内存语义。它还提供了一个原子的compareAndSet方法（如果该方法成功执行，那么将实现与读取/写入一个volatile变量相同的内存效果），以及原子的添加、递增和递减等方法。AtomicInteger表面上非常像一个扩展的Counter类，但在发生竞争的情况下能提供更高的可伸缩性，因为它直接利用了硬件对并发的支持。</p></li></ul><p>简单来说就是原子类来实现CAS无锁模式的算法。</p></blockquote><h3 id="6-原子类的常用类"><a href="#6-原子类的常用类" class="headerlink" title="6. 原子类的常用类"></a>6. 原子类的常用类</h3><p><strong>参考回答</strong>：</p><blockquote><ul><li><p>AtomicBoolean</p></li><li><p>AtomicInteger</p></li><li><p>AtomicLong</p></li><li><p>AtomicReference&#x20;</p></li></ul></blockquote><h3 id="7-说一下Atomic的原理"><a href="#7-说一下Atomic的原理" class="headerlink" title="7. 说一下Atomic的原理?"></a>7. 说一下Atomic的原理?</h3><p><strong>参考回答</strong>：</p><blockquote><ul><li>Atomic包中的类基本的特性就是在多线程环境下，当有多个线程同时对单个（包括基本类型及引用类型）变量进行操作时，具有排他性，即当多个线程同时对该变量的值进行更新时，仅有一个线程能成功，而未成功的线程可以自旋锁一样，继续尝试，一直等到执行成功。</li></ul></blockquote><h3 id="8-死锁与活锁的区别，死锁与饥饿的区别"><a href="#8-死锁与活锁的区别，死锁与饥饿的区别" class="headerlink" title="8. 死锁与活锁的区别，死锁与饥饿的区别?"></a>8. 死锁与活锁的区别，死锁与饥饿的区别?</h3><p><strong>参考回答</strong>：</p><blockquote><p><strong>死锁：</strong>&#x662F;指两个或两个以上的进程（或线程）在执行过程中，因争夺资源而造成的一种互相等待的现象，若无外力作用，它们都将无法推进下去。</p><p><strong>活锁：</strong>&#x4EFB;务或者执行者没有被阻塞，由于某些条件没有满足，导致一直重复尝试，失败，尝试，失败。</p><p>活锁和死锁的区别在于，处于活锁的实体是在不断的改变状态，这就是所谓的“活”，而处于死锁的实体表现为等待；活锁有可能自行解开，死锁则不能。</p><p><strong>饥饿：</strong>&#x4E00;个或者多个线程因为种种原因无法获得所需要的资源，导致一直无法执行的状态。&#x20;</p><p>Java中导致饥饿的原因:</p><p>1、高优先级线程吞噬所有的低优先级线程的CPU时间。</p><p>2、线程被永久堵塞在一个等待进入同步块的状态，因为其他线程总是能在它之前持续地对该同步块进行访问。</p><p>3、线程在等待一个本身也处于永久等待完成的对象(比如调用这个对象的wait方法)，因为其他线程总是被持续地获得唤醒。&#x20;</p></blockquote><h3 id="9-如何避免死锁"><a href="#9-如何避免死锁" class="headerlink" title="9. 如何避免死锁"></a>9. 如何避免死锁</h3><blockquote><p>死锁是多线程编程中的一种常见问题，它发生在两个或多个线程相互等待对方释放资源的情况下，导致程序无法继续执行。为了避免死锁，我们可以采用以下策略：</p><ol><li><p><strong>锁顺序</strong>：定义一个固定的锁获取顺序，并要求所有线程都按照相同的顺序获取锁。这可以减少不同线程之间资源争夺的可能性。</p></li><li><p><strong>超时机制</strong>：在获取锁时，设置一个超时时间。如果超过指定时间仍然无法获取锁，线程应该释放已经持有的锁并重试，或者采取其他适当的措施。这有助于避免线程无限期地等待锁。</p></li><li><p><strong>避免嵌套锁</strong>：尽量避免在一个锁的持有期间再次尝试获取其他锁。如果确实需要获取多个锁，请确保获取的顺序是固定的，以减少死锁风险。</p></li><li><p><strong>使用锁机制</strong>：比如Java中的ReentrantLock，它支持可中断的锁获取和条件等待，有助于避免死锁。&#x20;</p></li></ol></blockquote><h3 id="10-为什么-wait-和-notify-方法要在同步块中调用"><a href="#10-为什么-wait-和-notify-方法要在同步块中调用" class="headerlink" title="10. 为什么 wait 和 notify 方法要在同步块中调用"></a>10. 为什么 wait 和 notify 方法要在同步块中调用</h3><blockquote><p>调用wait()就是释放锁，释放锁的前提是必须要先获得锁，先获得锁才能释放锁。</p><p>notify(),notifyAll()是将锁交给含有wait()方法的线程，让其继续执行下去，如果自身没有锁，怎么叫把锁交给其他线程 。</p></blockquote><h3 id="11-说下对AQS的理解"><a href="#11-说下对AQS的理解" class="headerlink" title="11. 说下对AQS的理解"></a>11. 说下对AQS的理解</h3><p>AQS（AbstractQueuedSynchronizer）是Java并发编程中的一个重要组件，它是一个抽象类，提供了线程同步的底层实现机制。AQS的作用是实现线程的同步和互斥操作，它提供了两种主要的锁机制，分别是排他锁和共享锁。</p><p><strong>排他锁也称为独占锁</strong>，在多个线程竞争同一共享资源时，同一时刻只允许一个线程访问该共享资源，即多个线程中只有一个线程获得锁资源。在AQS中，排他锁是通过内置的同步状态来实现的。当同步状态为0时，表示锁是未被获取的；当同步状态大于0时，表示锁已经被获取且被占用；当同步状态小于0时，表示锁已经被获取但是处于等待状态。</p><p><strong>共享锁</strong>允许多个线程同时获得锁资源，但是在同一时刻只有一个线程可以获取到锁的拥有权，其他线程需要等待该线程释放锁。在AQS中，共享锁的实现与排他锁类似，也是通过先进内置的同步状态来实现的。</p><p>AQS通过一个内置的<strong>FIFO</strong>（先进先出）等待队列来实现线程的排队和调度。当线程需要获取锁资源时，如果锁已经被其他线程获取，则该线程会被加入到等待队列中等待。当锁被释放时，等待队列中的第一个线程会获得锁资源并继续执行。</p><p>在实现AQS时，需要继承自AQS类并实现其抽象方法。其中比较重要的方法包括：tryAcquire()和tryRelease()方法，用于实现锁的获取和释放；acquire()和release()方法，用于实现阻塞和唤醒操作；isHeldExclusively()方法，用于判断是否是排他锁。&#x20;</p><p>答案：</p><blockquote><p>AQS是多线程同步器，它是J.U.C包中多个组件的底层实现，如Lock、CountDownLatch、Semaphore等都用到了AQS。<strong>从本质上来说，AQS提供了两种锁机制，分别是排他锁，和共享锁。</strong>&#x6392;他锁，就是存在多线程竞争同一共享资源时，同一时刻只允许一个线程访问该共享资源，也就是多个线程中只能有一个线程获得锁资源，比如Lock中的ReentrantLock重入锁实现就是用到了AQS中的排他锁功能。<strong>共享锁也称为读锁</strong>，就是在同一时刻允许多个线程同时获得锁资源，比如CountDownLatch和Semaphore都是用到了AQS中的共享锁功能。</p><p>AQS有三个核心的问题：</p><p>AQS维持着一个int类型的互斥变量state来记录锁竞争的一个状态，0表示当前没有任何线程竞争锁资源，而大于等于1表示已经有线程正在持有锁资源。一个线程来获取锁资源的时候，首先判断state是否等于0，如果是(无锁状态)，则把这个state更新成1，表示占用到锁。此时如果多个线程进行同样的操作，会造成线程安全问题。AQS采用了CAS机制来保证互斥变量state的原子性。</p><p>未获取到锁资源的线程通过Unsafe类中的park方法对线程进行阻塞，把阻塞的线程按照先进先出的原则加入到一个双向链表的结构<strong>CLH</strong>中，当获得锁资源的线程释放锁之后，会从双向链表的头部去唤醒下一个等待的线程再去竞争锁。</p><p><strong>CLH 队列</strong>是一个虚拟的双向队列,用于存储等待锁的线程。当线程尝试获取同步状态失败时，会将其封装成一个节点加入到队列的尾部，并处于等待状态。线程通过自旋的方式不断检查其前驱节点的状态来判断自己是否能够获取到锁。当持有锁的线程释放锁时，会唤醒其后继节点的线程进行竞争获取。</p><p>另外关于公平性和非公平性问题，AQS的处理方式是，在竞争锁资源的时候，公平锁需要判断双向链表中是否有阻塞的线程，如果有，则需要去排队等待；而非公平锁的处理方式是，不管双向链表中是否存在等待锁的线程，都会直接尝试更改互斥变量state去竞争锁。&#x20;</p></blockquote><p><a href="https://pdai.tech/md/java/thread/java-thread-x-lock-AbstractQueuedSynchronizer.html">JUC锁: 锁核心类AQS详解</a></p><p><a href="https://javaguide.cn/java/concurrent/aqs.html">AQS 详解</a></p><h3 id="12-说下CAS的原理"><a href="#12-说下CAS的原理" class="headerlink" title="12. 说下CAS的原理"></a>12. 说下CAS的原理</h3><blockquote><p>CAS（Compare And Swap）是一种<strong>乐观的并发控制机制</strong>，它的核心原理是基于硬件层面的原子性保证。CAS操作包含三个操作数——内存位置（V）、预期原值（A）和新值（B）。它的工作原理是：</p><ol><li><p>在将新值写入内存之前，CAS操作会先比较内存位置的值是否与预期原值相匹配。</p></li><li><p>如果内存位置的值与预期原值相匹配，那么处理器会自动将该位置的值更新为新值。</p></li><li><p>如果内存位置的值与预期原值不匹配，则CAS操作失败，不会修改内存值。</p></li></ol><p>CAS的优势在于它没有阻塞状态，不会引起线程上下文的切换和调度问题。然而，CAS也存在一些缺点，例如ABA问题和开销问题。ABA问题是指一个值原来是A，变成了B，又变成了A，那么使用CAS进行检查时会发现它的值没有发生变化，但是实际上却变化了。开销问题则是因为CAS自旋操作需要不断轮询内存位置，直到成功为止，这会消耗大量的CPU资源。&#x20;</p></blockquote><h3 id="13-ReentrantLock中的公平锁和非公平锁的底层实现"><a href="#13-ReentrantLock中的公平锁和非公平锁的底层实现" class="headerlink" title="13. ReentrantLock中的公平锁和非公平锁的底层实现"></a>13. ReentrantLock中的公平锁和非公平锁的底层实现</h3><blockquote><p>ReentrantLock是Java中提供的一种可重入锁，它支持两种锁的模式：公平锁和非公平锁。这两种锁模式的底层实现略有不同：</p><ol><li><p><strong>公平锁（Fair Lock）</strong>：公平锁的特点是按照请求锁的顺序来分配，即先到先得。在ReentrantLock中，通过构造函数可以选择创建一个公平锁。公平锁的底层实现使用了一个FIFO队列（First - In - First - Out），即等待队列。当一个线程请求锁时，如果锁已经被其他线程持有，请求线程会被放入等待队列的末尾，按照请求的顺序等待锁的释放。当锁被释放时，等待队列中的第一个线程会被唤醒并获得锁。</p></li><li><p><strong>非公平锁（Non - Fair Lock）</strong>：非公平锁不考虑请求锁的顺序，它允许新的请求线程插队并尝试立即获取锁，而不管其他线程是否在等待。在ReentrantLock中，默认情况下创建的是非公平锁。非公平锁的底层实现中，有一个等待队列，但它不会严格按照请求的顺序来分配锁，而是根据线程竞争的情况来判断是否立即分配给请求线程。</p></li></ol><p>底层实现中，无论是公平锁还是非公平锁，都使用了类似的同步器（Sync）来管理锁的状态和线程的竞争。不同之处在于如何处理等待队列中的线程，以及是否按照请求的顺序来分配锁。</p><p>需要注意的是，公平锁虽然遵循公平性原则，但在高并发情况下可能会引入较大的性能开销，因为每次都要维护一个有序的等待队列。而非公平锁则更加灵活，但可能导致某些线程一直获取不到锁。&#x20;</p></blockquote><h3 id="14-AQS是怎么实现同步管理的-底层数据结构"><a href="#14-AQS是怎么实现同步管理的-底层数据结构" class="headerlink" title="14. AQS是怎么实现同步管理的? 底层数据结构?"></a>14. AQS是怎么实现同步管理的? 底层数据结构?</h3><p><strong>参考回答</strong>：</p><blockquote><p>AQS主要依赖于<strong>一个双向链表</strong>和一个<strong>volatile类型的整数state</strong>来实现同步控制。该整数state用来表示同步状态，一般情况下，state=0表示没有线程占用同步资源，state&gt;0表示有线程占用同步资源，state&gt;1表示同步资源已经被争用了多次，比如ReentrantLock可以允许一个线程多次获得锁，每次state值加1。</p><p>AQS实现同步的关键在于，它提供了一个基于FIFO队列的等待队列，通过将等待线程加入等待队列中，然后在释放同步状态的时候，从等待队列中唤醒等待线程，从而实现了同步机制。</p><p>AQS的实现主要有两种方式：独占式（Exclusive）和共享式（Shared）。独占式是指只有一个线程可以占用同步资源，比如ReentrantLock，而共享式是指多个线程可以同时占用同步资源，比如CountDownLatch。在AQS中，这两种方式的实现是基本相同的，区别在于获取和释放同步状态的方式不同。&#x20;</p></blockquote><h3 id="15-什么是可重入，什么是可重入锁"><a href="#15-什么是可重入，什么是可重入锁" class="headerlink" title="15. 什么是可重入，什么是可重入锁?"></a>15. 什么是可重入，什么是可重入锁?</h3><p><strong>参考回答</strong>：</p><blockquote><p>“可重入锁”概念是：自己可以再次获取自己的内部锁。比如一个线程获得了某个对象的锁，此时这个对象锁还没有释放，当其再次想要获取这个对象的锁的时候还是可以获取的，如果不可锁重入的话，就会造成死锁。同一个线程每次获取锁，锁的计数器都自增1，所以要等到锁的计数器下降为0时才能释放锁。</p></blockquote><h3 id="16-公平锁和非公平锁有什么区别"><a href="#16-公平锁和非公平锁有什么区别" class="headerlink" title="16. 公平锁和非公平锁有什么区别?"></a>16. 公平锁和非公平锁有什么区别?</h3><p><strong>参考回答</strong>：</p><blockquote><ul><li><p>公平锁：锁被释放之后，先申请的线程先得到锁。性能较差一些，因为公平锁为了保证时间上的绝对顺序，上下文切换更频繁。</p></li><li><p>非公平锁：锁被释放之后，后申请的线程可能会先获取到锁，是随机或者按照其他优先级排序的。性能更好，但可能会导致某些线程永远无法获取到锁。&#x20;</p></li></ul></blockquote><h3 id="17-为什么非公平锁比公平锁性能更好"><a href="#17-为什么非公平锁比公平锁性能更好" class="headerlink" title="17. 为什么非公平锁比公平锁性能更好?"></a>17. 为什么非公平锁比公平锁性能更好?</h3><blockquote><p><strong>参考回答</strong>：</p><ul><li><p>公平锁执行流程：获取锁时，先将线程自己添加到同步队列的队尾并休眠，当某线程用完锁之后，会去唤醒同步队列队首的线程尝试去获取锁，锁的使用同步也就是队列中的先后顺序，在整个过程中，线程会从运行状态切换到休眠状态，再从休眠状态恢复成运行状态，但线程每次休眠和恢复都需要从用户态转换成内核态，而这个状态的转换是比较慢的，所以公平锁的执行速度会比较慢。</p></li><li><p>非公平锁执行流程：当线程获取锁时，会先通过CAS尝试获取锁，如果获取成功就直接拥有锁，如果获取锁失败才会进入同步队列，等待下次尝试获取锁。这样做的好处是，获取锁不遵循先到先得的规则，从而避免了一次线程休眠和恢复的操作，这样就加速了程序的执行效率。&#x20;</p></li></ul></blockquote><h3 id="18-ReentrantLock是如何实现公平锁的-非公平锁的"><a href="#18-ReentrantLock是如何实现公平锁的-非公平锁的" class="headerlink" title="18. ReentrantLock是如何实现公平锁的? 非公平锁的?"></a>18. ReentrantLock是如何实现公平锁的? 非公平锁的?</h3><p><strong>参考回答</strong>：</p><blockquote><p>ReentrantLock类内部总共存在Sync、NonfairSync、FairSync三个类，NonfairSync与FairSync类继承自Sync类，Sync类继承自AbstractQueueuedSynchronizer抽象类。</p><p>非公平锁是ReentrantLock的默认实现。公平锁对比非公平锁的实现差异主要体现在tryAcquire方法（获取锁）这里。非公平锁（NonfairSync）的tryAcquire实现直接调用了父类Sync中的nonfairTryAcquire。</p><p>而公平锁tryAcquire的唯一不同的点为判断条件多了hasQueuedPredecessors()方法，即加入了同步队列中当前节点是否有前驱节点的判断，如果该方法返回true，则表示有线程比当前线程更早地请求获取锁，因此需要等待前驱线程获取并释放锁之后才能继续获取锁（这就叫公平）。</p></blockquote><h3 id="19-ReentrantReadWriteLock是什么"><a href="#19-ReentrantReadWriteLock是什么" class="headerlink" title="19. ReentrantReadWriteLock是什么?"></a>19. ReentrantReadWriteLock是什么?</h3><p><strong>参考回答</strong>：</p><blockquote><p>答：<code>ReentrantReadWriteLock</code>实现了<code>ReadWriteLock</code>，是一个可重入的读写锁，既可以保证多个线程同时读的效率，同时又可以保证有写入操作时的线程安全。</p><p><code>ReentrantReadWriteLock</code>其实是两把锁，一把是WriteLock（写锁），一把是ReadLock（读锁）。读锁是共享锁，写锁是独占锁。读锁可以被同时读，可以同时被多个线程持有，而写锁最多只能同时被一个线程持有。&#x20;</p></blockquote><h3 id="20-共享锁和独占锁有什么区别"><a href="#20-共享锁和独占锁有什么区别" class="headerlink" title="20. 共享锁和独占锁有什么区别?"></a>20. 共享锁和独占锁有什么区别?</h3><blockquote><p><strong>参考回答</strong>：</p><ul><li><p>共享锁：一把锁可以被多个线程同时获得。</p></li><li><p>独占锁：一把锁只能被一个线程获得。</p></li></ul></blockquote><h3 id="21-线程持有读锁还能获取写锁吗"><a href="#21-线程持有读锁还能获取写锁吗" class="headerlink" title="21. 线程持有读锁还能获取写锁吗?"></a>21. 线程持有读锁还能获取写锁吗?</h3><p><strong>参考回答</strong>：</p><blockquote><p>在线程持有读锁的情况下：该线程不能取得写锁(因为获取写锁的时候，如果发现当前的读锁被占用，就马上获取失败，不管读锁是不是被当前线程持有)。</p><p>在线程持有写锁的情况下：该线程可以继续获取读锁（获取读锁时如果发现写锁被占用，只有写锁没有被当前线程占用的情况才会获取失败）。</p></blockquote><h3 id="22-什么是锁的升降级-RentrantReadWriteLock为什么不支持锁升级"><a href="#22-什么是锁的升降级-RentrantReadWriteLock为什么不支持锁升级" class="headerlink" title="22. 什么是锁的升降级? RentrantReadWriteLock为什么不支持锁升级?"></a>22. 什么是锁的升降级? RentrantReadWriteLock为什么不支持锁升级?</h3><p><strong>参考回答</strong>：</p><blockquote><p>写锁可以降级为读锁，但是读锁却不能升级为写锁。这是因为读锁升级为写锁会引起线程的争夺，毕竟写锁属于是独占锁，这样的话，会影响性能。另外，还可能会有死锁问题发生。举个例子：假设两个线程的读锁都想升级写锁，则需要对方都释放自己锁，而双方都不释放，就会产生死锁。&#x20;</p></blockquote><h3 id="23-ReentrantReadWriteLock底层读写状态如何设计的"><a href="#23-ReentrantReadWriteLock底层读写状态如何设计的" class="headerlink" title="23. ReentrantReadWriteLock底层读写状态如何设计的?"></a>23. ReentrantReadWriteLock底层读写状态如何设计的?</h3><p><strong>参考回答</strong>：</p><blockquote><p>答：高16位为读锁，低16位为写锁。&#x20;</p></blockquote><h2 id="并发安全容器-并发工具类"><a href="#并发安全容器-并发工具类" class="headerlink" title="并发安全容器/并发工具类"></a>并发安全容器/并发工具类</h2><h3 id="1-JDK7与JDK8之间HashMap的区别？"><a href="#1-JDK7与JDK8之间HashMap的区别？" class="headerlink" title="1. JDK7与JDK8之间HashMap的区别？"></a>1. JDK7与JDK8之间HashMap的区别？</h3><blockquote><ol><li><p>JDK8中新增了红黑树，JDK8是通过数组+链表+红黑树来实现的；</p></li><li><p>JDK7中链表的插入是用的头插法，而JDK8中则改为了尾插法；</p></li><li><p>JDK8中因为使用了红黑树保证了插入和查询的效率，所以实际上JDK8中的Hash算法实现的复杂度降低了；</p></li><li><p>JDK8中数组扩容的条件也发生了变化，只会判断是否当前元素个数是否超过了阈值，而不再判断当前put进来的元素对应的数组下标位置是否有值；</p></li><li><p>JDK7中是先扩容再添加新元素，JDK8中是先添加新元素然后再扩容。&#x20;</p></li></ol></blockquote><h3 id="2-ConcurrentHashMap和Hashtable的区别"><a href="#2-ConcurrentHashMap和Hashtable的区别" class="headerlink" title="2. ConcurrentHashMap和Hashtable的区别?"></a>2. ConcurrentHashMap和Hashtable的区别?</h3><p><strong>参考回答</strong>：</p><blockquote><p>ConcurrentHashMap和Hashtable的区别主要体现在实现线程安全的方式上不同。</p><p><strong>底层数据结构</strong>：JDK1.7的ConcurrentHashMap底层采用分段的数组+链表实现，JDK1.8采用的数据结构跟HashMap1.8的结构一样，数组+链表/红黑二叉树。Hashtable和JDK1.8之前的HashMap的底层数据结构类似都是采用数组+链表的形式，数组是HashMap的主体，链表则是主要为了解决哈希冲突而存在的；</p><p><strong>实现线程安全的方式（重要）</strong>：</p><p>在JDK1.7的时候，ConcurrentHashMap对整个桶数组进行了分割分段(Segment，分段锁)，每一把锁只锁容器其中一部分数据，多线程访问容器里不同数据段的数据，就不会存在锁竞争，提高并发访问率。</p><p>到了JDK1.8的时候，ConcurrentHashMap已经摒弃了Segment的概念，而是直接用Node数组+链表+红黑树的数据结构来实现，并发控制使用synchronized和CAS来操作。(JDK1.6以后synchronized锁做了很多优化) 整个看起来就像是优化过且线程安全的HashMap，虽然在JDK1.8中还能看到Segment的数据结构，但是已经简化了属性，只是为了兼容旧版本；</p><p>Hashtable(同一把锁)：使用synchronized来保证线程安全，效率非常低下。当一个线程访问同步方法时，其他线程也访问同步方法，可能会进入阻塞或轮询状态，如使用put添加元素，另一个线程不能使用put添加元素，也不能使用get，竞争会越来越激烈效率越低。&#x20;</p></blockquote><h3 id="3-ConcurrentHashMap-JDK1-7实现的原理是什么"><a href="#3-ConcurrentHashMap-JDK1-7实现的原理是什么" class="headerlink" title="3. ConcurrentHashMap JDK1.7实现的原理是什么?"></a>3. ConcurrentHashMap JDK1.7实现的原理是什么?</h3><blockquote><p><strong>参考回答</strong>：</p><ul><li><p>首先将数据分为一段一段（这个“段”就是Segment）的存储，然后给每一段数据配一把锁，当一个线程占用锁访问其中一个段数据时，其他段的数据也能被其他线程访问。</p></li><li><p>ConcurrentHashMap是由Segment数组结构和HashEntry数组结构组成。</p></li><li><p>Segment继承了ReentrantLock，所以Segment是一种可重入锁，扮演锁的角色。HashEntry用于存储键值对数据。</p></li><li><p>一个ConcurrentHashMap里包含一个Segment数组，Segment的个数一旦初始化就不能改变。Segment数组的大小默认是16，也就是说默认可以同时支持16个线程并发写。</p></li><li><p>Segment的结构和HashMap类似，是一种数组和链表结构，一个Segment包含一个HashEntry数组，每个HashEntry是一个链表结构的元素，每个Segment守护着一个HashEntry数组里的元素，当对HashEntry数组的数据进行修改时，必须首先获得对应的Segment的锁。也就是说，对同一Segment的并发写入会被阻塞，不同Segment的写入是可以并发执行的。&#x20;</p></li></ul></blockquote><h3 id="4-ConcurrentHashMap-JDK1-8实现的原理是什么"><a href="#4-ConcurrentHashMap-JDK1-8实现的原理是什么" class="headerlink" title="4. ConcurrentHashMap JDK1.8实现的原理是什么?"></a>4. ConcurrentHashMap JDK1.8实现的原理是什么?</h3><p><strong>参考回答</strong>：</p><blockquote><p>JDK1.8 ConcurrentHashMap取消了Segment分段锁，采用Node + CAS + synchronized来保证并发安全。数据结构跟HashMap 1.8的结构类似，数组+链表/红黑二叉树。Java 8在链表长度超过一定阈值8（同时满足容量&gt;=64）时将链表（寻址时间复杂度为O(N)）转换为红黑树（寻址时间复杂度为O(log(N))）。</p><p>Java 8中，锁粒度更细，synchronized只锁定当前链表或红黑二叉树的首节点，这样只要hash不冲突，就不会产生并发，就不会影响其他Node的读写，效率大幅提升。</p></blockquote><h3 id="5-ConcurrentHashMap-JDK1-7的实现和1-8的实现有什么区别"><a href="#5-ConcurrentHashMap-JDK1-7的实现和1-8的实现有什么区别" class="headerlink" title="5. ConcurrentHashMap JDK1.7的实现和1.8的实现有什么区别?"></a>5. ConcurrentHashMap JDK1.7的实现和1.8的实现有什么区别?</h3><blockquote><p><strong>参考回答</strong>：</p><ul><li><p><strong>线程安全实现方式</strong>：JDK 1.7采用Segment分段锁来保证安全，Segment是继承自ReentrantLock。JDK1.8放弃了Segment分段锁的设计，采用Node + CAS + synchronized保证线程安全，锁粒度更细，synchronized只锁定当前链表或红黑二叉树的首节点。</p></li><li><p><strong>Hash碰撞解决方法</strong>：JDK 1.7采用拉链法，JDK1.8采用拉链法结合红黑树（链表长度超过一定阈值时，将链表转换为红黑树）。</p></li><li><p><strong>并发度</strong>：JDK 1.7最大并发度是Segment的个数，默认是16。JDK 1.8最大并发度是Node数组的大小，并发度更大。&#x20;</p></li></ul></blockquote><h3 id="6-JDK1-8中，ConCurrentHashmap什么情况下链表才会转换成红黑树进行存储"><a href="#6-JDK1-8中，ConCurrentHashmap什么情况下链表才会转换成红黑树进行存储" class="headerlink" title="6. JDK1.8中，ConCurrentHashmap什么情况下链表才会转换成红黑树进行存储?"></a>6. JDK1.8中，ConCurrentHashmap什么情况下链表才会转换成红黑树进行存储?</h3><p><strong>参考回答</strong>：</p><blockquote><p>答：链表长度大于等于8，且数组长度大于等于64。</p><p>并非一开始就创建红黑树结构，如果当前Node数组长度小于阈值MIN_TREEIFY_CAPACITY，默认为64，先通过扩大数组容量为原来的两倍以缓解单个链表元素过大的性能问题。</p></blockquote><h3 id="7-JDK1-8中，ConcurrentHashmap的put过程是怎样的"><a href="#7-JDK1-8中，ConcurrentHashmap的put过程是怎样的" class="headerlink" title="7. JDK1.8中，ConcurrentHashmap的put过程是怎样的?"></a>7. JDK1.8中，ConcurrentHashmap的put过程是怎样的?</h3><p><strong>参考回答</strong>：</p><blockquote><p>整体流程跟HashMap比较类似，大致是以下几步：</p><ul><li><p>如果桶数组未初始化，则初始化；</p></li><li><p>如果待插入的元素所在的桶为空，则尝试把此元素直接插入到桶的第一个位置；</p></li><li><p>如果正在扩容，则当前线程一起加入到扩容的过程中；</p></li><li><p>如果待插入的元素所在的桶不为空且没在迁移元素，则锁住这个桶；</p></li><li><p>如果当前桶中元素以链表方式存储，则在链表中寻找该元素或者插入元素；</p></li><li><p>如果当前桶中元素以红黑树方式存储，则在红黑树中寻找该元素或者插入元素；</p></li><li><p>如果元素存在，则覆盖旧值；</p></li><li><p>如果元素不存在，整个Map的元素个数加1，并检查是否需要扩容；&#x20;</p></li></ul></blockquote><h3 id="8-ConcurrentHashMap的get方法是否要加锁，为什么"><a href="#8-ConcurrentHashMap的get方法是否要加锁，为什么" class="headerlink" title="8. ConcurrentHashMap的get方法是否要加锁，为什么?"></a>8. ConcurrentHashMap的get方法是否要加锁，为什么?</h3><p><strong>参考回答</strong>：</p><blockquote><p>答：不需要。get方法不涉及对变量的修改，所以会导致并发下可能处问题的原因就是读共享变量的可见性问题。而ConcurrentHashMap中，对get方法中用到的共享变量都使用volatile关键字修饰，所以整个get方法不加锁也不会有问题。</p></blockquote><h3 id="9-ConcurrentHashMap默认初始容量是多少"><a href="#9-ConcurrentHashMap默认初始容量是多少" class="headerlink" title="9. ConcurrentHashMap默认初始容量是多少?"></a>9. ConcurrentHashMap默认初始容量是多少?</h3><p><strong>参考回答</strong>：</p><blockquote><p>答：初始容量为16</p></blockquote><h3 id="10-ConcurrentHashMap的key，value是否可以为null"><a href="#10-ConcurrentHashMap的key，value是否可以为null" class="headerlink" title="10. ConcurrentHashMap的key，value是否可以为null?"></a>10. ConcurrentHashMap的key，value是否可以为null?</h3><p><strong>参考回答</strong>：</p><blockquote><p>答：不行。如果key或者value为null会抛出空指针异常。(原因是因为没办法解决get返回值为null时的二义性问题，即没办法确定是存储的值本身为null，还是说值不存在)；</p><p>注意：HashMap允许使用null作为值和键。(因为HashMap只能单线程下使用，所以hashmap可以用containsKey来二次判断，排除二义性问题)&#x20;</p></blockquote><h3 id="11-存储在ConcurrentHashMap中每个节点是什么样的，有哪些变量"><a href="#11-存储在ConcurrentHashMap中每个节点是什么样的，有哪些变量" class="headerlink" title="11.存储在ConcurrentHashMap中每个节点是什么样的，有哪些变量?"></a>11.存储在ConcurrentHashMap中每个节点是什么样的，有哪些变量?</h3><p><strong>参考回答</strong>：</p><blockquote><p>答：它是实现Map.Entry\<K, V>接口。里面存放了hash，key，value，以及next节点。它的value和next节点是用volatile进行修饰，可以保证多线程之间的可见性。</p></blockquote><h3 id="12-什么是BlockingQueue"><a href="#12-什么是BlockingQueue" class="headerlink" title="12. 什么是BlockingQueue?"></a>12. 什么是BlockingQueue?</h3><p><strong>参考回答</strong>：</p><blockquote><p>阻塞队列(BlockingQueue)是一个支持两个附加操作的队列。这两个附加的操作支持阻塞的插入和移除方法。</p><ol><li><p>支持阻塞的插入方法：意思是当队列满时，队列会阻塞插入元素的线程，直到队列不满。</p></li><li><p>支持阻塞的移除方法：意思是在队列为空时，获取元素的线程会等待队列变为非空。&#x20;</p></li></ol></blockquote><h3 id="13-你了解哪些阻塞队列"><a href="#13-你了解哪些阻塞队列" class="headerlink" title="13.你了解哪些阻塞队列"></a>13.你了解哪些阻塞队列</h3><blockquote><ul><li><p>ArrayBlockingQueue：一个由数组结构组成的有界阻塞队列。</p></li><li><p>LinkedBlockingQueue：一个由链表结构组成的阻塞队列。此队列创建时可以不指定容量大小，默认是Integer.MAX_VALUE，也就是无界的。但也可以指定队列大小，从而成为有界的。</p></li><li><p>PriorityBlockingQueue：一个支持优先级排序的无界阻塞队列。默认情况下元素采取自然顺序升序排列。也可以自定义类实现compareTo()方法来指定元素排序规则。</p></li><li><p>DelayQueue：一个使用优先级队列实现的无界阻塞队列。队列使用PriorityQueue来实现。队列中的元素必须实现Delayed接口，在创建元素时可以指定多久才能从队列中获取当前元素。只有在延迟期满时才能从队列中提取元素。（常用在缓存有效期，定时任务调度等场景）</p></li><li><p>SynchronousQueue：一个不存储元素的阻塞队列。每一个put操作必须等待一个take操作，否则不能继续添加元素。队列本身并不存储任何元素，非常适合传递性场景。</p></li><li><p>LinkedTransferQueue：一个由链表结构组成的单向无界阻塞队列。它设计了一种直接在生产者和消费者之间传输元素的机制，称为“transfer”。当生产者调用transfer(e)方法时，它会阻塞直到有一个消费者接收该元素。适用于需要高效地在生产者和消费者之间直接传输数据的场景，尤其是当生产者和消费者之间的速度大致匹配时。</p></li><li><p>LinkedBlockingDeque：一个由链表结构组成的双向阻塞队列。所谓双向队列指的是可以从队列的两端插入和移出元素。相比其他的阻塞队列，LinkedBlockingDeque多了addFirst、addLast、offerFirst、offerLast、peekFirst和peekLast等方法。双向阻塞队列可以运用在“工作窃取”模式中。&#x20;</p></li></ul></blockquote><h3 id="14-ArrayBlockingQueue和LinkedBlockingQueue有什么区别"><a href="#14-ArrayBlockingQueue和LinkedBlockingQueue有什么区别" class="headerlink" title="14. ArrayBlockingQueue和LinkedBlockingQueue有什么区别?"></a>14. ArrayBlockingQueue和LinkedBlockingQueue有什么区别?</h3><p><strong>参考回答</strong>：</p><blockquote><p>答：ArrayBlockingQueue和LinkedBlockingQueue是Java并发包中常用的两种阻塞队列实现，它们都是线程安全的。不过，它们之间也存在下面这些区别：</p><ul><li><p>底层实现：ArrayBlockingQueue基于数组实现，而LinkedBlockingQueue基于链表实现。</p></li><li><p>是否有界：ArrayBlockingQueue是有界队列，必须在创建时指定容量大小。LinkedBlockingQueue创建时可以不指定容量大小，默认是Integer.MAX_VALUE，也就是无界的。但也可以指定队列大小，从而成为有界的。</p></li><li><p>锁是否分离：ArrayBlockingQueue中的锁是没有分离的，即生产和消费用的是同一个锁；LinkedBlockingQueue中的锁是分离的，即生产用的是putLock，消费是takeLock，这样可以防止生产者和消费者线程之间的锁争夺。</p></li><li><p>内存占用：ArrayBlockingQueue需要提前分配数组内存，而LinkedBlockingQueue则是动态分配链表节点内存。这意味着，ArrayBlockingQueue在创建时就会占用一定的内存空间，且往往申请的内存比实际所用的内存更大，而LinkedBlockingQueue则是根据元素的增加而逐渐占用内存空间。&#x20;</p></li></ul></blockquote><h3 id="15-如果队列是空的，消费者会一直等待，当生产者添加元素时，消费者是如何知道当前队列有元素的呢"><a href="#15-如果队列是空的，消费者会一直等待，当生产者添加元素时，消费者是如何知道当前队列有元素的呢" class="headerlink" title="15. 如果队列是空的，消费者会一直等待，当生产者添加元素时，消费者是如何知道当前队列有元素的呢?"></a>15. 如果队列是空的，消费者会一直等待，当生产者添加元素时，消费者是如何知道当前队列有元素的呢?</h3><p><strong>参考回答</strong>：</p><blockquote><p>答：使用通知模式实现。所谓通知模式，当消费者从空的队列获取元素时会阻塞住消费者，此时如果生产者放了一个元素进入队列，则需要通知阻塞住消费者当前有元素可取。同理当生产者往满的队列里添加元素时会阻塞住生产者，当消费者消费了一个队列中的元素后，会通知生产者当前队列可用。通过查看JDK源码发现部分阻塞队列使用了Condition来实现。&#x20;</p></blockquote><h3 id="16-CountDownLatch，CyclicBarrier，Semaphore，Exchanger了解吗"><a href="#16-CountDownLatch，CyclicBarrier，Semaphore，Exchanger了解吗" class="headerlink" title="16. CountDownLatch，CyclicBarrier，Semaphore，Exchanger了解吗?"></a>16. CountDownLatch，CyclicBarrier，Semaphore，Exchanger了解吗?</h3><blockquote><p><strong>参考回答</strong>：</p><ul><li><p>CountDownLatch：倒计数器。允许一个或多个线程等待其他线程完成操作。</p></li><li><p>CyclicBarrier的字面意思是可循环使用（Cyclic）的屏障（Barrier）。它要做的事情是，让一组线程到达一个屏障（也可以叫同步点）时被阻塞，直到最后一个线程到达屏障时，屏障才会开门，所有被屏障拦截的线程才会继续运行。</p></li><li><p>Semaphore（信号量）：是用来控制同时访问特定资源的线程数量，它通过协调各个线程，以保证合理的使用公共资源。</p></li><li><p>Exchanger（交换者）：是一个用于线程间协作的工具类。Exchanger用于进行线程间的数据交换。它提供一个同步点，在这个同步点，两个线程可以交换彼此的数据。&#x20;</p></li></ul></blockquote><h3 id="17-CyclicBarrier和CountDownLatch有什么区别"><a href="#17-CyclicBarrier和CountDownLatch有什么区别" class="headerlink" title="17. CyclicBarrier和CountDownLatch有什么区别?"></a>17. CyclicBarrier和CountDownLatch有什么区别?</h3><p><strong>参考回答</strong>：</p><blockquote><ol><li>CyclicBarrier是可重用的，其中的线程会等待所有的线程完成任务。届时，屏障将被拆除，并可以选择性地做一些特定的动作。</li></ol><p>CountDownLatch是一次性的，不同的线程在同一个计数器上工作，直到计数器为0.</p><ul><li>CyclicBarrier面向的是线程数；</li></ul><p>CountDownLatch面向的是任务数。</p><ul><li><p>在使用CyclicBarrier时，你必须在构造中指定参与协作的线程数，这些线程必须调用await()方法；使用CountDownLatch时，则必须要指定任务数，至于这些任务由哪些线程完成无关紧要。</p></li><li><p>CyclicBarrier可以在所有的线程释放后重新使用；CountDownLatch在计数器为0时不能再使用。&#x20;</p></li></ul></blockquote><h3 id="18-常见函数"><a href="#18-常见函数" class="headerlink" title="18.常见函数"></a>18.常见函数</h3><blockquote><p>在 JUC（Java.util.concurrent）中，一些常用的函数及其作用如下：</p><ol><li><p><code>park()</code> 和 <code>unpark()</code>：</p><ul><li><p><code>park()</code>：用于阻塞当前线程。</p></li><li><p><code>unpark(Thread thread)</code>：用于唤醒指定的被 <code>park()</code> 阻塞的线程。</p></li></ul></li><li><p><code>wait()</code>、<code>notify()</code> 和 <code>notifyAll()</code>：</p><ul><li><p><code>wait()</code>：使当前线程等待，直到其他线程调用此对象的 <code>notify()</code> 方法或 <code>notifyAll()</code> 方法。</p></li><li><p><code>notify()</code>：唤醒在此对象监视器上等待的单个线程。</p></li><li><p><code>notifyAll()</code>：唤醒在此对象监视器上等待的所有线程。</p></li></ul></li><li><p><code>Thread.sleep(long millis)</code>：使当前正在执行的线程暂停指定的毫秒数。</p></li><li><p><code>CountDownLatch</code>：</p><ul><li><p><code>countDown()</code>：使计数器减 1。</p></li><li><p><code>await()</code>：等待计数器变为 0。</p></li></ul></li><li><p><code>CyclicBarrier</code>：</p><ul><li><code>await()</code>：等待所有线程都到达屏障点。</li></ul></li><li><p><code>Semaphore</code>：</p><ul><li><p><code>acquire()</code>：获取一个许可，如果没有可用许可则阻塞。</p></li><li><p><code>release()</code>：释放一个许可。</p></li></ul></li><li><p><code>Future</code> 和 <code>CompletableFuture</code>：用于处理异步任务的结果。</p></li></ol><p>这些函数和类为多线程编程提供了丰富的工具，帮助开发者更有效地管理线程的同步、协作和异步操作。&#x20;</p></blockquote>]]></content>
    
    
    <summary type="html">🥧本人的JUC基础面试总结</summary>
    
    
    
    <category term="面试题" scheme="https://outoflovenicoo.github.io/categories/%E9%9D%A2%E8%AF%95%E9%A2%98/"/>
    
    
    <category term="JUC" scheme="https://outoflovenicoo.github.io/tags/JUC/"/>
    
  </entry>
  
  <entry>
    <title>Spring基础面试题</title>
    <link href="https://outoflovenicoo.github.io/posts/2025-01-09-Spring%E5%9F%BA%E7%A1%80%E9%9D%A2%E8%AF%95%E9%A2%98.html"/>
    <id>https://outoflovenicoo.github.io/posts/2025-01-09-Spring%E5%9F%BA%E7%A1%80%E9%9D%A2%E8%AF%95%E9%A2%98.html</id>
    <published>2025-01-09T10:19:03.000Z</published>
    <updated>2025-03-23T14:00:00.000Z</updated>
    
    <content type="html"><![CDATA[<h1 id="1-Spring面试题"><a href="#1-Spring面试题" class="headerlink" title="1.Spring面试题"></a>1.Spring面试题</h1><h2 id="一、Spring概述"><a href="#一、Spring概述" class="headerlink" title="一、Spring概述"></a>一、Spring概述</h2><h3 id="1-Spring中的设计模式有哪些？"><a href="#1-Spring中的设计模式有哪些？" class="headerlink" title="1. Spring中的设计模式有哪些？"></a>1. Spring中的设计模式有哪些？</h3><ul><li><p><strong>工厂模式</strong>：Spring容器本质是工厂，通过BeanFactory、ApplicationContext等利用该模式创建bean对象，将对象创建和使用分离，便于管理和维护bean实例。</p></li><li><p><strong>代理模式</strong>：Spring AOP功能借助此模式实现，分动态代理和静态代理，用于在不修改目标对象代码的情况下，为其添加额外功能，如日志记录、事务管理等。</p></li><li><p><strong>单例模式</strong>：Spring中Bean默认是单例的，即整个应用中只有一个实例，利于容器对Bean统一管理，减少资源消耗。</p></li><li><p><strong>模板模式</strong>：像JdbcTemplate、RestTemplate等以Template结尾的类，定义了操作数据库、网络等的通用骨架，具体实现步骤由子类完成，提高了代码复用性。</p></li><li><p><strong>观察者模式</strong>：Spring事件驱动模型是其经典应用，存在事件发布者、事件和事件监听器，发布者发布事件，监听器监听并做出响应，实现组件间解耦。</p></li><li><p><strong>适配器模式</strong>：Spring AOP的增强或通知（Advice）使用该模式，在Spring MVC中也用于适配Controller，让不兼容的接口协同工作。</p></li><li><p><strong>策略模式</strong>：Spring的Resource接口有不同实现类，根据不同策略访问资源，便于在运行时动态选择算法或行为。&#x20;</p></li></ul><h3 id="2-IOC的实现原理"><a href="#2-IOC的实现原理" class="headerlink" title="2.IOC的实现原理"></a>2.IOC的实现原理</h3><ol><li><p>扫描和解析配置文件或注解信息，将其转换为内部的对象定义和依赖关系；</p></li><li><p>根据对象定义和依赖关系，使用反射机制动态创建和初始化对象，并将对象注入到需要使用它们的地方。</p></li></ol><p>具体来说，Spring IOC的实现过程如下：</p><ul><li><p>读取配置文件或解析注解信息，将其转换为内部的对象定义和依赖关系。在Spring中，可以使用XML文件或注解来配置对象和依赖关系。Spring通过解析配置文件或注解信息，将其转换为内部的对象定义和依赖关系（BeanDefinition）放到容器（BeanFactory）中。对象定义包括对象的类型、属性、构造函数等信息，依赖关系包括对象之间的依赖关系、依赖注入方式等信息。</p></li><li><p>实例化bean对象：Spring会根据对象定义的类型和构造函数信息，使用反射机制来创建对象。</p></li><li><p>设置属性：实例化后的仍然是一个原生的状态，并没有进行依赖注入。这一步Spring根据BeanDefinition中的信息进行属性填充，依赖注入。</p></li><li><p>调用Aware接口：Spring会检测该对象是否实现了xxxAware接口，如果有会在这里执行完成。Aware主要是能获取到Spring容器中的一些资源，然后可以供后续步骤，例如初始化阶段使用。</p></li><li><p>BeanPostProcessor前置处理：postProcessBeforeInitialization方法。上述几个步骤后，bean对象已经被正确构造，但如果想要对象被初始化前再进行一些自定义的处理，就可以通过BeanPostProcessor接口的该方法来实现。</p></li><li><p>初始化阶段：该阶段Spring首先会看是否实现了InitializingBean接口的afterPropertiesSet方法以及是否有自定义的init - method等，如果有会进行调用执行。</p></li><li><p>BeanPostProcessor后置处理：postProcessAfterInitialization方法。当前正在初始化的bean对象会被传递进来，我们就可以对这个bean作任何处理，与前面前置处理相对的，这个函数会在InitializationBean完成后执行，因此为后置处理。</p></li><li><p>bean初始化完成可以被使用了。</p></li></ul><p>总的来说，Spring IOC的实现原理是通过反射机制动态创建对象，依赖注入，对象初始化。通过解耦对象之间的依赖关系，使得应用程序更加灵活、可维护、可扩展。&#x20;</p><h3 id="3-IOC和DI有什么关系"><a href="#3-IOC和DI有什么关系" class="headerlink" title="3.IOC和DI有什么关系"></a>3.IOC和DI有什么关系</h3><p><img src="2025-01-09-Spring基础面试题/image3.png" alt=""></p><h3 id="4-谈谈你对Spring的理解"><a href="#4-谈谈你对Spring的理解" class="headerlink" title="4. 谈谈你对Spring的理解"></a>4. 谈谈你对Spring的理解</h3><p><img src="2025-01-09-Spring基础面试题/image4.png" alt=""></p><h3 id="5-Spring有哪些缺点"><a href="#5-Spring有哪些缺点" class="headerlink" title="5. Spring有哪些缺点"></a>5. Spring有哪些缺点</h3><p><img src="2025-01-09-Spring基础面试题/image5.png" alt=""></p><p><img src="2025-01-09-Spring基础面试题/image6.png" alt=""></p><h3 id="6-⭐️Spring-Ioc容器的加载过程"><a href="#6-⭐️Spring-Ioc容器的加载过程" class="headerlink" title="6. ⭐️Spring-Ioc容器的加载过程"></a>6. ⭐️Spring-Ioc容器的加载过程</h3><p>Spring的IOC容器工作的过程，其实可以划分为两个阶段：配置解析阶段和Bean的创建段。其中：</p><ul><li><p>配置解析阶段主要做的工作是加载和<strong>解析配置文件</strong>，将配置的bean解析成BeanDefinition。</p><ul><li><p>整个过程是：</p><ol><li><p>读取配置：通过BeanDefinitionReader读取配置文件或配置类。</p></li><li><p>解析配置信息：如ComponentScan、Bean配置等。</p></li><li><p>扫描类注解：根据ComponentScan扫描@Component、@Bean、@Configuration、@Import等注解…</p></li><li><p>将符合的bean注册为BeanDefinition。</p></li></ol></li></ul></li><li><p>Bean的创建过程主要做的工作是根据BeanDefinition创建Bean。</p><ul><li><p><strong>大概过程：</strong></p><ol><li><p>实例化Bean：容器根据配置文件中的Bean定义，实例化Bean对象。可以通过构造函数实例化、工厂方法实例化、静态工厂方法实例化等方式来创建Bean对象。</p></li><li><p>注入Bean属性：容器会为实例化的Bean对象设置属性，可以通过setter方法注入属性值，也可以通过构造函数注入属性值。</p></li><li><p>处理依赖关系：容器会处理Bean之间的依赖关系，将依赖的Bean注入到需要的地方。</p></li><li><p>执行初始化方法：容器会调用Bean的初始化方法，可以通过实现InitializingBean接口或在配置文件中指定初始化方法来定义Bean的初始化逻辑。</p></li><li><p>注册Bean：容器会将实例化、属性设置和初始化完成的Bean对象注册到容器中，以便后续的使用和管理。</p></li><li><p>完成加载：容器完成所有Bean的加载和初始化后，即完成了IOC容器的加载过程。此时，可以通过容器调用getBean获取Bean对象。&#x20;</p></li></ol></li></ul></li></ul><h2 id="二、Spring-Bean"><a href="#二、Spring-Bean" class="headerlink" title="二、Spring Bean"></a>二、Spring Bean</h2><h3 id="1-什么是Bean"><a href="#1-什么是Bean" class="headerlink" title="1.什么是Bean"></a>1.什么是Bean</h3><p><img src="2025-01-09-Spring基础面试题/image8.png" alt=""></p><h3 id="2-⭐️Bean生命周期"><a href="#2-⭐️Bean生命周期" class="headerlink" title="2.⭐️Bean生命周期"></a>2.⭐️Bean生命周期</h3><p><img src="2025-01-09-Spring基础面试题/image9.png" alt=""></p><p><img src="2025-01-09-Spring基础面试题/image10.png" alt=""></p><p><img src="2025-01-09-Spring基础面试题/image11.png" alt=""></p><h3 id="3-什么是FactoryBean？"><a href="#3-什么是FactoryBean？" class="headerlink" title="3. 什么是FactoryBean？"></a>3. 什么是FactoryBean？</h3><p><img src="2025-01-09-Spring基础面试题/image12.png" alt=""></p><h3 id="4-⭐️BeanFactory-和-FactoryBean区别是什么？"><a href="#4-⭐️BeanFactory-和-FactoryBean区别是什么？" class="headerlink" title="4. ⭐️BeanFactory 和 FactoryBean区别是什么？"></a>4. ⭐️BeanFactory 和 FactoryBean区别是什么？</h3><p><img src="2025-01-09-Spring基础面试题/image13.png" alt=""></p><h3 id="5-⭐️BeanFactory-和-ApplicationContext有什么区别？"><a href="#5-⭐️BeanFactory-和-ApplicationContext有什么区别？" class="headerlink" title="5.⭐️BeanFactory 和 ApplicationContext有什么区别？"></a>5.⭐️BeanFactory 和 ApplicationContext有什么区别？</h3><p><img src="2025-01-09-Spring基础面试题/image14.png" alt=""></p><h3 id="6-Bean的作用域有哪些？"><a href="#6-Bean的作用域有哪些？" class="headerlink" title="6. Bean的作用域有哪些？"></a>6. Bean的作用域有哪些？</h3><p><img src="2025-01-09-Spring基础面试题/image15.png" alt=""></p><hr><h3 id="7-⭐️Bean-是线程安全的吗？"><a href="#7-⭐️Bean-是线程安全的吗？" class="headerlink" title="7. ⭐️Bean 是线程安全的吗？"></a>7. ⭐️Bean 是线程安全的吗？</h3><p><img src="2025-01-09-Spring基础面试题/image16.png" alt=""></p><h3 id="8-将一个类声明为-Spring-的-Bean-的注解有哪些？"><a href="#8-将一个类声明为-Spring-的-Bean-的注解有哪些？" class="headerlink" title="8. 将一个类声明为 Spring 的 Bean 的注解有哪些？"></a>8. 将一个类声明为 Spring 的 Bean 的注解有哪些？</h3><p><img src="2025-01-09-Spring基础面试题/image17.png" alt=""></p><h3 id="9-注入Bean-的注解有哪些？"><a href="#9-注入Bean-的注解有哪些？" class="headerlink" title="9. 注入Bean 的注解有哪些？"></a>9. 注入Bean 的注解有哪些？</h3><p><img src="2025-01-09-Spring基础面试题/image18.png" alt=""></p><hr><h3 id="10-Autowired底层的实现原理是什么？"><a href="#10-Autowired底层的实现原理是什么？" class="headerlink" title="10. @Autowired底层的实现原理是什么？"></a>10. @Autowired底层的实现原理是什么？</h3><p><img src="2025-01-09-Spring基础面试题/image19.png" alt=""></p><h3 id="11-⭐️AutoWired-与-Resource-区别"><a href="#11-⭐️AutoWired-与-Resource-区别" class="headerlink" title="11.⭐️AutoWired 与 Resource 区别"></a>11.⭐️AutoWired 与 Resource 区别</h3><p><img src="2025-01-09-Spring基础面试题/image20.png" alt=""></p><h3 id="12-❓什么是三级缓存？"><a href="#12-❓什么是三级缓存？" class="headerlink" title="12. ❓什么是三级缓存？"></a>12. ❓什么是三级缓存？</h3><p><img src="2025-01-09-Spring基础面试题/image21.png" alt=""></p><hr><h3 id="13-⭐️-为什么需要三级缓存？"><a href="#13-⭐️-为什么需要三级缓存？" class="headerlink" title="13.⭐️ 为什么需要三级缓存？"></a>13.⭐️ 为什么需要三级缓存？</h3><p><img src="2025-01-09-Spring基础面试题/image22.png" alt=""></p><h3 id="14-❓Spring如何解决循环依赖问题？"><a href="#14-❓Spring如何解决循环依赖问题？" class="headerlink" title="14. ❓Spring如何解决循环依赖问题？"></a>14. ❓Spring如何解决循环依赖问题？</h3><p><img src="2025-01-09-Spring基础面试题/image23.png" alt=""></p><h3 id="15-⭐️Bean有哪几种配置方式？"><a href="#15-⭐️Bean有哪几种配置方式？" class="headerlink" title="15.⭐️Bean有哪几种配置方式？"></a>15.⭐️Bean有哪几种配置方式？</h3><p><img src="2025-01-09-Spring基础面试题/image24.png" alt=""></p><hr><h2 id="三、Spring-AOP"><a href="#三、Spring-AOP" class="headerlink" title="三、Spring AOP"></a>三、Spring AOP</h2><h3 id="1-⭐️什么是AOP"><a href="#1-⭐️什么是AOP" class="headerlink" title="1.⭐️什么是AOP?"></a>1.⭐️什么是AOP?</h3><p><img src="2025-01-09-Spring基础面试题/image25.png" alt=""></p><p><img src="2025-01-09-Spring基础面试题/image26.png" alt=""></p><hr><h3 id="2-谈谈你对AOP的理解"><a href="#2-谈谈你对AOP的理解" class="headerlink" title="2.谈谈你对AOP的理解"></a>2.谈谈你对AOP的理解</h3><p><img src="2025-01-09-Spring基础面试题/image27.png" alt=""></p><p><img src="2025-01-09-Spring基础面试题/image28.png" alt=""></p><h3 id="3-AOP有哪些实现方式"><a href="#3-AOP有哪些实现方式" class="headerlink" title="3.AOP有哪些实现方式"></a>3.AOP有哪些实现方式</h3><p><img src="2025-01-09-Spring基础面试题/image29.png" alt=""></p><h3 id="4-⭐️Spring-AOP-and-AspectJ-AOP-有什么区别？"><a href="#4-⭐️Spring-AOP-and-AspectJ-AOP-有什么区别？" class="headerlink" title="4. ⭐️Spring AOP and AspectJ AOP 有什么区别？"></a>4. ⭐️Spring AOP and AspectJ AOP 有什么区别？</h3><p><img src="2025-01-09-Spring基础面试题/image30.png" alt=""></p><p><img src="2025-01-09-Spring基础面试题/image31.png" alt=""></p><h3 id="5-Spring-AOP通知和执行顺序？"><a href="#5-Spring-AOP通知和执行顺序？" class="headerlink" title="5. Spring-AOP通知和执行顺序？"></a>5. Spring-AOP通知和执行顺序？</h3><p><img src="2025-01-09-Spring基础面试题/image32.png" alt=""></p><hr><h3 id="6-⭐️⭐️⭐️JDK动态代理和CGLIB动态代理的区别"><a href="#6-⭐️⭐️⭐️JDK动态代理和CGLIB动态代理的区别" class="headerlink" title="6.⭐️⭐️⭐️JDK动态代理和CGLIB动态代理的区别"></a>6.⭐️⭐️⭐️JDK动态代理和CGLIB动态代理的区别</h3><p><img src="2025-01-09-Spring基础面试题/image33.png" alt=""></p><p><img src="2025-01-09-Spring基础面试题/image34.png" alt=""></p><h3 id="7-⭐️什么情况下AOP会失效，怎么解决？"><a href="#7-⭐️什么情况下AOP会失效，怎么解决？" class="headerlink" title="7. ⭐️什么情况下AOP会失效，怎么解决？"></a>7. ⭐️什么情况下AOP会失效，怎么解决？</h3><p><img src="2025-01-09-Spring基础面试题/image35.png" alt=""></p><hr><h2 id="四、Spring注解"><a href="#四、Spring注解" class="headerlink" title="四、Spring注解"></a>四、Spring注解</h2><h3 id="1-Configuration和-Component有什么区别？"><a href="#1-Configuration和-Component有什么区别？" class="headerlink" title="1. @Configuration和@Component有什么区别？"></a>1. @Configuration和@Component有什么区别？</h3><p><img src="2025-01-09-Spring基础面试题/image36.png" alt=""></p><h3 id="2-⭐️-Component，-Controller，-Repository，-Service-有何区别？"><a href="#2-⭐️-Component，-Controller，-Repository，-Service-有何区别？" class="headerlink" title="2. ⭐️@Component， @Controller， @Repository， @Service 有何区别？"></a>2. ⭐️@Component， @Controller， @Repository， @Service 有何区别？</h3><p><img src="2025-01-09-Spring基础面试题/image37.png" alt=""></p><h3 id="3-⭐️-Component-和-Bean-有什么区别？"><a href="#3-⭐️-Component-和-Bean-有什么区别？" class="headerlink" title="3. ⭐️@Component 和 @Bean 有什么区别？"></a>3. ⭐️@Component 和 @Bean 有什么区别？</h3><p><img src="2025-01-09-Spring基础面试题/image38.png" alt=""></p><hr><h3 id="4-Required-注解有什么用？"><a href="#4-Required-注解有什么用？" class="headerlink" title="4. @Required 注解有什么用？"></a>4. @Required 注解有什么用？</h3><p><img src="2025-01-09-Spring基础面试题/image39.png" alt=""></p><h3 id="5-⭐️⭐️⭐️-Qualifier-注解有什么用？"><a href="#5-⭐️⭐️⭐️-Qualifier-注解有什么用？" class="headerlink" title="5. ⭐️⭐️⭐️@Qualifier 注解有什么用？"></a>5. ⭐️⭐️⭐️@Qualifier 注解有什么用？</h3><p><img src="2025-01-09-Spring基础面试题/image40.png" alt=""></p><hr><h3 id="6-RequestMapping-注解有什么用？"><a href="#6-RequestMapping-注解有什么用？" class="headerlink" title="6. @RequestMapping 注解有什么用？"></a>6. @RequestMapping 注解有什么用？</h3><p><img src="2025-01-09-Spring基础面试题/image41.png" alt=""></p><h3 id="7-RequestMapping-和-GetMapping-注解的不同之处在哪里？"><a href="#7-RequestMapping-和-GetMapping-注解的不同之处在哪里？" class="headerlink" title="7. @RequestMapping 和 @GetMapping 注解的不同之处在哪里？"></a>7. @RequestMapping 和 @GetMapping 注解的不同之处在哪里？</h3><p><img src="2025-01-09-Spring基础面试题/image42.png" alt=""></p><h3 id="8-Controller-注解有什么用"><a href="#8-Controller-注解有什么用" class="headerlink" title="8. @Controller 注解有什么用"></a>8. @Controller 注解有什么用</h3><p><img src="2025-01-09-Spring基础面试题/image43.png" alt=""></p><h3 id="9-⭐️-RestController-和-Controller-有什么区别？"><a href="#9-⭐️-RestController-和-Controller-有什么区别？" class="headerlink" title="9. ⭐️@RestController 和 @Controller 有什么区别？"></a>9. ⭐️@RestController 和 @Controller 有什么区别？</h3><p><img src="2025-01-09-Spring基础面试题/image44.png" alt=""></p><p><img src="2025-01-09-Spring基础面试题/image45.png" alt=""></p><p><img src="2025-01-09-Spring基础面试题/image46.png" alt=""></p><p><img src="2025-01-09-Spring基础面试题/image47.png" alt=""></p><h3 id="10-⭐️-RequestParam-和-PathVariable-两个注解的区别？"><a href="#10-⭐️-RequestParam-和-PathVariable-两个注解的区别？" class="headerlink" title="10. ⭐️@RequestParam 和 @PathVariable 两个注解的区别？"></a>10. ⭐️@RequestParam 和 @PathVariable 两个注解的区别？</h3><p><img src="2025-01-09-Spring基础面试题/image48.png" alt=""></p><hr><h2 id="五、Spring事务"><a href="#五、Spring事务" class="headerlink" title="五、Spring事务"></a>五、Spring事务</h2><h3 id="1-⭐️说一下-spring-的事务隔离级别？"><a href="#1-⭐️说一下-spring-的事务隔离级别？" class="headerlink" title="1. ⭐️说一下 spring 的事务隔离级别？"></a>1. ⭐️说一下 spring 的事务隔离级别？</h3><p><img src="2025-01-09-Spring基础面试题/image49.png" alt=""></p><p><img src="2025-01-09-Spring基础面试题/image50.png" alt=""></p><h3 id="2-⭐️-说一下Spring的事务传播行为"><a href="#2-⭐️-说一下Spring的事务传播行为" class="headerlink" title="2.⭐️ 说一下Spring的事务传播行为"></a>2.⭐️ 说一下Spring的事务传播行为</h3><p><a href="https://mp.weixin.qq.com/s/tRFoa76ElLFIrZRTwHIUMQ">https://mp.weixin.qq.com/s/tRFoa76ElLFIrZRTwHIUMQ</a></p><p><img src="2025-01-09-Spring基础面试题/image51.png" alt=""></p><hr><h3 id="3-⭐️Spring事件监听的核心机制是什么？"><a href="#3-⭐️Spring事件监听的核心机制是什么？" class="headerlink" title="3. ⭐️Spring事件监听的核心机制是什么？"></a>3. ⭐️Spring事件监听的核心机制是什么？</h3><p>Spring事件监听的核心机制围绕观察者模式展开：</p><p>观察者模式：它允许一个对象（称为主题或被观察者）维护一组依赖于它的对象（称为观察者），并在主题状态发生变化时通知观察者。</p><p>它包含三个核心：</p><ol><li><p><strong>事件：</strong>&#x4E8B;件是观察者模式中的主题状态变化的具体表示，它封装了事件发生时的信息。在Spring中，事件通常是普通的Java对象，用于传递数据或上下文信息。</p></li><li><p><strong>事件发布者：</strong>&#x5728;Spring中，事件发布者充当主题的角色，负责触发并发布事件。它通常实现了ApplicationEventPublisher接口或使用注解@Autowired来获得事件发布功能。</p></li><li><p><strong>事件监听器</strong>：事件监听器充当观察者的角色，负责监听并响应事件的发生。它实现了ApplicationListener接口，通过onApplicationEvent()方法来处理事件。</p></li></ol><p>总之，Spring事件监听机制的核心机制是观察者模式，通过事件、事件发布者和事件监听器的协作，实现了松耦合的组件通信，使得应用程序更加灵活和可维护。&#x20;</p><h3 id="4-⭐️Spring事务的失效原因？"><a href="#4-⭐️Spring事务的失效原因？" class="headerlink" title="4. ⭐️Spring事务的失效原因？"></a>4. ⭐️Spring事务的失效原因？</h3><ol><li><p><strong>自身调用问题：</strong>&#x73;pring是通过aop的方式，对需要spring管理事务的bean生成了代理对象，然后通过代理对象拦截了目标方法的执行，在方法前后添加了事务的功能，所以必须通过代理对象调用目标方法的时候，事务才会起效。</p></li><li><p><strong>非public方法导致的事务时效：</strong>&#x5F53;事务方法被标记为非public时，Spring的事务代理通常是通过Java动态代理或CGLIB动态代理生成的，这些代理要求目标方法是公开可访问的public。</p></li><li><p><strong>方法本身自己捕捉了异常</strong>，这样即使出现异常也不会触发事务的回滚，所以要进行抛出，而不是自己捕捉。</p></li><li><p>造成事务回滚的异常一般是<strong>Error类异常或者是运行时异常</strong>，如果抛出的是检查型异常的话，那么不会造成事务回滚，所以我们可以将rollbackfor配置为Exception。</p></li><li><p>开启事务的bean<strong>没有交给spring容器管理</strong>。</p></li><li><p><strong>数据库不支持事务。&#x20;</strong></p></li></ol><h3 id="5-Spring-事务实现方式有哪些？"><a href="#5-Spring-事务实现方式有哪些？" class="headerlink" title="5. Spring 事务实现方式有哪些？"></a>5. Spring 事务实现方式有哪些？</h3><p><img src="2025-01-09-Spring基础面试题/image54.png" alt=""></p><h3 id="6-声明式事务实现原理了解吗？"><a href="#6-声明式事务实现原理了解吗？" class="headerlink" title="6. 声明式事务实现原理了解吗？"></a>6. 声明式事务实现原理了解吗？</h3><p><img src="2025-01-09-Spring基础面试题/image55.png" alt=""></p><h3 id="7-⭐️-protected-和-private-加事务会生效吗？"><a href="#7-⭐️-protected-和-private-加事务会生效吗？" class="headerlink" title="7.⭐️ protected 和 private 加事务会生效吗？"></a>7.⭐️ protected 和 private 加事务会生效吗？</h3><p><img src="2025-01-09-Spring基础面试题/image56.png" alt=""></p><h3 id="8-Spring-声明式事务无效可能的原因有哪些？"><a href="#8-Spring-声明式事务无效可能的原因有哪些？" class="headerlink" title="8. Spring 声明式事务无效可能的原因有哪些？"></a>8. Spring 声明式事务无效可能的原因有哪些？</h3><p><img src="2025-01-09-Spring基础面试题/image57.png" alt=""></p><hr><h2 id="六、Spring-MVC"><a href="#六、Spring-MVC" class="headerlink" title="六、Spring MVC"></a>六、Spring MVC</h2><h3 id="1-MVC是什么？MVC设计模式的好处有哪些"><a href="#1-MVC是什么？MVC设计模式的好处有哪些" class="headerlink" title="1. MVC是什么？MVC设计模式的好处有哪些"></a>1. MVC是什么？MVC设计模式的好处有哪些</h3><p><img src="2025-01-09-Spring基础面试题/image58.png" alt=""></p><p><img src="2025-01-09-Spring基础面试题/image59.png" alt=""></p><hr><h3 id="2-SpringMVC有哪些核心组件？"><a href="#2-SpringMVC有哪些核心组件？" class="headerlink" title="2. SpringMVC有哪些核心组件？"></a>2. SpringMVC有哪些核心组件？</h3><p><img src="2025-01-09-Spring基础面试题/image60.png" alt=""></p><h3 id="3-⭐️SpringMVC的执行流程了解吗？"><a href="#3-⭐️SpringMVC的执行流程了解吗？" class="headerlink" title="3. ⭐️SpringMVC的执行流程了解吗？"></a>3. ⭐️SpringMVC的执行流程了解吗？</h3><p><img src="2025-01-09-Spring基础面试题/image61.png" alt=""></p><p><img src="2025-01-09-Spring基础面试题/image62.png" alt=""></p><h3 id="4-Spring-MVC-拦截器是什么？"><a href="#4-Spring-MVC-拦截器是什么？" class="headerlink" title="4. Spring MVC 拦截器是什么？"></a>4. Spring MVC 拦截器是什么？</h3><p><img src="2025-01-09-Spring基础面试题/image63.png" alt=""></p><h3 id="5-拦截器的使用场景有哪些？"><a href="#5-拦截器的使用场景有哪些？" class="headerlink" title="5. 拦截器的使用场景有哪些？"></a>5. 拦截器的使用场景有哪些？</h3><p><img src="2025-01-09-Spring基础面试题/image64.png" alt=""></p><hr><h3 id="6-⭐️如何实现过滤器？"><a href="#6-⭐️如何实现过滤器？" class="headerlink" title="6. ⭐️如何实现过滤器？"></a>6. ⭐️如何实现过滤器？</h3><p><img src="2025-01-09-Spring基础面试题/image65.png" alt=""></p><p><img src="2025-01-09-Spring基础面试题/image66.png" alt=""></p><hr><h3 id="7-⭐️SpringMVC的拦截器和过滤器有什么区别？执行顺序？"><a href="#7-⭐️SpringMVC的拦截器和过滤器有什么区别？执行顺序？" class="headerlink" title="7. ⭐️SpringMVC的拦截器和过滤器有什么区别？执行顺序？"></a>7. ⭐️SpringMVC的拦截器和过滤器有什么区别？执行顺序？</h3><p>拦截器和过滤器的区别主要体现在以下5点：</p><ol><li><p>出身不同：过滤器来自于Servlet，而拦截器来自于Spring框架；</p></li><li><p>触发时机不同：请求的执行顺序是：请求进入容器 &gt; 进入过滤器 &gt; 进入Servlet &gt; 进入拦截器 &gt; 执行控制器（Controller）。所以过滤器和拦截器的执行时机，是过滤器先执行，然后才会执行拦截器，最后才会进入真正要调用的方法；</p></li><li><p>底层实现不同：过滤器是基于方法回调实现的，拦截器是基于动态代理（底层是反射）实现的；</p></li><li><p>支持的项目类型不同：过滤器是Servlet规范中定义的，所以过滤器要依赖Servlet容器，它只能用在Web项目中；而拦截器是Spring中的一个组件，因此拦截器既可以用在Web项目中，同时还可以用在Application或Swing程序中；&#x20;</p></li><li><p>使用的场景不同：因为拦截器更接近业务系统，所以拦截器主要用来实现项目中的业务判断，比如：登录判断、权限判断、日志记录等业务；而过滤器通常是用来实现通用功能过滤的，比如：敏感词过滤、字符集编码设置、响应数据压缩等功能 。&#x20;</p></li></ol><h3 id="8-⭐️Spring-MVC异常处理是什么？"><a href="#8-⭐️Spring-MVC异常处理是什么？" class="headerlink" title="8. ⭐️Spring MVC异常处理是什么？"></a>8. ⭐️Spring MVC异常处理是什么？</h3><p><img src="2025-01-09-Spring基础面试题/image68.png" alt=""></p><hr><h1 id="2-SpringBoot面试题"><a href="#2-SpringBoot面试题" class="headerlink" title="2.SpringBoot面试题"></a>2.SpringBoot面试题</h1><h3 id="1-SpringBoot可以同时处理多少请求"><a href="#1-SpringBoot可以同时处理多少请求" class="headerlink" title="1. SpringBoot可以同时处理多少请求"></a>1. SpringBoot可以同时处理多少请求</h3><p>SpringBoot默认的内嵌容器是Tomcat，也就是我们的程序实际上是运行在Tomcat里的。所以与其说SpringBoot可以处理多少请求，到不如说Tomcat可以处理多少请求。</p><p>在SpringBoot中处理请求数量相关的参数有四个：</p><ul><li><p>server.tomcat.threads.min - spare：最少的工作线程数，默认大小是10。该参数相当于长期工，如果并发请求的数量达到不到10，就会依次使用这几个线程去处理请求。</p></li><li><p>server.tomcat.threads.max：最多的工作线程数，默认大小是200。该参数相当于临时工，如果并发请求的数量在10到200之间，就会使用这些临时工线程进行处理。</p></li><li><p>server.tomcat.max - connections：最大连接数，默认大小是8192。表示Tomcat可以处理的最大请求数量，超过8192的请求就会被放入到等待队列。</p></li><li><p>server.tomcat.accept - count：等待队列的长度，默认大小是100。</p></li></ul><p>如果把Tomcat比作一家饭店的话，那么一个请求其实就相当于一位客人。min - spare就是厨师(长期工)；max是厨师总数(长期工+临时工)；max - connections就是饭店里的座位数量；accept - count是门口小板凳的数量。来的客人优先坐到饭店里面，然后厨师开始忙活，如果长期工可以干的，就让长期工干，如果长期工干不完，就再让临时工干。图中的厨师一共15人，饭店里有30个座位，也就是说，如果现在来了20个客人，那么就会有5个人先在饭店里等着。如果现在来了35个人，饭店里坐不下，就会让5个人先到门口坐一下。如果来了50个人，那么饭店座位+门口小板凳一共40个，所以就会有10人离开。</p><p>也就是说，SpringBoot同时所能处理的最大请求数量是max - connections+accept - count，超过该数量的请求直接就会被丢掉。&#x20;</p><h3 id="2-❓SpringBoot启动原理"><a href="#2-❓SpringBoot启动原理" class="headerlink" title="2.❓SpringBoot启动原理"></a>2.❓SpringBoot启动原理</h3><p><img src="2025-01-09-Spring基础面试题/image70.jpeg" alt=""></p><p><img src="2025-01-09-Spring基础面试题/image71.png" alt=""></p><hr><h3 id="3-⭐️为什么SpringBoot的jar可以直接运行？"><a href="#3-⭐️为什么SpringBoot的jar可以直接运行？" class="headerlink" title="3. ⭐️为什么SpringBoot的jar可以直接运行？"></a>3. ⭐️为什么SpringBoot的jar可以直接运行？</h3><p><img src="2025-01-09-Spring基础面试题/image72.png" alt=""></p><h3 id="4-⭐️Spring-Boot为什么默认使用CGLIB"><a href="#4-⭐️Spring-Boot为什么默认使用CGLIB" class="headerlink" title="4. ⭐️Spring Boot为什么默认使用CGLIB"></a>4. ⭐️Spring Boot为什么默认使用CGLIB</h3><p><img src="2025-01-09-Spring基础面试题/image73.png" alt=""></p><h3 id="5-⭐️Spring与Spring-Boot的区别？"><a href="#5-⭐️Spring与Spring-Boot的区别？" class="headerlink" title="5. ⭐️Spring与Spring Boot的区别？"></a>5. ⭐️Spring与Spring Boot的区别？</h3><p><img src="2025-01-09-Spring基础面试题/image74.png" alt=""></p><hr><h3 id="6-⭐️Spring、-Spring-MVC和SpringBoot有什么区别？"><a href="#6-⭐️Spring、-Spring-MVC和SpringBoot有什么区别？" class="headerlink" title="6. ⭐️Spring、 Spring MVC和SpringBoot有什么区别？"></a>6. ⭐️Spring、 Spring MVC和SpringBoot有什么区别？</h3><p><img src="2025-01-09-Spring基础面试题/image75.png" alt=""></p><h3 id="7-项目怎么用SpringBoot的？"><a href="#7-项目怎么用SpringBoot的？" class="headerlink" title="7. 项目怎么用SpringBoot的？"></a>7. 项目怎么用SpringBoot的？</h3><p><img src="2025-01-09-Spring基础面试题/image76.png" alt=""></p><h3 id="8-运行-Spring-Boot-有哪几种方式？"><a href="#8-运行-Spring-Boot-有哪几种方式？" class="headerlink" title="8. 运行 Spring Boot 有哪几种方式？"></a>8. 运行 Spring Boot 有哪几种方式？</h3><p><img src="2025-01-09-Spring基础面试题/image77.png" alt=""></p><hr><h3 id="9-⭐️-Spring-Boot-自动装配是什么？"><a href="#9-⭐️-Spring-Boot-自动装配是什么？" class="headerlink" title="9.⭐️ Spring Boot 自动装配是什么？"></a>9.⭐️ Spring Boot 自动装配是什么？</h3><p><img src="2025-01-09-Spring基础面试题/image78.png" alt=""></p><h3 id="10-⭐️SpringBoot-自动化配置原理是什么？"><a href="#10-⭐️SpringBoot-自动化配置原理是什么？" class="headerlink" title="10. ⭐️SpringBoot 自动化配置原理是什么？"></a>10. ⭐️SpringBoot 自动化配置原理是什么？</h3><p><img src="2025-01-09-Spring基础面试题/image79.png" alt=""></p><p><img src="2025-01-09-Spring基础面试题/image80.png" alt=""></p><h3 id="11-⭐️Spring-Boot-有几种方式读取配置文件？"><a href="#11-⭐️Spring-Boot-有几种方式读取配置文件？" class="headerlink" title="11. ⭐️Spring Boot 有几种方式读取配置文件？"></a>11. ⭐️Spring Boot 有几种方式读取配置文件？</h3><p><img src="2025-01-09-Spring基础面试题/image81.png" alt=""></p><h3 id="12-Spring-Boot-配置文件的加载顺序？"><a href="#12-Spring-Boot-配置文件的加载顺序？" class="headerlink" title="12. Spring Boot 配置文件的加载顺序？"></a>12. Spring Boot 配置文件的加载顺序？</h3><p><img src="2025-01-09-Spring基础面试题/image82.png" alt=""></p><p><img src="2025-01-09-Spring基础面试题/image83.png" alt=""></p><hr><h3 id="13-⭐️bootstrap-properties-和-application-，properties-有何区别？"><a href="#13-⭐️bootstrap-properties-和-application-，properties-有何区别？" class="headerlink" title="13. ⭐️bootstrap.properties 和 application.，properties 有何区别？"></a>13. ⭐️bootstrap.properties 和 application.，properties 有何区别？</h3><p><img src="2025-01-09-Spring基础面试题/image84.png" alt=""></p><p><img src="2025-01-09-Spring基础面试题/image85.png" alt=""></p><h3 id="14-Spring-Boot-Actuator是什么？"><a href="#14-Spring-Boot-Actuator是什么？" class="headerlink" title="14. Spring Boot Actuator是什么？"></a>14. Spring Boot Actuator是什么？</h3><p><strong>Spring Boot Actuator</strong>是Spring Boot提供的一个用于<strong>监控和管理应用程序</strong>的模块。包括不限于健康检查、日志监控、指标收集、审计功能、报警功能等。开发人员可以通过这些监控及时发现问题并解决。</p><p>默认情况下，Spring Boot Actuator已经集成在Spring Boot中，只需要在项目中添加依赖并配置一些参数即可使用。&#x20;</p><h3 id="15-Spring-Boot-项目如何热部署？"><a href="#15-Spring-Boot-项目如何热部署？" class="headerlink" title="15. Spring Boot 项目如何热部署？"></a>15. Spring Boot 项目如何热部署？</h3><p><img src="2025-01-09-Spring基础面试题/image87.png" alt=""></p><h3 id="16-⭐️Spring-Boot-中的-starter-是什么？"><a href="#16-⭐️Spring-Boot-中的-starter-是什么？" class="headerlink" title="16. ⭐️Spring Boot 中的 starter 是什么？"></a>16. ⭐️Spring Boot 中的 starter 是什么？</h3><p><img src="2025-01-09-Spring基础面试题/image88.png" alt=""></p><h3 id="17-Spring-Boot-有哪些-starter-？"><a href="#17-Spring-Boot-有哪些-starter-？" class="headerlink" title="17. Spring Boot 有哪些 starter ？"></a>17. Spring Boot 有哪些 starter ？</h3><p><img src="2025-01-09-Spring基础面试题/image89.png" alt=""></p><h3 id="18-Spring-Boot-打包成的jar-和普通的jar-有什么区别？"><a href="#18-Spring-Boot-打包成的jar-和普通的jar-有什么区别？" class="headerlink" title="18. Spring Boot 打包成的jar 和普通的jar 有什么区别？"></a>18. Spring Boot 打包成的jar 和普通的jar 有什么区别？</h3><p>Spring  boot打包成的jar包可执行但是不能引用。</p><p><strong>SpringBoot如何实现打包</strong></p><ul><li><p>进入项目目录在控制台输入mvn clean package，clean是清空已存在的项目包，package进行打包。</p></li><li><p>或者点击左边选项栏中的Maven，先点击clean再点击package。&#x20;</p></li></ul><p>Spring Boot项目最终打包成的jar是可执行jar，这种jar可以直接通过java -jar xxx.jar命令来运行，这种jar不可以作为普通的jar被其他项目依赖，即使依赖了也无法使用其中的类。</p><p>Spring Boot的jar无法被其他项目依赖，主要还是他和普通jar的结构不同。普通的jar包，解压后直接就是包名，包里就是我们的代码，而Spring Boot打包成的可执行jar解压后，在\BOOT - INF\classes目录下才是我们的代码，因此无法被直接引用。如果非要引用，可以在pom.xml文件中增加配置，将Spring Boot项目打包成两个jar，一个可执行，一个可引用。&#x20;</p><hr><h3 id="19-⭐️-SpringBoot-的核心注解是哪个？它主要由哪几个注解组成的？"><a href="#19-⭐️-SpringBoot-的核心注解是哪个？它主要由哪几个注解组成的？" class="headerlink" title="19.⭐️ SpringBoot 的核心注解是哪个？它主要由哪几个注解组成的？"></a>19.⭐️ SpringBoot 的核心注解是哪个？它主要由哪几个注解组成的？</h3><p><img src="2025-01-09-Spring基础面试题/image92.png" alt=""></p><h3 id="20-SpringBoot事务的使用"><a href="#20-SpringBoot事务的使用" class="headerlink" title="20. SpringBoot事务的使用"></a>20. SpringBoot事务的使用</h3><p><img src="2025-01-09-Spring基础面试题/image93.png" alt=""></p><h3 id="21-⭐️什么是-JavaConfig？"><a href="#21-⭐️什么是-JavaConfig？" class="headerlink" title="21. ⭐️什么是 JavaConfig？"></a>21. ⭐️什么是 JavaConfig？</h3><p>Spring JavaConfig 是Spring社区的产品，Spring 3.0引入了它，它提供了配置Spring IOC容器的纯Java方法，有助于避免使用XML配置。使用JavaConfig的优点在于：</p><ul><li><p>面向对象的配置。配置被定义为JavaConfig中的类，用户可利用Java面向对象功能，配置类可继承、重写@Bean方法等。</p></li><li><p>减少或消除XML配置。许多开发人员不希望在XML和Java间来回切换，JavaConfig提供纯Java配置Spring容器的方法，虽然仅用JavaConfig配置容器可行，但常将其与XML混合匹配。</p></li><li><p>类型安全和重构友好。Java 5.0对泛型的支持，使按类型检索bean，无需强制转换或基于字符串查找。</p></li></ul><p>常用的Java config：</p><ul><li><p>@Configuration：在类上标注此注解，表示该类是配置类。</p></li><li><p>@ComponentScan：在配置类上添加此注解，默认扫描该类所在包下所有配置类，相当于之前的\<context:component-scan>。</p></li><li><p>@Bean：bean的注入，相当于以前的&lt; bean id=”objectMapper” class=”org.codehaus.jackson.map.ObjectMapper” /&gt;。&#x20;</p></li><li><p>@EnableWebMvc：相当于xml的\<mvc:annotation-driven>。</p></li><li><p>@ImportResource：相当于xml的&lt; import resource=”applicationContext-cache.xml”&gt; 。&#x20;</p></li></ul><h3 id="22-什么是-YAML？"><a href="#22-什么是-YAML？" class="headerlink" title="22. 什么是 YAML？"></a>22. 什么是 YAML？</h3><p><img src="2025-01-09-Spring基础面试题/image95.png" alt=""></p><h3 id="23-⭐️什么是-Spring-Profiles？"><a href="#23-⭐️什么是-Spring-Profiles？" class="headerlink" title="23. ⭐️什么是 Spring Profiles？"></a>23. ⭐️什么是 Spring Profiles？</h3><p><img src="2025-01-09-Spring基础面试题/image96.png" alt=""></p><h3 id="24-SpringBoot多数据源拆分的思路"><a href="#24-SpringBoot多数据源拆分的思路" class="headerlink" title="24. SpringBoot多数据源拆分的思路"></a>24. SpringBoot多数据源拆分的思路</h3><p><img src="2025-01-09-Spring基础面试题/image97.png" alt=""></p><h3 id="25-保护-Spring-Boot-应用有哪些方法？"><a href="#25-保护-Spring-Boot-应用有哪些方法？" class="headerlink" title="25. 保护 Spring Boot 应用有哪些方法？"></a>25. 保护 Spring Boot 应用有哪些方法？</h3><p><img src="2025-01-09-Spring基础面试题/image98.png" alt=""></p><h3 id="26-⭐️Spring-Boot-中如何解决跨域问题？"><a href="#26-⭐️Spring-Boot-中如何解决跨域问题？" class="headerlink" title="26. ⭐️Spring Boot 中如何解决跨域问题？"></a>26. ⭐️Spring Boot 中如何解决跨域问题？</h3><p><img src="2025-01-09-Spring基础面试题/image99.png" alt=""></p><h3 id="27-Spring-Boot-中的监视器是什么？"><a href="#27-Spring-Boot-中的监视器是什么？" class="headerlink" title="27. Spring Boot 中的监视器是什么？"></a>27. Spring Boot 中的监视器是什么？</h3><p><img src="2025-01-09-Spring基础面试题/image100.png" alt=""></p><h3 id="28-✅如何使用-Spring-Boot-实现全局异常处理？"><a href="#28-✅如何使用-Spring-Boot-实现全局异常处理？" class="headerlink" title="28. ✅如何使用 Spring Boot 实现全局异常处理？"></a>28. ✅如何使用 Spring Boot 实现全局异常处理？</h3><p><strong>@ControllerAdvice + @ExceptionHandler</strong></p><p>在这种异常处理方式下，会给所有或者指定的Controller织入异常处理的逻辑（AOP），当Controller中的方法抛出异常的时候，由被@ExceptionHandler注解修饰的方法进行处理。&#x20;</p><h3 id="29-如何重新加载-Spring-Boot-上的更改，而无需重新启动服务器？Spring-Boot项目如何热部署？"><a href="#29-如何重新加载-Spring-Boot-上的更改，而无需重新启动服务器？Spring-Boot项目如何热部署？" class="headerlink" title="29. 如何重新加载 Spring Boot 上的更改，而无需重新启动服务器？Spring Boot项目如何热部署？"></a>29. 如何重新加载 Spring Boot 上的更改，而无需重新启动服务器？Spring Boot项目如何热部署？</h3><p><img src="2025-01-09-Spring基础面试题/image102.png" alt=""></p><h3 id="30您使用了哪些-starter-maven-依赖项？"><a href="#30您使用了哪些-starter-maven-依赖项？" class="headerlink" title="30您使用了哪些 starter maven 依赖项？"></a>30您使用了哪些 starter maven 依赖项？</h3><p><img src="2025-01-09-Spring基础面试题/image103.png" alt=""></p><hr><h1 id="3-Spring-Cloud面试题"><a href="#3-Spring-Cloud面试题" class="headerlink" title="3.Spring Cloud面试题"></a>3.Spring Cloud面试题</h1><h2 id="一、微服务概念"><a href="#一、微服务概念" class="headerlink" title="一、微服务概念"></a>一、微服务概念</h2><h3 id="1-什么是微服务？"><a href="#1-什么是微服务？" class="headerlink" title="1. 什么是微服务？"></a>1. 什么是微服务？</h3><p><img src="2025-01-09-Spring基础面试题/image104.png" alt=""></p><h3 id="2-⭐️微服务相较于传统的web项目有什么优势？"><a href="#2-⭐️微服务相较于传统的web项目有什么优势？" class="headerlink" title="2. ⭐️微服务相较于传统的web项目有什么优势？"></a>2. ⭐️微服务相较于传统的web项目有什么优势？</h3><p><img src="2025-01-09-Spring基础面试题/image105.png" alt=""></p><h3 id="3微服务的通讯方式有哪些？"><a href="#3微服务的通讯方式有哪些？" class="headerlink" title="3微服务的通讯方式有哪些？"></a>3微服务的通讯方式有哪些？</h3><p><img src="2025-01-09-Spring基础面试题/image106.png" alt=""></p><h3 id="4-⭐️分布式和微服务有什么区别？"><a href="#4-⭐️分布式和微服务有什么区别？" class="headerlink" title="4. ⭐️分布式和微服务有什么区别？"></a>4. ⭐️分布式和微服务有什么区别？</h3><p><img src="2025-01-09-Spring基础面试题/image107.png" alt=""></p><hr><h3 id="5-⭐️现在有哪些流行的微服务解决方案？"><a href="#5-⭐️现在有哪些流行的微服务解决方案？" class="headerlink" title="5. ⭐️现在有哪些流行的微服务解决方案？"></a>5. ⭐️现在有哪些流行的微服务解决方案？</h3><p><img src="2025-01-09-Spring基础面试题/image108.png" alt=""></p><hr><h3 id="6-说下微服务有哪些组件？"><a href="#6-说下微服务有哪些组件？" class="headerlink" title="6. 说下微服务有哪些组件？"></a>6. 说下微服务有哪些组件？</h3><p><img src="2025-01-09-Spring基础面试题/image109.png" alt=""></p><h3 id="7-⭐️-微服务架构如何运行的？"><a href="#7-⭐️-微服务架构如何运行的？" class="headerlink" title="7.⭐️ 微服务架构如何运行的？"></a>7.⭐️ 微服务架构如何运行的？</h3><p><img src="2025-01-09-Spring基础面试题/image110.png" alt=""></p><h2 id="二、Spring-Cloud"><a href="#二、Spring-Cloud" class="headerlink" title="二、Spring Cloud"></a>二、Spring Cloud</h2><h3 id="1-Spring-Cloud是什么？"><a href="#1-Spring-Cloud是什么？" class="headerlink" title="1. Spring Cloud是什么？"></a>1. Spring Cloud是什么？</h3><p><img src="2025-01-09-Spring基础面试题/image111.png" alt=""></p><h3 id="2-Spring-Boot-和-Spring-Cloud-的关系是什么？"><a href="#2-Spring-Boot-和-Spring-Cloud-的关系是什么？" class="headerlink" title="2. Spring Boot 和 Spring Cloud 的关系是什么？"></a>2. Spring Boot 和 Spring Cloud 的关系是什么？</h3><p><img src="2025-01-09-Spring基础面试题/image112.png" alt=""></p><h3 id="3-Spring-Cloud-由什么组成？"><a href="#3-Spring-Cloud-由什么组成？" class="headerlink" title="3. Spring Cloud 由什么组成？"></a>3. Spring Cloud 由什么组成？</h3><p><img src="2025-01-09-Spring基础面试题/image113.png" alt=""></p><h2 id="三、服务注册与发现"><a href="#三、服务注册与发现" class="headerlink" title="三、服务注册与发现"></a>三、服务注册与发现</h2><h3 id="1-SpringCloud可以选择哪些注册中心？"><a href="#1-SpringCloud可以选择哪些注册中心？" class="headerlink" title="1. SpringCloud可以选择哪些注册中心？"></a>1. SpringCloud可以选择哪些注册中心？</h3><p><img src="2025-01-09-Spring基础面试题/image114.png" alt=""></p><h3 id="2-⭐️Nacos、-Eureka、-Zookeeper注册中心的区别"><a href="#2-⭐️Nacos、-Eureka、-Zookeeper注册中心的区别" class="headerlink" title="2. ⭐️Nacos、 Eureka、 Zookeeper注册中心的区别"></a>2. ⭐️Nacos、 Eureka、 Zookeeper注册中心的区别</h3><p><img src="2025-01-09-Spring基础面试题/image115.png" alt=""></p><p><img src="2025-01-09-Spring基础面试题/image116.png" alt=""></p><h3 id="3-⭐️Nacos的服务注册表结构是怎样的？"><a href="#3-⭐️Nacos的服务注册表结构是怎样的？" class="headerlink" title="3. ⭐️Nacos的服务注册表结构是怎样的？"></a>3. ⭐️Nacos的服务注册表结构是怎样的？</h3><p><img src="2025-01-09-Spring基础面试题/image117.png" alt=""></p><h3 id="4-Nacos中的Namespace是什么？如何使用它来组织和管理微服务？"><a href="#4-Nacos中的Namespace是什么？如何使用它来组织和管理微服务？" class="headerlink" title="4. Nacos中的Namespace是什么？如何使用它来组织和管理微服务？"></a>4. Nacos中的Namespace是什么？如何使用它来组织和管理微服务？</h3><p>Nacos中的<strong>Namespace</strong>是用于隔离不同环境或应用之间的配置和服务信息的概念。通过使用Namespace，可以将不同的环境（例如开发、测试和生产）或不同的应用程序（例如Web应用和移动应用）的配置和服务信息分离开来，以避免冲突和错误。</p><p>在Nacos中，每个Namespace都有自己独立的配置和服务注册表。这意味着，如果您有多个应用程序需要使用Nacos，您可以将它们分别放置在不同的Namespace中。每个Namespace都有自己的命名空间ID，用于标识该Namespace。要使用Namespace，在Nacos客户端初始化时，您需要指定要使用的Namespace ID。</p><p>通过使用Namespace，您可以对不同Namespace下的服务进行分组和管理，例如可以使用Nacos提供的<strong>Group</strong>功能对同一Namespace下的服务进行分组，方便管理和查找。同时，使用Namespace还可以对不同环境下的配置进行隔离，避免不同环境之间的配置冲突。&#x20;</p><hr><h2 id="四、负载均衡"><a href="#四、负载均衡" class="headerlink" title="四、负载均衡"></a>四、负载均衡</h2><h3 id="1-在Spring-Cloud中，怎么实现服务的负载均衡？"><a href="#1-在Spring-Cloud中，怎么实现服务的负载均衡？" class="headerlink" title="1. 在Spring Cloud中，怎么实现服务的负载均衡？"></a>1. 在Spring Cloud中，怎么实现服务的负载均衡？</h3><p><img src="2025-01-09-Spring基础面试题/image119.png" alt=""></p><p><img src="2025-01-09-Spring基础面试题/image120.png" alt=""></p><h3 id="2-负载均衡有什么策略？"><a href="#2-负载均衡有什么策略？" class="headerlink" title="2. 负载均衡有什么策略？"></a>2. 负载均衡有什么策略？</h3><p><img src="2025-01-09-Spring基础面试题/image121.png" alt=""></p><hr><h2 id="五、⭐️远程调用"><a href="#五、⭐️远程调用" class="headerlink" title="五、⭐️远程调用"></a>五、⭐️远程调用</h2><h3 id="1-能说下HTTP和RPC的区别吗？"><a href="#1-能说下HTTP和RPC的区别吗？" class="headerlink" title="1. 能说下HTTP和RPC的区别吗？"></a>1. 能说下HTTP和RPC的区别吗？</h3><p>严格来讲，HTTP和不是一个层面的东西：</p><ul><li><p>HTTP（Hypertext Transfer Protocol）是一种应用层协议，主要强调的是网络通信；</p></li><li><p>RPC（Remote Procedure Call，远程过程调用）是一种用于分布式系统之间通信的协议，强调的是服务之间的远程调用。</p></li></ul><p>一些RPC框架比如gRPC，底层传输协议其实也是用的HTTP2，包括Dubbo3，也兼容了gRPC，使用了HTTP2作为传输层的一层协议。&#x20;</p><p><img src="2025-01-09-Spring基础面试题/image.png" alt=""></p><p>在微服务体系里：</p><ul><li><p>基于HTTP风格的远程调用通常使用框架如Feign来实现</p></li><li><p>基于RPC的远程调用通常使用框架如Dubbo来实现</p></li></ul><hr><h3 id="2-⭐️什么是Feign？"><a href="#2-⭐️什么是Feign？" class="headerlink" title="2. ⭐️什么是Feign？"></a>2. ⭐️什么是Feign？</h3><p><img src="2025-01-09-Spring基础面试题/image125.png" alt=""></p><h3 id="3-为什么Feign第一次调用耗时很长？"><a href="#3-为什么Feign第一次调用耗时很长？" class="headerlink" title="3. 为什么Feign第一次调用耗时很长？"></a>3. 为什么Feign第一次调用耗时很长？</h3><p><img src="2025-01-09-Spring基础面试题/image126.png" alt=""></p><h3 id="4-Fegin怎么做负载均衡？Ribbon？"><a href="#4-Fegin怎么做负载均衡？Ribbon？" class="headerlink" title="4. Fegin怎么做负载均衡？Ribbon？"></a>4. Fegin怎么做负载均衡？Ribbon？</h3><p><img src="2025-01-09-Spring基础面试题/image127.png" alt=""></p><h3 id="5-Feign和Dubbo的区别呢？"><a href="#5-Feign和Dubbo的区别呢？" class="headerlink" title="5. Feign和Dubbo的区别呢？"></a>5. Feign和Dubbo的区别呢？</h3><p><img src="2025-01-09-Spring基础面试题/image128.png" alt=""></p><h3 id="6-Feign与-OpenFeign的区别？"><a href="#6-Feign与-OpenFeign的区别？" class="headerlink" title="6. Feign与 OpenFeign的区别？"></a>6. Feign与 OpenFeign的区别？</h3><p><img src="2025-01-09-Spring基础面试题/image129.png" alt=""></p><h3 id="7-Ribbon和-Feign-调用服务的区别是什么？"><a href="#7-Ribbon和-Feign-调用服务的区别是什么？" class="headerlink" title="7. Ribbon和 Feign 调用服务的区别是什么？"></a>7. Ribbon和 Feign 调用服务的区别是什么？</h3><p><img src="2025-01-09-Spring基础面试题/image130.png" alt=""></p><hr><h2 id="六、服务容灾"><a href="#六、服务容灾" class="headerlink" title="六、服务容灾"></a>六、服务容灾</h2><h3 id="1-⭐️什么是断路器？为什么需要断路器"><a href="#1-⭐️什么是断路器？为什么需要断路器" class="headerlink" title="1. ⭐️什么是断路器？为什么需要断路器"></a>1. ⭐️什么是断路器？为什么需要断路器</h3><p><img src="2025-01-09-Spring基础面试题/image131.png" alt=""></p><h3 id="2-什么是Hystrix？"><a href="#2-什么是Hystrix？" class="headerlink" title="2. 什么是Hystrix？"></a>2. 什么是Hystrix？</h3><p><img src="2025-01-09-Spring基础面试题/image132.png" alt=""></p><h3 id="3-⭐️微服务雪崩效应是什么？"><a href="#3-⭐️微服务雪崩效应是什么？" class="headerlink" title="3. ⭐️微服务雪崩效应是什么？"></a>3. ⭐️微服务雪崩效应是什么？</h3><p><img src="2025-01-09-Spring基础面试题/image133.png" alt=""></p><h3 id="4-⭐️服务降级，你了解吗？"><a href="#4-⭐️服务降级，你了解吗？" class="headerlink" title="4. ⭐️服务降级，你了解吗？"></a>4. ⭐️服务降级，你了解吗？</h3><p><img src="2025-01-09-Spring基础面试题/image134.png" alt=""></p><h3 id="5-服务熔断，你了解吗？"><a href="#5-服务熔断，你了解吗？" class="headerlink" title="5. 服务熔断，你了解吗？"></a>5. 服务熔断，你了解吗？</h3><p><img src="2025-01-09-Spring基础面试题/image135.png" alt=""></p><hr><h3 id="6-服务限流，你了解吗？"><a href="#6-服务限流，你了解吗？" class="headerlink" title="6. 服务限流，你了解吗？"></a>6. 服务限流，你了解吗？</h3><p><img src="2025-01-09-Spring基础面试题/image136.png" alt=""></p><h3 id="7-什么是降级熔断？为什么要进行熔断？"><a href="#7-什么是降级熔断？为什么要进行熔断？" class="headerlink" title="7. 什么是降级熔断？为什么要进行熔断？"></a>7. 什么是降级熔断？为什么要进行熔断？</h3><p><img src="2025-01-09-Spring基础面试题/image137.png" alt=""></p><h3 id="8-⭐️有哪些熔断降级方案实现？"><a href="#8-⭐️有哪些熔断降级方案实现？" class="headerlink" title="8. ⭐️有哪些熔断降级方案实现？"></a>8. ⭐️有哪些熔断降级方案实现？</h3><p><img src="2025-01-09-Spring基础面试题/image138.png" alt=""></p><h3 id="9-⭐️Sentinel-是什么？它是如何工作的？"><a href="#9-⭐️Sentinel-是什么？它是如何工作的？" class="headerlink" title="9. ⭐️Sentinel 是什么？它是如何工作的？"></a>9. ⭐️Sentinel 是什么？它是如何工作的？</h3><p><img src="2025-01-09-Spring基础面试题/image139.png" alt=""></p><h3 id="10-Sentinel怎么实现限流的？"><a href="#10-Sentinel怎么实现限流的？" class="headerlink" title="10. Sentinel怎么实现限流的？"></a>10. Sentinel怎么实现限流的？</h3><p><img src="2025-01-09-Spring基础面试题/image140.png" alt=""></p><p><img src="2025-01-09-Spring基础面试题/image142.png" alt=""></p><p><img src="2025-01-09-Spring基础面试题/image141.png" alt=""></p><h3 id="11-Sentinel采用的什么限流算法？"><a href="#11-Sentinel采用的什么限流算法？" class="headerlink" title="11. Sentinel采用的什么限流算法？"></a>11. Sentinel采用的什么限流算法？</h3><p><img src="2025-01-09-Spring基础面试题/image143.png" alt=""></p><h3 id="12-Sentinel怎么实现集群限流？"><a href="#12-Sentinel怎么实现集群限流？" class="headerlink" title="12. Sentinel怎么实现集群限流？"></a>12. Sentinel怎么实现集群限流？</h3><p><img src="2025-01-09-Spring基础面试题/image144.png" alt=""></p><h3 id="13-Sentinel-与Hystrix的区别是什么？"><a href="#13-Sentinel-与Hystrix的区别是什么？" class="headerlink" title="13. Sentinel 与Hystrix的区别是什么？"></a>13. Sentinel 与Hystrix的区别是什么？</h3><p><img src="2025-01-09-Spring基础面试题/image145.png" alt=""></p><hr><h2 id="七、服务网关"><a href="#七、服务网关" class="headerlink" title="七、服务网关"></a>七、服务网关</h2><h3 id="1-⭐️什么是服务网关？为什么需要服务网关？"><a href="#1-⭐️什么是服务网关？为什么需要服务网关？" class="headerlink" title="1. ⭐️什么是服务网关？为什么需要服务网关？"></a>1. ⭐️什么是服务网关？为什么需要服务网关？</h3><p><img src="2025-01-09-Spring基础面试题/image146.png" alt=""></p><h3 id="2-SpringCloud可以选择哪些APl网关？"><a href="#2-SpringCloud可以选择哪些APl网关？" class="headerlink" title="2. SpringCloud可以选择哪些APl网关？"></a>2. SpringCloud可以选择哪些APl网关？</h3><p><img src="2025-01-09-Spring基础面试题/image147.png" alt=""></p><hr><h3 id="3-什么是限流算法，网关如何实现限流？"><a href="#3-什么是限流算法，网关如何实现限流？" class="headerlink" title="3. 什么是限流算法，网关如何实现限流？"></a>3. 什么是限流算法，网关如何实现限流？</h3><p><img src="2025-01-09-Spring基础面试题/image148.png" alt=""></p><h3 id="4-什么是Spring-Cloud-Gateway"><a href="#4-什么是Spring-Cloud-Gateway" class="headerlink" title="4.什么是Spring Cloud Gateway"></a>4.什么是Spring Cloud Gateway</h3><p><img src="2025-01-09-Spring基础面试题/image149.png" alt=""></p><h3 id="5-Spring-Cloud-Gateway核心概念？"><a href="#5-Spring-Cloud-Gateway核心概念？" class="headerlink" title="5. Spring Cloud Gateway核心概念？"></a>5. Spring Cloud Gateway核心概念？</h3><p><img src="2025-01-09-Spring基础面试题/image150.png" alt=""></p><hr><h3 id="6-为什么我们选择GateWay？"><a href="#6-为什么我们选择GateWay？" class="headerlink" title="6. 为什么我们选择GateWay？"></a>6. 为什么我们选择GateWay？</h3><p><img src="2025-01-09-Spring基础面试题/image151.png" alt=""></p><h3 id="7-Spring-Cloud-GateWay工作流程？"><a href="#7-Spring-Cloud-GateWay工作流程？" class="headerlink" title="7. Spring Cloud GateWay工作流程？"></a>7. Spring Cloud GateWay工作流程？</h3><p><img src="2025-01-09-Spring基础面试题/image152.png" alt=""></p><hr><h2 id="八、配置中心"><a href="#八、配置中心" class="headerlink" title="八、配置中心"></a>八、配置中心</h2><h3 id="1-⭐️什么是配置中心？为什么需要配置中心？"><a href="#1-⭐️什么是配置中心？为什么需要配置中心？" class="headerlink" title="1. ⭐️什么是配置中心？为什么需要配置中心？"></a>1. ⭐️什么是配置中心？为什么需要配置中心？</h3><p><img src="2025-01-09-Spring基础面试题/image153.png" alt=""></p><h3 id="2-SpringCloud可以选择哪些配置中心？"><a href="#2-SpringCloud可以选择哪些配置中心？" class="headerlink" title="2. SpringCloud可以选择哪些配置中心？"></a>2. SpringCloud可以选择哪些配置中心？</h3><p><img src="2025-01-09-Spring基础面试题/image154.png" alt=""></p><h3 id="3-Nacos配置中心的原理了解吗？"><a href="#3-Nacos配置中心的原理了解吗？" class="headerlink" title="3. Nacos配置中心的原理了解吗？"></a>3. Nacos配置中心的原理了解吗？</h3><p><img src="2025-01-09-Spring基础面试题/image155.png" alt=""></p><h3 id="4-Nacos配置中心长轮询机制？"><a href="#4-Nacos配置中心长轮询机制？" class="headerlink" title="4. Nacos配置中心长轮询机制？"></a>4. Nacos配置中心长轮询机制？</h3><p><img src="2025-01-09-Spring基础面试题/image156.png" alt=""></p><h3 id="5-链路跟踪"><a href="#5-链路跟踪" class="headerlink" title="5. 链路跟踪"></a>5. 链路跟踪</h3><p><img src="2025-01-09-Spring基础面试题/image157.png" alt=""></p><h3 id="6-SpringCloud可以选择哪些微服务链路追踪方案？"><a href="#6-SpringCloud可以选择哪些微服务链路追踪方案？" class="headerlink" title="6. SpringCloud可以选择哪些微服务链路追踪方案？"></a>6. SpringCloud可以选择哪些微服务链路追踪方案？</h3><p><img src="2025-01-09-Spring基础面试题/image158.png" alt=""></p><h2 id="九、分布式事务"><a href="#九、分布式事务" class="headerlink" title="九、分布式事务"></a>九、分布式事务</h2><h3 id="1-⭐️什么情况下需要用到分布式事务？有哪些方案？"><a href="#1-⭐️什么情况下需要用到分布式事务？有哪些方案？" class="headerlink" title="1. ⭐️什么情况下需要用到分布式事务？有哪些方案？"></a>1. ⭐️什么情况下需要用到分布式事务？有哪些方案？</h3><p><img src="2025-01-09-Spring基础面试题/image159.png" alt=""></p><h3 id="2-什么是Seata？谈谈你对Seata的理解？"><a href="#2-什么是Seata？谈谈你对Seata的理解？" class="headerlink" title="2. 什么是Seata？谈谈你对Seata的理解？"></a>2. 什么是Seata？谈谈你对Seata的理解？</h3><p><img src="2025-01-09-Spring基础面试题/image160.png" alt=""></p><h3 id="3-Seata支持哪些模式的分布式事务？"><a href="#3-Seata支持哪些模式的分布式事务？" class="headerlink" title="3. Seata支持哪些模式的分布式事务？"></a>3. Seata支持哪些模式的分布式事务？</h3><p><img src="2025-01-09-Spring基础面试题/image161.png" alt=""></p><p>&#x20;</p><p><img src="2025-01-09-Spring基础面试题/image162.png" alt=""></p><p>&#x20;</p><p><img src="2025-01-09-Spring基础面试题/image163.png" alt=""></p><p>&#x20;</p><p><img src="2025-01-09-Spring基础面试题/image164.png" alt=""></p><p>&#x20;</p><p><img src="2025-01-09-Spring基础面试题/image165.png" alt=""></p><hr><h3 id="4-了解Seata的实现原理吗？"><a href="#4-了解Seata的实现原理吗？" class="headerlink" title="4. 了解Seata的实现原理吗？"></a>4. 了解Seata的实现原理吗？</h3><p><img src="2025-01-09-Spring基础面试题/image166.png" alt=""></p><p>&#x20;</p><p><img src="2025-01-09-Spring基础面试题/image167.png" alt=""></p><p>&#x20;</p><p><img src="2025-01-09-Spring基础面试题/image168.png" alt=""></p><hr><h3 id="5-Seata的事务执行流程是什么样的？"><a href="#5-Seata的事务执行流程是什么样的？" class="headerlink" title="5. Seata的事务执行流程是什么样的？"></a>5. Seata的事务执行流程是什么样的？</h3><p><img src="2025-01-09-Spring基础面试题/image169.png" alt=""></p><h3 id="6-Seata的事务回滚是怎么实现的？"><a href="#6-Seata的事务回滚是怎么实现的？" class="headerlink" title="6. Seata的事务回滚是怎么实现的？"></a>6. Seata的事务回滚是怎么实现的？</h3><p><img src="2025-01-09-Spring基础面试题/image170.png" alt=""></p><h2 id="十、其它"><a href="#十、其它" class="headerlink" title="十、其它"></a>十、其它</h2><h3 id="1-你们的服务怎么做监控和告警？"><a href="#1-你们的服务怎么做监控和告警？" class="headerlink" title="1. 你们的服务怎么做监控和告警？"></a>1. 你们的服务怎么做监控和告警？</h3><p><img src="2025-01-09-Spring基础面试题/image171.png" alt=""></p><h3 id="2-你们的服务怎么做日志收集？"><a href="#2-你们的服务怎么做日志收集？" class="headerlink" title="2. 你们的服务怎么做日志收集？"></a>2. 你们的服务怎么做日志收集？</h3><p><img src="2025-01-09-Spring基础面试题/image172.png" alt=""></p><h3 id="3-说下你对DDD的理解？"><a href="#3-说下你对DDD的理解？" class="headerlink" title="3. 说下你对DDD的理解？"></a>3. 说下你对DDD的理解？</h3><p><img src="2025-01-09-Spring基础面试题/image173.png" alt=""></p>]]></content>
    
    
    <summary type="html">🥧本人的Spring基础面试总结</summary>
    
    
    
    <category term="面试题" scheme="https://outoflovenicoo.github.io/categories/%E9%9D%A2%E8%AF%95%E9%A2%98/"/>
    
    
    <category term="Spring" scheme="https://outoflovenicoo.github.io/tags/Spring/"/>
    
  </entry>
  
  <entry>
    <title>分布式学习笔记</title>
    <link href="https://outoflovenicoo.github.io/posts/2025331n.html"/>
    <id>https://outoflovenicoo.github.io/posts/2025331n.html</id>
    <published>2025-01-09T10:19:03.000Z</published>
    <updated>2025-03-23T14:00:00.000Z</updated>
    
    <content type="html"><![CDATA[<h1 id="1-分布式理论（CAP-amp-BASE）："><a href="#1-分布式理论（CAP-amp-BASE）：" class="headerlink" title="1.分布式理论（CAP &amp; BASE）："></a>1.分布式理论（CAP &amp; BASE）：</h1><h2 id="1-CAP"><a href="#1-CAP" class="headerlink" title="(1) CAP:"></a>(1) CAP:</h2><p><img src="./assets/(null" alt="img">-20250331104223525.(null))</p><p>首先，我解释下<strong>CAP定理</strong>的含义，c是指一致性，就是指所有节点访问同一份最新的数据副本。A是指可用性，表示非故障的节点在合理的时间内返回合理的响应（不是错误或者超时的响应），A是指分区容错性分布式系统出现网络分区的时候，仍然能够对外提供服务。</p><p>如果是一个分布式系统，肯定有很多个节点，为了系统的安全性。P是一定要满足的。在此基础上，强一致性和可用性只能满足二选一。因为如果要满足强一致性，那么在读写时必须要对其加锁。这时候其它节点的读写操作就被禁用了，那么其它节点的可用性就无法保证。而如果保证可用性，那每个节点的实时数据无法保证强一致性。对于分布式系统，因此只能完成CP和AP。无法完成CA。</p><h1 id="2-分布式-paxos和raft的区别"><a href="#2-分布式-paxos和raft的区别" class="headerlink" title="2.分布式-paxos和raft的区别"></a>2.分布式-paxos和raft的区别</h1><p><a href="https://learn.lianglianglee.com/专栏/24讲吃透分布式数据库-完/20  共识算法：一次性说清楚 Paxos、Raft 等算法的区别.md">20 共识算法:一次性说清楚 Paxos、Raft 等算法的区别</a></p><p>答：Paxos在一个节点当选为就是 leader 节点之后，其他的从节点如果不满主节点的那个投票策略的话，是可以对主节点的投票就是进行否决的。Paxos就是三阶段提交。但是 raft 的话就是只要集群中存在 leader 节点的话，从节点就是会按照主节点的策略来进行一致性的执行。</p><h1 id="3-分布式-为什么就是分布式的共识算法都需要要求多数派提交才能完成它的分布式一致性？"><a href="#3-分布式-为什么就是分布式的共识算法都需要要求多数派提交才能完成它的分布式一致性？" class="headerlink" title="3.分布式-为什么就是分布式的共识算法都需要要求多数派提交才能完成它的分布式一致性？"></a>3.分布式-为什么就是分布式的共识算法都需要要求多数派提交才能完成它的分布式一致性？</h1><p>有作恶节点，消息可能到的顺序不一样，拜占庭问题</p>]]></content>
    
    
    <summary type="html">🥧本人的分布式学习笔记</summary>
    
    
    
    <category term="学习" scheme="https://outoflovenicoo.github.io/categories/%E5%AD%A6%E4%B9%A0/"/>
    
    
    <category term="分布式" scheme="https://outoflovenicoo.github.io/tags/%E5%88%86%E5%B8%83%E5%BC%8F/"/>
    
  </entry>
  
  <entry>
    <title>阿里开发规约学习总结</title>
    <link href="https://outoflovenicoo.github.io/posts/2025-01-09-%E9%98%BF%E9%87%8C%E5%BC%80%E5%8F%91%E8%A7%84%E7%BA%A6%E5%AD%A6%E4%B9%A0%E6%80%BB%E7%BB%93.html"/>
    <id>https://outoflovenicoo.github.io/posts/2025-01-09-%E9%98%BF%E9%87%8C%E5%BC%80%E5%8F%91%E8%A7%84%E7%BA%A6%E5%AD%A6%E4%B9%A0%E6%80%BB%E7%BB%93.html</id>
    <published>2025-01-09T10:19:03.000Z</published>
    <updated>2025-03-23T14:00:00.000Z</updated>
    
    <content type="html"><![CDATA[<h1 id="一、编程规约"><a href="#一、编程规约" class="headerlink" title="一、编程规约"></a>一、编程规约</h1><h2 id="1-应该用确定有值的对象调用方法"><a href="#1-应该用确定有值的对象调用方法" class="headerlink" title="1.应该用确定有值的对象调用方法"></a>1.应该用确定有值的对象调用方法</h2><p><img src="2025-01-09-阿里开发规约学习总结/image-14.png" alt=""></p><h2 id="2-包装类对象应该用equals比较而不要用"><a href="#2-包装类对象应该用equals比较而不要用" class="headerlink" title="2.包装类对象应该用equals比较而不要用=="></a>2.包装类对象应该用equals比较而不要用==</h2><p><img src="2025-01-09-阿里开发规约学习总结/image-11.png" alt=""></p><h2 id="3-任何货币金额，均以最小货币单位且整型类型来进行存储。"><a href="#3-任何货币金额，均以最小货币单位且整型类型来进行存储。" class="headerlink" title="3.任何货币金额，均以最小货币单位且整型类型来进行存储。"></a>3.任何货币金额，均以最小货币单位且整型类型来进行存储。</h2><h2 id="4-⭐️浮点数之间的等值判断，float基本数据类型不能用-来比较，浮点数包装数据类型不能用-equals来判断"><a href="#4-⭐️浮点数之间的等值判断，float基本数据类型不能用-来比较，浮点数包装数据类型不能用-equals来判断" class="headerlink" title="4.⭐️浮点数之间的等值判断，float基本数据类型不能用==来比较，浮点数包装数据类型不能用 equals来判断"></a>4.⭐️浮点数之间的等值判断，float基本数据类型不能用==来比较，浮点数包装数据类型不能用 equals来判断</h2><p><img src="2025-01-09-阿里开发规约学习总结/image-10.png" alt=""></p><p>因为：</p><p><img src="2025-01-09-阿里开发规约学习总结/image-9.png" alt=""></p><h2 id="5-禁止使用构造方法-BigDecimal-double-的方式把-double-值转化为-BigDecimal-对象"><a href="#5-禁止使用构造方法-BigDecimal-double-的方式把-double-值转化为-BigDecimal-对象" class="headerlink" title="5.禁止使用构造方法 BigDecimal(double)的方式把 double 值转化为 BigDecimal 对象"></a>5.禁止使用构造方法 BigDecimal(double)的方式把 double 值转化为 BigDecimal 对象</h2><p><img src="2025-01-09-阿里开发规约学习总结/image-13.png" alt=""></p><h2 id="6-POJO用包装数据类型"><a href="#6-POJO用包装数据类型" class="headerlink" title="6.POJO用包装数据类型"></a>6.POJO用包装数据类型</h2><p><img src="2025-01-09-阿里开发规约学习总结/image-12.png" alt=""></p><h2 id="7-使用索引访问用-String-的-split-方法得到的数组时，需做最后一个分隔符后有无内容的检查，否则会有抛-IndexOutOfBoundsException-的风险"><a href="#7-使用索引访问用-String-的-split-方法得到的数组时，需做最后一个分隔符后有无内容的检查，否则会有抛-IndexOutOfBoundsException-的风险" class="headerlink" title="7.使用索引访问用 String 的 split 方法得到的数组时，需做最后一个分隔符后有无内容的检查，否则会有抛 IndexOutOfBoundsException 的风险"></a>7.使用索引访问用 String 的 split 方法得到的数组时，需做最后一个分隔符后有无内容的检查，否则会有抛 IndexOutOfBoundsException 的风险</h2><p><img src="2025-01-09-阿里开发规约学习总结/image-7.png" alt=""></p><h2 id="8-循环体内，字符串的连接方式，使用-StringBuilder-的-append-方法进行扩展"><a href="#8-循环体内，字符串的连接方式，使用-StringBuilder-的-append-方法进行扩展" class="headerlink" title="8.循环体内，字符串的连接方式，使用 StringBuilder 的 append 方法进行扩展"></a>8.循环体内，字符串的连接方式，使用 StringBuilder 的 append 方法进行扩展</h2><p><img src="2025-01-09-阿里开发规约学习总结/image-8.png" alt=""></p><h2 id="9-慎用-Object-的-clone-方法来拷贝对象"><a href="#9-慎用-Object-的-clone-方法来拷贝对象" class="headerlink" title="9.慎用 Object 的 clone 方法来拷贝对象"></a>9.慎用 Object 的 clone 方法来拷贝对象</h2><p>说明： 对象 clone 方法默认是浅拷贝，若想实现深拷贝， 需覆写 clone 方法实现域对象的深度遍历式拷贝</p><h2 id="10-类成员与方法访问控制从严"><a href="#10-类成员与方法访问控制从严" class="headerlink" title="10.类成员与方法访问控制从严"></a>10.类成员与方法访问控制从严</h2><p><img src="2025-01-09-阿里开发规约学习总结/image.png" alt=""></p><p><img src="2025-01-09-阿里开发规约学习总结/image-1.png" alt=""></p><h2 id="11-日期格式化时，传入-pattern-中表示年份统一使用小写的-y"><a href="#11-日期格式化时，传入-pattern-中表示年份统一使用小写的-y" class="headerlink" title="11.日期格式化时，传入 pattern 中表示年份统一使用小写的 y"></a>11.日期格式化时，传入 pattern 中表示年份统一使用小写的 y</h2><p><img src="2025-01-09-阿里开发规约学习总结/image-2.png" alt=""></p><p><img src="2025-01-09-阿里开发规约学习总结/image-3.png" alt=""></p><h2 id="12-关于-hashCode-和-equals-的处理，遵循如下规则："><a href="#12-关于-hashCode-和-equals-的处理，遵循如下规则：" class="headerlink" title="12.关于 hashCode 和 equals 的处理，遵循如下规则："></a>12.关于 hashCode 和 equals 的处理，遵循如下规则：</h2><p><img src="2025-01-09-阿里开发规约学习总结/image-4.png" alt=""></p><h2 id="13-ArrayList-的-subList-结果不可强转成-ArrayList，否则会抛出-ClassCastException-异常"><a href="#13-ArrayList-的-subList-结果不可强转成-ArrayList，否则会抛出-ClassCastException-异常" class="headerlink" title="13.ArrayList 的 subList 结果不可强转成 ArrayList，否则会抛出 ClassCastException 异常"></a>13.ArrayList 的 subList 结果不可强转成 ArrayList，否则会抛出 ClassCastException 异常</h2><p><img src="2025-01-09-阿里开发规约学习总结/image-5.png" alt=""></p><h2 id="14-不允许在程序任何地方中使用：-x20"><a href="#14-不允许在程序任何地方中使用：-x20" class="headerlink" title="14.不允许在程序任何地方中使用：&#x20;"></a>14.不允许在程序任何地方中使用：&#x20;</h2><h3 id="1）-java-sql-Date。-x20"><a href="#1）-java-sql-Date。-x20" class="headerlink" title="1） java.sql.Date。&#x20;"></a>1） java.sql.Date。&#x20;</h3><p>不记录时间， getHours()抛出异常</p><h3 id="2）-java-sql-Time。"><a href="#2）-java-sql-Time。" class="headerlink" title="2） java.sql.Time。"></a>2） java.sql.Time。</h3><p>不记录日期， getYear()抛出异常</p><h3 id="3）-java-sql-Timestamp。"><a href="#3）-java-sql-Timestamp。" class="headerlink" title="3） java.sql.Timestamp。"></a>3） java.sql.Timestamp。</h3><p>在构造</p><p>方法 super((time/1000)*1000)， 在 Timestamp 属性 fastTime 和 nanos 分别存储秒和纳秒信息。</p><h2 id="15-使用工具类-Arrays-asList-把数组转换成集合时，不能使用其修改集合相关的方法，它的-add-remove-clear-方法会抛出-UnsupportedOperationException-异常"><a href="#15-使用工具类-Arrays-asList-把数组转换成集合时，不能使用其修改集合相关的方法，它的-add-remove-clear-方法会抛出-UnsupportedOperationException-异常" class="headerlink" title="15.使用工具类 Arrays.asList()把数组转换成集合时，不能使用其修改集合相关的方法，它的 add/remove/clear 方法会抛出 UnsupportedOperationException 异常"></a>15.使用工具类 Arrays.asList()把数组转换成集合时，不能使用其修改集合相关的方法，它的 add/remove/clear 方法会抛出 UnsupportedOperationException 异常</h2><p><img src="2025-01-09-阿里开发规约学习总结/image-6.png" alt=""></p><h2 id="16-泛型通配符-lt-extends-T-gt-来接收返回的数据，此写法的泛型集合不能使用-add-方法，而-lt-super-T-gt-不能使用-get-方法，-两者在接口调用赋值的场景中容易出错。"><a href="#16-泛型通配符-lt-extends-T-gt-来接收返回的数据，此写法的泛型集合不能使用-add-方法，而-lt-super-T-gt-不能使用-get-方法，-两者在接口调用赋值的场景中容易出错。" class="headerlink" title="16.泛型通配符\&lt;? extends T&gt;来接收返回的数据，此写法的泛型集合不能使用 add 方法，而\&lt;? super T&gt;不能使用 get 方法， 两者在接口调用赋值的场景中容易出错。"></a>16.泛型通配符\&lt;? extends T&gt;来接收返回的数据，此写法的泛型集合不能使用 add 方法，而\&lt;? super T&gt;不能使用 get 方法， 两者在接口调用赋值的场景中容易出错。</h2><p>说明： 扩展说一下 PECS(Producer Extends Consumer Super)原则： 第一、 频繁往外读取内容的，适合用</p><p>\&lt;? extends T&gt;。 第二、 经常往里插入的，适合用\&lt;? super T&gt;</p><h2 id="17-不要在-foreach-循环里进行元素的-remove-add-操作。-remove-元素请使用-Iterator方式，如果并发操作，需要对-Iterator-对象加锁。"><a href="#17-不要在-foreach-循环里进行元素的-remove-add-操作。-remove-元素请使用-Iterator方式，如果并发操作，需要对-Iterator-对象加锁。" class="headerlink" title="17.不要在 foreach 循环里进行元素的 remove/add 操作。 remove 元素请使用 Iterator方式，如果并发操作，需要对 Iterator 对象加锁。"></a>17.不要在 foreach 循环里进行元素的 remove/add 操作。 remove 元素请使用 Iterator方式，如果并发操作，需要对 Iterator 对象加锁。</h2><p><img src="2025-01-09-阿里开发规约学习总结/image-22.png" alt=""></p><h2 id="18-⭐️使用-entrySet-遍历-Map-类集合-KV，而不是-keySet-方式进行遍历。"><a href="#18-⭐️使用-entrySet-遍历-Map-类集合-KV，而不是-keySet-方式进行遍历。" class="headerlink" title="18.⭐️使用 entrySet 遍历 Map 类集合 KV，而不是 keySet 方式进行遍历。"></a>18.⭐️使用 entrySet 遍历 Map 类集合 KV，而不是 keySet 方式进行遍历。</h2><p><img src="2025-01-09-阿里开发规约学习总结/image-19.png" alt=""></p><p><img src="2025-01-09-阿里开发规约学习总结/image-21.png" alt=""></p><h2 id="19-线程池不允许使用-Executors-去创建，而是通ThreadPoolExecutor-的方式，这样的处理方式让写的同学更加明确线程池的运行规则，规避资源耗尽的风险"><a href="#19-线程池不允许使用-Executors-去创建，而是通ThreadPoolExecutor-的方式，这样的处理方式让写的同学更加明确线程池的运行规则，规避资源耗尽的风险" class="headerlink" title="19.线程池不允许使用 Executors 去创建，而是通ThreadPoolExecutor 的方式，这样的处理方式让写的同学更加明确线程池的运行规则，规避资源耗尽的风险"></a>19.线程池不允许使用 Executors 去创建，而是通ThreadPoolExecutor 的方式，这样的处理方式让写的同学更加明确线程池的运行规则，规避资源耗尽的风险</h2><p>说明： Executors 返回的线程池对象的弊端如下：</p><p>1） FixedThreadPool 和 SingleThreadPool：</p><p>允许的请求队列长度为 Integer.MAX_VALUE，可能会堆积大量的请求，从而导致 OOM。</p><p>2） CachedThreadPool：</p><p>允许的创建线程数量为 Integer.MAX_VALUE， 可能会创建大量的线程，从而导致 OOM。</p><h2 id="20-必须回收自定义的-ThreadLocal-变量"><a href="#20-必须回收自定义的-ThreadLocal-变量" class="headerlink" title="20.必须回收自定义的 ThreadLocal 变量"></a>20.必须回收自定义的 ThreadLocal 变量</h2><p>尤其在线程池场景下，线程经常会被复用，如果不清理自定义的 ThreadLocal 变量，可能会影响后续业务逻辑和造成内存泄露等问题。尽量在代理中使用 try-finally 块进行回收。</p><p><img src="2025-01-09-阿里开发规约学习总结/image-18.png" alt=""></p><h2 id="21-在使用阻塞等待获取锁的方式中，必须在-try-代码块之外，并且在加锁方法与-try-代码块之间没有任何可能抛出异常的方法调用，避免加锁成功后，在-finally-中无法解锁。"><a href="#21-在使用阻塞等待获取锁的方式中，必须在-try-代码块之外，并且在加锁方法与-try-代码块之间没有任何可能抛出异常的方法调用，避免加锁成功后，在-finally-中无法解锁。" class="headerlink" title="21.在使用阻塞等待获取锁的方式中，必须在 try 代码块之外，并且在加锁方法与 try 代码块之间没有任何可能抛出异常的方法调用，避免加锁成功后，在 finally 中无法解锁。"></a>21.在使用阻塞等待获取锁的方式中，必须在 try 代码块之外，并且在加锁方法与 try 代码块之间没有任何可能抛出异常的方法调用，避免加锁成功后，在 finally 中无法解锁。</h2><p><strong>说明一：</strong> 如果在 lock 方法与 try 代码块之间的方法调用抛出异常，那么无法解锁，造成其它线程无法成功获取锁。</p><p><strong>说明二：</strong> 如果 lock 方法在 try 代码块之内，可能由于其它方法抛出异常，导致在 finally 代码块中， unlock对未加锁的对象解锁，它会调用 AQS 的 tryRelease 方法（取决于具体实现类），抛出llegalMonitorStateException 异常。</p><p><strong>说明三：</strong> 在 Lock 对象的 lock 方法实现中可能抛出 unchecked 异常，产生的后果与说明二相同。</p><p><img src="2025-01-09-阿里开发规约学习总结/image-20.png" alt=""></p><p><img src="2025-01-09-阿里开发规约学习总结/image-15.png" alt=""></p><h2 id="22-乐观锁与悲观锁的选择"><a href="#22-乐观锁与悲观锁的选择" class="headerlink" title="22.乐观锁与悲观锁的选择"></a>22.乐观锁与悲观锁的选择</h2><p>并发修改同一记录时，避免更新丢失， 需要加锁。 要么在应用层加锁，要么在缓存加</p><p>锁，要么在数据库层使用乐观锁，使用 version 作为更新依据。</p><p><strong>说明：</strong> 如果每次访问冲突概率小于 20%，推荐使用乐观锁，否则使用悲观锁。乐观锁的重试次数不得小于3 次。</p><p><strong>资金相关的金融敏感信息，使用悲观锁策略。</strong></p><p>说明： 乐观锁在获得锁的同时已经完成了更新操作，校验逻辑容易出现漏洞，另外，乐观锁对冲突的解决策略有较复杂的要求，处理不当容易造成系统压力或数据异常，所以资金相关的金融敏感信息不建议使用乐观锁更新。</p><p>正例： 悲观锁遵循一锁、 二判、 三更新、 四释放的原则。</p><h2 id="23-使用-CountDownLatch-进行异步转同步操作"><a href="#23-使用-CountDownLatch-进行异步转同步操作" class="headerlink" title="23.使用 CountDownLatch 进行异步转同步操作"></a>23.使用 CountDownLatch 进行异步转同步操作</h2><p>使用 CountDownLatch 进行异步转同步操作，每个线程退出前必须调用 countDown 方</p><p>法，线程执行代码注意 catch 异常，确保 countDown 方法被执行到，避免主线程无法执行至</p><p>await 方法，直到超时才返回结果。</p><p><strong>说明：</strong> 注意，子线程抛出<strong>异常堆栈</strong>，不能在主线程 try-catch 到</p><h2 id="24-⭐️避免-Random-实例被多线程使用，虽然共享该实例是线程安全的，但会因竞争同一-seed导致的性能下降。"><a href="#24-⭐️避免-Random-实例被多线程使用，虽然共享该实例是线程安全的，但会因竞争同一-seed导致的性能下降。" class="headerlink" title="24.⭐️避免 Random 实例被多线程使用，虽然共享该实例是线程安全的，但会因竞争同一 seed导致的性能下降。"></a>24.⭐️避免 Random 实例被多线程使用，虽然共享该实例是线程安全的，但会因竞争同一 seed导致的性能下降。</h2><p><strong>说明：</strong> Random 实例包括 java.util.Random 的实例或者 Math.random()的方式。</p><p><strong>正例：</strong> 在 JDK7 之后，可以直接使用 API ThreadLocalRandom， 而在 JDK7 之前， 需要编码保证每个线程持有一个单独的 Random 实例。</p><h2 id="25-当-switch-括号内的变量类型为-String-并且此变量为外部参数时，必须先进行-null判断。"><a href="#25-当-switch-括号内的变量类型为-String-并且此变量为外部参数时，必须先进行-null判断。" class="headerlink" title="25.当 switch 括号内的变量类型为 String 并且此变量为外部参数时，必须先进行 null判断。"></a>25.当 switch 括号内的变量类型为 String 并且此变量为外部参数时，必须先进行 null判断。</h2><p><img src="2025-01-09-阿里开发规约学习总结/image-16.png" alt=""></p><h2 id="26-在高并发场景中，避免使用”-等于”-判断作为中断或退出的条件。"><a href="#26-在高并发场景中，避免使用”-等于”-判断作为中断或退出的条件。" class="headerlink" title="26.在高并发场景中，避免使用” 等于” 判断作为中断或退出的条件。"></a>26.在高并发场景中，避免使用” 等于” 判断作为中断或退出的条件。</h2><p><strong>说明：</strong> 如果并发控制没有处理好，容易产生等值判断被“击穿” 的情况，使用大于或小于的区间判断条件来代替。</p><p><strong>反例：</strong> 判断剩余奖品数量等于 0 时，终止发放奖品，但因为并发处理错误导致奖品数量瞬间变成了负数，这样的话，活动无法终止。</p><h2 id="27-避免采用取反逻辑运算符。"><a href="#27-避免采用取反逻辑运算符。" class="headerlink" title="27.避免采用取反逻辑运算符。"></a>27.避免采用取反逻辑运算符。</h2><p>说明： 取反逻辑不利于快速理解，并且取反逻辑写法一般都存在对应的正向逻辑写法。</p><p>正例： 使用 if (x &lt; 628) 来表达 x 小于 628。</p><p>反例： 使用 if (!(x &gt;= 628)) 来表达 x 小于 628。</p><h1 id="二、注释规约："><a href="#二、注释规约：" class="headerlink" title="二、注释规约："></a>二、注释规约：</h1><h2 id="1-及时清理不再使用的代码段或配置信息。"><a href="#1-及时清理不再使用的代码段或配置信息。" class="headerlink" title="1.及时清理不再使用的代码段或配置信息。"></a>1.及时清理不再使用的代码段或配置信息。</h2><p><strong>说明：</strong> 对于垃圾代码或过时配置，坚决清理干净，避免程序过度臃肿，代码冗余。</p><p>正例： 对于暂时被注释掉，后续可能恢复使用的代码片段，在注释代码上方，统一规定使用三个斜杠(///)来说明注释掉代码的理由。 如：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">hello</span><span class="params">()</span> &#123;</span><br><span class="line">    <span class="comment">/// 业务方通知活动暂停</span></span><br><span class="line">    <span class="comment">// Business business = new Business();</span></span><br><span class="line">    <span class="comment">// business.active();</span></span><br><span class="line">    System.out.println(<span class="string">&quot;it&#x27;s finished&quot;</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h1 id="三、前后端规约"><a href="#三、前后端规约" class="headerlink" title="三、前后端规约"></a>三、前后端规约</h1><h2 id="1-前后端数据列表相关的接口返回，如果为空，则返回空数组-或空集合"><a href="#1-前后端数据列表相关的接口返回，如果为空，则返回空数组-或空集合" class="headerlink" title="1.前后端数据列表相关的接口返回，如果为空，则返回空数组[]或空集合{}"></a>1.前后端数据列表相关的接口返回，如果为空，则返回空数组[]或空集合{}</h2><p><strong>说明：&#x20;</strong>&#x6B64;条约定有利于数据层面上的协作更加高效，减少前端很多琐碎的 null 判断。</p><h2 id="2-对于需要使用超大整数的场景，服务端一律使用-String-字符串类型返回，禁止使用Long-类型。"><a href="#2-对于需要使用超大整数的场景，服务端一律使用-String-字符串类型返回，禁止使用Long-类型。" class="headerlink" title="2.对于需要使用超大整数的场景，服务端一律使用 String 字符串类型返回，禁止使用Long 类型。"></a>2.对于需要使用超大整数的场景，服务端一律使用 String 字符串类型返回，禁止使用Long 类型。</h2><h1 id="四、异常日志"><a href="#四、异常日志" class="headerlink" title="四、异常日志"></a>四、异常日志</h1><h2 id="1-事务场景中，抛出异常被-catch-后，如果需要回滚，一定要注意手动回滚事务。"><a href="#1-事务场景中，抛出异常被-catch-后，如果需要回滚，一定要注意手动回滚事务。" class="headerlink" title="1.事务场景中，抛出异常被 catch 后，如果需要回滚，一定要注意手动回滚事务。"></a>1.事务场景中，抛出异常被 catch 后，如果需要回滚，一定要注意手动回滚事务。</h2><h2 id="2-不要在-finally-块中使用-return。"><a href="#2-不要在-finally-块中使用-return。" class="headerlink" title="2.不要在 finally 块中使用 return。"></a>2.不要在 finally 块中使用 return。</h2><p><strong>说明：</strong> try 块中的 return 语句执行成功后，并不马上返回，而是继续执行 finally 块中的语句，如果此处存在 return 语句，则在此直接返回，无情丢弃掉 try 块中的返回点。</p><p><img src="2025-01-09-阿里开发规约学习总结/image-17.png" alt=""></p><h2 id="3-防止-NPE，是程序员的基本修养，注意-NPE-产生的场景："><a href="#3-防止-NPE，是程序员的基本修养，注意-NPE-产生的场景：" class="headerlink" title="3.防止 NPE，是程序员的基本修养，注意 NPE 产生的场景："></a>3.防止 NPE，是程序员的基本修养，注意 NPE 产生的场景：</h2><p>1） 返回类型为基本数据类型， return 包装数据类型的对象时，自动拆箱有可能产生 NPE。</p><p>反例： public int f() { return Integer 对象}， 如果为 null，自动解箱抛 NPE。</p><p>2） 数据库的查询结果可能为 null。</p><p>3） 集合里的元素即使 isNotEmpty，取出的数据元素也可能为 null。</p><p>4） 远程调用返回对象时，一律要求进行空指针判断，防止 NPE。</p><p>5） 对于 Session 中获取的数据，建议进行 NPE 检查，避免空指针。</p><p>6） 级联调用 obj.getA().getB().getC()；一连串调用，易产生 NPE。</p><p><strong>正例：</strong> 使用 JDK8 的 Optional 类来防止 NPE 问题</p><h2 id="4-在日志输出时，字符串变量之间的拼接使用占位符的方式。"><a href="#4-在日志输出时，字符串变量之间的拼接使用占位符的方式。" class="headerlink" title="4.在日志输出时，字符串变量之间的拼接使用占位符的方式。"></a>4.在日志输出时，字符串变量之间的拼接使用占位符的方式。</h2><p><strong>说明：</strong> 因为 String 字符串的拼接会使用 StringBuilder 的 append()方式，有一定的性能损耗。使用占位符仅是替换动作，可以有效提升性能。</p><p><strong>正例：</strong> logger.debug(“Processing trade with id: {} and symbol: {}”, id, symbol);</p><h2 id="5-生产环境禁止直接使用-System-out-或-System-err-输出日志或使用e-printStackTrace-打印异常堆栈。"><a href="#5-生产环境禁止直接使用-System-out-或-System-err-输出日志或使用e-printStackTrace-打印异常堆栈。" class="headerlink" title="5.生产环境禁止直接使用 System.out 或 System.err 输出日志或使用e.printStackTrace()打印异常堆栈。"></a>5.生产环境禁止直接使用 System.out 或 System.err 输出日志或使用e.printStackTrace()打印异常堆栈。</h2><p><strong>说明：</strong> 标准日志输出与标准错误输出文件每次 Jboss 重启时才滚动，如果大量输出送往这两个文件，容易造成文件大小超过操作系统大小限制。</p><h1 id="五，安全规约"><a href="#五，安全规约" class="headerlink" title="五，安全规约"></a>五，安全规约</h1><h2 id="x20-1-用户输入的-SQL-参数严格使用参数绑定或者-METADATA-字段值限定，防止-SQL-注入，禁止字符串拼接-SQL-访问数据库。"><a href="#x20-1-用户输入的-SQL-参数严格使用参数绑定或者-METADATA-字段值限定，防止-SQL-注入，禁止字符串拼接-SQL-访问数据库。" class="headerlink" title="&#x20;1.用户输入的 SQL 参数严格使用参数绑定或者 METADATA 字段值限定，防止 SQL 注入，禁止字符串拼接 SQL 访问数据库。"></a>&#x20;1.用户输入的 SQL 参数严格使用参数绑定或者 METADATA 字段值限定，防止 SQL 注入，禁止字符串拼接 SQL 访问数据库。</h2><p><strong>反例：</strong> 某系统签名大量被恶意修改，即是因为对于危险字符 # —没有进行转义，导致数据库更新时， where后边的信息被注释掉，对全库进行更新。</p><h2 id="2-用户请求传入的任何参数必须做有效性验证。"><a href="#2-用户请求传入的任何参数必须做有效性验证。" class="headerlink" title="2.用户请求传入的任何参数必须做有效性验证。"></a>2.用户请求传入的任何参数必须做有效性验证。</h2><p><strong>说明： 忽略参数校验可能导致：</strong></p><p>⚫ page size 过大导致内存溢出</p><p>⚫ 恶意 order by 导致数据库慢查询</p><p>⚫ 缓存击穿</p><p>⚫ SSRF</p><p>⚫ 任意重定向</p><p>⚫ SQL 注入， Shell 注入， 反序列化注入</p><p>⚫ 正则输入源串拒绝服务 ReDoS</p><p>Java 代码用正则来验证客户端的输入，有些正则写法验证普通用户输入没有问题，但是如果攻击人员使用的是特殊构造的字符串来验证，有可能导致死循环的结果</p><h1 id="六、数据库规约"><a href="#六、数据库规约" class="headerlink" title="六、数据库规约"></a>六、数据库规约</h1><h2 id="1-表达是与否概念的字段，必须使用-is-xxx-的方式命名，数据类型是-unsigned-tinyint"><a href="#1-表达是与否概念的字段，必须使用-is-xxx-的方式命名，数据类型是-unsigned-tinyint" class="headerlink" title="1.表达是与否概念的字段，必须使用 is_xxx 的方式命名，数据类型是 unsigned tinyint"></a>1.表达是与否概念的字段，必须使用 is_xxx 的方式命名，数据类型是 unsigned tinyint</h2><p><strong>说明：</strong> 任何字段如果为非负数，必须是 unsigned。</p><p><strong>注意：</strong> POJO 类中的任何布尔类型的变量，都不要加 is 前缀，所以，需要在\<resultMap>设置从 is_xxx 到Xxx 的映射关系。数据库表示是与否的值，使用 tinyint 类型，坚持 is_xxx 的命名方式是为了明确其取值含义与取值范围。</p><p><strong>正例：</strong> 表达逻辑删除的字段名 is_deleted， 1 表示删除， 0 表示未删除。</p><h2 id="2-索引命名"><a href="#2-索引命名" class="headerlink" title="2.索引命名"></a>2.索引命名</h2><p>主键索引名为 pk_字段名；唯一索引名为 uk_字段名； 普通索引名则为 idx_字段名。</p><p>说明： pk_ 即 primary key； uk_ 即 unique key； idx_ 即 index 的简称。</p><h2 id="3-小数类型为-decimal，禁止使用-float-和-double。"><a href="#3-小数类型为-decimal，禁止使用-float-和-double。" class="headerlink" title="3.小数类型为 decimal，禁止使用 float 和 double。"></a>3.小数类型为 decimal，禁止使用 float 和 double。</h2><p>说明： 在存储的时候， float 和 double 都存在精度损失的问题，很可能在比较值的时候，得到不正确的结果。如果存储的数据范围超过 decimal 的范围，建议将数据拆成整数和小数并分开存储。</p><h2 id="4-varchar使用"><a href="#4-varchar使用" class="headerlink" title="4.varchar使用"></a>4.varchar使用</h2><p>varchar 是可变长字符串，不预先分配存储空间，长度不要超过 5000，如果存储长度大于此值，定义字段类型为 text，独立出来一张表，用主键来对应，避免影响其它字段索引效率</p><h2 id="5-表必备三字段：-id-create-time-update-time"><a href="#5-表必备三字段：-id-create-time-update-time" class="headerlink" title="5.表必备三字段： id, create_time, update_time"></a>5.表必备三字段： id, create_time, update_time</h2><p>说明： 其中 id 必为主键，类型为 bigint unsigned、单表时自增、步长为 1。 create_time, update_time的类型均为 datetime 类型，前者现在时表示主动式创建，后者过去分词表示被动式更新。</p><h2 id="6-业务上具有唯一特性的字段，即使是组合字段，也必须建成唯一索引"><a href="#6-业务上具有唯一特性的字段，即使是组合字段，也必须建成唯一索引" class="headerlink" title="6.业务上具有唯一特性的字段，即使是组合字段，也必须建成唯一索引"></a>6.业务上具有唯一特性的字段，即使是组合字段，也必须建成唯一索引</h2><p><strong>说明：</strong> 不要以为唯一索引影响了 insert 速度，这个速度损耗可以忽略，但提高查找速度是明显的； 另外，即使在应用层做了非常完善的校验控制，只要没有唯一索引，根据墨菲定律，必然有脏数据产生。</p><h2 id="7-利用覆盖索引来进行查询操作，-避免回表。"><a href="#7-利用覆盖索引来进行查询操作，-避免回表。" class="headerlink" title="7.利用覆盖索引来进行查询操作， 避免回表。"></a>7.利用覆盖索引来进行查询操作， 避免回表。</h2><p><strong>说明：</strong> 如果一本书需要知道第 11 章是什么标题，会翻开第 11 章对应的那一页吗？目录浏览一下就好，这个目录就是起到覆盖索引的作用。</p><p><strong>正例：</strong> 能够建立索引的种类分为主键索引、唯一索引、普通索引三种，而覆盖索引只是一种查询的一种效果，用 explain 的结果， extra 列会出现： using index。</p><h2 id="8-⭐️利用延迟关联或者子查询优化超多分页场景"><a href="#8-⭐️利用延迟关联或者子查询优化超多分页场景" class="headerlink" title="8.⭐️利用延迟关联或者子查询优化超多分页场景"></a>8.⭐️利用延迟关联或者子查询优化超多分页场景</h2><p><strong>说明：</strong> MySQL 并不是跳过 offset 行，而是取 offset+N 行，然后返回放弃前 offset 行，返回 N 行，那当offset 特别大的时候，效率就非常的低下，要么控制返回的总页数，要么对超过特定阈值的页数进行 SQL改写。</p><p><strong>正例：</strong> 先快速定位需要获取的 id 段，然后再关联：</p><p>SELECT t1.* FROM 表 1 as t1, (select id from 表 1 where 条件 LIMIT 100000,20 ) as t2 where t1.id=t2.id</p><h2 id="9-当某一列的值全是-NULL-时，-count-col-的返回结果为-0，但-sum-col-的返回结果为NULL，因此使用-sum-时需注意-NPE-问题。"><a href="#9-当某一列的值全是-NULL-时，-count-col-的返回结果为-0，但-sum-col-的返回结果为NULL，因此使用-sum-时需注意-NPE-问题。" class="headerlink" title="9.当某一列的值全是 NULL 时， count(col)的返回结果为 0，但 sum(col)的返回结果为NULL，因此使用 sum()时需注意 NPE 问题。"></a>9.当某一列的值全是 NULL 时， count(col)的返回结果为 0，但 sum(col)的返回结果为NULL，因此使用 sum()时需注意 NPE 问题。</h2><p><strong>正例：</strong> 可以使用如下方式来避免 sum 的 NPE 问题： SELECT IFNULL(SUM(column), 0) FROM table;</p><h2 id="10-使用-ISNULL-来判断是否为-NULL-值"><a href="#10-使用-ISNULL-来判断是否为-NULL-值" class="headerlink" title="10.使用 ISNULL()来判断是否为 NULL 值"></a>10.使用 ISNULL()来判断是否为 NULL 值</h2><p><strong>说明：</strong> NULL 与任何值的直接比较都为 NULL。</p><p>1） NULL&lt;&gt;NULL 的返回结果是 NULL， 而不是 false。</p><p>2） NULL=NULL 的返回结果是 NULL， 而不是 true。</p><p>3） NULL&lt;&gt;1 的返回结果是 NULL，而不是 true。</p><p><strong>反例：</strong> 在 SQL 语句中，如果在 null 前换行，影响可读性。 select * from table where column1 is null and column3 is not null; 而<code>ISNULL(column)</code>是一个整体，简洁易懂。从性能数据上分析， <code>ISNULL(column)</code>执行效率更快一些。</p><h2 id="11-⭐️数据库层面禁止使用"><a href="#11-⭐️数据库层面禁止使用" class="headerlink" title="11.⭐️数据库层面禁止使用"></a><strong>11.⭐️数据库层面禁止使用</strong></h2><h3 id="（1）不得使用外键与级联，一切外键概念必须在应用层解决。"><a href="#（1）不得使用外键与级联，一切外键概念必须在应用层解决。" class="headerlink" title="（1）不得使用外键与级联，一切外键概念必须在应用层解决。"></a>（1）不得使用外键与级联，一切外键概念必须在应用层解决。</h3><p><strong>说明：</strong> 学生表中的 student_id 是主键，那么成绩表中的 student_id 则为外键。如果更新学生表中的 student_id，同时触发成绩表中的 student_id 更新， 即为级联更新。外键与级联更新适用于单机低并发，不适合分布式、高并发集群；级联更新是强阻塞，存在数据库更新风暴的风险；外键影响数据库的插入速度。</p><h3 id="（2）禁止使用存储过程，存储过程难以调试和扩展，更没有移植性"><a href="#（2）禁止使用存储过程，存储过程难以调试和扩展，更没有移植性" class="headerlink" title="（2）禁止使用存储过程，存储过程难以调试和扩展，更没有移植性"></a>（2）禁止使用存储过程，存储过程难以调试和扩展，更没有移植性</h3><h2 id="12-在表查询中，一律不要使用-作为查询的字段列表，需要哪些字段必须明确写明"><a href="#12-在表查询中，一律不要使用-作为查询的字段列表，需要哪些字段必须明确写明" class="headerlink" title="12. 在表查询中，一律不要使用 * 作为查询的字段列表，需要哪些字段必须明确写明"></a>12. 在表查询中，一律不要使用 * 作为查询的字段列表，需要哪些字段必须明确写明</h2><p><strong>说明：</strong> 1）增加查询分析器解析成本。 2）增减字段容易与 resultMap 配置不一致。 3）无用字段增加网络消耗，尤其是 text 类型的字段</p>]]></content>
    
    
    <summary type="html">🥧阿里开发规约学习总结</summary>
    
    
    
    <category term="学习" scheme="https://outoflovenicoo.github.io/categories/%E5%AD%A6%E4%B9%A0/"/>
    
    
    <category term="开发规范" scheme="https://outoflovenicoo.github.io/tags/%E5%BC%80%E5%8F%91%E8%A7%84%E8%8C%83/"/>
    
  </entry>
  
  <entry>
    <title>Redis面试题</title>
    <link href="https://outoflovenicoo.github.io/posts/2025-01-09-Redis%E9%9D%A2%E8%AF%95%E9%A2%98.html"/>
    <id>https://outoflovenicoo.github.io/posts/2025-01-09-Redis%E9%9D%A2%E8%AF%95%E9%A2%98.html</id>
    <published>2025-01-09T10:19:03.000Z</published>
    <updated>2025-03-23T14:00:00.000Z</updated>
    
    <content type="html"><![CDATA[<h1 id="学习"><a href="#学习" class="headerlink" title="学习"></a>学习</h1><h2 id="1-大key热key问题"><a href="#1-大key热key问题" class="headerlink" title="1.大key热key问题"></a>1.大key热key问题</h2><blockquote><p><a href="https://xiaolincoding.com/redis/storage/bigkey_aof_rdb.html">Redis 大 Key 对持久化有什么影响？</a></p><p><a href="https://www.cnblogs.com/rjzheng/p/10874537.html">【原创】谈谈redis的热key问题如何解决 - 孤独烟 - 博客园</a></p><p><a href="https://xiaolincoding.com/redis/cluster/cache_problem.html">什么是缓存雪崩、击穿、穿透？</a></p></blockquote><p><img src="2025-01-09-Redis面试题/diagram.png" alt=""></p><h1 id="概念"><a href="#概念" class="headerlink" title="概念"></a>概念</h1><h2 id="1-说说你对Redis的理解"><a href="#1-说说你对Redis的理解" class="headerlink" title="1. 说说你对Redis的理解"></a>1. 说说你对Redis的理解</h2><p>Redis是一个基于Key - Value存储结构的开源内存数据库，也是一种NoSQL数据库。</p><p>它支持多种数据类型，包括String、Map、Set、ZSet和List，以满足不同应用场景的需求。</p><p>Redis以内存存储和优化的数据结构为基础，提供了快速的读写性能和高效的数据访问。常被用作应用与数据库之间的缓存组件，提升数据IO效率。</p><p>此外，Redis支持主从复制、哨兵机制和集群方式，实现高可用性和水平扩展。&#x20;</p><p><img src="2025-01-09-Redis面试题/image2.png" alt=""></p><ol><li><p><strong>主从复制</strong>：主从复制是Redis最基本的高可用方案，它通过将一个Redis实例作为主节点，将多个Redis实例作为从节点，实现数据的同步复制。主节点负责写入数据，从节点负责读取数据，当主节点宕机时，从节点可以自动切换成主节点，保证系统的可用性。</p></li><li><p><strong>哨兵机制</strong>：哨兵机制是Redis提供的一种自动故障转移方案，它可以监控主节点的状态，当主节点宕机时，自动将从节点切换成主节点，保证系统的可用性。哨兵机制还可以监控从节点的状态，当从节点宕机时，自动将从其他从节点中选举一个节点切换成主节点。</p></li><li><p><strong>集群方式</strong>：集群方式是Redis提供的一种分布式方案，它将多个Redis实例组成一个集群，每个实例负责一部分数据。集群方式可以自动将数据分配到不同的节点上，保证系统的可用性和扩展性。集群方式还可以自动将数据备份到其他节点上，保证数据的可靠性。&#x20;</p></li></ol><h2 id="2-⭐️Redis的热Key问题如何解决"><a href="#2-⭐️Redis的热Key问题如何解决" class="headerlink" title="2. ⭐️Redis的热Key问题如何解决"></a>2. ⭐️Redis的热Key问题如何解决</h2><p>首先一般来说我们生产环境用的都是redis集群来做缓存，hotkey主要是指某个特定的key，分布到了redis集群某个节点上，但是相比于其他同类型的key，这个key的访问频率极高，导致存储这个key的redis节点负载过高，可能导致redis不可用，实际生产环境中比如有：某个商品突然成为爆品，结果大家都去买他，大量的查询达到对应商品缓存所在redis节点。</p><p><strong>解决方案：</strong>&#x5BF9;于可预知的hot key问题，比如商品秒杀，我们在发布商品的时候就需要对这些活动商品进行<strong>缓存预热</strong>，并且利用分布式缓存本地缓存来帮助提高我们的查询性能，对于不可预知的场景，我们一般来说都会接入我们的热点探测系统，定期上报我们对应key的调用次数，有热点探测系统检测是否是热key，然后通过sdk通知各个应用节点快速构建本地缓存，来抗住这些热key带来的流量，当然我们也有兜底的方案，比如：限流熔断等。&#x20;</p><h2 id="3-一个REDIS实例最多能存放多少KEYS"><a href="#3-一个REDIS实例最多能存放多少KEYS" class="headerlink" title="3. 一个REDIS实例最多能存放多少KEYS"></a>3. 一个REDIS实例最多能存放多少KEYS</h2><p>Redis的每个实例最多可以存放<strong>2^32 - 1</strong>个keys，即大约42亿个keys，这是由Redis内部使用的哈希表决定的，它使用32位无符号整数作为索引。Redis使用的哈希函数和负载因子等因素也会影响实际可存放键的数量。</p><p>需要注意的是，尽管Redis允许存储数量庞大的键，但在实践中，存储过多的键可能会导致性能下降和内存消耗增加。因此，在设计应用程序时，需要根据实际需求和硬件资源来合理规划键的数量，避免过度使用Redis实例造成负担。如果需要存储更多的键值对，可以考虑使用Redis集群或分片技术，以扩展整体存储容量。&#x20;</p><h2 id="4-Redis为什么这么快"><a href="#4-Redis为什么这么快" class="headerlink" title="4. Redis为什么这么快"></a>4. Redis为什么这么快</h2><ol><li><p>首先redis是基于内存的nosql数据库，基于内存的读写效率本身就非常高</p></li><li><p>redis内部对应核心命令的执行采用了单线程模型，并且给予内存模型，单条命令的执行速度远小于线程上下文的开销，所以使用单线程能够大大提升我们redis的吞吐量</p></li><li><p>内部提供了高亮查询和操作的数据结构</p></li><li><p>采用IO多路复用模型，能够同时处理大量连接，并且使用reator模型，能够并发的处理连接以及对连接进行响应，但是内部命令执行还是单线程的</p></li><li><p>5.对redis常用操作进行优化，提供了管道技术和批量操作技术，能够减少单次redis操作的网络开销</p></li></ol><h2 id="5-怎么实现Redis的高可用？"><a href="#5-怎么实现Redis的高可用？" class="headerlink" title="5. 怎么实现Redis的高可用？"></a>5. 怎么实现Redis的高可用？</h2><ol><li><p><strong>主从复制</strong>：通过设置主从复制，将主节点的数据同步到多个从节点上。主节点负责处理写操作，并将写操作的日志复制给从节点，从节点则负责处理读请求。如果主节点发生故障，可以将一个从节点升级为新的主节点，从而实现故障转移和高可用。</p></li><li><p><strong>哨兵机制</strong>：使用Redis哨兵来监控主节点和从节点的状态。哨兵是一组独立运行的进程，它会监控Redis实例的健康状态，并在主节点出现故障时自动进行故障转移。它还能够监控从节点，并在需要时将其提升为主节点。</p></li><li><p><strong>集群模式</strong>：Redis集群是一种分布式方案，可以将多个Redis节点组成一个逻辑集群，提供数据分片和自动故障恢复。每个节点负责存储和处理部分数据，通过节点间的数据分片和分布式算法保证数据的可用性和负载均衡。当集群中的某个节点出现故障时，集群会自动进行故障转移和恢复。&#x20;</p></li></ol><h2 id="6-Redis是单线程还是多线程"><a href="#6-Redis是单线程还是多线程" class="headerlink" title="6. Redis是单线程还是多线程"></a>6. Redis是单线程还是多线程</h2><p>Redis 6.x版本引入了多线程的I/O处理，但这并不改变其核心数据处理的单线程特性。多线程I/O处理主要用于处理网络I/O，以提高<strong>网络吞吐量</strong>，而核心的数据操作仍然由单个主线程处理。</p><p>总的来说，Redis的单线程模型是其设计的一个核心特点，它使得Redis在保持简单性的同时，能够提供极高的性能。&#x20;</p><h2 id="7-⭐️为什么Redis-单线程模型效率也能那么高"><a href="#7-⭐️为什么Redis-单线程模型效率也能那么高" class="headerlink" title="7. ⭐️为什么Redis 单线程模型效率也能那么高"></a>7. ⭐️为什么Redis 单线程模型效率也能那么高</h2><p>尽管Redis采用了单线程模型，但其效率仍然非常高。以下是一些原因：</p><ol><li><p><strong>非阻塞IO</strong>：Redis使用了事件驱动的非阻塞IO机制。它通过事件循环处理来自客户端的请求，在等待数据IO时并不会阻塞主线程，而是继续处理其他请求。这种机制允许Redis以高效地方式处理大量的并发连接。</p></li><li><p><strong>内存操作</strong>：Redis主要将数据存储在内存中，并且由于单线程模型的存在，在内存操作的情况下，Redis可以通过简单的指针操作来实现快速读写，而不需要考虑复杂的数据同步和竞争条件。</p></li><li><p><strong>单线程避免的开销</strong>：与多线程模型相比，单线程模型避免了线程间的上下文切换、锁竞争和资源管理开销。这使得Redis可以更高效地使用CPU资源，并减少了大量与线程相关的开销。</p></li></ol><p>需要注意的是，Redis单线程模型适合于处理大量的短期操作和快速响应的场景，但在处理长时间运行的计算密集型任务时可能会有性能上的不足。为了提高处理能力和并发性，可以使用Redis的集群模式、多实例部署或将计算密集型任务委托给其他更适合的工具或语言来处理。</p><h2 id="8-说说你对Redis操作原子性的理解"><a href="#8-说说你对Redis操作原子性的理解" class="headerlink" title="8. 说说你对Redis操作原子性的理解"></a>8. 说说你对Redis操作原子性的理解</h2><p>Redis的操作是原子性的，这是因为Redis的每个命令都是以单线程的方式执行的，整个命令的执行过程是不可中断的，要么全部执行成功，要么全部执行失败。</p><p>在Redis中，每个命令都会被转换成一个或多个底层操作，这些操作会基于数据结构的特定实现来执行。比如，对于字符串类型，获取一个键值对、设置一个键值对等操作都是原子性的。在执行这些底层操作时，Redis会使用一些技术来保证原子性，主要包括以下两点：</p><ol><li><p>Redis使用单线程模型，避免了多线程之间的竞争条件和锁开销，从而保证了操作的原子性。</p></li><li><p>Redis在执行一些复杂的操作时，比如事务、Lua脚本等，会将多个底层操作打包成一个原子性操作，这些底层操作要么全部执行成功，要么全部执行失败。在事务和Lua脚本中，Redis同时支持回滚操作，即当一些命令执行成功，后面的命令出错时，Redis可以自动撤销已经执行的命令。</p></li></ol><p>因此，Redis的操作是原子性的，这得益于Redis单线程模型和底层操作的实现方式。这种原子性操作保证了Redis能够提供高效和可靠的服务。&#x20;</p><h1 id="数据结构-x20"><a href="#数据结构-x20" class="headerlink" title="数据结构&#x20;"></a>数据结构&#x20;</h1><h2 id="1-说说-Redis-的数据类型"><a href="#1-说说-Redis-的数据类型" class="headerlink" title="1. 说说 Redis 的数据类型"></a>1. 说说 Redis 的数据类型</h2><p>Redis支持五种主要的数据类型：</p><ol><li><p><strong>String</strong>：String是最常用的数据类型，在Redis中以二进制安全的方式存储字符串。它可以包含任何类型的数据，比如文本、整数或二进制数据。</p></li><li><p><strong>Hash</strong>：Hash是一个键值对的集合，其中每个键都与一个值相关联。在Redis中，Hash可以用于存储和操作对象，每个键值对相当于对象的字段和值。</p></li><li><p><strong>List</strong>：List是一个按照插入顺序排序的字符串元素集合。集合中的元素可以重复，可以从列表的两端进行插入和删除操作，可用于实现队列、栈等数据结构。</p></li><li><p><strong>Set</strong>：Set是一个无序、唯一的字符串集合，不允许重复的成员。可以对集合执行添加、删除和判断成员是否存在等操作，也支持集合间的交集、并集和差集运算。</p></li><li><p><strong>Sorted Set</strong>：Sorted Set是一个有序的字符串集合，每个成员都关联着一个分数。集合中的成员根据分数的大小进行排序，可以进行范围查询和按分数排名操作。</p></li></ol><p>除了这些主要的数据类型，Redis还提供了其他一些特殊的数据结构和功能，如HyperLogLog用于基数统计、Geo用于地理位置信息存储、Pub/Sub用于发布与订阅等。&#x20;</p><h2 id="2-❓Redis底层数据结构？"><a href="#2-❓Redis底层数据结构？" class="headerlink" title="2.❓Redis底层数据结构？"></a>2.❓Redis底层数据结构？</h2><p><a href="https://xiaolincoding.com/redis/data_struct/command.html">Redis 常见数据类型和应用场景</a></p><p><img src="2025-01-09-Redis面试题/diagram-1.png" alt=""></p><p><a href="https://xiaolincoding.com/redis/data_struct/data_struct.html#%E9%94%AE%E5%80%BC%E5%AF%B9%E6%95%B0%E6%8D%AE%E5%BA%93%E6%98%AF%E6%80%8E%E4%B9%88%E5%AE%9E%E7%8E%B0%E7%9A%84">Redis 数据结构</a></p><p><img src="2025-01-09-Redis面试题/image-1.png" alt=""></p><h2 id="3-❓为什么用跳表，不用红黑树、B-树"><a href="#3-❓为什么用跳表，不用红黑树、B-树" class="headerlink" title="3.❓为什么用跳表，不用红黑树、B+树"></a>3.❓为什么用跳表，不用红黑树、B+树</h2><p>答：因为ZSet有一个核心功能是范围查找，采用跳表可以比较容易查找到一个范围的起点和终点（依次往后查找），而红黑树不行。且跳表比红黑树实现更简单，更容易实现，可以通过控制跳表的索引层级来控制内存的消耗。</p><h1 id="持久化"><a href="#持久化" class="headerlink" title="持久化"></a>持久化</h1><h2 id="1-说说Redis的持久化机制"><a href="#1-说说Redis的持久化机制" class="headerlink" title="1. 说说Redis的持久化机制"></a>1. 说说Redis的持久化机制</h2><p>Redis有两种持久化机制：RDB和AOF。</p><ul><li><p><strong>RDB</strong>：是一种快照持久化的方式，它会将Redis在某个时间点的数据状态以二进制的方式保存到硬盘上的一个文件中。RDB持久化可以通过配置定时或手动触发，也可以设置自动触发的条件。RDB的优点是生成的文件比AOF文件更小，恢复速度也更快，适合用于备份和灾难恢复。</p></li><li><p><strong>AOF</strong>：是一种追加日志持久化方式，它会将Redis执行的写命令追加到一个文件的末尾。当Redis重启时，它会重新执行这些写命令来恢复数据状态。AOF提供了更可靠的持久化方式，因为它可以保证每个写操作都被记录下来，并且不会发生数据丢失的情况。AOF文件可以根据配置进行同步写入硬盘的频率，包括每秒同步、每写入命令同步和禁用同步三种模式。&#x20;</p></li></ul><h2 id="2-AOF的三种写回策略？​"><a href="#2-AOF的三种写回策略？​" class="headerlink" title="2.AOF的三种写回策略？​"></a>2.AOF的三种写回策略？​</h2><p>Always、Everysec 和 No，这三种策略在可靠性上是从高到低，而在性能上从低到高。</p><p>Always是每次写操作命令执行完后，同步将 AOF 日志数据写回硬盘；Everysec每次写操作命令执行完后，先将命令写入到 AOF 文件的内核缓冲区，然后每隔一秒将缓冲区里的内容写回到硬盘；No就是不控制写回硬盘的时机。每次写操作命令执行完后，先将命令写入到 AOF 文件的内核缓冲区，再由操作系统决定何时将缓冲区内容写回硬盘。</p><h2 id="3-AOF的磁盘重写机制？​"><a href="#3-AOF的磁盘重写机制？​" class="headerlink" title="3.AOF的磁盘重写机制？​"></a>3.AOF的磁盘重写机制？​</h2><p>随着执行的命令越多，AOF 文件的体积自然也会越来越大，为了避免日志文件过大， Redis 提供了 AOF 重写机制，它会直接扫描数据中所有的键值对数据，然后为每一个键值对生成一条写操作命令，接着将该命令写入到新的 AOF 文件，重写完成后，就替换掉现有的 AOF 日志。重写的过程是由后台子进程完成的，这样可以使得主进程可以继续正常处理命令。</p><h2 id="4-AOF的重写的具体过程？​"><a href="#4-AOF的重写的具体过程？​" class="headerlink" title="4.AOF的重写的具体过程？​"></a>4.AOF的重写的具体过程？​</h2><p>触发重写机制后，主进程会创建重写 AOF 的子进程，此时父子进程共享物理内存，重写子进程只会对这个内存进行只读。重写 AOF 子进程读取数据库里的所有数据，并逐一把内存数据的键值对转换成一条命令，再将命令记录到重写日志。</p><p>在发生写操作的时候，操作系统才会去复制物理内存，这样是为了防止 fork 创建子进程时，由于物理内存数据的复制时间过长而导致父进程长时间阻塞的问题。</p><h2 id="5-为什么先执行Redis命令，再把数据写入AOF日志呢？"><a href="#5-为什么先执行Redis命令，再把数据写入AOF日志呢？" class="headerlink" title="5.为什么先执行Redis命令，再把数据写入AOF日志呢？"></a>5.为什么先执行Redis命令，再把数据写入AOF日志呢？</h2><p>好处:</p><ul><li><p>保证正确写入：如果当前的命令语法有问题，错误的命令记录到AOF日志里后可能还会进行语法检查。先执行Redis命令，再把数据写入AOF日志可以保证写入的都是正确可执行的命令。</p></li><li><p>不阻塞当前写操作：因为当写操作命令执行成功后才会将命令记录到AOF日志，避免写入阻塞。</p></li></ul><p>缺陷：</p><ul><li><p>数据可能会丢失：执行写操作命令和记录日志是两个过程，Redis还没来得及将命令写入到硬盘时发生宕机，数据会有丢失的风险。</p></li><li><p>阻塞其他操作：不会阻塞当前命令的执行，但因为AOF日志也是在主线程中执行，所以当Redis把日志文件写入磁盘的时候，还是会阻塞后续的操作无法执行。&#x20;</p></li></ul><h2 id="6-AOF子进程的内存数据跟主进程的内存数据不一致怎么办？​"><a href="#6-AOF子进程的内存数据跟主进程的内存数据不一致怎么办？​" class="headerlink" title="6.AOF子进程的内存数据跟主进程的内存数据不一致怎么办？​"></a>6.AOF子进程的内存数据跟主进程的内存数据不一致怎么办？​</h2><p>Redis设置了一个 AOF 重写缓冲区，这个缓冲区在创建 bgrewriteaof 子进程之后开始使用。在重写 AOF 期间，当 Redis 执行完一个写命令之后，它会同时将这个写命令写入到AOF 缓冲区和AOF 重写缓冲区。当子进程完成 AOF 重写工作后，会向主进程发送一条信号。主进程收到该信号后，会调用一个信号处理函数，将 AOF 重写缓冲区中的所有内容追加到新的 AOF 的文件中，使得新旧两个 AOF 文件所保存的数据库状态一致；新的 AOF 的文件进行改名，覆盖现有的 AOF 文件。</p><h2 id="7-RDB-在执行快照的时候，数据能修改吗？​"><a href="#7-RDB-在执行快照的时候，数据能修改吗？​" class="headerlink" title="7.RDB 在执行快照的时候，数据能修改吗？​"></a>7.RDB 在执行快照的时候，数据能修改吗？​</h2><p>可以。执行 bgsave 过程中，Redis 依然可以继续处理操作命令的，数据是能被修改的，采用的是写时复制技术（Copy-On-Write, COW）。执行 bgsave 命令的时候，会通过 fork（）创建子进程，此时子进程和父进程是共享同一片内存数据的，因为创建子进程的时候，会复制父进程的页表，但是页表指向的物理内存还是一个，由于共享父进程的所有数据，可以直接读取主线程里的内存数据，并将数据写入到 RDB 文件。此时如果主线程执行读操作，则主线程和 bgsave 子进程互相不影响。如果主线程要修改共享数据里的某一块数据，就会发生写时复制，数据的物理内存就会被复制一份，主线程在这个数据副本进行修改操作。与此同时，子进程可以继续把原来的数据写入到 RDB 文件。</p><h2 id="11-说说Redis的过期策略"><a href="#11-说说Redis的过期策略" class="headerlink" title="11. 说说Redis的过期策略"></a>11. 说说Redis的过期策略</h2><p>对于redis的数据，如果过期了，并不会立刻自动取删除他，主要有两种方案，第一种惰性删除，只有当我们下一次再查询他的时候，发现他已经过期了，再删除，否则会常驻在内存中，优点是减少删除的开销，但是会浪费内存。</p><p>第二种是：定期删除，redis每个一段时间内，会去检查哪些key已经过期，然后释放过期key占用的空间</p><p>第三种：一般来说我们会配合二者一起使用</p><p><strong>Redis 选择惰性删除+定期删除这两种策略配和使用</strong>，以求在合理使用 CPU 时间和避免内存浪费之间取得平衡。Redis 在访问或者修改 key 之前，都会调用 expireIfNeeded 函数对其进行检查，检查 key 是否过期：​如果过期，则删除该 key，然后返回 null 客户端；​如果没有过期，不做任何处理，然后返回正常的键值对给客户端；​</p><p>每隔一段时间，从过期字典中随机抽取 20 个 key；检查这 20 个 key 是否过期，并删除已过期的 key；已过期 key 的数量占比随机抽取 key 的数量大于 25%，则继续重复步骤直到比重小于25%。</p><h2 id="12-说说Redis的内存淘汰策略"><a href="#12-说说Redis的内存淘汰策略" class="headerlink" title="12.说说Redis的内存淘汰策略"></a>12.说说Redis的内存淘汰策略</h2><p><strong>不进行数据淘汰的策略</strong></p><p>它表示当运行内存超过最大设置内存时，不淘汰任何数据，这时如果有新的数据写入，则会触发OOM，只是单纯的查询或者删除操作的话还是可以正常工作。</p><p><strong>进行数据淘汰的策略</strong></p><p>在设置了过期时间的数据中进行淘汰：</p><p>在所有数据范围内进行淘汰：</p><h2 id="13-Redis持久化时对过期键会如何处理的？​"><a href="#13-Redis持久化时对过期键会如何处理的？​" class="headerlink" title="13.Redis持久化时对过期键会如何处理的？​"></a>13.Redis持久化时对过期键会如何处理的？​</h2><p><strong>RDB</strong></p><p>RDB分文生成阶段和加载阶段，生成阶段会对key进行过期检查，过期的key不会保存到RDB文件中；加载阶段看服务器是主服务器还是从服务器，如果是主服务器，在载入 RDB 文件时，程序会对文件中保存的键进行检查，过期键不会被载入到数据库中；如果从服务器，在载入 RDB 文件时，不论键是否过期都会被载入到数据库中。但由于主从服务器在进行数据同步时，从服务器的数据会被清空。过期键对载入 RDB 文件的从服务器也不会造成影响。</p><p><strong>AOF</strong></p><p>AOF文件写入阶段和AOF重写阶段。写入阶段如果数据库某个过期键还没被删除，AOF 文件会保留此过期键，当此过期键被删除后，Redis 会向 AOF 文件追加一条 DEL 命令来显式地删除该键值。重写阶段会对 Redis 中的键值对进行检查，已过期的键不会被保存到重写后的 AOF 文件中。</p><h2 id="14-Redis主从模式中，对过期键会如何处理？"><a href="#14-Redis主从模式中，对过期键会如何处理？" class="headerlink" title="14.Redis主从模式中，对过期键会如何处理？"></a>14.Redis主从模式中，对过期键会如何处理？</h2><p>从库不会进行过期扫描，从库的过期键处理依靠主服务器控制，主库在 key 到期时，会在 AOF 文件里增加一条 del 指令，同步到所有的从库，从库通过执行这条 del 指令来删除过期的 key。</p><p>如果主从同步发生意外，原本主库的 key 过期了，但是 del 指令没有同步给从库成功，导致从库内存中存在已经过期但没有删除的 key，这时候有客户端访问从库时，即使 key 还是在内存的，但是从库发现 key 是过期（根据过期时间）的，就不会返回 key 的数据给客户端了。</p><h1 id="应用"><a href="#应用" class="headerlink" title="应用"></a>应用</h1><h2 id="1-Redis有哪些常用应用场景"><a href="#1-Redis有哪些常用应用场景" class="headerlink" title="1. Redis有哪些常用应用场景"></a>1. Redis有哪些常用应用场景</h2><ol><li><p><strong>缓存</strong>：Redis可以作为缓存层，加速访问频繁的数据。由于其高性能、支持持久化和数据结构丰富等特点，使其成为一个理想的缓存解决方案。在缓存方面，Redis能够存储热点数据、频繁查询结果、会话数据等，从而减轻数据库负载，提高系统整体性能。</p></li><li><p><strong>会话存储</strong>：Redis可以用于存储用户会话数据，特别是在分布式系统中，多个服务器之间共享会话数据非常方便。这在网站、应用程序中管理用户登录状态、购物车信息等方面非常有用。</p></li><li><p><strong>消息队列</strong>：Redis的发布/订阅功能以及List数据结构的弹性特性，使其可以作为轻量级消息队列使用。应用程序可以将消息发布到Redis，而其他应用程序可以订阅这些消息并处理它们，实现解耦和异步通信。</p></li><li><p><strong>计数器</strong>：Redis的原子操作和计数器数据结构使其成为实现各种计数功能的理想选择。比如，可以用来统计网站的点击量、点赞数、在线用户数等。</p></li><li><p><strong>实时排行榜</strong>：Redis的有序集合数据结构非常适合实现实时排行榜功能。通过将用户得分作为有序集合的成员，可以轻松地获取排行榜数据并支持快速的更新。</p></li><li><p><strong>分布式锁</strong>：Redis的SETNX命令可以用来实现分布式锁，保证在分布式环境下对共享资源的互斥访问。</p></li><li><p><strong>分布式状态存储</strong>：除了会话数据，Redis还可以用来存储应用程序的状态信息，比如用户的偏好设置、临时状态等。&#x20;</p></li></ol><h2 id="2-什么是缓存击穿、缓存穿透、缓存雪崩"><a href="#2-什么是缓存击穿、缓存穿透、缓存雪崩" class="headerlink" title="2. 什么是缓存击穿、缓存穿透、缓存雪崩"></a>2. 什么是缓存击穿、缓存穿透、缓存雪崩</h2><p><img src="2025-01-09-Redis面试题/image14.png" alt=""></p><p><a href="https://ls8sck0zrg.feishu.cn/wiki/IqzrwXjITiFZ6mkqQoHcsPq8nkg#share-N16YdrTvOo1CyVxr2ttcxJR1n0d">https://ls8sck0zrg.feishu.cn/wiki/IqzrwXjITiFZ6mkqQoHcsPq8nkg#share-N16YdrTvOo1CyVxr2ttcxJR1n0d</a></p><h2 id="3-布隆过滤器是怎么工作的？"><a href="#3-布隆过滤器是怎么工作的？" class="headerlink" title="3.布隆过滤器是怎么工作的？"></a>3.布隆过滤器是怎么工作的？</h2><p>布隆过滤器由初始值都为0的位图数组和N个哈希函数两部分组成。在写入数据库数据时，在布隆过滤器里做个标记，这样下次查询数据是否在数据库时，只需要查询布隆过滤器，如果查询到数据没有被标记，说明不在数据库中。</p><ul><li><p>第一步，使用N个哈希函数分别对数据做哈希计算，得到N个哈希值</p></li><li><p>第二步，将第一步得到的N个哈希值对位图数组的长度取模，得到每个哈希值在位图数组的对应位置</p></li><li><p>第三步，将每个哈希值在位图数组的对应位置的值设置为1、</p></li></ul><p>缺陷</p><ul><li><p>布隆过滤器由于是基于哈希函数实现查找的，会存在哈希冲突的可能性，数据可能落在相同位置，存在误判的情况。查询布隆过滤器说数据存在，并不一定证明数据库中存在这个数据，但是查询到数据不存在，数据库中一定就不存在这个数据。</p></li><li><p>不支持一个关键字的删除，因为一个关键字的删除会牵连其他的关键字。改进方法就是counting Bloom filter，用一个counter数组代替位数组，就可以支持删除了。</p></li><li><p>对于输入的n个元素，要确定数组m大小和hash函数的个数，hash函数个数k = (ln2) * (m/n) 时，错误率最小。在错误率不大于E情况下，m至少要等于n*lg(1/E)才能表示n个元素的集合。&#x20;</p></li></ul><h2 id="4-如何保证数据库和缓存的一致性？"><a href="#4-如何保证数据库和缓存的一致性？" class="headerlink" title="4.如何保证数据库和缓存的一致性？"></a>4.如何保证数据库和缓存的一致性？</h2><p><a href="https://mcnfxurl5vzo.feishu.cn/wiki/Tfj8wjNOei9by3kjWjVcL0pwn5g#share-ZIJvdlLucoi7wyxvThSc9iPFnbc"> 11.场景题</a></p><h3 id="Cache-Aside"><a href="#Cache-Aside" class="headerlink" title="Cache Aside"></a>Cache Aside</h3><ul><li><p>原理：<strong>先从缓存中读取数据，如果没有就再去数据库里面读数据，然后把数据放回缓存中，如果缓存中可以找到数据就直接返回数据；</strong>&#x66F4;新数据的时候先把数据持久化到数据库，然后再让缓存失效。</p></li><li><p>问题：假如有两个操作一个更新一个查询，第一个操作先更新数据库，还来不及删除缓存，查询操作可能拿到的就是旧的数据；更新操作马上让缓存失效了，所以后续的查询可以保证数据的一致性；<strong>还有的问题就是有一个是读操作没有命中缓存，然后就到数据库中取数据，此时来了一个写操作，写完数据库后，让缓存失效，然后，之前的那个读操作再把老的数据放进去，也会造成脏数据。</strong></p></li><li><p>可行性：出现上述问题的概率其实非常低，需要同时达成读缓存时缓存失效并且有并发写的操作。数据库读写要比缓存慢得多，所以读操作在写操作之前进入数据库，并且在写操作之后更新，概率比较低。</p></li></ul><h3 id="Read-Write-Through"><a href="#Read-Write-Through" class="headerlink" title="Read/Write Through"></a>Read/Write Through</h3><ul><li><p>原理：Read/Write Through原理是把更新数据库（Repository）的操作由缓存代理，应用认为后端是一个单一的存储，而存储自己维护自己的缓存。</p></li><li><p>Read Through：就是在查询操作中更新缓存，也就是说，当缓存失效的时候，Cache Aside策略是由调用方负责把数据加载入缓存，而Read Through则用缓存服务自己来加载，从而对调用方是透明的。</p></li><li><p>Write Through：当有数据更新的时候，如果没有命中缓存，直接更新数据库，然后返回。如果命中了缓存，则更新缓存，然后再由缓存自己更新数据库（这是一个同步操作）。&#x20;</p></li></ul><h3 id="Write-Behind"><a href="#Write-Behind" class="headerlink" title="Write Behind"></a>Write Behind</h3><p>原理：在更新数据的时候，只更新缓存，不更新数据库，而缓存会异步地批量更新数据库。这个设计的好处就是让数据的I/O操作非常快，带来的问题是，数据不是强一致性的，而且可能会丢。</p><h2 id="5-如何保证删除缓存操作一定能成功？​"><a href="#5-如何保证删除缓存操作一定能成功？​" class="headerlink" title="5.如何保证删除缓存操作一定能成功？​"></a>5.如何保证删除缓存操作一定能成功？​</h2><p><strong>重试机制</strong></p><p>引入消息队列，删除缓存的操作由消费者来做，删除失败的话重新去消息队列拉取相应的操作，超过一定次数没有删除成功就像业务层报错。</p><p><strong>订阅BINLog</strong></p><p>订阅 binlog 日志，拿到具体要操作的数据，然后再执行缓存删除。可以让删除服务模拟自己伪装成一个 MySQL 的从节点，向 MySQL 主节点发送 dump 请求，主节点收到请求后，就会开始推送 BINLog ，删除服务解析 BINLog 字节流之后，转换为便于读取的结构化数据，再进行删除。</p><p>订阅bin log会跟 mq 结合一起用，通过 订阅bin log知道数据发生更新，然后投递给消息队列，然后让消息队列重试。</p><h2 id="6-业务一致性要求高怎么办？"><a href="#6-业务一致性要求高怎么办？" class="headerlink" title="6.业务一致性要求高怎么办？"></a>6.业务一致性要求高怎么办？</h2><p><strong>先更新数据库再更新缓存</strong></p><p>可以先更新数据库再更新缓存，但是可能会有并发更新的缓存不一致的问题。解决办法是更新缓存前加一个分布式锁，保证同一时间只运行一个请求更新缓存，加锁后对于写入的性能就会带来影响；在更新完缓存时，给缓存加上较短的过期时间，出现缓存不一致的情况缓存的数据也会很快过期。</p><p><strong>延迟双删</strong></p><p>采用延迟双删，先删除缓存，然后更新数据库，等待一段时间再删除缓存。保证第一个操作再睡眠之后，第二个操作完成更新缓存操作。但是具体睡眠多久其实是个玄学，很难评估出来，这个方案也只是尽可能保证一致性而已，依然也会出现缓存不一致的现象。</p><p>提示：最好给锁设置过期时间防止阻塞。</p><blockquote><p><a href="https://ls8sck0zrg.feishu.cn/wiki/wikcnEJdzUmS3CgUHXUCjJY5Iad">https://ls8sck0zrg.feishu.cn/wiki/wikcnEJdzUmS3CgUHXUCjJY5Iad</a></p><p><a href="https://xiaolincoding.com/redis/architecture/mysql_redis_consistency.html#%E6%95%B0%E6%8D%AE%E5%BA%93%E5%92%8C%E7%BC%93%E5%AD%98%E5%A6%82%E4%BD%95%E4%BF%9D%E8%AF%81%E4%B8%80%E8%87%B4%E6%80%A7">数据库和缓存如何保证一致性？</a></p></blockquote><h2 id="7-⭐️说说你对缓存双写不一致的理解"><a href="#7-⭐️说说你对缓存双写不一致的理解" class="headerlink" title="7. ⭐️说说你对缓存双写不一致的理解"></a>7. ⭐️说说你对缓存双写不一致的理解</h2><p><strong>缓存不一致</strong>主要是指我们的业务系统里面引入了缓存提升我们查询性能，但是当我们数据库数据发生变更的时候，我们如何去保证缓存和数据库中数据的一致性问题，主要有两大种方案。</p><p>首先是异步通知，可以利用canal监听我们mysql的数据变化，然后发送变更缓存消息到mq，让业务系统去对缓存进行更新，由于我们一般监听binlog都是在从mysql上进行，而主从同步有一定的延时，监听完消息发送到mq又存在一定的延时，所以他的实时性不是很好，比较适合用在一致性要求不是很高的缓存场景，并且异步通知最大的优点就是解耦，对于更新缓存的逻辑不需要耦合在代码中<br>第二种方案也是得物使用规范的中最推荐的同步双写，之所以使用这种方案，就是非常多的业务中都涉及到钱相关，如果缓存长时间不一致容易造成大量的资损，比如：我们商品中心大量商品数据进行了缓存，此时我们管理员修改了价格，这个缓存怎么同步，其实就是缓存一致性的问题，对于这种一致性比较高的业务，我们推荐最佳方案是采用延时双删，先删缓存，然后写数据库，然后过500ms再删一次缓存，这种方案能够尽可能避免出现缓存不一致的问题，但是也是无法完全避免，因为可能出现一些极端情况，比如出现了慢SQL，查了半天还是旧数据，结果我们双删也删完了，他又走了旧数据的逻辑，但是这种都可以通过监控来进行优化，尽最大可能不出现问题。</p><p>如果想要保证强一致性，其实方案就是使用读写锁来保证了，但是一般C端业务，优先考虑用户体验性，如果不是直接操作钱一般不使用这种方案。</p><p><img src="2025-01-09-Redis面试题/image.png" alt=""></p><h2 id="8-如何实现延迟队列？"><a href="#8-如何实现延迟队列？" class="headerlink" title="8.如何实现延迟队列？"></a>8.如何实现延迟队列？</h2><p>使用ZSet，ZSet有一个Score属性可以用来存储延迟执行的时间。使用zadd score1 value1命令，再利用zrangebyscore查询符合条件的所有待处理的任务，通过循环执行队列任务。</p><h2 id="9-如何设计一个缓存策略，可以动态缓存热点数据呢？"><a href="#9-如何设计一个缓存策略，可以动态缓存热点数据呢？" class="headerlink" title="9.如何设计一个缓存策略，可以动态缓存热点数据呢？"></a>9.如何设计一个缓存策略，可以动态缓存热点数据呢？</h2><p>由于数据存储受限，系统并不是将所有数据都需要存放到缓存中的，而只是将其中一部分热点数据缓存起来，所以我们要设计一个热点数据动态缓存的策略。</p><p>热点数据动态缓存的策略总体思路：<strong>通过数据最新访问时间来做排名，并过滤掉不常访问的数据，只留下经常访问的数据。用zadd方法和zrange方法来完成排序队列和获取前面商品。</strong></p><p>例子：</p><p>以电商平台场景中的例子，现在要求只缓存用户经常访问的Top 1000的商品。具体细节如下：</p><ul><li><p>先通过缓存系统做一个排序队列（比如存放1000个商品），系统会根据商品的访问时间，更新队列信息，越是最近访问的商品排名越靠前；</p></li><li><p>同时系统会定期过滤掉队列中排名最后的200个商品，然后再从数据库中随机读取出200个商品加入队列中；</p></li><li><p>当请求每次到达的时候，会先从队列中获取商品ID，如果命中，就根据ID再从另一个缓存数据结构中读取实际的商品信息，并返回。&#x20;</p></li></ul><h2 id="10-⭐️分布式锁原理和潜在风险"><a href="#10-⭐️分布式锁原理和潜在风险" class="headerlink" title="10.⭐️分布式锁原理和潜在风险"></a>10.⭐️分布式锁原理和潜在风险</h2><blockquote><p><a href="https://ls8sck0zrg.feishu.cn/wiki/Kdz7wj1g8il0SXkviJNcYDKEnHf">https://ls8sck0zrg.feishu.cn/wiki/Kdz7wj1g8il0SXkviJNcYDKEnHf</a></p></blockquote><ol><li><p><strong>Redis实现分布式锁原理</strong>：一个客户端想要加锁，就会去Redis中查找对应的key是否存在，如果不存在，就创建这个key，表示加锁成功，当另外一个客户端也想加锁时，发现这个key已经存在了，就会返回加锁失败。可以采用setnx命令将查询是否存在 - 创建key这个过程变成一个原子操作，或者使用Lua脚本，让Redis单线程执行这个脚本。</p></li><li><p><strong>潜在风险1</strong>：当一个客户端成功执行setnx进行加锁之后，结果执行del命令释放锁，却一直没有成功，导致锁没有释放，其他客户端无法获取锁，从而影响业务。</p><ul><li><strong>解决方法</strong>：给这个锁设置过期时间，当超过过期时间时，Redis会自动将其释放，可以采用setnx命令的nx参数，再使用px参数设置毫秒过期时间，或者ex参数（这是秒过期时间）。</li></ul></li><li><p><strong>潜在风险2</strong>：当客户端A成功加锁之后，但却被客户端B使用del命令进行删除，而如果马上有其他客户端来获取锁，就会和客户端A一起共享数据，造成业务逻辑错误。</p><ul><li><strong>解决方法</strong>：给这个锁对应的Value设置一个唯一标识，保证每个客户端的唯一标识不同，当删除锁的时候，需要先检查这个value是否与客户端标识一致才能进行删除。而这也导致删除锁操作变成了读取变量、判断变量、删除变量多个操作，需要保证执行的原子性，所以这里也需要整合Lua脚本，发送给Redis单线程执行。&#x20;</li></ul></li><li><p><strong>潜在风险3</strong>：当锁的过期时间已经到了，但业务还没有完成。</p><ul><li><strong>解决方法</strong>：启动一个看门狗（go启动一个goroutine），在过期之前刷新一下过期时间。&#x20;</li></ul></li></ol><h2 id="11-使用Redis实现分布式锁的优点和缺点"><a href="#11-使用Redis实现分布式锁的优点和缺点" class="headerlink" title="11.使用Redis实现分布式锁的优点和缺点?"></a>11.使用Redis实现分布式锁的优点和缺点?</h2><ul><li><p>优点：性能高效；实现方便；避免单点故障。</p></li><li><p>缺点：超时时 间不好设置。如果锁的超时间设置过长，会影响性能，如果设置的超时间过短会保护不到共享资源。Redis主从复制模式中的数据是异步复制的，导致分布式锁的不可靠性。如果在Redis主节点获取到锁后，在没有同步到其他节点时，Redis主节点宕机了，此时新的Redis主节点依然可以获取锁，所以多个应用服务就可以同时获取到锁。</p></li></ul><h2 id="12-如何为分布式锁设置合理的超时时间"><a href="#12-如何为分布式锁设置合理的超时时间" class="headerlink" title="12.如何为分布式锁设置合理的超时时间?"></a>12.如何为分布式锁设置合理的超时时间?</h2><p>可以基于续约的方式设置超时时间：先给锁设置一个超时时间，然后启动一个守护线程，让守护线程在一段时间后，重新设置这个锁的超时时间。实现方式就是：写一个守护线程，然后去判断锁的情况，当锁快失效的时候，再次进行续约加锁，当主线程执行完成后，销毁续约锁即可，不过这种方式实现起来相对复杂。&#x20;</p><h2 id="13-❓Redis解决集群情况下分布式锁的可靠性"><a href="#13-❓Redis解决集群情况下分布式锁的可靠性" class="headerlink" title="13.❓Redis解决集群情况下分布式锁的可靠性?"></a>13.❓Redis解决集群情况下分布式锁的可靠性?</h2><p>分布式锁算法Redlock（红锁）。基于多个Redis节点的分布式锁，即使有节点发生了故障，锁变量仍然是存在的，客户端还是可以完成锁操作。官方推荐是至少部署5个Redis节点，而且都是主节点，它们之间没有任何关系，都是一个个孤立的节点。</p><p><strong>基本思路：</strong>&#x662F;让客户端和多个独立的Redis节点依次请求申请加锁，<strong>如果客户端能够和半数以上的节点成功地完成加锁操作，那么就认为，客户端成功地获得分布式锁</strong>，否则加锁失败。即使有某个Redis节点发生故障，锁的数据在其他节点上也有保存，客户端仍然可以正常地进行锁操作，锁的数据也不会丢。</p><p>Redlock算法加锁三个过程：</p><p>加锁成功要同时满足两个条件：有超过半数的Redis节点成功的获取到了锁，并且总耗时没有超过锁的有效时间，那么就是加锁成功。</p><p>加锁成功后，客户端需要重新计算这把锁的有效时间，计算的结果是「锁最初设置的过期时间」减去「客户端从大多数节点获取锁的总耗时（t2-t1）」。如果计算的结果已经来不及完成共享数据的操作了，可以释放锁，以免出现还没完成数据操作，锁就过期了的情况。加锁失败后，客户端向所有Redis节点发起释放锁的操作，执行释放锁的Lua脚本就可以。&#x20;</p><h2 id="14-Redis管道有什么用？"><a href="#14-Redis管道有什么用？" class="headerlink" title="14.Redis管道有什么用？"></a>14.Redis管道有什么用？</h2><p>管道技术是客户端提供的一种批处理技术，用于一次处理多个 Redis 命令，从而提高整个交互的性能。使用管道技术可以解决多个命令执行时的网络等待，它是把多个命令整合到一起发送给服务器端处理之后统一返回给客户端，这样就免去了每条命令执行后都要等待的情况，从而有效地提高了程序的执行效率。</p><p>但使用管道技术也要注意避免发送的命令过大，或管道内的数据太多而导致的网络阻塞。管道技术本质上是客户端提供的功能，而非 Redis 服务器端的功能。</p><blockquote><p>Redis 的IO多路复用用的是管道？</p><h2 id="说说你对PIPELINE的理解"><a href="#说说你对PIPELINE的理解" class="headerlink" title="说说你对PIPELINE的理解"></a>说说你对PIPELINE的理解</h2><p>redis本端网络通信使用的是Redis协议，本质上是把我们的命令通过协议包装发送给redis，需要经过编码解码和网络传输的过程。如果每次发送的数据较少，能够把时间消耗在解码和拆包的时间短，时间全浪费在这些时间上了，此时我们就可以使用<strong>pipeline，单次网络通信传输一堆指令，减少网络通信来回的次数。&#x20;</strong></p></blockquote><h2 id="15-Redis如何处理大key"><a href="#15-Redis如何处理大key" class="headerlink" title="15.Redis如何处理大key?"></a>15.Redis如何处理大key?</h2><p><strong>定义：String类型的值大于10 KB；Hash、List、Set、ZSet类型的元素的个数超过5000个；</strong></p><p><strong>影响：</strong></p><p><strong>处理：</strong></p><ul><li><p>把大key拆分成多个小key来存储。比如把一个大的哈希结构分割成多个小的哈希结构，减少单个key的大小以降低内存的压力。</p><ul><li><p>当value是string时，比较难拆分，则使用序列化、压缩算法将key的大小控制在合理范围内，但是序列化和反序列化都会带来更多时间上的消耗。</p></li><li><p>当value是string，压缩之后仍然是大key，则需要进行拆分，一个大key分为不同的部分，记录每个部分的key，使用multiget等操作实现事务读取。</p></li><li><p>分拆成几个key-value，存储在一个hash中，每个field代表一个具体的属性，使用hget，hmget来获取部分的value，使用hset，hmset更新部分属性</p></li><li><p>当value是list/set等集合类型时，根据预估的数据规模来进行分片，不同的元素计算后分到不同的片。&#x20;</p></li></ul></li><li><p>搭建redis集群，把key分配到不同的节点上，降低单个redis节点的存储压力。</p></li></ul><h2 id="16-Redis支持事务回滚吗？"><a href="#16-Redis支持事务回滚吗？" class="headerlink" title="16.Redis支持事务回滚吗？"></a>16.Redis支持事务回滚吗？</h2><p>不支持，Redis 提供的 DISCARD 命令只能用来主动放弃事务执行，把暂存的命令队列清空，起不到回滚的效果。因为Redis 事务的执行时，错误通常都是编程错误造成的，这种错误通常只会出现在开发环境中，而很少会在实际的生产环境中出现，所以官方认为没有必要为 Redis 开发事务回滚功能。</p><h2 id="17-Redis到底支不支持事务啊？"><a href="#17-Redis到底支不支持事务啊？" class="headerlink" title="17. Redis到底支不支持事务啊？"></a>17. Redis到底支不支持事务啊？</h2><p><img src="2025-01-09-Redis面试题/image22.png" alt=""></p><p><img src="2025-01-09-Redis面试题/image23.png" alt=""></p><p>Redis 支持事务。</p><p>Redis 事务可以让一系列命令按顺序执行，在执行过程中不会被其他客户端的命令打断。</p><p>Redis 事务使用 <code>MULTI</code> 命令开启，然后将多个命令放入事务中，最后使用 <code>EXEC</code> 命令执行事务。</p><p>需要注意的是，Redis 事务不支持回滚，即在事务执行过程中，如果某条命令执行失败，不会影响已经执行成功的命令，也不会回滚整个事务。但从 Redis 2.6 版本开始，增加了对乐观锁的支持，通过 <code>WATCH</code> 命令可以在事务执行前监视一些键，如果在事务执行过程中这些键被其他客户端修改，事务会执行失败。</p><h1 id="高可用"><a href="#高可用" class="headerlink" title="高可用"></a>高可用</h1><p><img src="2025-01-09-Redis面试题/diagram-2.png" alt=""></p><h2 id="1-REDIS-集群的原理是什么"><a href="#1-REDIS-集群的原理是什么" class="headerlink" title="1. REDIS 集群的原理是什么"></a>1. REDIS 集群的原理是什么</h2><p>Redis集群通过<strong>数据分片和主从复制</strong>实现了横向扩展和高可用性。它将<strong>数据划分为16384个哈希槽</strong>，并将这些槽均匀地分配到多个节点上。每个节点负责处理一部分槽的数据，实现了数据的分散存储和负载均衡。</p><p>在集群中，<strong>每个哈希槽有一个主节点和多个从节点</strong>。主节点负责处理读写请求，而从节点则通过主从复制机制复制主节点的数据，提供数据的冗余备份和故障恢复功能。</p><p>当主节点发生故障时，集群会自动进行故障转移。它会选举一个从节点升级为新的主节点，保证服务的持续可用性。同时，集群管理节点负责监控节点的状态，并协调故障转移过程。</p><p><strong>客户端在与Redis集群交互时，根据键的哈希值将请求发送到相应的节点。客户端还可以通过集群管理节点获取整个集群的拓扑信息，了解哪些键存储在哪个节点上。</strong></p><p>通过数据分片和主从复制，Redis集群实现了数据水平切分、负载均衡和高可用性。它允许数据规模和吞吐量的线性扩展，并能自动处理节点故障。集群管理节点协调集群状态，客户端通过哈希映射与集群交互，从而实现了一个稳定和可靠的Redis分布式系统。&#x20;</p><p><img src="2025-01-09-Redis面试题/image16.png" alt=""></p><h2 id="2-REDIS集群方案什么情况下会导致整个集群不可用"><a href="#2-REDIS集群方案什么情况下会导致整个集群不可用" class="headerlink" title="2. REDIS集群方案什么情况下会导致整个集群不可用"></a>2. REDIS集群方案什么情况下会导致整个集群不可用</h2><ol><li><p>多个主节点同时故障：如果多个主节点同时发生故障，而且它们的从节点无法升级为新的主节点，那么整个集群将无法提供读写服务。</p></li><li><p>集群管理节点故障：集群管理节点负责监控集群状态和协调故障转移操作。如果集群管理节点发生故障，并且无法及时恢复或替换，那么集群将失去管理和协调能力，可能导致集群不可用。</p></li><li><p>网络分区：如果集群中的节点之间发生网络分区，即无法互相通信，那么可能会引起脑裂（split - brain）问题。在这种情况下，每个分区内的节点可能会认为自己是合法的Redis集群，导致数据冲突和不一致性，最终导致整个集群无法正常工作。</p></li><li><p>配置错误：如果Redis集群的配置出现错误或者某些节点的配置不一致，可能导致集群无法正常运行。</p></li><li><p>内存不足：如果集群中的某个节点的内存不足以容纳当前处理的数据量，可能会导致该节点性能下降甚至崩溃，从而影响整个集群的可用性。&#x20;</p></li></ol><h2 id="3-⭐️REDIS集群会有写操作丢失吗？为什么"><a href="#3-⭐️REDIS集群会有写操作丢失吗？为什么" class="headerlink" title="3. ⭐️REDIS集群会有写操作丢失吗？为什么"></a>3. ⭐️REDIS集群会有写操作丢失吗？为什么</h2><p>在Redis集群中，由于采用了主从复制模型的异步复制机制，写操作有一定的丢失风险。</p><p>当客户端向主节点发送写操作时，主节点会立即返回成功响应，而不等待所有从节点执行复制。如果主节点在执行完写操作后出现故障或网络问题，导致从节点无法及时接收到复制操作，那么这些未复制的写操作将会丢失。&#x20;</p><h2 id="4-主从模式的同步过程？"><a href="#4-主从模式的同步过程？" class="headerlink" title="4.主从模式的同步过程？"></a>4.主从模式的同步过程？</h2><h3 id="第一次同步"><a href="#第一次同步" class="headerlink" title="第一次同步"></a>第一次同步</h3><p>主要分为建立连接协商、主从数据同步、发送新操作三个步骤：</p><ul><li><p>连接协商：从服务器先发送命令给主服务器表示要进行数据同步，命令内容包括主服务器的runID和复制进度两个参数，主服务器收到命令之后会给从服务响应命令，响应包括主服务器的runID和复制进度。从服务器收到响应之后会记录这两个值。</p></li><li><p>主从数据同步：主服务器生成RDB文件并发送给从服务器，从服务器收到RDB之后先清空自己的数据，再载入RDB文件。为了主从数据的一致性，这个期间主服务器后续的写操作会记录到replication buffer缓冲区里。</p></li><li><p>发送新操作：主服务器发送replication buffer里面的写操作给从服务器，从服务器执行这些操作。第一次同步完成。</p></li></ul><h3 id="命令传播"><a href="#命令传播" class="headerlink" title="命令传播"></a>命令传播</h3><p>第一次同步完成之后双方会维护一个TCP连接，后续主服务器的写命令通过TCP连接发送给从服务器，保证主从一致。</p><h3 id="压力分摊"><a href="#压力分摊" class="headerlink" title="压力分摊"></a>压力分摊</h3><p>为了分摊服务器的压力，生成和传输RDB的工作可以分摊到经理从服务器上。</p><h3 id="增量复制"><a href="#增量复制" class="headerlink" title="增量复制"></a>增量复制</h3><p>如果服务器网路断开，在恢复之后，会把网络断开期间主服务器接收到的写操作命令同步给从服务器。&#x20;</p><h2 id="5-主服务器如何知道要将哪些增量数据发送给从服务器？"><a href="#5-主服务器如何知道要将哪些增量数据发送给从服务器？" class="headerlink" title="5.主服务器如何知道要将哪些增量数据发送给从服务器？"></a>5.主服务器如何知道要将哪些增量数据发送给从服务器？</h2><p>网络断开从服务器重新上线之后，会发送自己的复制偏移量到主服务器，主服务器根据偏移量之间的差距判断要执行的操作：如果从服务器要读的数据在repl_backlog_buffe中，则采用增量复制；如果不在，采用全量复制。</p><blockquote><p>什么是repl_backlog_buffer？​</p><p>repl_backlog_buffer是一个环形缓冲区，用于主从服务器断连后，从中找到差异的数据；replication offset标记缓冲区的同步进度。</p></blockquote><h2 id="6-如何避免主从数据的不一致？"><a href="#6-如何避免主从数据的不一致？" class="headerlink" title="6.如何避免主从数据的不一致？"></a>6.如何避免主从数据的不一致？</h2><p>让主从节点处于同一机房，降低网络延迟；或者由外部程序监控主从复制进度：先计算得出主从服务之间的复制进度差，如果复制进度差大于程序设定的阈值，让客户端不再在此节点读取数据，减小数据不一致的情况对业务的影响。</p><p>为了避免出现客户端和所有从节点都不能连接的情况，需要把复制进度差值的阈值设置得大一些。</p><p><a href="https://learn.lianglianglee.com/%E4%B8%93%E6%A0%8F/Redis%20%E6%A0%B8%E5%BF%83%E6%8A%80%E6%9C%AF%E4%B8%8E%E5%AE%9E%E6%88%98/32%20%20Redis%E4%B8%BB%E4%BB%8E%E5%90%8C%E6%AD%A5%E4%B8%8E%E6%95%85%E9%9A%9C%E5%88%87%E6%8D%A2%EF%BC%8C%E6%9C%89%E5%93%AA%E4%BA%9B%E5%9D%91%EF%BC%9F.md">32 Redis主从同步与故障切换，有哪些坑?</a></p><h2 id="7-什么是集群的脑裂？​"><a href="#7-什么是集群的脑裂？​" class="headerlink" title="7.什么是集群的脑裂？​"></a>7.什么是集群的脑裂？​</h2><p>如果主节点的网络突然发生了问题与所有的从节点都失联了，但此时的主节点和客户端的网络是正常的，客户端不知道集群内部已经出现了问题，还在向这个失联的主节点写数据，此时这些数据被主节点缓存到了缓冲区里。哨兵也发现主节点失联了，就会在从节点中选举出一个leader作为主节点，会导致集群有两个主节点。</p><p>网络恢复后哨兵因为之前已经选举出一个新主节点了，它就会把旧主节点降级，然后从旧主节点会向新主节点请求数据同步，因为第一次同步是全量同步的方式，旧主节点会清空掉自己本地的数据。客户端在过程之前写入的数据就会丢失了。所以脑裂会导致集群数据的丢失。</p><h2 id="8-如何减少主从切换带来的数据丢失？​"><a href="#8-如何减少主从切换带来的数据丢失？​" class="headerlink" title="8.如何减少主从切换带来的数据丢失？​"></a>8.如何减少主从切换带来的数据丢失？​</h2><p><strong>异步复制同步丢失</strong></p><p>配置一个阈值，一旦所有的从节点数据复制和同步的延迟都超过了阈值，主节点就会拒绝接收任何请求。对于客户端发现主节点不可写后，可以采取降级措施。将数据暂时写入本地缓存和磁盘中，在一段时间后重新写入主节点来保证数据不丢失，也可以将数据写入消息队列，等主节点恢复正常，再隔一段时间去消费消息队列中的数据，让将数据重新写入主节点。</p><p><strong>集群产生脑裂数据丢失</strong></p><p>当主节点发现「从节点下线的数量太多」，或者「网络延迟太大」的时候，那么禁止主节点进行写数据，直接把错误返回给客户端。设置主节点连接的从节点中至少有 N 个从节点，并且主节点进行数据复制时的 ACK 消息延迟不能超过 T 秒，否则，主节点就不会再接收客户端的写请求了。等到新主节点上线时，就只有新主节点能接收和处理客户端请求，此时，新写的数据会被直接写到新主节点中。而原主节点会被哨兵降为从节点，即使它的数据被清空了，也不会有新数据丢失。</p>]]></content>
    
    
    <summary type="html">🥧本人的Redis面试题</summary>
    
    
    
    <category term="面试题" scheme="https://outoflovenicoo.github.io/categories/%E9%9D%A2%E8%AF%95%E9%A2%98/"/>
    
    
    <category term="Redis" scheme="https://outoflovenicoo.github.io/tags/Redis/"/>
    
  </entry>
  
</feed>
