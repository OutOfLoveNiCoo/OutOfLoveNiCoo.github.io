<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
  <title>OutOfLove🥝</title>
  
  
  <link href="https://outoflovenicoo.github.io/atom.xml" rel="self"/>
  
  <link href="https://outoflovenicoo.github.io/"/>
  <updated>2025-04-25T14:00:00.000Z</updated>
  <id>https://outoflovenicoo.github.io/</id>
  
  <author>
    <name>OutOfLove🥝</name>
    
  </author>
  
  <generator uri="https://hexo.io/">Hexo</generator>
  
  <entry>
    <title>Redis高可用个人总结</title>
    <link href="https://outoflovenicoo.github.io/posts/2025-04-25-Redis%E9%AB%98%E5%8F%AF%E7%94%A8%E4%B8%AA%E4%BA%BA%E6%80%BB%E7%BB%93.html"/>
    <id>https://outoflovenicoo.github.io/posts/2025-04-25-Redis%E9%AB%98%E5%8F%AF%E7%94%A8%E4%B8%AA%E4%BA%BA%E6%80%BB%E7%BB%93.html</id>
    <published>2025-04-25T10:19:03.000Z</published>
    <updated>2025-04-25T14:00:00.000Z</updated>
    
    <content type="html"><![CDATA[<p><img src="2025-04-25-Redis%E9%AB%98%E5%8F%AF%E7%94%A8%E4%B8%AA%E4%BA%BA%E6%80%BB%E7%BB%93/diagram.png" alt=""></p><h1>Redis 高可用个人总结</h1><p>在现代分布式系统中，Redis 作为高性能的键值存储数据库，其高可用性至关重要。本文是个人对 Redis 高可用的个人总结。 </p><h2 id="一、主从集群：数据备份与读写分离">一、主从集群：数据备份与读写分离</h2><p>主从集群是 Redis 高可用的基础架构，其核心好处在于实现数据备份和读写分离。主服务器负责处理写操作和部分读操作，从服务器则复制主服务器数据，分担读请求，提升系统整体性能。 </p><h3 id="数据同步机制">数据同步机制</h3><ul><li><p><strong>全量同步（第一次同步）</strong>： </p><ul><li><p><strong>第一阶段：建立链接，协商同步</strong>：从服务器通过主服务器的 <code>runID</code> 和复制进度 <code>offset</code> 判断是否进行全量同步。若从服务器初次连接或 <code>runID</code> 不匹配，将触发全量同步。 </p></li><li><p><strong>第二阶段：主服务器同步数据给从服务器</strong>：主服务器执行 <code>bgsave</code> 命令生成 RDB 文件，并发送给从服务器。从服务器收到后，先清空当前数据，再载入 RDB 文件。 </p></li><li><p><strong>第三阶段：主服务器发送新写操作命令</strong>：主服务器发送完 RDB 文件后，从服务器载入数据并回复确认。主服务器将 <code>replication buffer</code> 缓冲区记录的写操作命令发送给从服务器，执行后两者数据达成一致。 </p></li></ul></li><li><p><strong>增量同步</strong>：主从服务器完成第一次同步后，通过维护一个 TCP 连接持续同步。主服务器将写命令同时发送给从服务器和写入 <code>repl_backlog_buffer</code> 缓冲区。若网络断开重连，从服务器发送 <code>slave_repl_offset</code> 给主服务器，主服务器对比 <code>master_repl_offset</code> 和 <code>slave_repl_offset</code>：若从服务器需要的数据在 <code>repl_backlog_buffer</code> 中存在，采用增量同步；若不存在，则进行全量同步。 </p></li></ul><h2 id="二、哨兵集群：自动故障转移">二、哨兵集群：自动故障转移</h2><p>哨兵集群在主从集群基础上，增加了自动监控和故障转移功能。多个哨兵节点相互通信，监控主节点和从节点状态。当主节点出现故障，哨兵通过投票机制判断主节点是否“主观下线”，若多数哨兵认同，则判定“客观下线”，并选举新的主节点，通知从节点切换复制目标，实现自动故障转移，确保系统高可用性。 </p><h2 id="三、分片集群：突破单机容量限制">三、分片集群：突破单机容量限制</h2><p>当数据量超过单机 Redis 容量时，需采用分片集群。 </p><h3 id="数据扩展方式">数据扩展方式</h3><ul><li><p><strong>纵向扩展</strong>：升级单个 Redis 实例资源（如内存、磁盘、CPU），但受硬件限制，扩展性有限。 </p></li><li><p><strong>横向扩展</strong>：增加 Redis 实例个数，分片集群将数据分散到多个实例。 </p></li></ul><h3 id="数据切片与实例映射">数据切片与实例映射</h3><ul><li><p>数据切片：将数据划分为多个切片，每个实例存储部分切片。例如，通过 <code>CRC16(key) % 16384</code> 计算键对应的 <code>Slot</code>（槽位），每个实例负责若干 <code>Slot</code>。 </p></li><li><p>客户端路由：客户端存储 <code>slots</code> 与实例节点的映射关系。访问时，对 <code>key</code> 进行 <code>CRC16</code> 计算后取模，定位到对应 <code>Slot</code>，再连接到相应实例，实现高效数据访问。 </p></li></ul><h2 id="四、其他相关知识">四、其他相关知识</h2><h3 id="一致性哈希算法">一致性哈希算法</h3><p>一致性哈希算法是一种用于分布式系统的哈希算法，其核心思想是将哈希值空间组织成一个首尾相接的环形。每个节点和数据键值对都通过哈希函数映射到这个环上。当集群中增加或减少节点时，受影响的数据仅为该节点相邻的部分，从而大幅减少数据迁移量。在 Redis 分片集群中，虽然并非直接采用一致性哈希算法，但数据分片及 <code>Slot</code> 分配的思路与之相似，都是为了实现数据的均衡分布，降低节点变动对系统的影响，提升分布式环境下数据管理的灵活性与稳定性。 </p><h3 id="CAP-理论">CAP 理论</h3><p>CAP 理论是分布式系统的基础理论，它指出在一个分布式系统中，一致性（Consistency）、可用性（Availability）和分区容错性（Partition Tolerance）这三个核心需求无法同时被满足，需要根据实际场景进行取舍。 </p><p>在 Redis 的高可用架构中，主从集群和哨兵集群通常优先保障可用性和分区容错性。例如，主从复制过程中存在数据同步延迟，从服务器的数据可能与主服务器不一致，这是牺牲了强一致性来换取系统的高可用性和应对网络分区的能力，确保在部分节点故障或网络异常时，系统仍能提供服务。 </p><h3 id="Raft-算法">Raft 算法</h3><p>Raft 算法是一种分布式共识算法，旨在解决分布式系统中节点间的主节点选举、日志同步等一致性问题。它通过将节点角色划分为领导者（Leader）、跟随者（Follower）和候选者（Candidate），并定义明确的选举规则和日志复制流程，来保证集群在分布式环境下达成共识。 </p><p>在 Redis 哨兵集群中，哨兵节点选举主节点的过程与 Raft 算法的选举机制有相似之处。多个哨兵节点通过投票来决定是否将主节点判定为下线，并在需要时选举新的主节点。这种基于投票达成共识的方式，确保了选主过程的可靠性和一致性，避免了“脑裂”等异常情况，与 Raft 算法在分布式共识上的目标一致，都是为了在多个节点间实现可靠的协调与决策。 </p><p>个人总结，Redis 的高可用架构通过主从集群、哨兵集群和分片集群等多种方式，结合数据同步、自动故障转移和数据分片等技术，满足不同场景下的需求。而一致性哈希算法、CAP 理论和 Raft 算法等知识，则为理解和设计 Redis 高可用架构提供了理论基础和技术支撑，帮助我们在实际应用中更好地保障 Redis 服务的稳定性和高性能。 </p><h2 id="参考博客：">参考博客：</h2><blockquote><p><a href="https://xiaolincoding.com/redis/cluster/master_slave_replication.html">主从复制是怎么实现的？</a></p><p><a href="https://xiaolincoding.com/redis/cluster/sentinel.html#%E6%AD%A5%E9%AA%A4%E5%9B%9B-%E5%B0%86%E6%97%A7%E4%B8%BB%E8%8A%82%E7%82%B9%E5%8F%98%E4%B8%BA%E4%BB%8E%E8%8A%82%E7%82%B9">为什么要有哨兵？</a></p><p><a href="https://learn.lianglianglee.com/%E4%B8%93%E6%A0%8F/Redis%20%E6%A0%B8%E5%BF%83%E6%8A%80%E6%9C%AF%E4%B8%8E%E5%AE%9E%E6%88%98/09%20%20%E5%88%87%E7%89%87%E9%9B%86%E7%BE%A4%EF%BC%9A%E6%95%B0%E6%8D%AE%E5%A2%9E%E5%A4%9A%E4%BA%86%EF%BC%8C%E6%98%AF%E8%AF%A5%E5%8A%A0%E5%86%85%E5%AD%98%E8%BF%98%E6%98%AF%E5%8A%A0%E5%AE%9E%E4%BE%8B%EF%BC%9F.md">09 切片集群:数据增多了，是该加内存还是加实例?</a></p><p><a href="https://learn.lianglianglee.com/%E4%B8%93%E6%A0%8F/Redis%20%E6%A0%B8%E5%BF%83%E5%8E%9F%E7%90%86%E4%B8%8E%E5%AE%9E%E6%88%98/39%20%E5%AE%9E%E6%88%98%EF%BC%9ARedis%20%E9%9B%86%E7%BE%A4%E6%A8%A1%E5%BC%8F%EF%BC%88%E4%B8%8A%EF%BC%89.md">39 实战:Redis 集群模式(上)</a></p><p><a href="https://learn.lianglianglee.com/%E4%B8%93%E6%A0%8F/Redis%20%E6%A0%B8%E5%BF%83%E5%8E%9F%E7%90%86%E4%B8%8E%E5%AE%9E%E6%88%98/40%20%E5%AE%9E%E6%88%98%EF%BC%9ARedis%20%E9%9B%86%E7%BE%A4%E6%A8%A1%E5%BC%8F%EF%BC%88%E4%B8%8B%EF%BC%89.md">40 实战:Redis 集群模式(下)</a></p><p><a href="https://learn.lianglianglee.com/%E4%B8%93%E6%A0%8F/300%E5%88%86%E9%92%9F%E5%90%83%E9%80%8F%E5%88%86%E5%B8%83%E5%BC%8F%E7%BC%93%E5%AD%98-%E5%AE%8C/28%20%E5%A6%82%E4%BD%95%E6%9E%84%E5%BB%BA%E4%B8%80%E4%B8%AA%E9%AB%98%E6%80%A7%E8%83%BD%E3%80%81%E6%98%93%E6%89%A9%E5%B1%95%E7%9A%84Redis%E9%9B%86%E7%BE%A4%EF%BC%9F.md">28 如何构建一个高性能、易扩展的Redis集群?</a></p></blockquote>]]></content>
    
    
    <summary type="html">🥧Redis高可用个人总结</summary>
    
    
    
    <category term="学习" scheme="https://outoflovenicoo.github.io/categories/%E5%AD%A6%E4%B9%A0/"/>
    
    
    <category term="Redis" scheme="https://outoflovenicoo.github.io/tags/Redis/"/>
    
  </entry>
  
  <entry>
    <title>MQ可靠性、有序性、幂等性等问题</title>
    <link href="https://outoflovenicoo.github.io/posts/2025-04-22-MQ%E5%8F%AF%E9%9D%A0%E6%80%A7%E3%80%81%E6%9C%89%E5%BA%8F%E6%80%A7%E3%80%81%E5%B9%82%E7%AD%89%E6%80%A7%E7%AD%89%E9%97%AE%E9%A2%98.html"/>
    <id>https://outoflovenicoo.github.io/posts/2025-04-22-MQ%E5%8F%AF%E9%9D%A0%E6%80%A7%E3%80%81%E6%9C%89%E5%BA%8F%E6%80%A7%E3%80%81%E5%B9%82%E7%AD%89%E6%80%A7%E7%AD%89%E9%97%AE%E9%A2%98.html</id>
    <published>2025-04-22T10:19:03.000Z</published>
    <updated>2025-04-22T14:00:00.000Z</updated>
    
    <content type="html"><![CDATA[<p>在面试饿了么的时候，问到了比较多的MQ场景题，感觉挺深的，现在总结下，方便以后经常复习。</p><h2 id="思维导图：">思维导图：</h2><p><img src="2025-04-22-MQ%E5%8F%AF%E9%9D%A0%E6%80%A7%E3%80%81%E6%9C%89%E5%BA%8F%E6%80%A7%E3%80%81%E5%B9%82%E7%AD%89%E6%80%A7%E7%AD%89%E9%97%AE%E9%A2%98/diagram.png" alt=""></p><p>在分布式系统中，消息中间件（MQ）扮演着至关重要的角色，它能有效解耦系统组件、异步处理任务并提升系统的可扩展性。但在实际应用中，消息丢失、重复、积压以及有序性等问题也随之而来。本文将结合思维导图内容，详细梳理 MQ 的核心技术与解决方案。 </p><h2 id="一、确保消息不丢失">一、确保消息不丢失</h2><h3 id="生产者层面">生产者层面</h3><ul><li><p><strong>事务与 confirm 机制</strong>：开启 RabbitMQ 事务，确保消息生产阶段的可靠性；同时使用 confirm 机制，让生产者知晓消息是否成功抵达 MQ 服务器，若未确认则可重发。 </p></li><li><p><strong>消息持久化</strong>：将消息标记为持久化，确保 MQ 服务器重启后消息不丢失。需注意队列、交换机也需配置持久化，以保证完整的持久化链路。 </p></li></ul><h3 id="MQ-本身处理单点故障">MQ 本身处理单点故障</h3><ul><li><p><strong>单节点模式</strong>：结构简单，非集群环境下，节点宕机则业务受影响，仅适用于简单场景。 </p></li><li><p><strong>普通模式</strong>：消息仅存在于当前节点，若节点宕机，未消费的消息可能丢失，需依赖持久化且重启后恢复。 </p></li><li><p><strong>镜像模式</strong>：消息同步到其他节点，提升高可用性，但会降低吞吐量，适用于对消息可靠性要求高的场景。 </p></li></ul><h3 id="消费者层面">消费者层面</h3><p>采用手动 ACK 机制，消费者处理完业务逻辑后再确认消息，避免因处理过程中宕机导致消息丢失。 </p><p><img src="2025-04-22-MQ%E5%8F%AF%E9%9D%A0%E6%80%A7%E3%80%81%E6%9C%89%E5%BA%8F%E6%80%A7%E3%80%81%E5%B9%82%E7%AD%89%E6%80%A7%E7%AD%89%E9%97%AE%E9%A2%98/image.png" alt=""></p><p>消费完可以发一条消息让上游感知到下游的任务执行状态，通过分布式ID保证消息只执行一次。</p><h2 id="二、消息常见问题处理">二、消息常见问题处理</h2><h3 id="消息重复与幂等性">消息重复与幂等性</h3><p>在消息补偿机制触发时，重复消息难以避免。通过引入分布式 ID，确保消费端对重复消息的处理具有幂等性。即无论消息接收多少次，处理结果与只处理一次一致，避免业务逻辑混乱。 </p><h3 id="消息积压">消息积压</h3><p>消息积压通常因消费者处理能力不足或故障导致。可通过增加消费者实例、优化消费逻辑提升处理速度，或在 MQ 端调整队列配置、采用批量消费等方式缓解。 </p><h3 id="消息有序性">消息有序性</h3><p>在分布式环境下，网络延迟、节点性能差异等因素易导致消息到达顺序与发送顺序不一致。例如，电商系统中订单创建、支付、发货等消息若顺序错乱，会引发业务逻辑错误。以下是保证消息有序性的详细方案：</p><h4 id="解决方案一：拆分多个-queue，每个-queue-一个-consumer">解决方案一：拆分多个 queue，每个 queue 一个 consumer</h4><p>将需要顺序处理的同类消息发送至同一个 queue。如电商订单系统中，每个订单的相关消息（创建、支付、发货）发送到特定 queue，每个 queue 仅由一个 consumer 处理，确保单个 queue 内消息有序。此方案缺点是 queue 数量可能过多，管理复杂，且吞吐量受单个 consumer 处理能力限制。可在消费者内部采用多线程提升处理效率，但需注意线程安全，确保同一 queue 消息处理顺序。</p><h4 id="解决方案二：一个-queue-对应一个-consumer，内部用内存队列排队">解决方案二：一个 queue 对应一个 consumer，内部用内存队列排队</h4><p>consumer 从 queue 接收消息后，存入内存队列，按顺序分发给底层 worker 处理，保证全局有序。但此方案中 consumer 成为单点，若宕机影响较大。可通过 consumer 集群解决，但需协调内存队列状态，增加实现复杂度。</p><h4 id="利用-MQ-自身有序特性（以-RocketMQ-为例）">利用 MQ 自身有序特性（以 RocketMQ 为例）</h4><p><img src="2025-04-22-MQ%E5%8F%AF%E9%9D%A0%E6%80%A7%E3%80%81%E6%9C%89%E5%BA%8F%E6%80%A7%E3%80%81%E5%B9%82%E7%AD%89%E6%80%A7%E7%AD%89%E9%97%AE%E9%A2%98/image-1.png" alt=""></p><p>RocketMQ 支持有序消息特性，生产者发送消息时指定队列，将同一业务流程的消息发送到同一队列，消费者按顺序消费该队列消息，确保消息有序性。此方式在代码层面，生产者需指定队列，消费者监听对应队列，实现相对简洁且高效。</p><p>个人总结，选择消息有序性方案需结合业务场景。高并发且部分有序的场景，拆分队列更合适；严格全局有序场景，可采用单个 queue 加内存队列或利用 MQ 自身有序特性，在保证业务需求的同时，权衡系统复杂度与性能。</p><h2 id="三、MQ-技术选型：以-RabbitMQ-与-RocketMQ-为例">三、MQ 技术选型：以 RabbitMQ 与 RocketMQ 为例</h2><h3 id="MessageQueue-相关模式">MessageQueue 相关模式</h3><ul><li><p><strong>广播模式</strong>：一个队列被多个消费者监听，同一 ConsumerGroup 下每个消费者处理全部消息，适用于通知推送等小流量场景。 </p></li><li><p><strong>消息拉取模式</strong>：分为拉取式（pull）和推送式（push）。Pull 需消费者主动轮询，实时性差但可控；Push 封装了轮询，实时性强但资源占用高。 </p></li><li><p><strong>消息消费模式</strong>： </p><ul><li><p>广播模式（一对多）：同一 ConsumerGroup 下所有消费者都接收同一 Topic 消息。 </p></li><li><p>集群模式（一对一）：同一 ConsumerGroup 下消费者平分 Topic 消息，每条消息仅消费一次。 </p></li></ul></li><li><p><strong>Queue 分配算法</strong>：如平均分配等，确保消费者合理负载。 </p></li></ul><h3 id="RabbitMQ-与-RocketMQ-的区别">RabbitMQ 与 RocketMQ 的区别</h3><ul><li><p><strong>协议支持</strong>：RabbitMQ 遵循 AMQP 协议，具有高度标准化与通用性，便于与支持该协议的工具、系统集成；RocketMQ 采用自定义协议，在设计上更聚焦于高性能与低延迟，能针对特定场景进行优化。 </p></li><li><p><strong>性能表现</strong>：RocketMQ 在高吞吐量、低延迟场景下表现优异，适合处理海量消息的互联网场景，如电商大促期间的订单消息、物流通知等；RabbitMQ 在中等并发量下表现稳定，但高并发时吞吐量相对有限，更适合企业级应用中对消息可靠性要求高、业务逻辑复杂但流量并非超大规模的场景。 </p></li><li><p><strong>可靠性与高可用性</strong>：RabbitMQ 的镜像模式可实现消息在节点间同步，保障高可用性，但会牺牲部分吞吐量；RocketMQ 通过主从架构、Dledger 机制等实现高可用，同时保持较高的消息处理性能，且支持消息持久化到磁盘，确保数据不丢失。 </p></li><li><p><strong>生态与社区</strong>：RabbitMQ 社区成熟，插件丰富，可轻松扩展功能（如消息监控、复杂路由等）；RocketMQ 社区活跃度高，在国内互联网公司应用广泛，对中文文档与国内技术支持更友好，且不断演进新特性（如延迟消息、事务消息的优化）。 </p></li><li><p><strong>应用场景</strong>：RabbitMQ 常用于金融支付、企业 ERP 等对协议标准性、可靠性要求高且业务逻辑复杂的场景；RocketMQ 则更多应用于互联网领域，如电商、物流、社交平台的实时消息推送、异步订单处理、流量削峰填谷等场景。 </p></li></ul><h2 id="四、其他关键问题">四、其他关键问题</h2><h3 id="如何选型消息中间件？">如何选型消息中间件？</h3><p>需综合考量吞吐量、延迟、可靠性、集群能力、生态支持等。例如 RocketMQ 适合高吞吐、低延迟场景，RabbitMQ 适合对可靠性要求高且业务复杂的场景。 </p><h3 id="队列模型与发布订阅模型区别">队列模型与发布订阅模型区别</h3><ul><li><p>队列模型：多个消费者竞争消费队列中消息，每条消息仅被一个消费者处理。 </p></li><li><p>发布订阅模型：消息发布到 Topic，多个订阅者（消费者组）都能收到完整消息副本，适用于一对多通信。 </p></li></ul><h3 id="消息队列实现高吞吐的原因">消息队列实现高吞吐的原因</h3><ul><li><p>异步处理：解耦生产与消费，无需等待。 </p></li><li><p>批量处理：支持批量发送与消费，减少交互次数。 </p></li><li><p>内存缓存：利用内存快速读写，结合持久化保证数据安全。 </p></li></ul><h3 id="序列化、传输协议与内存管理">序列化、传输协议与内存管理</h3><ul><li><p>序列化：选择高效的序列化方式（如 Protobuf），减少数据体积与处理开销。 </p></li><li><p>传输协议：如 RocketMQ 采用自定义协议，兼顾性能与功能；RabbitMQ 支持 AMQP 协议，通用性强。 </p></li><li><p>内存管理：合理控制消息缓存，避免内存溢出，通过分页、过期消息清理等机制优化。 </p></li></ul><h2 id="参考博客：">参考博客：</h2><blockquote><p><a href="https://cloud.tencent.com/developer/article/2342719">RabbitMQ消息丢失的场景，如何保证消息不丢失？</a></p><p><a href="https://blog.csdn.net/weixin_42039228/article/details/123526391">RabbitMQ如何保证消息的顺序性【重点】-CSDN博客</a></p><p><a href="https://xie.infoq.cn/article/c84491a814f99c7b9965732b1">消息队列（五）如何保证消息的顺序性？_Java_奈何花开_InfoQ写作社区</a></p><p><a href="https://blog.csdn.net/smallspot/article/details/105650948">MQ选型:ActiveMQ、RocketMQ、RabbitMQ、Kafka对比_rocketmq和rabbitmq哪个用的多-CSDN博客</a></p><p><a href="https://blog.csdn.net/weixin_48133130/article/details/134126430?ops_request_misc=%257B%2522request%255Fid%2522%253A%25226b0326d502eea4f750ef128acf68a7b1%2522%252C%2522scm%2522%253A%252220140713.130102334..%2522%257D&amp;request_id=6b0326d502eea4f750ef128acf68a7b1&amp;biz_id=0&amp;utm_medium=distribute.pc_search_result.none-task-blog-2~all~top_positive~default-1-134126430-null-null.142%5Ev102%5Epc_search_result_base3&amp;utm_term=RocketMQ&amp;spm=1018.2226.3001.4187">RocketMQ分布式消息队列（最详细）-CSDN博客</a></p></blockquote>]]></content>
    
    
    <summary type="html">🥧MQ可靠性、有序性、幂等性等问题</summary>
    
    
    
    <category term="学习" scheme="https://outoflovenicoo.github.io/categories/%E5%AD%A6%E4%B9%A0/"/>
    
    
    <category term="前沿" scheme="https://outoflovenicoo.github.io/tags/%E5%89%8D%E6%B2%BF/"/>
    
  </entry>
  
  <entry>
    <title>新的技术-MCP原理和使用</title>
    <link href="https://outoflovenicoo.github.io/posts/2025-04-20-%E6%96%B0%E7%9A%84%E6%8A%80%E6%9C%AF-MCP%E5%8E%9F%E7%90%86%E5%92%8C%E4%BD%BF%E7%94%A8.html"/>
    <id>https://outoflovenicoo.github.io/posts/2025-04-20-%E6%96%B0%E7%9A%84%E6%8A%80%E6%9C%AF-MCP%E5%8E%9F%E7%90%86%E5%92%8C%E4%BD%BF%E7%94%A8.html</id>
    <published>2025-04-20T10:19:03.000Z</published>
    <updated>2025-04-20T14:00:00.000Z</updated>
    
    <content type="html"><![CDATA[<h1>MCP介绍与原理：</h1><h2 id="1-介绍">1.介绍</h2><p>​MCP（Model Context Protocol，模型上下文协议） ，2024年11月底，由 Anthropic 推出的一种开放标准，旨在统一大型语言模型（LLM）与外部数据源和工具之间的通信协议。MCP 的主要目的在于解决当前 AI 模型因数据孤岛限制而无法充分发挥潜力的难题，MCP 使得 AI 应用能够安全地访问和操作本地及远程数据，为 AI 应用提供了连接万物的接口。</p><p>​MCP 可以直接在 AI 与数据（包括本地数据和互联网数据）之间架起一座桥梁，通过 MCP 服务器和 MCP 客户端，大家只要都遵循这套协议，就能实现“万物互联”。</p><p>​有了MCP，可以和数据和文件系统、开发工具、Web 和浏览器自动化、生产力和通信、各种社区生态能力全部集成，实现强大的协作工作能力，它的价值远不可估量。</p><p><img src="2025-04-20-%E6%96%B0%E7%9A%84%E6%8A%80%E6%9C%AF-MCP%E5%8E%9F%E7%90%86%E5%92%8C%E4%BD%BF%E7%94%A8/v2-fa3cdcd616cd3dc22732fa3f529cc7f7_1440w.jpg" alt="img"></p><h3 id="MCP-与-Function-Calling-的区别"><strong>MCP 与 Function Calling 的区别</strong></h3><p>这两种技术都旨在增强 AI 模型与外部数据的交互能力，但 MCP 不止可以增强 AI 模型，还可以是其他的应用系统。</p><p><img src="2025-04-20-%E6%96%B0%E7%9A%84%E6%8A%80%E6%9C%AF-MCP%E5%8E%9F%E7%90%86%E5%92%8C%E4%BD%BF%E7%94%A8/v2-b82dc0e2da4a258438b84484d1af8319_1440w.jpg" alt="img"></p><h2 id="2-工作原理">2.工作原理</h2><p>MCP 协议采用了一种独特的架构设计，它将 LLM 与资源之间的通信划分为三个主要部分：客户端、服务器和资源。</p><p>客户端负责发送请求给 MCP 服务器，服务器则将这些请求转发给相应的资源。这种分层的设计使得 MCP 协议能够更好地控制访问权限，确保只有经过授权的用户才能访问特定的资源。</p><p>以下是 MCP 的基本工作流程：</p><ul><li><p>初始化连接：客户端向服务器发送连接请求，建立通信通道。</p></li><li><p>发送请求：客户端根据需求构建请求消息，并发送给服务器。</p></li><li><p>处理请求：服务器接收到请求后，解析请求内容，执行相应的操作（如查询数据库、读取文件等）。</p></li><li><p>返回结果：服务器将处理结果封装成响应消息，发送回客户端。</p></li><li><p>断开连接：任务完成后，客户端可以主动关闭连接或等待服务器超时关闭。</p><p><img src="2025-04-20-%E6%96%B0%E7%9A%84%E6%8A%80%E6%9C%AF-MCP%E5%8E%9F%E7%90%86%E5%92%8C%E4%BD%BF%E7%94%A8/v2-bb82edf5b8651051be151c279e7679e1_1440w-20250420103956741.jpg" alt="img"></p></li></ul><h3 id="MCP-核心架构">MCP 核心架构</h3><p>MCP 遵循客户端-服务器架构（client-server），其中包含以下几个核心概念：</p><ul><li><p>MCP 主机（MCP Hosts）：发起请求的 LLM 应用程序（例如 <a href="https://zhida.zhihu.com/search?content_id=254488153&amp;content_type=Article&amp;match_order=1&amp;q=Claude+Desktop&amp;zhida_source=entity">Claude Desktop</a>、IDE 或 AI 工具）。</p></li><li><p>MCP 客户端（MCP Clients）：在主机程序内部，与 MCP server 保持 1:1 的连接。</p></li><li><p>MCP 服务器（MCP Servers）：为 MCP client 提供上下文、工具和 prompt 信息。</p></li><li><p>本地资源（Local Resources）：本地计算机中可供 MCP server 安全访问的资源（例如文件、数据库）。</p></li><li><p>远程资源（Remote Resources）：MCP server 可以连接到的远程资源（例如通过 API）。</p><p><img src="2025-04-20-%E6%96%B0%E7%9A%84%E6%8A%80%E6%9C%AF-MCP%E5%8E%9F%E7%90%86%E5%92%8C%E4%BD%BF%E7%94%A8/v2-492a176fa0a06b585e752dc676d28b77_1440w.jpg" alt="img"></p></li></ul><h3 id="MCP-client-和-MCP-server">MCP client 和 MCP server</h3><p>MCP client 充当 LLM 和 MCP server 之间的桥梁，MCP client 的工作流程如下：</p><ul><li>MCP client 首先从 MCP server 获取可用的工具列表。</li><li>将用户的查询连同工具描述通过 function calling 一起发送给 LLM。</li><li>LLM 决定是否需要使用工具以及使用哪些工具。</li><li>如果需要使用工具，MCP client 会通过 MCP server 执行相应的工具调用。</li><li>工具调用的结果会被发送回 LLM。</li><li>LLM 基于所有信息生成自然语言响应。</li><li>最后将响应展示给用户。</li></ul><p>MCP server 是 MCP 架构中的关键组件，它可以提供 3 种主要类型的功能：</p><ul><li>资源（Resources）：类似文件的数据，可以被客户端读取，如 API 响应或文件内容。</li><li>工具（Tools）：可以被 LLM 调用的函数（需要用户批准）。</li><li>提示（Prompts）：预先编写的模板，帮助用户完成特定任务。</li></ul><h3 id="通信机制"><strong>通信机制</strong></h3><p>MCP 协议支持两种主要的通信机制：基于标准输入输出的本地通信和基于<a href="https://zhida.zhihu.com/search?content_id=254488153&amp;content_type=Article&amp;match_order=1&amp;q=SSE&amp;zhida_source=entity">SSE</a>（<a href="https://link.zhihu.com/?target=https%3A//en.wikipedia.org/wiki/Server-sent_events">Server-Sent Events</a>）的远程通信。</p><p>这两种机制都使用 <a href="https://link.zhihu.com/?target=https%3A//www.jsonrpc.org/specification">JSON-RPC 2.0</a> 格式进行消息传输，确保了通信的标准化和可扩展性。</p><ul><li>本地通信**：**通过 stdio 传输数据，适用于在同一台机器上运行的客户端和服务器之间的通信。</li><li>远程通信**：**利用 SSE 与 HTTP 结合，实现跨网络的实时数据传输，适用于需要访问远程资源或分布式部署的场景。</li></ul><h2 id="3-MCP个人实践">3.MCP个人实践</h2><h3 id="前言：">前言：</h3><ol><li><p>安装 Claude Desktop： 确保已在 macOS 或 Windows 系统上安装最新版本的 Claude Desktop。</p><p>这一部分需要一个国外邮箱和国外手机号，国外手机号可以使用sms-activate获得。</p></li><li><p>配置 MCP 服务器： 在 Claude Desktop 的配置文件中，配置入口Claude Desktop—&gt;菜单—&gt;Settings—&gt;Developer—&gt;Edit Config：</p><p><img src="2025-04-20-%E6%96%B0%E7%9A%84%E6%8A%80%E6%9C%AF-MCP%E5%8E%9F%E7%90%86%E5%92%8C%E4%BD%BF%E7%94%A8/image-20250420104518943.png" alt="image-20250420104518943"></p></li></ol><p><img src="2025-04-20-%E6%96%B0%E7%9A%84%E6%8A%80%E6%9C%AF-MCP%E5%8E%9F%E7%90%86%E5%92%8C%E4%BD%BF%E7%94%A8/image-20250420104634339.png" alt="image-20250420104634339"></p><p>配置后，下面会出现锤子</p><p><img src="2025-04-20-%E6%96%B0%E7%9A%84%E6%8A%80%E6%9C%AF-MCP%E5%8E%9F%E7%90%86%E5%92%8C%E4%BD%BF%E7%94%A8/image-20250420104729266.png" alt="image-20250420104729266"></p><h3 id="一、控制本地文件">一、控制本地文件</h3><p><img src="2025-04-20-%E6%96%B0%E7%9A%84%E6%8A%80%E6%9C%AF-MCP%E5%8E%9F%E7%90%86%E5%92%8C%E4%BD%BF%E7%94%A8/image-20250420104755519.png" alt="image-20250420104755519"></p><h3 id="二、实时搜索">二、实时搜索</h3><p><strong>接入tavily实现实时搜索</strong></p><p><img src="2025-04-20-%E6%96%B0%E7%9A%84%E6%8A%80%E6%9C%AF-MCP%E5%8E%9F%E7%90%86%E5%92%8C%E4%BD%BF%E7%94%A8/image-20250420104856401.png" alt="image-20250420104856401"></p><h2 id="参考博客：">参考博客：</h2><p><a href="https://www.claudemcp.com/zh/docs/quickstart">ClaudeMcp使用文档</a></p><p><a href="https://zhuanlan.zhihu.com/p/27327515233">MCP原理详解</a></p><p>[抢先体验:Claude + MCP 零成本实现网络搜索+网页爬虫_claude desktop下载-CSDN博客](<a href="https://blog.csdn.net/m0_37996629/article/details/146456420?ops_request_misc=%7B%22request%5Fid%22%3A%22f7bc1da06e0c3b4d1920f3cdec516773%22%2C%22scm%22%3A%2220140713.130102334..%22%7D&amp;request_id=f7bc1da06e0c3b4d1920f3cdec516773&amp;biz_id=0&amp;utm_medium=distribute.pc_search_result.none-task-blog-2~all~ElasticSearch~search_v2-6-146456420-null-null.142%5Ev102%5Epc_search_result_base3&amp;utm_term=Claude">https://blog.csdn.net/m0_37996629/article/details/146456420?ops_request_misc={&quot;request_id&quot;%3A&quot;f7bc1da06e0c3b4d1920f3cdec516773&quot;%2C&quot;scm&quot;%3A&quot;20140713.130102334..&quot;}&amp;request_id=f7bc1da06e0c3b4d1920f3cdec516773&amp;biz_id=0&amp;utm_medium=distribute.pc_search_result.none-task-blog-2~all~ElasticSearch~search_v2-6-146456420-null-null.142^v102^pc_search_result_base3&amp;utm_term=Claude</a> %2B MCP&amp;spm=1018.2226.3001.4187)</p>]]></content>
    
    
    <summary type="html">🥧新的技术-MCP原理和使用</summary>
    
    
    
    <category term="学习" scheme="https://outoflovenicoo.github.io/categories/%E5%AD%A6%E4%B9%A0/"/>
    
    
    <category term="前沿" scheme="https://outoflovenicoo.github.io/tags/%E5%89%8D%E6%B2%BF/"/>
    
  </entry>
  
  <entry>
    <title>并发编程的内存泄漏与内存溢出问题</title>
    <link href="https://outoflovenicoo.github.io/posts/2025-04-19-%E5%B9%B6%E5%8F%91%E7%BC%96%E7%A8%8B%E7%9A%84%E5%86%85%E5%AD%98%E6%B3%84%E6%BC%8F%E4%B8%8E%E5%86%85%E5%AD%98%E6%BA%A2%E5%87%BA%E9%97%AE%E9%A2%98.html"/>
    <id>https://outoflovenicoo.github.io/posts/2025-04-19-%E5%B9%B6%E5%8F%91%E7%BC%96%E7%A8%8B%E7%9A%84%E5%86%85%E5%AD%98%E6%B3%84%E6%BC%8F%E4%B8%8E%E5%86%85%E5%AD%98%E6%BA%A2%E5%87%BA%E9%97%AE%E9%A2%98.html</id>
    <published>2025-04-19T10:19:03.000Z</published>
    <updated>2025-04-19T14:00:00.000Z</updated>
    
    <content type="html"><![CDATA[<h1>思维导图</h1><p><img src="2025-04-19-%E5%B9%B6%E5%8F%91%E7%BC%96%E7%A8%8B%E7%9A%84%E5%86%85%E5%AD%98%E6%B3%84%E6%BC%8F%E4%B8%8E%E5%86%85%E5%AD%98%E6%BA%A2%E5%87%BA%E9%97%AE%E9%A2%98/diagram.png" alt=""></p><p>在Java编程中，内存泄漏和内存溢出是常见且需要重点关注的问题。它们会导致程序性能下降，甚至崩溃。本文将详细介绍这两个概念、常见原因、表现迹象及解决方法。</p><h2 id="一、内存泄漏">一、内存泄漏</h2><h3 id="1-常见原因">1. 常见原因</h3><ul><li><p><strong>静态属性导致内存泄漏</strong>：静态变量生命周期长，若引用了大对象或长时间不用的对象，易导致内存泄漏。例如，静态集合类不断添加元素却不清理。</p></li><li><p><strong>未关闭的资源</strong>：数据库连接、文件流、网络连接等资源使用后未关闭，会一直占用内存。即使程序不再使用这些资源，垃圾回收器也无法回收，因为资源的引用未释放。</p></li><li><p><strong>使用ThreadLocal后未手动清理</strong>：ThreadLocal为每个线程提供独立变量副本，但若使用后不调用<code>remove</code>方法，线程长期存活时，ThreadLocal关联的对象会一直存在，占用内存。</p></li><li><p><strong>线程泄漏</strong>：线程结束后，相关资源未正确释放。如线程池中的线程未正确关闭，一直占用内存资源。</p></li></ul><h3 id="2-迹象">2. 迹象</h3><ul><li><p><strong>内存占用不断增加</strong>：观察程序内存占用，若持续上升且不释放，很可能存在内存泄漏。随着时间推移，内存占用越来越高，最终可能导致内存溢出。</p></li><li><p><strong>长时间运行后性能下降</strong>：程序运行一段时间后变慢，因内存泄漏使系统可用内存减少，垃圾回收频繁，影响程序执行效率。</p></li><li><p><strong>频繁的垃圾回收</strong>：尤其是Full GC频繁发生，说明内存中存在大量无法被回收的对象，可能是内存泄漏导致。</p></li></ul><h3 id="3-解决方法">3. 解决方法</h3><ul><li><p><strong>正确关闭资源</strong>：</p><ul><li><p>对于支持<code>try - with - resources</code>的资源（如<code>AutoCloseable</code>实现类），使用该语句自动关闭资源，确保资源使用后及时释放。</p></li><li><p>对于不支持的资源（如某些旧版数据库连接），在<code>finally</code>块中手动关闭，保证即使出现异常，资源也能释放。</p></li></ul></li><li><p><strong>使用ThreadLocal后手动清理</strong>：在使用完ThreadLocal变量后，及时调用<code>remove</code>方法，清除线程本地存储的变量，避免内存占用。</p></li><li><p><strong>避免线程泄漏</strong>：在线程不再需要时，调用<code>Thread</code>的<code>interrupt</code>方法或其他合适方式停止线程，确保线程相关资源正确关闭，如关闭线程池中的空闲线程。</p></li></ul><h2 id="二、内存溢出">二、内存溢出</h2><h3 id="1-常见原因-2">1. 常见原因</h3><ul><li><p><strong>大量对象创建</strong>：程序中循环或频繁创建大量对象，且未及时回收，超过JVM堆内存限制，导致内存溢出。例如，一次性加载大量数据到内存中创建对象。</p></li><li><p><strong>持久引用</strong>：如缓存、集合等数据结构长时间持有对象引用，即使对象不再使用，也无法被垃圾回收器回收，造成内存占用累积。</p></li><li><p><strong>递归调用</strong>：深度递归可能导致栈内存耗尽，出现<code>StackOverflowError</code>，这也是一种内存溢出情况。</p></li></ul><h3 id="2-JVM内存结构中的溢出情况">2. JVM内存结构中的溢出情况</h3><ul><li><p><strong>堆溢出</strong>：错误信息<code>java.lang.OutOfMemoryError: java heap space</code>。当堆中创建的对象过多，垃圾回收无法及时回收，且堆内存达到最大限制（通过<code>-Xmx</code>设置）时发生。</p></li><li><p><strong>方法区溢出</strong>：JDK 1.8前为<code>java.lang.OutOfMemoryError: PermGen space</code>，JDK 1.8后为<code>java.lang.OutOfMemoryError: Metaspace</code>。加载的类、常量过多，超过方法区内存限制时出现。</p></li><li><p><strong>直接内存溢出</strong>：错误信息<code>java.lang.OutOfMemoryError: Direct buffer memory</code>。使用<code>ByteBuffer.allocateDirect()</code>等分配直接内存时，若未正确管理（如未调用<code>clear</code>），直接内存使用过多导致溢出。</p></li></ul><h3 id="3-解决方法-2">3. 解决方法</h3><ul><li><p><strong>定位问题</strong>：通过<code>top</code>等命令定位到占用内存高的线程，分析其堆存储文件（如使用<code>jmap</code>生成堆转储文件，用<code>jhat</code>或其他工具分析），确定具体导致溢出的对象和代码。</p></li><li><p><strong>检查数据加载</strong>：若因一次从数据库取出过多数据导致内存中对象过多，修改查询方式，采用分页查询等，减少一次性加载的数据量。</p></li><li><p><strong>排查内存泄漏</strong>：检查<code>List</code>、<code>Map</code>等集合对象是否使用后未清除元素，确保不再使用的对象能被垃圾回收。例如，及时清除缓存中过期的数据。</p></li><li><p><strong>调整JVM参数</strong>：若启动参数中内存设定过小（<code>-Xms</code>、<code>-Xmx</code>），适当增加内存。但需注意，增加内存不是万能的，还需结合代码优化，避免无限制消耗内存。</p></li></ul><p>内存泄漏和内存溢出是Java程序中需要重点关注的问题。通过了解其原因、表现和解决方法，能更好地优化程序，提高稳定性和性能。在开发中，要养成良好的编码习惯，及时释放资源，合理管理对象引用，定期监控程序内存使用情况，以便及时发现和解决问题。 </p><h2 id="参考博客：">参考博客：</h2><p><a href="https://xiaolincoding.com/interview/jvm.html#%E5%86%85%E5%AD%98%E6%B3%84%E6%BC%8F%E5%92%8C%E5%86%85%E5%AD%98%E6%BA%A2%E5%87%BA%E7%9A%84%E7%90%86%E8%A7%A3">Java虚拟机面试题</a></p><p><a href="https://www.cnblogs.com/flydean/p/17722512.html">www.cnblogs.com</a></p>]]></content>
    
    
    <summary type="html">🥧并发编程的内存泄漏与内存溢出问题</summary>
    
    
    
    <category term="学习" scheme="https://outoflovenicoo.github.io/categories/%E5%AD%A6%E4%B9%A0/"/>
    
    
    <category term="JUC" scheme="https://outoflovenicoo.github.io/tags/JUC/"/>
    
    <category term="思维导图" scheme="https://outoflovenicoo.github.io/tags/%E6%80%9D%E7%BB%B4%E5%AF%BC%E5%9B%BE/"/>
    
  </entry>
  
  <entry>
    <title>Java集合学习</title>
    <link href="https://outoflovenicoo.github.io/posts/2025-04-17-Java%E9%9B%86%E5%90%88%E5%AD%A6%E4%B9%A0.html"/>
    <id>https://outoflovenicoo.github.io/posts/2025-04-17-Java%E9%9B%86%E5%90%88%E5%AD%A6%E4%B9%A0.html</id>
    <published>2025-04-17T10:19:03.000Z</published>
    <updated>2025-04-17T14:00:00.000Z</updated>
    
    <content type="html"><![CDATA[<h1>Java集合学习</h1><h2 id="个人总结思维导图：">个人总结思维导图：</h2><p><img src="2025-04-17-Java%E9%9B%86%E5%90%88%E5%AD%A6%E4%B9%A0/image-20250419111601404.png" alt="image-20250419111601404"></p><p>​在腾讯面试的过程中，被问到了一些基础问题，Java的集合框架。当时回答的有点不太好，很多概念都有点模糊，根本原因是没有自己总结过，所以现在特地总结一下，当然这个总结可能还不完善，后续会不断迭代优化。</p><h2 id="单列集合部分">单列集合部分</h2><h3 id="ArrayList">ArrayList</h3><p>​ArrayList是<code>List</code>接口的一个实现类。它的默认初始容量为0，当首次添加元素时，其容量会扩充到10。这种动态扩容的机制使得ArrayList在存储元素时具有一定的灵活性，适合元素数量不确定的场景。</p><h3 id="HashSet">HashSet</h3><p>​HashSet是<code>Set</code>接口的实现类，其实现原理基于哈希值。当向HashSet中加入对象时，会先计算对象的<code>hashcode</code>值来判断对象加入的位置，同时也会与其他已加入对象的<code>hashcode</code>值作比较。如果没有相同的<code>hashcode</code>值，HashSet会假设对象没有重复出现；但如果发现有相同<code>hashcode</code>值的对象，这时会调用<code>equals()</code>方法来检查对象是否真的相同，若两者相同，HashSet就不会让加入操作成功，以此保证集合中元素的唯一性。</p><h3 id="Queue与Deque">Queue与Deque</h3><p>​<code>Queue</code>（队列）接口有多种实现，比如<code>PriorityQueue</code>（优先队列）和<code>BlockingQueue</code>（阻塞队列，其下又细分<code>ArrayBlockingQueue</code>、<code>LinkedBlockingQueue</code>等）。<code>Deque</code>（双端队列）接口也有对应的实现类，如<code>ArrayDeque</code>（每次扩容为原来的2倍+1）和<code>LinkedList</code>，这些实现类为不同的队列操作需求提供了支持。</p><h3 id="Stack">Stack</h3><p><code>Stack</code>（栈）不推荐使用，主要有两个原因。一是其线程安全机制低效且冗余，在多线程环境下性能不佳；二是它有着不合理的继承关系，<code>Stack</code>继承自<code>Vector</code>，而<code>Vector</code>本质上是一个基于数组的动态数组，是“可增长的对象数组”，并非专门为栈（LIFO，后进先出）设计的数据结构，这种设计上的不合理导致<code>Stack</code>在实际应用中存在诸多问题。</p><h2 id="双列集合部分">双列集合部分</h2><h3 id="HashMap详解">HashMap详解</h3><h4 id="实现原理">实现原理</h4><p>​HashMap的工作原理基于哈希表。它通过计算键的哈希值，并将其转化为数组索引，从而快速定位键值对的存储位置。在理想情况下，哈希函数能将键均匀分布到哈希表中，以最小化哈希冲突。在Java 1.7中，HashMap主要使用链表来解决哈希冲突，将具有相同哈希值的键值对链接在一起；但在Java 1.8中，为了进一步提高性能，当链表长度和数组长度超过一定阈值时，链表会转换为红黑树。红黑树作为一种自平衡的二叉搜索树，能够在哈希冲突较多时提供更快的查找、插入和删除操作功能。这样，HashMap结合哈希表、链表和红黑树的原理，实现了高效的键值对存储和查找功能。</p><h4 id="扩容机制">扩容机制</h4><p>​HashMap的扩容触发条件有两个：一是元素个数大于负载因子乘以桶大小；二是桶内元素个数大于8且桶的个数小于64时也会触发扩容。扩容时，会重新计算元素的位置，计算方式为<code>(n-1) &amp; hash</code>（<code>n</code>为新的容量），新的位置要么是原来的位置，要么是原来的位置加上旧容量。</p><p>​需要注意的是，HashMap扩容时，不会对元素对象本身进行复制，而是将元素对象的引用迁移到新的哈希表中，然后根据新的容量重新计算元素在新哈希表中的位置。</p><h3 id="ConcurrentHashMap在JDK8中的实现">ConcurrentHashMap在JDK8中的实现</h3><h4 id="put方法安全机制">put方法安全机制</h4><p>​在JDK8中，ConcurrentHashMap采用了分段锁，同时使用CAS（Compare and Swap，比较并交换）和<code>synchronized</code>来保证线程安全。其<code>put</code>方法的安全保证步骤如下：首先计算哈希值；接着判断数组是否初始化；然后根据哈希值定位到对应的桶位置；再判断桶是否为空，若为空则使用CAS操作尝试将新节点插入到该位置，若CAS操作成功，插入完成，若失败，说明有其他线程已经插入了节点，继续后续步骤；之后检查桶头节点的哈希值是否为<code>MOVED</code>（表示该桶正在进行扩容迁移），若是则协助进行扩容；最后加锁插入或更新，对桶的头节点使用<code>synchronized</code>关键字加锁，然后遍历链表或红黑树，若找到相同的键，更新其值，若未找到，将新节点插入到链表尾部（链表长度小于8）或插入到红黑树中（链表长度大于等于8且数组长度大于等于64），若插入后链表长度达到8且数组长度小于64，进行数组扩容；若数组长度大于等于64，将链表转换为红黑树。</p><h4 id="扩容机制-2">扩容机制</h4><p>​ConcurrentHashMap的扩容机制较为复杂。初始化迁移任务时，当一个线程发现需要扩容时，会先创建一个新的数组，其容量是原数组的两倍，同时，会将<code>sizeCtl</code>设置为一个负数，表示正在进行扩容操作，并记录参与扩容的线程数。多线程协助迁移时，ConcurrentHashMap支持多线程协助进行扩容操作，每个线程会领取一个或多个桶的迁移任务，将原数组中对应桶的节点迁移到新数组中，在迁移过程中，使用<code>ForwardingNode</code>节点标记原数组中已经迁移完成的桶，其他线程在访问这些桶时，会自动跳转到新数组中继续操作。链表迁移时，对于链表节点，会根据节点的哈希值重新计算在新数组中的位置，将链表拆分成两个链表，分别放入新数组的不同位置。红黑树迁移时，对于红黑树节点，同样会根据哈希值重新计算位置，可能会将红黑树拆分成两个链表或红黑树，再放入新数组中。当所有的迁移任务都完成后，将新数组替换原数组，扩容操作结束，同时，将<code>sizeCtl</code>更新为新的阈值。</p><h3 id="HashMap与HashTable的区别">HashMap与HashTable的区别</h3><h4 id="线程安全">线程安全</h4><p>​HashTable是线程安全的，它的<code>put</code>、<code>get</code>等方法都使用<code>synchronized</code>关键字进行同步控制；而HashMap是非线程安全的，在多线程环境下如果不进行额外的同步控制，可能会出现数据不一致等问题。</p><h4 id="对null键值的支持">对null键值的支持</h4><p>​HashMap允许键和值为<code>null</code>，但是只能有一个<code>null</code>键，值可以有多个<code>null</code>；而HashTable不允许键或值为<code>null</code>，若尝试将<code>null</code>键或值放入HashTable中，会抛出<code>NullPointerException</code>。</p><h4 id="初始容量与扩容">初始容量与扩容</h4><p>​HashMap的初始容量为16（默认情况下），负载因子为0.75；HashTable的初始容量为11，负载因子同样为0.75。在扩容方面，HashMap扩容时新容量是原容量的2倍；HashTable扩容时新容量是原容量的2倍+1。</p><h4 id="哈希值计算">哈希值计算</h4><p>​HashMap在计算哈希值时，对哈希值进行了高位运算，以优化哈希值在数组中的分布，减少哈希冲突；而HashTable直接使用键的<code>hashCode()</code>方法返回的值作为哈希值，没有进行额外的处理。</p><p>总之，Java集合框架中的这些知识点在实际开发中非常重要，理解它们的实现原理和特性，能够帮助我们更合理地选择和使用集合类，写出高效、稳定的代码。</p><h2 id="参考博客">参考博客</h2><p><a href="https://javabetter.cn/collection/hashmap.html#_05%E3%80%81%E5%B0%8F%E7%BB%93">HashMap详解</a></p><p><a href="https://javaguide.cn/java/collection/hashmap-source-code.html">HashMap源码</a></p>]]></content>
    
    
    <summary type="html">🥧Java集合学习</summary>
    
    
    
    <category term="学习" scheme="https://outoflovenicoo.github.io/categories/%E5%AD%A6%E4%B9%A0/"/>
    
    
    <category term="思维导图" scheme="https://outoflovenicoo.github.io/tags/%E6%80%9D%E7%BB%B4%E5%AF%BC%E5%9B%BE/"/>
    
  </entry>
  
  <entry>
    <title>MySQL用B+树读取数据，从磁盘中读和从SSD中读有什么不同的影响</title>
    <link href="https://outoflovenicoo.github.io/posts/2025-04-17-MySQL%E7%94%A8B+%E6%A0%91%E8%AF%BB%E5%8F%96%E6%95%B0%E6%8D%AE%EF%BC%8C%E4%BB%8E%E7%A3%81%E7%9B%98%E4%B8%AD%E8%AF%BB%E5%92%8C%E4%BB%8ESSD%E4%B8%AD%E8%AF%BB%E6%9C%89%E4%BB%80%E4%B9%88%E4%B8%8D%E5%90%8C%E7%9A%84%E5%BD%B1%E5%93%8D.html"/>
    <id>https://outoflovenicoo.github.io/posts/2025-04-17-MySQL%E7%94%A8B+%E6%A0%91%E8%AF%BB%E5%8F%96%E6%95%B0%E6%8D%AE%EF%BC%8C%E4%BB%8E%E7%A3%81%E7%9B%98%E4%B8%AD%E8%AF%BB%E5%92%8C%E4%BB%8ESSD%E4%B8%AD%E8%AF%BB%E6%9C%89%E4%BB%80%E4%B9%88%E4%B8%8D%E5%90%8C%E7%9A%84%E5%BD%B1%E5%93%8D.html</id>
    <published>2025-04-17T10:19:03.000Z</published>
    <updated>2025-04-17T14:00:00.000Z</updated>
    
    <content type="html"><![CDATA[<p>面试腾讯的时候问到过一道题：MySQL用B+树读取数据，从磁盘中读和从SSD中读有什么不同的影响。这可把我问蒙了，SSD有点不记得了，现在复盘下。</p><h3 id="一、物理特性与读写原理"><strong>一、物理特性与读写原理</strong></h3><p><img src="2025-04-17-MySQL%E7%94%A8B+%E6%A0%91%E8%AF%BB%E5%8F%96%E6%95%B0%E6%8D%AE%EF%BC%8C%E4%BB%8E%E7%A3%81%E7%9B%98%E4%B8%AD%E8%AF%BB%E5%92%8C%E4%BB%8ESSD%E4%B8%AD%E8%AF%BB%E6%9C%89%E4%BB%80%E4%B9%88%E4%B8%8D%E5%90%8C%E7%9A%84%E5%BD%B1%E5%93%8D/image-1.png" alt=""></p><h4 id="1-磁盘读写">1.磁盘读写</h4><h5 id="读取数据过程">读取数据过程</h5><ol><li><p>寻道（Seek）</p><ul><li><p>当操作系统或应用程序请求读取数据时，磁盘控制器首先确定数据所在的逻辑地址（通常对应为 柱面号、磁头号、扇区号）。</p></li><li><p>磁头臂驱动磁头在盘片表面径向移动，定位到目标磁道（柱面）。</p></li><li><p>耗时因素：寻道时间取决于磁头移动距离，是随机访问（如随机 IO）的主要延迟来源（平均寻道时间约 5~15ms）。</p></li></ul></li><li><p>旋转定位（Rotational Latency）</p><ul><li><p>磁头到达目标磁道后，等待目标扇区旋转到磁头下方。</p></li><li><p>耗时因素：取决于磁盘转速（如 7200 转 / 分钟的磁盘，平均旋转延迟约 4.17ms）。</p></li></ul></li><li><p>数据传输（Data Transfer）</p><ul><li><p>磁头读取扇区中的磁性信号，转换为电信号后通过数据总线传输到磁盘缓存（Cache）。</p></li><li><p>若数据需提供给主机，再通过接口（如 SATA、NVMe）传输到内存。</p></li><li><p>传输速率：受限于磁盘转速和磁道密度，顺序读取速率较高（约 100~200MB/s），随机读取因寻道和旋转延迟大幅下降。</p></li></ul></li><li><p>错误校验</p><ul><li>读取数据时通过校验码（如 CRC）验证数据完整性，若出错则尝试重试或标记坏块。</li></ul></li></ol><h5 id="写入数据过程">写入数据过程</h5><ol><li><p>寻道与旋转定位</p><ul><li>与读取过程类似，先定位到目标磁道和扇区。</li></ul></li><li><p>数据写入</p><ul><li><p>磁头通过电流改变盘片表面磁性颗粒的极性，记录数据（0/1）。</p></li><li><p>写入前可能需要擦除原有数据（部分磁盘支持覆盖写入，但频繁擦写会影响寿命，不过 HDD 无此问题，因基于磁性而非闪存）。</p></li></ul></li><li><p>缓存与持久化</p><ul><li>数据先写入磁盘缓存，再由磁盘控制器决定何时写入盘片（异步写入时可能延迟，需依赖电池备份缓存确保断电不丢失）。</li></ul></li></ol><h4 id="2-SSD读写">2.SSD读写</h4><p><a href="https://blog.csdn.net/fuhanghang/article/details/134941585?ops_request_misc=%257B%2522request%255Fid%2522%253A%252291f7df9daec3edaee205dfda406a40d9%2522%252C%2522scm%2522%253A%252220140713.130102334..%2522%257D&amp;request_id=91f7df9daec3edaee205dfda406a40d9&amp;biz_id=0&amp;utm_medium=distribute.pc_search_result.none-task-blog-2~all~ElasticSearch~search_v2-9-134941585-null-null.142%5Ev102%5Epc_search_result_base3&amp;utm_term=SSD%E8%AF%BB%E5%8F%96%E6%95%B0%E6%8D%AE%E6%96%B9%E5%BC%8F&amp;spm=1018.2226.3001.4187">深入浅出SSD-CSDN博客</a></p><p><img src="2025-04-17-MySQL%E7%94%A8B+%E6%A0%91%E8%AF%BB%E5%8F%96%E6%95%B0%E6%8D%AE%EF%BC%8C%E4%BB%8E%E7%A3%81%E7%9B%98%E4%B8%AD%E8%AF%BB%E5%92%8C%E4%BB%8ESSD%E4%B8%AD%E8%AF%BB%E6%9C%89%E4%BB%80%E4%B9%88%E4%B8%8D%E5%90%8C%E7%9A%84%E5%BD%B1%E5%93%8D/image.png" alt=""></p><h5 id="SSD-数据读取数据">SSD 数据读取数据</h5><ol><li><p>逻辑地址到物理地址的转换（地址映射）</p><ul><li><p>当操作系统请求读取数据时，首先发送逻辑地址（LBA，Logical Block Address）。</p></li><li><p>主控通过FTL（Flash Translation Layer，闪存转换层）将逻辑地址转换为 NAND 闪存中的物理地址（包括芯片编号、块号、页号）。</p></li><li><p>FTL 维护一张动态映射表（通常存储在 DRAM 缓存中），记录逻辑地址与物理地址的对应关系，支持磨损均衡（将写入分散到不同块，避免某些块过度磨损）。</p></li></ul></li><li><p>数据读取操作（从 NAND 闪存中读取）</p><ul><li><p>选中目标页：主控向目标 NAND 芯片发送命令，通过 行地址译码器（X Decoder）选中目标块，再通过列地址译码器（Y Decoder） 选中目标页。</p></li><li><p>读取电荷信号：NAND 存储单元通过电荷电压表示数据（如 SLC 的高电压代表 1，低电压代表 0）。读取时，控制电路向单元施加读取电压，检测晶体管的导通状态，判断存储的是 1 还是 0。</p></li><li><p>信号放大与纠错：</p><ul><li><p>由于电荷可能因时间或电压波动出现衰减，读取的信号需通过 **sense amplifier（敏感放大器）** 放大并模数转换（ADC）。</p></li><li><p>主控通过 **ECC（错误校验码）** 对数据进行纠错，确保读取的准确性（SSD 内置硬件级 ECC，可纠正单比特或多比特错误）。</p></li></ul></li></ul></li><li><p>数据传输到主机</p><ul><li><p>读取的数据先暂存到 NAND 芯片的页缓存（Page Buffer），再通过 SSD 内部总线传输到主控的 DRAM 缓存。</p></li><li><p>主控将数据打包，通过接口（如 SATA、NVMe）传输到主机内存（RAM），完成读取操作。</p></li></ul></li></ol><h5 id="SSD写操作："><strong>SSD写操作：</strong></h5><p>主机通过接口发送写命令给SSD，SSD接收到该命令后执行，并接收主机要写入的数据。数据一般会先缓存在SSD内部的RAM中，FTL会为每个逻辑数据块分配一个闪存地址，当数据凑到一定数量后，FTL便会发送写闪存请求给后端，然后后端根据写请求，把缓存中的数据写到对应的闪存空间。由于闪存不能覆盖写，闪存块需擦除才能写入。主机发来的某个数据块，它不是写在闪存固定位置，SSD可以为其分配任何可能的闪存空间写入。因此，SSD内部需要FTL这样一个东西，完成逻辑数据块到闪存物理空间的转换或者映射。</p><p>举例：假设SSD容量为128GB，逻辑数据块大小为4KB，所以该SSD一共有128GB/4KB=32M个逻辑数据块。每个逻辑块都有一个映射，即每个逻辑块在闪存空间都有一个存储位置。闪存地址大小如果用4字节表示，那么存储32M个逻辑数据块在闪存中的地址则需要32M×4B=128MB大小的映射表。</p><p>正因为SSD内部维护了一张逻辑地址到物理地址转换的映射表，当主机发来读命令时，SSD能根据需要读取的逻辑数据块查找该映射表，获取这些逻辑数据在闪存空间所在的位置，后端便能从闪存上把对应数据读到SSD内部缓存空间，然后前端负责把这些数据返回给主机。</p><h3 id="二、对MySQL-B-树查询的具体影响"><strong>二、对MySQL B+树查询的具体影响</strong></h3><h4 id="1-随机IO性能差异"><strong>1. 随机IO性能差异</strong></h4><ul><li><p><strong>B+树的查询特性</strong>：B+树的查询过程是逐层遍历索引节点（从根节点到叶子节点），每次节点访问对应一次磁盘/SSD的IO操作。对于非聚集索引，查询可能需要多次随机IO（如回表查询）。</p></li><li><p><strong>磁盘（HDD）的瓶颈</strong>：  </p><ul><li><p>机械结构导致随机IO性能极低，尤其是在高并发场景下，大量随机IO会引发严重的寻道竞争和队列延迟。  </p></li><li><p>例如：一次简单的索引查询可能需要3-5次随机IO，若HDD的随机IOPS（每秒操作次数）仅为100-200次，则每秒最多处理约40-60次查询（假设每次查询需3次IO）。</p></li></ul></li><li><p><strong>SSD的优势</strong>：  </p><ul><li><p>无机械延迟，随机IOPS可达数万甚至数十万次，能快速响应大量索引节点的随机访问。  </p></li><li><p>同样以3次IO的查询为例，SSD的随机IOPS若为10万次，则每秒可处理约3万次查询，性能提升近百倍。</p></li></ul></li></ul><h4 id="2-顺序IO与预读机制"><strong>2. 顺序IO与预读机制</strong></h4><ul><li><p><strong>MySQL的预读机制</strong>：系统会提前将相邻的数据块预读入内存（如InnoDB的<code>read_ahead_threshold</code>参数），以减少IO次数。</p></li><li><p><strong>磁盘（HDD）的表现</strong>：  </p><ul><li><p>顺序读写性能较好，预读机制能有效减少部分随机IO。  </p></li><li><p>但预读依赖数据的连续性，若索引节点碎片化严重（如频繁删除数据），预读效率会下降。</p></li></ul></li><li><p><strong>SSD的表现</strong>：  </p><ul><li><p>顺序读写速度更快，预读效率更高。  </p></li><li><p>即使索引碎片化，随机IO的低延迟仍能弥补预读不足的问题。</p></li></ul></li></ul><h4 id="3-响应时间与吞吐量"><strong>3. 响应时间与吞吐量</strong></h4><ul><li><p><strong>磁盘（HDD）</strong>：  </p><ul><li><p>单次查询的响应时间通常*毫秒级，吞吐量受限于机械结构，难以应对高并发场景。  </p></li><li><p>适合小规模、低并发的应用（如单机测试环境）。</p></li></ul></li><li><p><strong>SSD</strong>：  </p><ul><li><p>单次查询的响应时间可降至微秒级，吞吐量显著提升，支持高并发的在线事务处理（OLTP）。  </p></li><li><p>例如：在oltpbench测试中，使用SSD的MySQL数据库吞吐量可比HDD提升5-10倍。</p></li></ul></li></ul><h4 id="4-耐用性与写操作影响"><strong>4. 耐用性与写操作影响</strong></h4><ul><li><p><strong>磁盘（HDD）</strong>：  </p><ul><li><p>机械结构易受物理震动影响，长期高负载下可能导致磁头或盘片损坏。  </p></li><li><p>写操作对读取性能无直接影响（除非触发磁盘碎片整理）。</p></li></ul></li><li><p><strong>SSD</strong>：  </p><ul><li><p>无机械损耗，但NAND闪存存在写入次数限制（寿命由PE次数决定，如TLC闪存约1000-3000次PE）。  </p></li><li><p>频繁的写操作（如索引更新）可能缩短SSD寿命，但现代SSD通过磨损均衡（Wear Leveling）和垃圾回收（GC）机制已大幅缓解此问题。  </p></li><li><p>对读取性能无直接影响，但写入密集型场景需关注SSD的剩余寿命。</p></li></ul></li></ul><h3 id="三、实际应用场景建议"><strong>三、实际应用场景建议</strong></h3><table><thead><tr><th><strong>场景</strong></th><th><strong>推荐存储介质</strong></th><th><strong>理由</strong></th></tr></thead><tbody><tr><td><strong>高并发OLTP系统</strong></td><td>SSD</td><td>随机IO性能优势显著，大幅降低查询延迟，提升吞吐量。</td></tr><tr><td><strong>数据仓库/OLAP系统</strong></td><td>SSD或HDD</td><td>若以顺序查询为主，HDD性价比更高；若包含大量索引或实时查询，优先选SSD。</td></tr><tr><td><strong>低成本单机环境</strong></td><td>HDD</td><td>适合小型数据库或开发测试场景，成本低但性能有限。</td></tr><tr><td><strong>混合负载系统</strong></td><td>分层存储</td><td>热数据（高频查询的索引和数据）存SSD，冷数据存HDD或云存储（如MySQL InnoDB Cluster）。</td></tr></tbody></table><h3 id="四、优化建议"><strong>四、优化建议</strong></h3><ol><li><p><strong>针对SSD的优化</strong>：  </p><ul><li><p>启用InnoDB的<code>innodb_flush_neighbors</code>参数（设为0以减少随机写）。  </p></li><li><p>定期执行<code>OPTIMIZE TABLE</code>或<code>ALTER TABLE</code>整理索引碎片（但避免过度操作影响SSD寿命）。  </p></li><li><p>选择支持TRIM命令的SSD，并确保操作系统已启用TRIM（释放无效块，提升性能）。</p></li></ul></li><li><p><strong>针对HDD的优化</strong>：  </p><ul><li><p>增大InnoDB缓冲池（<code>innodb_buffer_pool_size</code>），尽量将热数据缓存到内存，减少磁盘访问。  </p></li><li><p>定期进行磁盘碎片整理，提升顺序IO效率。  </p></li><li><p>避免高并发随机查询，优先使用覆盖索引减少回表。</p></li></ul></li></ol><h3 id="总结"><strong>总结</strong></h3><ul><li><p><strong>核心差异</strong>：SSD通过消除机械延迟，大幅提升随机IO性能，显著降低B+树查询的响应时间，尤其适合高并发场景；HDD则受限于机械结构，随机IO成为性能瓶颈，但顺序读写和成本优势仍适用于特定场景。  </p></li><li><p>HDD​：</p><ul><li><p>B+ 树的节点大小通常与磁盘块对齐（如 16KB），以最小化单次 IO 代价。</p></li><li><p>优化策略倾向于减少树的高度（如增加节点容量），降低随机 IO 次数。</p></li><li><p>需要依赖预读（Read-ahead）机制提前加载相邻数据，掩盖 HDD 顺序读取的延迟。</p></li></ul></li><li><p>SSD​：</p><ul><li><p>节点大小可能更灵活（SSD 的“页”通常为 4-16KB，但随机读取成本低）。</p></li><li><p>树的高度对延迟影响较小，可容忍稍高的层数以换取更紧凑的节点结构(增加空间利用率)，因为IO成本低。</p></li><li><p>预读机制的收益降低（随机读取足够快），可能更关注并发 IO 或异步访问优化。</p></li></ul></li></ul>]]></content>
    
    
    <summary type="html">🥧MySQL用B+树读取数据，从磁盘中读和从SSD中读有什么不同的影响</summary>
    
    
    
    <category term="学习" scheme="https://outoflovenicoo.github.io/categories/%E5%AD%A6%E4%B9%A0/"/>
    
    
    <category term="MySQL" scheme="https://outoflovenicoo.github.io/tags/MySQL/"/>
    
    <category term="操作系统" scheme="https://outoflovenicoo.github.io/tags/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/"/>
    
  </entry>
  
  <entry>
    <title>华为416批次笔试</title>
    <link href="https://outoflovenicoo.github.io/posts/2025-04-17-%E5%8D%8E%E4%B8%BA416%E6%89%B9%E6%AC%A1%E7%AC%94%E8%AF%95.html"/>
    <id>https://outoflovenicoo.github.io/posts/2025-04-17-%E5%8D%8E%E4%B8%BA416%E6%89%B9%E6%AC%A1%E7%AC%94%E8%AF%95.html</id>
    <published>2025-04-17T10:19:03.000Z</published>
    <updated>2025-04-17T14:00:00.000Z</updated>
    
    <content type="html"><![CDATA[<h1>2025年4月16日华为笔试复盘</h1><p>​这场笔试做的很糟糕，三道题一道也没a出来，不过幸好最后及格了，我觉得需要复盘一下为什么做的这么糟糕。</p><p>​题目来源网站：CodeFun:<a href="https://codefun2000.com/pset/673c82a4d67fed3f6531c8e1">https://codefun2000.com/pset/673c82a4d67fed3f6531c8e1</a></p><h2 id="第一题">第一题</h2><p><a href="https://codefun2000.com/p/P2845">https://codefun2000.com/p/P2845</a></p><p><img src="2025-04-17-%E5%8D%8E%E4%B8%BA416%E6%89%B9%E6%AC%A1%E7%AC%94%E8%AF%95/image-20250418102041869.png" alt="image-20250418102041869"></p><p><img src="2025-04-17-%E5%8D%8E%E4%B8%BA416%E6%89%B9%E6%AC%A1%E7%AC%94%E8%AF%95/image-20250418102120394.png" alt="image-20250418102120394"></p><p>其实看到这一题，我第一眼就想到用位运算，但是位运算不知道该怎么样去遍历，因为答案可能有多个行叠加。所以我采取了一个比较通用的dfs方法去遍历所有可能(但是没注意到m,n的长度最大为1000，位运算肯定超时)。</p><p>这是当时的做法（回忆版）</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> java.util.*;</span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Main</span> &#123;</span><br><span class="line">    <span class="keyword">static</span> <span class="type">int</span>[][] cases;</span><br><span class="line">    <span class="keyword">static</span> <span class="type">int</span> minCount;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">        <span class="type">Scanner</span> <span class="variable">sc</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Scanner</span>(System.in);</span><br><span class="line">        <span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> sc.nextInt();</span><br><span class="line">        <span class="type">int</span> <span class="variable">j</span> <span class="operator">=</span> sc.nextInt();</span><br><span class="line">        cases = <span class="keyword">new</span> <span class="title class_">int</span>[i][j];</span><br><span class="line">        </span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">x</span> <span class="operator">=</span> <span class="number">0</span>; x &lt; i; x++) &#123;</span><br><span class="line">            <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">y</span> <span class="operator">=</span> <span class="number">0</span>; y &lt; j; y++) &#123;</span><br><span class="line">                cases[x][y] = sc.nextInt();</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">        <span class="type">boolean</span>[] covered = <span class="keyword">new</span> <span class="title class_">boolean</span>[j];</span><br><span class="line">        <span class="type">int</span> <span class="variable">count</span> <span class="operator">=</span> <span class="number">0</span>;  </span><br><span class="line">        dfs(covered,<span class="number">0</span>,<span class="number">0</span>,<span class="number">0</span>);</span><br><span class="line">        System.out.println(allCovered ? count : -<span class="number">1</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">// DFS</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">dfs</span><span class="params">(<span class="type">boolean</span>[] covered, <span class="type">int</span> caseIndex, <span class="type">int</span> selected, <span class="type">int</span> coveredCount)</span> &#123;</span><br><span class="line">        <span class="comment">// 判断当前是否已经覆盖了所有模块</span></span><br><span class="line">        <span class="keyword">if</span> (coveredCount == covered.length) &#123;</span><br><span class="line">            minCount = Math.min(minCount, selected); <span class="comment">// 更新最小测试用例数</span></span><br><span class="line">            <span class="keyword">return</span>;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 如果当前已选择的测试用例数量已经大于或等于最小值，剪枝</span></span><br><span class="line">        <span class="keyword">if</span> (selected &gt;= minCount) &#123;</span><br><span class="line">            <span class="keyword">return</span>;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 递归选择每个测试用例</span></span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> caseIndex; i &lt; cases.length; i++) &#123;</span><br><span class="line">            <span class="type">boolean</span>[] newCov = Arrays.copyOf(covered, covered.length); <span class="comment">// 复制当前已覆盖的模块</span></span><br><span class="line">            <span class="type">int</span> <span class="variable">newCovCount</span> <span class="operator">=</span> coveredCount;</span><br><span class="line"></span><br><span class="line">            <span class="comment">// 更新覆盖状态</span></span><br><span class="line">            <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">j</span> <span class="operator">=</span> <span class="number">0</span>; j &lt; cases[i].length; j++) &#123;</span><br><span class="line">                <span class="keyword">if</span> (cases[i][j] == <span class="number">1</span> &amp;&amp; !newCov[j]) &#123;</span><br><span class="line">                    newCov[j] = <span class="literal">true</span>;</span><br><span class="line">                    newCovCount++;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">            dfs(newCov, i + <span class="number">1</span>, selected + <span class="number">1</span>, newCovCount);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br></pre></td></tr></table></figure><p>不出意外超时了，最后只通过了25%😭，这道题做了半天没a出来，<strong>进而影响了下一道题</strong>。</p><p>再来说一下这道题的正确做法吧，转化成集合去遍历，这里没想到</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> java.util.Scanner;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Main</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">        <span class="type">Scanner</span> <span class="variable">sc</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Scanner</span>(System.in);</span><br><span class="line">        <span class="comment">// 读取测试用例总数 n 和模块总数 m</span></span><br><span class="line">        <span class="type">int</span> <span class="variable">n</span> <span class="operator">=</span> sc.nextInt();</span><br><span class="line">        <span class="type">int</span> <span class="variable">m</span> <span class="operator">=</span> sc.nextInt();</span><br><span class="line">        <span class="type">int</span>[] tests = <span class="keyword">new</span> <span class="title class_">int</span>[n];</span><br><span class="line">        </span><br><span class="line">        <span class="comment">// 将每个测试用例转换为位掩码表示</span></span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i &lt; n; i++) &#123;</span><br><span class="line">            <span class="type">int</span> <span class="variable">mask</span> <span class="operator">=</span> <span class="number">0</span>;</span><br><span class="line">            <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">j</span> <span class="operator">=</span> <span class="number">0</span>; j &lt; m; j++) &#123;</span><br><span class="line">                <span class="type">int</span> <span class="variable">x</span> <span class="operator">=</span> sc.nextInt();</span><br><span class="line">                <span class="keyword">if</span> (x == <span class="number">1</span>) &#123;</span><br><span class="line">                    mask |= (<span class="number">1</span> &lt;&lt; j);</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">            tests[i] = mask;</span><br><span class="line">        &#125;</span><br><span class="line">        </span><br><span class="line">        <span class="comment">// 目标掩码：所有模块都被覆盖（低 m 位全为 1）</span></span><br><span class="line">        <span class="type">int</span> <span class="variable">target</span> <span class="operator">=</span> (<span class="number">1</span> &lt;&lt; m) - <span class="number">1</span>;</span><br><span class="line">        <span class="type">int</span> <span class="variable">ans</span> <span class="operator">=</span> Integer.MAX_VALUE;</span><br><span class="line">        </span><br><span class="line">        <span class="comment">// 枚举所有可能的测试用例子集（采用二进制枚举）</span></span><br><span class="line">      <span class="comment">/*</span></span><br><span class="line"><span class="comment">      暴力枚举，这里没想到</span></span><br><span class="line"><span class="comment">      0 0 0 都不选</span></span><br><span class="line"><span class="comment">      0 0 1 选第一个</span></span><br><span class="line"><span class="comment">      0 1 1 选第一个第二个</span></span><br><span class="line"><span class="comment">      1 1 1 全选</span></span><br><span class="line"><span class="comment">      */</span></span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">s</span> <span class="operator">=</span> <span class="number">0</span>; s &lt; (<span class="number">1</span> &lt;&lt; n); s++) &#123;</span><br><span class="line">            <span class="type">int</span> <span class="variable">unionMask</span> <span class="operator">=</span> <span class="number">0</span>;</span><br><span class="line">            <span class="type">int</span> <span class="variable">cnt</span> <span class="operator">=</span> <span class="number">0</span>;</span><br><span class="line">            <span class="comment">// 遍历子集中的每个测试用例，将其覆盖情况合并</span></span><br><span class="line">            <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i &lt; n; i++) &#123;</span><br><span class="line">              <span class="comment">// 选当前行</span></span><br><span class="line">                <span class="keyword">if</span> ((s &amp; (<span class="number">1</span> &lt;&lt; i)) != <span class="number">0</span>) &#123;</span><br><span class="line">                    unionMask |= tests[i];</span><br><span class="line">                    cnt++;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="comment">// 如果当前子集能够覆盖所有模块，则更新答案</span></span><br><span class="line">            <span class="keyword">if</span> (unionMask == target) &#123;</span><br><span class="line">                ans = Math.min(ans, cnt);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        </span><br><span class="line">        <span class="comment">// 如果没有满足要求的子集，输出 -1；否则输出最小用例数</span></span><br><span class="line">        System.out.println(ans == Integer.MAX_VALUE ? -<span class="number">1</span> : ans);</span><br><span class="line">        sc.close();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br></pre></td></tr></table></figure><h2 id="第二题">第二题</h2><p><a href="https://codefun2000.com/p/P2846">https://codefun2000.com/p/P2846</a></p><p><img src="2025-04-17-%E5%8D%8E%E4%B8%BA416%E6%89%B9%E6%AC%A1%E7%AC%94%E8%AF%95/image-20250418105640610.png" alt="image-20250418105640610"></p><p><img src="2025-04-17-%E5%8D%8E%E4%B8%BA416%E6%89%B9%E6%AC%A1%E7%AC%94%E8%AF%95/image-20250418105657826.png" alt="image-20250418105657826"></p><p>因为第一题没a出来，导致做这题的思路都很乱。一开始想用一个TreeSet去存储图的信息，发现这样做不对。</p><p>然后想着用一个HashMap去存领接表，但是感觉图的构建很麻烦，这是一个双向图，整个思路都是乱的，想先写BFS的代码，写到一半意思到时间可能快不够了，继续做这题做不出来这次笔试就过不了，没办法，只能舍弃了，直接输出“NA”骗了7%的分，惭愧😭。</p><p>后面做完第三题再来看第二题，发现DFS应该也能做，但是没时间了。。。主要是这题图的构建要复杂一点。</p><p><strong>正确做法：</strong></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br><span class="line">132</span><br><span class="line">133</span><br><span class="line">134</span><br><span class="line">135</span><br><span class="line">136</span><br><span class="line">137</span><br><span class="line">138</span><br><span class="line">139</span><br><span class="line">140</span><br><span class="line">141</span><br><span class="line">142</span><br><span class="line">143</span><br><span class="line">144</span><br><span class="line">145</span><br><span class="line">146</span><br><span class="line">147</span><br><span class="line">148</span><br><span class="line">149</span><br><span class="line">150</span><br><span class="line">151</span><br><span class="line">152</span><br><span class="line">153</span><br><span class="line">154</span><br><span class="line">155</span><br><span class="line">156</span><br><span class="line">157</span><br><span class="line">158</span><br><span class="line">159</span><br><span class="line">160</span><br><span class="line">161</span><br><span class="line">162</span><br><span class="line">163</span><br><span class="line">164</span><br><span class="line">165</span><br><span class="line">166</span><br><span class="line">167</span><br><span class="line">168</span><br><span class="line">169</span><br><span class="line">170</span><br><span class="line">171</span><br><span class="line">172</span><br><span class="line">173</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> java.util.*;</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">RouteFinder</span> &#123;</span><br><span class="line">    <span class="comment">// 线路数量</span></span><br><span class="line">    <span class="keyword">static</span> <span class="type">int</span> N;</span><br><span class="line">    <span class="comment">// 起点站</span></span><br><span class="line">    <span class="keyword">static</span> String start;</span><br><span class="line">    <span class="comment">// 终点站</span></span><br><span class="line">    <span class="keyword">static</span> String target;</span><br><span class="line">    <span class="comment">// 存储线路之间的换乘信息，键为线路编号，值为该线路可换乘的线路及换乘站信息</span></span><br><span class="line">    <span class="keyword">static</span> Map&lt;Integer, List&lt;Route&gt;&gt; mp = <span class="keyword">new</span> <span class="title class_">HashMap</span>&lt;&gt;();</span><br><span class="line">    <span class="comment">// 存储每个站点所在的线路，键为站点名称，值为包含该站点的线路编号列表</span></span><br><span class="line">    <span class="keyword">static</span> Map&lt;String, List&lt;Integer&gt;&gt; mp1 = <span class="keyword">new</span> <span class="title class_">HashMap</span>&lt;&gt;();</span><br><span class="line">    <span class="comment">// 记录换乘次数，初始化为 -1</span></span><br><span class="line">    <span class="keyword">static</span> <span class="type">int</span> <span class="variable">cnt</span> <span class="operator">=</span> -<span class="number">1</span>;</span><br><span class="line">    <span class="comment">// 标记是否找到可达路线</span></span><br><span class="line">    <span class="keyword">static</span> <span class="type">boolean</span> <span class="variable">flag</span> <span class="operator">=</span> <span class="literal">false</span>;</span><br><span class="line">    <span class="comment">// 记录到达终点站所在的线路编号</span></span><br><span class="line">    <span class="keyword">static</span> <span class="type">int</span> targ;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 内部类，用于存储线路和换乘站信息</span></span><br><span class="line">    <span class="keyword">static</span> <span class="keyword">class</span> <span class="title class_">Route</span> &#123;</span><br><span class="line">        <span class="comment">// 可换乘的线路编号</span></span><br><span class="line">        <span class="type">int</span> line;</span><br><span class="line">        <span class="comment">// 换乘站名称</span></span><br><span class="line">        String station;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 构造函数，初始化线路和换乘站信息</span></span><br><span class="line">        Route(<span class="type">int</span> line, String station) &#123;</span><br><span class="line">            <span class="built_in">this</span>.line = line;</span><br><span class="line">            <span class="built_in">this</span>.station = station;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 广度优先搜索函数，用于查找从起点站到终点站的最短换乘路线</span></span><br><span class="line">    <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">bfs</span><span class="params">(<span class="type">int</span>[] visited, Set&lt;Integer&gt; tar, <span class="type">int</span>[] father)</span> &#123;</span><br><span class="line">        <span class="comment">// 创建一个队列，用于存储待访问的线路编号</span></span><br><span class="line">        Queue&lt;Integer&gt; qu = <span class="keyword">new</span> <span class="title class_">LinkedList</span>&lt;&gt;();</span><br><span class="line">        <span class="comment">// 将起点站所在的所有线路编号加入队列，并标记为已访问</span></span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> x : mp1.get(start)) &#123;</span><br><span class="line">            qu.add(x);</span><br><span class="line">            visited[x] = <span class="number">1</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">// 当队列不为空且未找到可达路线时，继续搜索</span></span><br><span class="line">        <span class="keyword">while</span> (!qu.isEmpty() &amp;&amp; !flag) &#123;</span><br><span class="line">            <span class="comment">// 换乘次数加 1</span></span><br><span class="line">            cnt++;</span><br><span class="line">            <span class="comment">// 获取当前队列的大小，即当前层的线路数量</span></span><br><span class="line">            <span class="type">int</span> <span class="variable">size</span> <span class="operator">=</span> qu.size();</span><br><span class="line">            <span class="comment">// 遍历当前层的所有线路</span></span><br><span class="line">            <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i &lt; size; i++) &#123;</span><br><span class="line">                <span class="comment">// 取出队列头部的线路编号</span></span><br><span class="line">                <span class="type">int</span> <span class="variable">tmp</span> <span class="operator">=</span> qu.poll();</span><br><span class="line">                <span class="comment">// 如果该线路是终点站所在的线路，标记找到可达路线，记录线路编号并跳出循环</span></span><br><span class="line">                <span class="keyword">if</span> (tar.contains(tmp)) &#123;</span><br><span class="line">                    targ = tmp;</span><br><span class="line">                    flag = <span class="literal">true</span>;</span><br><span class="line">                    <span class="keyword">break</span>;</span><br><span class="line">                &#125;</span><br><span class="line">                <span class="comment">// 遍历该线路可换乘的所有线路</span></span><br><span class="line">                <span class="keyword">for</span> (Route next : mp.getOrDefault(tmp, <span class="keyword">new</span> <span class="title class_">ArrayList</span>&lt;&gt;())) &#123;</span><br><span class="line">                    <span class="comment">// 如果该线路已被访问过，跳过</span></span><br><span class="line">                    <span class="keyword">if</span> (visited[next.line] == <span class="number">1</span>) <span class="keyword">continue</span>;</span><br><span class="line">                    <span class="comment">// 标记该线路为已访问</span></span><br><span class="line">                    visited[next.line] = <span class="number">1</span>;</span><br><span class="line">                    <span class="comment">// 将该线路加入队列</span></span><br><span class="line">                    qu.add(next.line);</span><br><span class="line">                    <span class="comment">// 记录该线路的父线路编号</span></span><br><span class="line">                    father[next.line] = tmp;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">        <span class="comment">// 创建 Scanner 对象，用于读取用户输入</span></span><br><span class="line">        <span class="type">Scanner</span> <span class="variable">scanner</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Scanner</span>(System.in);</span><br><span class="line">        <span class="comment">// 读取线路数量</span></span><br><span class="line">        N = scanner.nextInt();</span><br><span class="line">        <span class="comment">// 消耗掉换行符</span></span><br><span class="line">        scanner.nextLine();</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 二维数组，用于存储线路之间的换乘站信息</span></span><br><span class="line">        String[][] graph = <span class="keyword">new</span> <span class="title class_">String</span>[N][N];</span><br><span class="line">        <span class="comment">// 初始化二维数组，将所有元素设置为 &quot;*&quot;</span></span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i &lt; N; i++) &#123;</span><br><span class="line">            Arrays.fill(graph[i], <span class="string">&quot;*&quot;</span>);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 遍历每条线路</span></span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i &lt; N; i++) &#123;</span><br><span class="line">            <span class="comment">// 读取该线路上的所有站点信息</span></span><br><span class="line">            <span class="type">String</span> <span class="variable">s</span> <span class="operator">=</span> scanner.nextLine();</span><br><span class="line">            <span class="comment">// 将站点信息按空格分割成数组</span></span><br><span class="line">            String[] stations = s.split(<span class="string">&quot; &quot;</span>);</span><br><span class="line">            <span class="comment">// 遍历该线路上的每个站点</span></span><br><span class="line">            <span class="keyword">for</span> (String tmp : stations) &#123;</span><br><span class="line">                <span class="comment">// 如果该站点已经存在于 mp1 中，说明该站点是换乘站</span></span><br><span class="line">                <span class="keyword">if</span> (mp1.containsKey(tmp)) &#123;</span><br><span class="line">                    <span class="comment">// 获取该站点所在的所有线路编号列表</span></span><br><span class="line">                    List&lt;Integer&gt; a = mp1.get(tmp);</span><br><span class="line">                    <span class="comment">// 遍历该站点所在的所有线路</span></span><br><span class="line">                    <span class="keyword">for</span> (<span class="type">int</span> j : a) &#123;</span><br><span class="line">                        <span class="comment">// 更新 mp 中线路之间的换乘信息</span></span><br><span class="line">                        mp.computeIfAbsent(i, k -&gt; <span class="keyword">new</span> <span class="title class_">ArrayList</span>&lt;&gt;()).add(<span class="keyword">new</span> <span class="title class_">Route</span>(j, tmp));</span><br><span class="line">                        <span class="comment">// 更新 graph 中线路之间的换乘站信息</span></span><br><span class="line">                        graph[i][j] = tmp;</span><br><span class="line">                        <span class="comment">// 由于是双向图，更新反向的换乘信息</span></span><br><span class="line">                        mp.computeIfAbsent(j, k -&gt; <span class="keyword">new</span> <span class="title class_">ArrayList</span>&lt;&gt;()).add(<span class="keyword">new</span> <span class="title class_">Route</span>(i, tmp));</span><br><span class="line">                        graph[j][i] = tmp;</span><br><span class="line">                    &#125;</span><br><span class="line">                    <span class="comment">// 将当前线路编号加入该站点所在的线路编号列表</span></span><br><span class="line">                    mp1.get(tmp).add(i);</span><br><span class="line">                &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                    <span class="comment">// 如果该站点是第一次出现，创建一个新的线路编号列表，并将当前线路编号加入其中</span></span><br><span class="line">                    List&lt;Integer&gt; list = <span class="keyword">new</span> <span class="title class_">ArrayList</span>&lt;&gt;();</span><br><span class="line">                    list.add(i);</span><br><span class="line">                    <span class="comment">// 将该站点及其所在的线路编号列表存入 mp1 中</span></span><br><span class="line">                    mp1.put(tmp, list);</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 读取起点站和终点站名称</span></span><br><span class="line">        start = scanner.next();</span><br><span class="line">        target = scanner.next();</span><br><span class="line">        <span class="comment">// 用于标记线路是否已被访问过的数组</span></span><br><span class="line">        <span class="type">int</span>[] visited = <span class="keyword">new</span> <span class="title class_">int</span>[N];</span><br><span class="line">        <span class="comment">// 用于记录每个线路的父线路编号的数组，初始化为 -1</span></span><br><span class="line">        <span class="type">int</span>[] father = <span class="keyword">new</span> <span class="title class_">int</span>[N];</span><br><span class="line">        Arrays.fill(father, -<span class="number">1</span>);</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 如果起点站或终点站不在任何线路上，输出 &quot;NA&quot;</span></span><br><span class="line">        <span class="keyword">if</span> (!mp1.containsKey(start) || !mp1.containsKey(target)) &#123;</span><br><span class="line">            System.out.println(<span class="string">&quot;NA&quot;</span>);</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            <span class="comment">// 创建一个集合，存储终点站所在的所有线路编号</span></span><br><span class="line">            Set&lt;Integer&gt; tar = <span class="keyword">new</span> <span class="title class_">HashSet</span>&lt;&gt;(mp1.get(target));</span><br><span class="line">            <span class="comment">// 调用广度优先搜索函数进行搜索</span></span><br><span class="line">            bfs(visited, tar, father);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 如果未找到可达路线，输出 &quot;NA&quot;</span></span><br><span class="line">        <span class="keyword">if</span> (!flag) &#123;</span><br><span class="line">            System.out.println(<span class="string">&quot;NA&quot;</span>);</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            <span class="comment">// 用于存储最终的路线信息</span></span><br><span class="line">            List&lt;String&gt; result = <span class="keyword">new</span> <span class="title class_">ArrayList</span>&lt;&gt;();</span><br><span class="line">            <span class="comment">// 从终点站所在的线路开始回溯</span></span><br><span class="line">            <span class="type">int</span> <span class="variable">u</span> <span class="operator">=</span> targ;</span><br><span class="line">            <span class="comment">// 将终点站加入结果列表</span></span><br><span class="line">            result.add(target);</span><br><span class="line">            <span class="comment">// 回溯路线，直到找到起点站所在的线路</span></span><br><span class="line">            <span class="keyword">while</span> (father[u] != -<span class="number">1</span>) &#123;</span><br><span class="line">                <span class="comment">// 将换乘站加入结果列表</span></span><br><span class="line">                result.add(graph[father[u]][u]);</span><br><span class="line">                <span class="comment">// 更新当前线路为父线路</span></span><br><span class="line">                u = father[u];</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="comment">// 将起点站加入结果列表</span></span><br><span class="line">            result.add(start);</span><br><span class="line">            <span class="comment">// 获取结果列表的大小</span></span><br><span class="line">            <span class="type">int</span> <span class="variable">n</span> <span class="operator">=</span> result.size();</span><br><span class="line">            <span class="comment">// 输出路线信息，用 &quot;-&quot; 连接各个站点</span></span><br><span class="line">            <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> n - <span class="number">1</span>; i &gt; <span class="number">0</span>; i--) &#123;</span><br><span class="line">                System.out.print(result.get(i) + <span class="string">&quot;-&quot;</span>);</span><br><span class="line">            &#125;</span><br><span class="line">            System.out.println(result.get(<span class="number">0</span>));</span><br><span class="line">            <span class="comment">// 输出总换乘次数（包括起点站和终点站）</span></span><br><span class="line">            System.out.println(<span class="number">2</span> + cnt);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;    </span><br></pre></td></tr></table></figure><h2 id="第三题">第三题</h2><p><img src="2025-04-17-%E5%8D%8E%E4%B8%BA416%E6%89%B9%E6%AC%A1%E7%AC%94%E8%AF%95/image-20250418110705215.png" alt="image-20250418110705215"></p><p><img src="2025-04-17-%E5%8D%8E%E4%B8%BA416%E6%89%B9%E6%AC%A1%E7%AC%94%E8%AF%95/image-20250418110727624.png" alt="image-20250418110727624"></p><p>这道题感觉比前面两题简单多了，有点像LeetCode和合并区间那道题，但是这里排序不能按照字典序进行排，索引比较朴素的思想是将ip地址转化成一个数进行排序。</p><p>我的做法：很奇怪，感觉没啥问题就只a了0.55</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> codefun.com.HuaWei;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> java.util.ArrayList;</span><br><span class="line"><span class="keyword">import</span> java.util.List;</span><br><span class="line"><span class="keyword">import</span> java.util.*;</span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">P2847</span> &#123;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 辅助方法：将IPv4地址转化为整数</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="type">long</span> <span class="title function_">ipToInt</span><span class="params">(String ip)</span> &#123;</span><br><span class="line">        String[] parts = ip.split(<span class="string">&quot;\\.&quot;</span>);</span><br><span class="line">        <span class="type">long</span> <span class="variable">result</span> <span class="operator">=</span> <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i &lt; <span class="number">4</span>; i++) &#123;</span><br><span class="line">            result += Integer.parseInt(parts[i]) * Math.pow(<span class="number">256</span>, <span class="number">3</span> - i);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> result;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> String <span class="title function_">intToIp</span><span class="params">(<span class="type">long</span> ipInt)</span> &#123;</span><br><span class="line">        <span class="type">int</span> <span class="variable">part1</span> <span class="operator">=</span> (<span class="type">int</span>) (ipInt / (<span class="type">int</span>)Math.pow(<span class="number">256</span>,<span class="number">3</span>));</span><br><span class="line">        <span class="type">int</span> <span class="variable">part2</span> <span class="operator">=</span> (<span class="type">int</span>)(ipInt / (<span class="type">int</span>)Math.pow(<span class="number">256</span>,<span class="number">2</span>)) % <span class="number">256</span>;</span><br><span class="line">        <span class="type">int</span> <span class="variable">part3</span> <span class="operator">=</span> (<span class="type">int</span>) ((ipInt / <span class="number">256</span>) % <span class="number">256</span>);</span><br><span class="line">        <span class="type">int</span> <span class="variable">part4</span> <span class="operator">=</span> (<span class="type">int</span>) (ipInt % <span class="number">256</span>);</span><br><span class="line">        <span class="keyword">return</span> part1 + <span class="string">&quot;.&quot;</span> + part2 + <span class="string">&quot;.&quot;</span> + part3 + <span class="string">&quot;.&quot;</span> + part4;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">        <span class="type">Scanner</span> <span class="variable">scanner</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Scanner</span>(System.in);</span><br><span class="line">        <span class="type">int</span> <span class="variable">N</span> <span class="operator">=</span> Integer.parseInt(scanner.nextLine());</span><br><span class="line">        List&lt;<span class="type">long</span>[]&gt; ipRanges = <span class="keyword">new</span> <span class="title class_">ArrayList</span>&lt;&gt;();</span><br><span class="line">        </span><br><span class="line">        <span class="comment">// 读取IP区间</span></span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i &lt; N; i++) &#123;</span><br><span class="line">            <span class="type">String</span> <span class="variable">line</span> <span class="operator">=</span> scanner.nextLine();</span><br><span class="line">            String[] parts = line.split(<span class="string">&quot; &quot;</span>);</span><br><span class="line">            <span class="type">long</span> <span class="variable">startIp</span> <span class="operator">=</span> ipToInt(parts[<span class="number">0</span>]);</span><br><span class="line">            <span class="type">long</span> <span class="variable">endIp</span> <span class="operator">=</span> ipToInt(parts[<span class="number">1</span>]);</span><br><span class="line">            ipRanges.add(<span class="keyword">new</span> <span class="title class_">long</span>[]&#123;startIp, endIp&#125;);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 按照业务需求进行排序</span></span><br><span class="line">        <span class="comment">// 排序规则: 先按IP占用数量 (endIp - startIp + 1)，再按起始IP排序</span></span><br><span class="line">        ipRanges.sort((a, b) -&gt; &#123;</span><br><span class="line">            <span class="type">long</span> <span class="variable">lenA</span> <span class="operator">=</span> a[<span class="number">1</span>] - a[<span class="number">0</span>] + <span class="number">1</span>;</span><br><span class="line">            <span class="type">long</span> <span class="variable">lenB</span> <span class="operator">=</span> b[<span class="number">1</span>] - b[<span class="number">0</span>] + <span class="number">1</span>;</span><br><span class="line">            <span class="keyword">if</span> (lenA == lenB) &#123;</span><br><span class="line">                <span class="keyword">return</span> Long.compare(a[<span class="number">0</span>], b[<span class="number">0</span>]);</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">return</span> Long.compare(lenA, lenB);</span><br><span class="line">        &#125;);</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 贪心算法，选择不重叠的区间</span></span><br><span class="line">        List&lt;<span class="type">long</span>[]&gt; result = <span class="keyword">new</span> <span class="title class_">ArrayList</span>&lt;&gt;();</span><br><span class="line">        <span class="type">long</span> <span class="variable">lastEnd</span> <span class="operator">=</span> -<span class="number">1</span>;</span><br><span class="line">        </span><br><span class="line">        <span class="keyword">for</span> (<span class="type">long</span>[] range : ipRanges) &#123;</span><br><span class="line">            <span class="keyword">if</span> (range[<span class="number">0</span>] &gt; lastEnd) &#123;</span><br><span class="line">                result.add(range);</span><br><span class="line">                lastEnd = range[<span class="number">1</span>];</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        </span><br><span class="line">        <span class="keyword">for</span> (<span class="type">long</span>[] range : result) &#123;</span><br><span class="line">            System.out.println(intToIp(range[<span class="number">0</span>]) + <span class="string">&quot; &quot;</span> + intToIp(range[<span class="number">1</span>]));</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure><p><strong>正确解法：</strong></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> codefun.com.HuaWei;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> java.util.*;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">P2847</span> &#123;</span><br><span class="line">    <span class="comment">// 将IPv4地址转化为整数，使用位运算保证精确性</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="type">long</span> <span class="title function_">ipToInt</span><span class="params">(String ip)</span> &#123;</span><br><span class="line">        String[] parts = ip.split(<span class="string">&quot;\\.&quot;</span>);</span><br><span class="line">        <span class="type">long</span> <span class="variable">result</span> <span class="operator">=</span> <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i &lt; <span class="number">4</span>; i++) &#123;</span><br><span class="line">            result |= (Long.parseLong(parts[i]) &lt;&lt; (<span class="number">24</span> - <span class="number">8</span> * i));</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> result;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 将整数转换回IPv4地址</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> String <span class="title function_">intToIp</span><span class="params">(<span class="type">long</span> ipInt)</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> ((ipInt &gt;&gt; <span class="number">24</span>) &amp; <span class="number">0xFF</span>) + <span class="string">&quot;.&quot;</span> +</span><br><span class="line">                ((ipInt &gt;&gt; <span class="number">16</span>) &amp; <span class="number">0xFF</span>) + <span class="string">&quot;.&quot;</span> +</span><br><span class="line">                ((ipInt &gt;&gt; <span class="number">8</span>) &amp; <span class="number">0xFF</span>) + <span class="string">&quot;.&quot;</span> +</span><br><span class="line">                (ipInt &amp; <span class="number">0xFF</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">        <span class="type">Scanner</span> <span class="variable">scanner</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Scanner</span>(System.in);</span><br><span class="line">        <span class="type">int</span> <span class="variable">N</span> <span class="operator">=</span> Integer.parseInt(scanner.nextLine().trim());  <span class="comment">// 读取业务数量</span></span><br><span class="line">        List&lt;<span class="type">long</span>[]&gt; ipRanges = <span class="keyword">new</span> <span class="title class_">ArrayList</span>&lt;&gt;();</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 读取每个业务的起始和结束IP，将其转为整数存储</span></span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i &lt; N; i++) &#123;</span><br><span class="line">            String[] parts = scanner.nextLine().split(<span class="string">&quot; &quot;</span>);</span><br><span class="line">            <span class="type">long</span> <span class="variable">start</span> <span class="operator">=</span> ipToInt(parts[<span class="number">0</span>]);</span><br><span class="line">            <span class="type">long</span> <span class="variable">end</span> <span class="operator">=</span> ipToInt(parts[<span class="number">1</span>]);</span><br><span class="line">            ipRanges.add(<span class="keyword">new</span> <span class="title class_">long</span>[]&#123;start, end&#125;);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 排序规则：</span></span><br><span class="line">        <span class="comment">// 1) 按结束IP升序</span></span><br><span class="line">        <span class="comment">// 2) 若结束IP相同，按区间长度(端点差+1)升序</span></span><br><span class="line">        <span class="comment">// 3) 若长度相同，按起始IP升序</span></span><br><span class="line">        ipRanges.sort((a, b) -&gt; &#123;</span><br><span class="line">            <span class="keyword">if</span> (a[<span class="number">1</span>] != b[<span class="number">1</span>]) &#123;</span><br><span class="line">                <span class="keyword">return</span> Long.compare(a[<span class="number">1</span>], b[<span class="number">1</span>]);</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="type">long</span> <span class="variable">lenA</span> <span class="operator">=</span> a[<span class="number">1</span>] - a[<span class="number">0</span>] + <span class="number">1</span>;</span><br><span class="line">            <span class="type">long</span> <span class="variable">lenB</span> <span class="operator">=</span> b[<span class="number">1</span>] - b[<span class="number">0</span>] + <span class="number">1</span>;</span><br><span class="line">            <span class="keyword">if</span> (lenA != lenB) &#123;</span><br><span class="line">                <span class="keyword">return</span> Long.compare(lenA, lenB);</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">return</span> Long.compare(a[<span class="number">0</span>], b[<span class="number">0</span>]);</span><br><span class="line">        &#125;);</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 贪心选择：选择不重叠、最早结束的区间以最大化业务数量</span></span><br><span class="line">        List&lt;<span class="type">long</span>[]&gt; result = <span class="keyword">new</span> <span class="title class_">ArrayList</span>&lt;&gt;();</span><br><span class="line">        <span class="type">long</span> <span class="variable">lastEnd</span> <span class="operator">=</span> -<span class="number">1</span>;</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">long</span>[] range : ipRanges) &#123;</span><br><span class="line">            <span class="keyword">if</span> (range[<span class="number">0</span>] &gt; lastEnd) &#123;</span><br><span class="line">                result.add(range);</span><br><span class="line">                lastEnd = range[<span class="number">1</span>];</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 输出最终规划的IP区间</span></span><br><span class="line">        <span class="keyword">for</span> (<span class="type">long</span>[] r : result) &#123;</span><br><span class="line">            System.out.println(intToIp(r[<span class="number">0</span>]) + <span class="string">&quot; &quot;</span> + intToIp(r[<span class="number">1</span>]));</span><br><span class="line">        &#125;</span><br><span class="line">        scanner.close();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure><p>主要改动了以下几处：</p><ol><li><p><strong>IP 转换方法优化</strong></p><ul><li><p>原来在 <code>ipToInt</code> 和 <code>intToIp</code> 中使用了 <code>Math.pow</code>，返回 <code>double</code> 再转 <code>long</code>，存在精度隐患。</p></li><li><p>要改成了位移运算：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">result |= (Long.parseLong(parts[i]) &lt;&lt; (<span class="number">24</span> - <span class="number">8</span> * i));</span><br></pre></td></tr></table></figure><p>和</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">((ipInt &gt;&gt; <span class="number">24</span>) &amp; <span class="number">0xFF</span>)</span><br></pre></td></tr></table></figure><p>这样既更高效，也完全精确。</p></li></ul></li><li><p><strong>排序规则</strong></p><ul><li>原先只按“区间长度（len）”和“起始 IP”排序，忽略了“结束 IP”对贪心选择的影响。</li><li>新版改为三层优先级：</li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 1) 按结束 IP 升序  </span></span><br><span class="line"><span class="comment">// 2) 若结束 IP 相同，再按区间长度升序  </span></span><br><span class="line"><span class="comment">// 3) 若长度相同，再按起始 IP 升序</span></span><br></pre></td></tr></table></figure><p>这样能保证贪心算法每次都选最早结束、最小占用的区间，以满足“最多业务数”、“最少地址量”和“起始最小”三重要求。</p></li></ol><p>这些改动确保了：</p><ul><li>IP 转换无精度误差</li><li>排序严格符合题意的三重比较</li><li>贪心算法能真正输出示例中预期的两个区间。</li></ul><p>反思：没有考虑数据精度对结果的影响。只是运气好过了0.55</p><h2 id="总结：">总结：</h2><p>这次算法做的不太好，主要有以下这个原因：</p><ul><li>​1.不敢用IDE写，用记事本导致写的优点磕磕绊绊</li><li>​2.第一题没做出来影响了心态，然后做第二题脑袋一团浆糊。</li><li>​3.做这场笔试之前，刷了很多次华为笔试真题。自己平时做感觉没问题，在考场上做却错漏百出，只能说平时和考场还是不一样。</li><li>​4.太想进华为，导致做笔试压力很大。心情不平和影响了自己的思路。</li></ul><p>总而言之，继续多刷算法，继续加油！</p>]]></content>
    
    
    <summary type="html">🥧华为416批次笔试</summary>
    
    
    
    <category term="算法" scheme="https://outoflovenicoo.github.io/categories/%E7%AE%97%E6%B3%95/"/>
    
    
    <category term="算法" scheme="https://outoflovenicoo.github.io/tags/%E7%AE%97%E6%B3%95/"/>
    
  </entry>
  
  <entry>
    <title>暑期实习面经整理</title>
    <link href="https://outoflovenicoo.github.io/posts/2025-04-10-%E6%9A%91%E6%9C%9F%E5%AE%9E%E4%B9%A0%E9%9D%A2%E7%BB%8F%E6%95%B4%E7%90%86.html"/>
    <id>https://outoflovenicoo.github.io/posts/2025-04-10-%E6%9A%91%E6%9C%9F%E5%AE%9E%E4%B9%A0%E9%9D%A2%E7%BB%8F%E6%95%B4%E7%90%86.html</id>
    <published>2025-04-10T10:19:03.000Z</published>
    <updated>2025-04-12T14:00:00.000Z</updated>
    
    <content type="html"><![CDATA[<h1>腾讯HR事业线</h1><h2 id="1-ThreadLocal为什么不安全，怎么解决的">1.ThreadLocal为什么不安全，<strong>怎么解决的</strong></h2><h2 id="2-volatiet的原理，主存、防止指令重排序？为什么其它加锁的地方不需要用到volatiet，其它语言有这种特性吗？">2.volatiet的原理，主存、防止指令重排序？为什么其它加锁的地方不需要用到volatiet，其它语言有这种特性吗？</h2><h2 id="3-CAP理论，一致性哈希算法">3.CAP理论，一致性哈希算法</h2><h2 id="4-前端的一个页面突然特别慢，是为什么">4.前端的一个页面突然特别慢，是为什么</h2><h2 id="5-索引失效场景">5.索引失效场景</h2><h2 id="7-事务失效场景，事务传播行为">7.事务失效场景，事务传播行为</h2><h2 id="8-mysql特别慢，该怎么解决">8.mysql特别慢，该怎么解决</h2><h2 id="9-防止sql注入，-和-分别用到什么时候">9.防止sql注入，#和$分别用到什么时候</h2><h2 id="10-索引跳跃扫描">10.索引跳跃扫描</h2><h2 id="11-怎么样用redis的hash结构存储一个大key">11.怎么样用redis的hash结构存储一个大key</h2><h2 id="12-RDB和AOF为什么要混合使用">12.RDB和AOF为什么要混合使用</h2><h2 id="13-短链系统中，怎么样存储海量的长链">13.短链系统中，怎么样存储海量的长链</h2><h2 id="14-操作系统之间进程通信方式有哪些">14.操作系统之间进程通信方式有哪些</h2><h2 id="15-反问：提建议">15.反问：提建议</h2><p>学习最好的方式是看官方文档，这样知识不会被异化。</p><h1>字节飞书</h1><h2 id="1-设计模式代码题-单例模式和责任链模式">1.设计模式代码题    单例模式和责任链模式</h2><h2 id="2-写的单例是懒汉式还是饿汉式">2.写的单例是懒汉式还是饿汉式</h2><h2 id="3-八股-ThreadLocal、双亲委派、弱引用">3.八股  ThreadLocal、双亲委派、弱引用</h2><h2 id="4-双亲委派为什么要这么设计，答了防止类被重复加载，面试官不是很满意">4.双亲委派为什么要这么设计，答了防止类被重复加载，面试官不是很满意</h2><h2 id="5-场景题-有50万个坐标点，如何设计数据结构来找到距离一个点最近的10个点">5.场景题  有50万个坐标点，如何设计数据结构来找到距离一个点最近的10个点</h2><h2 id="6-代码题，现场想的，判断一个字符串是不是一个顺子，需要考虑10还有A既能当14又能当2">6.代码题，现场想的，判断一个字符串是不是一个顺子，需要考虑10还有A既能当14又能当2</h2><h2 id="7-为什么流式写入可以防止内存溢出">7.为什么流式写入可以防止内存溢出</h2><h2 id="8-如果写到一半程序崩溃了，写入一半的文件会怎样">8.如果写到一半程序崩溃了，写入一半的文件会怎样</h2><h1>美团点评事业部</h1><h2 id="1-项目相关：guava原理，guava线程池在执行任务的时候系统宕机了任务该怎么办？">1.项目相关：guava原理，guava线程池在执行任务的时候系统宕机了任务该怎么办？</h2><h2 id="2-Jwt垂直越权，水平越权">2.Jwt垂直越权，水平越权</h2><h2 id="3-事务失效场景">3.事务失效场景</h2><h2 id="4-completablefuture-allof-怎么设置超时时间">4.completablefuture.allof()怎么设置超时时间</h2><h2 id="5-怎么保证消息的顺序性">5.怎么保证消息的顺序性</h2><h2 id="6-如何保证消息插入redis一定成功">6.如何保证消息插入redis一定成功</h2><h2 id="7-数据库第一范式，第二范式，第三范式。违反会造成什么后果">7.数据库第一范式，第二范式，第三范式。违反会造成什么后果</h2><h2 id="8-innodb-的buffer-poll的刷盘机制，如果有唯一索引又会有什么变化">8.innodb 的buffer poll的刷盘机制，如果有唯一索引又会有什么变化</h2><h2 id="9-线程池工作原理，小于核心线程数时，如果来了新任务会发生什么">9.线程池工作原理，小于核心线程数时，如果来了新任务会发生什么</h2><h2 id="10-select-a-b-form-table-where-a-1-and-b-2-order-by-c-desc应该建立什么索引，升序降序会对性能造成怎么样的影响？">10.select a,b form table where a = 1 and b = 2 order by c desc应该建立什么索引，升序降序会对性能造成怎么样的影响？</h2><h2 id="11-实习中遇到的难点，最近在学的东西，怎么去学习的">11.实习中遇到的难点，最近在学的东西，怎么去学习的</h2><h2 id="12-手撕">12.手撕</h2><h2 id="一面：sql-反转链表II">一面：sql + 反转链表II</h2><h2 id="二面：美团自己出的acm形式的题，看不懂差点寄了">二面：美团自己出的acm形式的题，看不懂差点寄了</h2><h1>美团无人机</h1><h2 id="1-自我介绍（学习-校园-竞赛-科研）">1. 自我介绍（学习+校园+竞赛+科研）</h2><h2 id="2-简单问一下科研主要做的内容">2. 简单问一下科研主要做的内容</h2><h2 id="3-为什么最后选择开发（喜欢逻辑的东西）">3. 为什么最后选择开发（喜欢逻辑的东西）</h2><h2 id="4-他自己介绍下那边无人机外卖业务">4. 他自己介绍下那边无人机外卖业务</h2><h2 id="5-说一下redis你有应用哪些场景（缓存：解释redis为什么做缓存，为什么快，单线程io多路复用，分布式锁-setnx和redission-redisson的redlock-和watch-dog大致说一下）">5. 说一下redis你有应用哪些场景（缓存：解释redis为什么做缓存，为什么快，单线程io多路复用，分布式锁 setnx和redission redisson的redlock 和watch dog大致说一下）</h2><h2 id="6-说一下分布式锁的项目应用">6. 说一下分布式锁的项目应用</h2><h2 id="7-说一下redis集群，主从和分片讲了下">7. 说一下redis集群，主从和分片讲了下</h2><h2 id="8-说一下分布式锁不是可能失效。讲了下redlock要redis集群多数都成功才能算分布式锁成功，失效情况很极端，比较少会碰到">8. 说一下分布式锁不是可能失效。讲了下redlock要redis集群多数都成功才能算分布式锁成功，失效情况很极端，比较少会碰到</h2><h2 id="9-如果订单需要兜底方案，三个小时后需要去检查有无完成，没有则警告">9. 如果订单需要兜底方案，三个小时后需要去检查有无完成，没有则警告</h2><h2 id="10-给你业务场景（无人机送外卖，一个接口相当于你只知道订单id，在不同情况需要返回比如起飞时候要有起飞机场无人机-如果派送中需要所处的位置等等）">10. 给你业务场景（无人机送外卖，一个接口相当于你只知道订单id，在不同情况需要返回比如起飞时候要有起飞机场无人机 如果派送中需要所处的位置等等）</h2><p>用状态机+连表查询巴拉巴拉（问了代码大致要怎么实现）然后说数据库表怎么设计，我没get到点，我就说了符合范式大致订单表有哪些字段对应哪些表，然后说了那这样不是连表查询很多怎么优化，我说像是机场这种信息可以作为缓存，因为本身这些信息不会咋变动，能不能继续优化，我询问订单是否是短时间的，如果是短时间的整个订单信息都可以作为缓存，因为类似于外卖可能只有在送的一小时之内会频繁查询后续删除缓存写入数据库。缓存数据库一致性 我就说了分强一致性场景双写（本场景），弱一致性先写数据库删除缓存，后续读不到缓存就能去数据库更新缓存，再问如果我现在整个接口那些信息查询都是别的系统的数据库不能直接查询要调用接口（分布式缓存、消息队列传数据不行）假设有一个接口就是3s其他都是1s之内。想法木桶效应，那就需要解决最长时常接口，可能那个接口不是经常变动的或者说允许一个数据延时误差，就这个数据我做缓存然后轮询定时任务进行更新，可能数据会有一定的滞后性，但是可以保证接口的响应速度</p><h2 id="11-手撕：">11. 手撕：</h2><p>开撕滑动窗口239</p><h1>其它面经</h1><p>饿了么、腾讯PCG、菜鸟、炎魂网络、滴滴待整理。</p>]]></content>
    
    
    <summary type="html">🥧暑期实习面经整理</summary>
    
    
    
    <category term="面试题" scheme="https://outoflovenicoo.github.io/categories/%E9%9D%A2%E8%AF%95%E9%A2%98/"/>
    
    
    <category term="面经" scheme="https://outoflovenicoo.github.io/tags/%E9%9D%A2%E7%BB%8F/"/>
    
  </entry>
  
  <entry>
    <title>深入探讨多线程操作数组背后的CPU伪共享与MESI协议</title>
    <link href="https://outoflovenicoo.github.io/posts/2025-04-01-%E6%B7%B1%E5%85%A5%E6%8E%A2%E8%AE%A8%E5%A4%9A%E7%BA%BF%E7%A8%8B%E6%93%8D%E4%BD%9C%E6%95%B0%E7%BB%84%E8%83%8C%E5%90%8E%E7%9A%84CPU%E4%BC%AA%E5%85%B1%E4%BA%AB%E4%B8%8EMESI%E5%8D%8F%E8%AE%AE.html"/>
    <id>https://outoflovenicoo.github.io/posts/2025-04-01-%E6%B7%B1%E5%85%A5%E6%8E%A2%E8%AE%A8%E5%A4%9A%E7%BA%BF%E7%A8%8B%E6%93%8D%E4%BD%9C%E6%95%B0%E7%BB%84%E8%83%8C%E5%90%8E%E7%9A%84CPU%E4%BC%AA%E5%85%B1%E4%BA%AB%E4%B8%8EMESI%E5%8D%8F%E8%AE%AE.html</id>
    <published>2025-04-01T10:19:03.000Z</published>
    <updated>2025-04-12T14:00:00.000Z</updated>
    
    <content type="html"><![CDATA[<h2 id="思维导图：">思维导图：</h2><p><img src="2025-04-01-%E6%B7%B1%E5%85%A5%E6%8E%A2%E8%AE%A8%E5%A4%9A%E7%BA%BF%E7%A8%8B%E6%93%8D%E4%BD%9C%E6%95%B0%E7%BB%84%E8%83%8C%E5%90%8E%E7%9A%84CPU%E4%BC%AA%E5%85%B1%E4%BA%AB%E4%B8%8EMESI%E5%8D%8F%E8%AE%AE/diagram.png" alt=""></p><h2 id="前言：">前言：</h2><p>这是一道腾讯的面试题，通过这个问题我理解了CPU缓存的一致性怎么保障的，具体场景如下：</p><p>当我们面对这样一个场景：n个线程去操纵数组的n个元素，编号为i的线程只会操作下标为i的数组元素 <code>arr[i]++</code>，看似每个线程各司其职，互不干扰，然而实际运行中却可能出现性能问题。这背后涉及CPU缓存结构、伪共享问题、MESI协议以及CPU Cache数据的写入方式，下面我们逐步分析。</p><h2 id="一、CPU缓存结构：L1、L2、L3">一、CPU缓存结构：L1、L2、L3</h2><p>在现代多核CPU架构中，缓存系统分为多个层级：</p><ul><li><p><strong>L1缓存</strong>：每个CPU核心都有独立的L1缓存，且进一步细分为L1数据缓存（存放数据）和L1指令缓存（存放指令）。它的速度最快，但容量最小，通常只有几十KB。例如，在一些CPU中，L1数据缓存和指令缓存可能各为32KB。</p></li><li><p><strong>L2缓存</strong>：同样每个核心独立拥有，容量比L1大，速度稍慢于L1。一般为几百KB到几MB不等，例如某些CPU的L2缓存可能是256KB或512KB。它的作用是在L1未命中时，为核心提供数据和指令。</p></li><li><p><strong>L3缓存</strong>：通常为多个核心共享，容量更大，速度相对L1、L2更慢。L3缓存可以达到几MB甚至几十MB，例如一些高端CPU的L3缓存可能为12MB或更高。它作为更大范围的缓存池，减少核心对内存的直接访问。</p></li></ul><p>数据在内存与缓存之间以 **Cache Line**（缓存行，通常为64字节）为单位传输。当CPU读取数据时，会将包含目标数据的整个Cache Line读入缓存。</p><h2 id="二、CPU-Cache数据的写入方式">二、CPU Cache数据的写入方式</h2><h3 id="写直达（Write-Through）">写直达（Write - Through）</h3><p>写直达是指CPU在写入数据到Cache时，会同时将数据写入内存。具体流程为：当CPU执行写入数据操作时，先检查数据是否在CPU Cache中。如果在，直接将数据写入Cache Block；如果不在，则先将数据写入内存，再完成操作。这种方式的优点是能保证内存和Cache中的数据始终一致，但每次写入都需要访问内存，会增加内存总线的流量，降低写入效率。在多线程伪共享场景中，写直达会频繁触发内存写入操作，引发更多的总线事务，导致其他核心更频繁地感知到Cache Line的变化，加剧伪共享带来的性能损耗。</p><h3 id="写回（Write-Back）">写回（Write - Back）</h3><p>写回策略下，CPU先将数据写入Cache Block，并标记该Cache Block为“脏”（已修改）。当Cache Block需要被替换（例如新的数据要存入，而Cache已满）时，才将脏数据写回内存。具体流程为：CPU将数据写入Cache Block后，检查数据是否在其他CPU Cache中。如果不在，直接标记Cache Block为脏；如果在，则需要先使其他核心中相同的Cache Line失效（通过MESI协议），然后标记当前Cache Block为脏。写回方式减少了内存写入次数，提升了写入效率，但存在数据不一致的风险（在数据写回内存前，内存中的数据是旧的）。在伪共享场景中，写回虽然减少了内存写入，但一个核心对Cache Block的修改（标记为脏）会通过MESI协议使其他核心的相同Cache Line失效，当其他核心后续操作同属一个Cache Line的元素时，需要重新读取数据，这一过程依然会产生缓存状态切换和数据同步开销。</p><h2 id="三、伪共享问题：隐藏的性能杀手">三、伪共享问题：隐藏的性能杀手</h2><h3 id="伪共享的定义与成因">伪共享的定义与成因</h3><p>伪共享指多个线程操作不同变量，但这些变量因存储在同一个Cache Line中，导致彼此的操作互相影响。例如，在上述多线程操作数组的场景中，假设数组在内存中连续存储，一个Cache Line（64字节）可以存放16个 <code>int</code> 类型的数组元素（每个 <code>int</code> 占4字节）。若线程A操作 <code>arr[i]</code>，线程B操作 <code>arr[j]</code>（<code>i</code> 与 <code>j</code> 对应的元素在同一个Cache Line），尽管逻辑上两者无直接关联，但硬件层面的缓存机制会让它们产生交互。</p><h3 id="伪共享如何影响性能">伪共享如何影响性能</h3><p>当一个线程修改Cache Line中的数据（如 <code>arr[i]++</code>），根据MESI协议，该Cache Line状态会变为“已修改”（写回策略）或触发内存写入（写直达策略），其他核心中相同的Cache Line会被标记为“已失效”。若其他线程此时要操作同属一个Cache Line的其他元素，需重新从内存或其他核心获取数据，这一过程涉及缓存状态的频繁切换（如从“共享”到“已失效”再到重新加载）、数据同步以及总线通信开销。即使这些线程操作的是不同变量，也会因伪共享导致大量不必要的缓存同步操作，严重影响程序性能。</p><h2 id="四、MESI协议：缓存一致性的保障">四、MESI协议：缓存一致性的保障</h2><p>MESI协议定义了Cache Line的四种状态，用于保证多核CPU缓存一致性：</p><ul><li><p><strong>独占（Exclusive）</strong>：该Cache Line只在当前核心缓存中，且数据与内存一致。此时其他核心没有该Cache Line的副本。</p></li><li><p><strong>共享（Shared）</strong>：多个核心缓存中都有该Cache Line，且数据与内存一致。多个核心可以同时读取该Cache Line中的数据。</p></li><li><p><strong>已修改（Modified）</strong>：该Cache Line在当前核心缓存中被修改，与内存不一致。其他核心若要读取该数据，需先从当前核心获取最新数据，当前核心会在适当时候将数据写回内存。</p></li><li><p><strong>已失效（Invalidated）</strong>：该Cache Line在当前核心缓存中失效，需从内存或其他核心重新获取数据。</p></li></ul><p>在伪共享场景中，一个核心对Cache Line的修改会触发MESI协议的状态变更，导致其他核心的相同Cache Line失效，进而引发一系列数据同步操作，这就是伪共享影响性能的底层机制。</p><h2 id="五、解决伪共享：让缓存行“各司其职”">五、解决伪共享：让缓存行“各司其职”</h2><p>最直接的解决方式是通过字节填充，确保每个数组元素或相关变量单独占据一个Cache Line。在Java中，可以使用 <code>@Contended</code> 注解（需开启JVM参数 <code>-XX:-RestrictContended</code>）来实现。例如：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> sun.misc.Contended;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">ArrayExample</span> &#123;</span><br><span class="line">    <span class="meta">@Contended</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">volatile</span> <span class="type">long</span>[] arr;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="title function_">ArrayExample</span><span class="params">(<span class="type">int</span> size)</span> &#123;</span><br><span class="line">        arr = <span class="keyword">new</span> <span class="title class_">long</span>[size];</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">increment</span><span class="params">(<span class="type">int</span> i)</span> &#123;</span><br><span class="line">        arr[i]++;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>或者手动添加填充字段：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">PaddedLong</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">volatile</span> <span class="type">long</span> value;</span><br><span class="line">    <span class="comment">// 填充7个long类型字段，共56字节，加上value本身8字节，刚好占满一个64字节的Cache Line</span></span><br><span class="line">    <span class="keyword">private</span> <span class="type">long</span> p1, p2, p3, p4, p5, p6, p7; </span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">ArrayExample</span> &#123;</span><br><span class="line">    <span class="keyword">private</span> PaddedLong[] arr;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="title function_">ArrayExample</span><span class="params">(<span class="type">int</span> size)</span> &#123;</span><br><span class="line">        arr = <span class="keyword">new</span> <span class="title class_">PaddedLong</span>[size];</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i &lt; size; i++) &#123;</span><br><span class="line">            arr[i] = <span class="keyword">new</span> <span class="title class_">PaddedLong</span>();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">increment</span><span class="params">(<span class="type">int</span> i)</span> &#123;</span><br><span class="line">        arr[i].value++;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>通过上述方式，每个元素或包含元素的对象能独立占据Cache Line，避免因伪共享导致的性能损耗。</p><p>总结来看，多线程操作数组元素时，看似简单的逻辑在底层硬件（CPU缓存结构、Cache数据写入方式）与缓存协议（MESI协议）的影响下可能产生性能问题。其实在实际开发中，我们很少会多线程去操作一个数组，不过这个问题让我对CPU缓存一致性有了更深的理解，很有意义。</p><h2 id="参考博客：">参考博客：</h2><p><a href="https://xiaolincoding.com/os/1_hardware/cpu_mesi.html#cpu-cache-%E7%9A%84%E6%95%B0%E6%8D%AE%E5%86%99%E5%85%A5">2.4 CPU 缓存一致性</a></p><p><a href="https://mp.weixin.qq.com/s/PDUqwAIaUxNkbjvRfovaCg">十张图介绍MESI</a></p>]]></content>
    
    
    <summary type="html">🥧深入探讨多线程操作数组背后的CPU伪共享与MESI协议</summary>
    
    
    
    <category term="学习" scheme="https://outoflovenicoo.github.io/categories/%E5%AD%A6%E4%B9%A0/"/>
    
    
    <category term="思维导图" scheme="https://outoflovenicoo.github.io/tags/%E6%80%9D%E7%BB%B4%E5%AF%BC%E5%9B%BE/"/>
    
  </entry>
  
  <entry>
    <title>根据字符串数组构建一颗二叉树</title>
    <link href="https://outoflovenicoo.github.io/posts/2025-03-25-%E6%A0%B9%E6%8D%AE%E5%AD%97%E7%AC%A6%E4%B8%B2%E6%95%B0%E7%BB%84%E6%9E%84%E5%BB%BA%E4%B8%80%E9%A2%97%E4%BA%8C%E5%8F%89%E6%A0%91.html"/>
    <id>https://outoflovenicoo.github.io/posts/2025-03-25-%E6%A0%B9%E6%8D%AE%E5%AD%97%E7%AC%A6%E4%B8%B2%E6%95%B0%E7%BB%84%E6%9E%84%E5%BB%BA%E4%B8%80%E9%A2%97%E4%BA%8C%E5%8F%89%E6%A0%91.html</id>
    <published>2025-03-25T07:19:03.000Z</published>
    <updated>2025-03-25T14:00:00.000Z</updated>
    
    <content type="html"><![CDATA[<p><strong>在面试手撕的时候，经常需要根据输入的字符串构建一颗树，由于第一次做，磕磕绊绊才写出来，这里记录一下吧</strong></p><h3 id="样例">样例</h3><p>根据字符串 <code>[1,2,3,null,4,null,5]</code> 构建二叉树时，需按照 <strong>层序遍历顺序</strong> 解析节点值，其中 <code>null</code> 表示空节点。以下是构建过程和结果：</p><h3 id="构建规则"><strong>构建规则</strong></h3><ol><li><strong>根节点</strong>：字符串中第一个非 <code>null</code> 的值（此处为 <code>1</code>）。</li><li><strong>层序填充</strong>：从根节点开始，按 <strong>左子节点 → 右子节点</strong> 的顺序依次填充后续节点：<ol><li>若当前节点为 <code>null</code>，则跳过其左右子节点。</li><li>空值（<code>null</code>）仅表示节点不存在，不参与树结构。</li></ol></li></ol><h3 id="详细构建步骤"><strong>详细构建步骤</strong></h3><h4 id="第-1-层（根节点）"><strong>第 1 层（根节点）</strong></h4><ul><li>节点值：<code>1</code>根节点为 <code>1</code>，对应位置 <code>i=0</code>。</li></ul><h4 id="第-2-层（根节点的左右子节点）"><strong>第 2 层（根节点的左右子节点）</strong></h4><ul><li>左子节点：位置 <code>i=1</code>，值为 <code>2</code>，非空，作为 <code>1</code> 的左子节点。</li><li>右子节点：位置 <code>i=2</code>，值为 <code>3</code>，非空，作为 <code>1</code> 的右子节点。</li></ul><h4 id="第-3-层（第-2-层节点的左右子节点）"><strong>第 3 层（第 2 层节点的左右子节点）</strong></h4><ul><li><strong>节点</strong> **<code>2</code>**的子节点：<ul><li>左子节点：位置 <code>i=3</code>，值为 <code>null</code>，跳过。</li><li>右子节点：位置 <code>i=4</code>，值为 <code>4</code>，非空，作为 <code>2</code> 的右子节点。</li></ul></li><li><strong>节点</strong> <strong><code>3</code></strong> 的子节点：<ul><li>左子节点：位置 <code>i=5</code>，值为 <code>null</code>，跳过。</li><li>右子节点：位置 <code>i=6</code>，值为 <code>5</code>，非空，作为 <code>3</code> 的右子节点。</li></ul></li></ul><h4 id="后续节点"><strong>后续节点</strong></h4><p>字符串中剩余内容（末尾逗号）可忽略，无有效节点。</p><h3 id="最终二叉-树结构"><strong>最终二叉****树结构</strong></h3><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">  1</span><br><span class="line"> / \</span><br><span class="line">2   3</span><br><span class="line"> \   \</span><br><span class="line">  4   5</span><br></pre></td></tr></table></figure><ul><li><strong>根节点</strong>：<code>1</code></li><li><strong>左子树</strong>：以 <code>2</code> 为根，其右子节点为 <code>4</code>。</li><li><strong>右子树</strong>：以 <code>3</code> 为根，其右子节点为 <code>5</code>。</li></ul><h3 id="验证层序遍历"><strong>验证层序遍历</strong></h3><p>构建后的二叉树层序遍历结果与输入字符串一致（忽略 <code>null</code> 后的有效节点）：</p><p><code>[1, 2, 3, 4, 5]</code>，符合预期。</p><h3 id="代码：">代码：</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> java.util.LinkedList;</span><br><span class="line"><span class="keyword">import</span> java.util.Queue;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 定义二叉树节点类</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">TreeNode</span> &#123;</span><br><span class="line">    <span class="type">int</span> val;</span><br><span class="line">    TreeNode left;</span><br><span class="line">    TreeNode right;</span><br><span class="line">    TreeNode(<span class="type">int</span> x) &#123; val = x; &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">BuildBinaryTree</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> TreeNode <span class="title function_">buildTree</span><span class="params">(String str)</span> &#123;</span><br><span class="line">        <span class="comment">// 去除首尾的方括号</span></span><br><span class="line">        str = str.substring(<span class="number">1</span>, str.length() - <span class="number">1</span>);</span><br><span class="line">        <span class="keyword">if</span> (str.isEmpty()) &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">null</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        String[] values = str.split(<span class="string">&quot;,&quot;</span>);</span><br><span class="line">        <span class="type">TreeNode</span> <span class="variable">root</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">TreeNode</span>(Integer.parseInt(values[<span class="number">0</span>]));</span><br><span class="line">        Queue&lt;TreeNode&gt; queue = <span class="keyword">new</span> <span class="title class_">LinkedList</span>&lt;&gt;();</span><br><span class="line">        queue.offer(root);</span><br><span class="line">        <span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">1</span>;</span><br><span class="line">        <span class="keyword">while</span> (!queue.isEmpty() &amp;&amp; i &lt; values.length) &#123;</span><br><span class="line">            <span class="type">TreeNode</span> <span class="variable">node</span> <span class="operator">=</span> queue.poll();</span><br><span class="line">            <span class="keyword">if</span> (!values[i].equals(<span class="string">&quot;null&quot;</span>)) &#123;</span><br><span class="line">                node.left = <span class="keyword">new</span> <span class="title class_">TreeNode</span>(Integer.parseInt(values[i]));</span><br><span class="line">                queue.offer(node.left);</span><br><span class="line">            &#125;</span><br><span class="line">            i++;</span><br><span class="line">            <span class="keyword">if</span> (i &lt; values.length &amp;&amp; !values[i].equals(<span class="string">&quot;null&quot;</span>)) &#123;</span><br><span class="line">                node.right = <span class="keyword">new</span> <span class="title class_">TreeNode</span>(Integer.parseInt(values[i]));</span><br><span class="line">                queue.offer(node.right);</span><br><span class="line">            &#125;</span><br><span class="line">            i++;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> root;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">        <span class="type">String</span> <span class="variable">input</span> <span class="operator">=</span> <span class="string">&quot;[1,2,3,null,4,null,5]&quot;</span>;</span><br><span class="line">        <span class="type">TreeNode</span> <span class="variable">root</span> <span class="operator">=</span> buildTree(input);</span><br><span class="line">        <span class="comment">// 这里可以添加遍历二叉树的代码来验证结果</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;    </span><br></pre></td></tr></table></figure>]]></content>
    
    
    <summary type="html">🥧根据字符串数组构建一颗二叉树</summary>
    
    
    
    <category term="算法" scheme="https://outoflovenicoo.github.io/categories/%E7%AE%97%E6%B3%95/"/>
    
    
    <category term="算法" scheme="https://outoflovenicoo.github.io/tags/%E7%AE%97%E6%B3%95/"/>
    
  </entry>
  
  <entry>
    <title>Guava的eventBus的原理</title>
    <link href="https://outoflovenicoo.github.io/posts/2025-03-20-Guava%E7%9A%84eventBus%E7%9A%84%E5%8E%9F%E7%90%86.html"/>
    <id>https://outoflovenicoo.github.io/posts/2025-03-20-Guava%E7%9A%84eventBus%E7%9A%84%E5%8E%9F%E7%90%86.html</id>
    <published>2025-03-20T10:19:03.000Z</published>
    <updated>2025-03-20T14:00:00.000Z</updated>
    
    <content type="html"><![CDATA[<h1>Guava的eventBus的原理</h1><p><img src="2025-03-20-Guava%E7%9A%84eventBus%E7%9A%84%E5%8E%9F%E7%90%86/diagram.png" alt=""></p><p>在Java应用开发中，同一JVM内的事件通知场景普遍存在。相较于分布式消息队列（MQ），Guava提供的EventBus框架以轻量、便捷的特点成为首选。本文将从架构设计、运行机制、使用场景及注意事项等方面，深入解析EventBus的核心原理。</p><h2 id="一、EventBus的架构组成">一、EventBus的架构组成</h2><p>EventBus由以下核心模块构成：</p><ol><li><p><strong>事件发送器</strong>  </p><ul><li><p><strong>EventBus</strong>：同步事件发送器，默认使用<code>DirectExecutor</code>直接在当前线程执行事件处理逻辑。  </p></li><li><p><strong>AsyncEventBus</strong>：异步事件发送器，需传入自定义线程池（如<code>ThreadPoolExecutor</code>），通过线程池实现异步调度。  </p></li></ul></li><li><p><strong>事件载体（Event）</strong>事件是通知的最小单元，可定义任意类型的POJO作为事件（如<code>LoginEvent</code>、<code>RegisterEvent</code>）。  </p></li><li><p><strong>订阅者注册器（SubscriberRegistry）</strong>负责管理订阅者与事件的映射关系，通过反射扫描订阅者类中被<code>@Subscribe</code>注解标记的方法，并将其与事件类型绑定到<code>Multimap&lt;Class&lt;?&gt;, Subscriber&gt;</code>集合中。  </p></li><li><p><strong>事件分发器（Dispatcher）</strong>  </p><ul><li><p><strong>PerThreadQueuedDispatcher</strong>（EventBus默认）：基于线程本地队列（<code>ThreadLocal&lt;Queue&lt;Event&gt;&gt;</code>）实现同步分发，按顺序处理事件。  </p></li><li><p><strong>LegacyAsyncDispatcher</strong>（AsyncEventBus默认）：通过线程池异步执行事件处理逻辑。  </p></li></ul></li><li><p><strong>订阅者（Subscriber）</strong>  </p><ul><li><p><strong>Subscriber</strong>：无同步修饰的订阅者，适用于线程安全的事件处理方法（需通过<code>@AllowConcurrentEvents</code>注解声明）。  </p></li><li><p><strong>SynchronizedSubscriber</strong>：自动添加<code>synchronized</code>同步块的订阅者，确保非线程安全方法在并发场景下的串行执行。</p></li></ul></li></ol><h2 id="二、核心运行流程解析">二、核心运行流程解析</h2><h3 id="1-初始化与注册">1. 初始化与注册</h3><ul><li><p><strong>创建EventBus实例</strong>  </p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 同步EventBus</span></span><br><span class="line"><span class="type">EventBus</span> <span class="variable">eventBus</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">EventBus</span>(); </span><br><span class="line"><span class="comment">// 异步EventBus（需指定线程池）</span></span><br><span class="line"><span class="type">ThreadPoolExecutor</span> <span class="variable">executor</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">ThreadPoolExecutor</span>(<span class="number">5</span>, <span class="number">20</span>, <span class="number">30</span>, TimeUnit.SECONDS, <span class="keyword">new</span> <span class="title class_">LinkedBlockingQueue</span>&lt;&gt;(<span class="number">20</span>));</span><br><span class="line"><span class="type">AsyncEventBus</span> <span class="variable">asyncEventBus</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">AsyncEventBus</span>(executor);</span><br></pre></td></tr></table></figure></li><li><p><strong>注册订阅者</strong>通过<code>eventBus.register(listener)</code>方法将订阅者对象注册到框架中。底层通过反射遍历<code>listener</code>的所有方法，提取被<code>@Subscribe</code>标记的方法，封装为<code>Subscriber</code>对象，并按事件类型存储到<code>SubscriberRegistry</code>的<code>Multimap</code>中。</p></li></ul><h3 id="2-事件发送与处理">2. 事件发送与处理</h3><ul><li><p><strong>事件发布</strong>调用<code>eventBus.post(event)</code>触发事件分发：  </p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">eventBus.post(<span class="keyword">new</span> <span class="title class_">LoginEvent</span>(<span class="string">&quot;user&quot;</span>, <span class="string">&quot;password&quot;</span>));</span><br></pre></td></tr></table></figure></li><li><p><strong>分发逻辑</strong>  </p><ul><li><p><strong>同步模式（EventBus）</strong>：通过<code>PerThreadQueuedDispatcher</code>将事件存入当前线程的本地队列，按顺序逐个调用订阅者的处理方法，同步阻塞直至所有处理完成。  </p></li><li><p><strong>异步模式（AsyncEventBus）</strong>：通过<code>LegacyAsyncDispatcher</code>将事件处理逻辑提交到线程池，由线程池异步执行，发送线程无需等待结果。  </p></li></ul></li><li><p><strong>死亡事件（DeadEvent）</strong>若事件未被任何订阅者处理，EventBus会自动将其包装为<code>DeadEvent</code>并重新发布，可通过订阅<code>DeadEvent</code>捕获未处理的事件。</p></li></ul><h3 id="3-线程安全与并发控制">3. 线程安全与并发控制</h3><ul><li><p><strong>订阅者方法的线程安全</strong>  </p><ul><li><p>若方法被<code>@AllowConcurrentEvents</code>注解标记，EventBus会创建普通<code>Subscriber</code>，允许并发执行（需自行保证线程安全）。  </p></li><li><p>未标记注解的方法会被包装为<code>SynchronizedSubscriber</code>，通过<code>synchronized</code>关键字确保同一订阅者实例的方法串行执行，可能成为高并发场景的性能瓶颈。</p></li></ul></li></ul><h2 id="三、典型使用场景与代码示例">三、典型使用场景与代码示例</h2><h3 id="1-配置与初始化">1. 配置与初始化</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Configuration</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">EventBusConfig</span> &#123;</span><br><span class="line">    <span class="meta">@Bean</span></span><br><span class="line">    <span class="keyword">public</span> AsyncEventBus <span class="title function_">asyncEventBus</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="type">ThreadPoolExecutor</span> <span class="variable">executor</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">ThreadPoolExecutor</span>(</span><br><span class="line">            <span class="number">5</span>, <span class="number">20</span>, <span class="number">30</span>, TimeUnit.SECONDS,</span><br><span class="line">            <span class="keyword">new</span> <span class="title class_">LinkedBlockingQueue</span>&lt;&gt;(<span class="number">20</span>),</span><br><span class="line">            <span class="keyword">new</span> <span class="title class_">ThreadPoolExecutor</span>.CallerRunsPolicy() <span class="comment">// 拒绝策略示例</span></span><br><span class="line">        );</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">new</span> <span class="title class_">AsyncEventBus</span>(executor);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="2-订阅者定义">2. 订阅者定义</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Component</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">EventListener</span> &#123;</span><br><span class="line">    <span class="comment">// 同步处理登录事件</span></span><br><span class="line">    <span class="meta">@Subscribe</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">handleLoginEvent</span><span class="params">(LoginEvent event)</span> &#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;Received login event: &quot;</span> + event.getUsername());</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 异步处理注册事件（需AsyncEventBus）</span></span><br><span class="line">    <span class="meta">@Subscribe</span></span><br><span class="line">    <span class="meta">@AllowConcurrentEvents</span> <span class="comment">// 声明线程安全，允许并发处理</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">handleRegisterEvent</span><span class="params">(RegisterEvent event)</span> &#123;</span><br><span class="line">        <span class="comment">// 耗时操作示例</span></span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            Thread.sleep(<span class="number">1000</span>);</span><br><span class="line">        &#125; <span class="keyword">catch</span> (InterruptedException e) &#123;</span><br><span class="line">            Thread.currentThread().interrupt();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="3-事件发送">3. 事件发送</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Service</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">EventPublisher</span> &#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">final</span> EventBus eventBus;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="title function_">EventPublisher</span><span class="params">(EventBus eventBus)</span> &#123;</span><br><span class="line">        <span class="built_in">this</span>.eventBus = eventBus;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">publishLoginEvent</span><span class="params">(String username, String password)</span> &#123;</span><br><span class="line">        eventBus.post(<span class="keyword">new</span> <span class="title class_">LoginEvent</span>(username, password));</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="四、注意事项与性能优化">四、注意事项与性能优化</h2><ul><li><p><strong>线程池配置</strong>  </p><ul><li><p>异步模式下需合理设置线程池参数（如核心线程数、队列容量、拒绝策略），避免任务堆积或线程耗尽。  </p></li><li><p>建议为不同类型的事件分配独立线程池，防止高耗时事件阻塞其他事件处理。  </p></li></ul></li><li><p><strong>反射开销</strong>  </p><ul><li>订阅者注册过程依赖反射，高频率注册/注销场景可能影响性能，建议在系统启动阶段完成所有订阅者注册。  </li></ul></li><li><p><strong>并发控制</strong>  </p><ul><li>非线程安全的订阅者方法（未使用<code>@AllowConcurrentEvents</code>）会被自动同步，高并发时需评估串行执行的性能影响，必要时通过线程安全的数据结构或异步拆分优化。  </li></ul></li><li><p><strong>异常处理</strong>  </p><ul><li>事件处理方法若抛出异常，会被EventBus捕获并记录，但不会中断其他订阅者的执行。建议在方法内部添加try-catch块，避免未预期异常导致系统不稳定。  </li></ul></li></ul><h2 id="五、总结">五、总结</h2><p>Guava EventBus通过简洁的发布-订阅模式，为JVM内的事件通信提供了高效解决方案。理解其架构设计（如同步/异步分发机制、订阅者注册原理）和线程安全策略，能帮助开发者在实际项目中合理选择EventBus或AsyncEventBus，并通过优化线程池配置、减少反射开销等手段提升系统性能。在微服务或复杂业务场景中，结合分布式消息队列（如Kafka、RabbitMQ）与EventBus，可进一步构建层次化的事件驱动架构。</p><h2 id="参考博客：">参考博客：</h2><p><a href="https://cloud.tencent.com/developer/article/1377032">Guava原理深度解析</a></p>]]></content>
    
    
    <summary type="html">🥧Guava的eventBus的原理</summary>
    
    
    
    <category term="学习" scheme="https://outoflovenicoo.github.io/categories/%E5%AD%A6%E4%B9%A0/"/>
    
    
    <category term="原理" scheme="https://outoflovenicoo.github.io/tags/%E5%8E%9F%E7%90%86/"/>
    
  </entry>
  
  <entry>
    <title>CompletableFuture原理及其使用</title>
    <link href="https://outoflovenicoo.github.io/posts/2025-03-19-CompletableFuture%E5%8E%9F%E7%90%86%E5%8F%8A%E5%85%B6%E4%BD%BF%E7%94%A8.html"/>
    <id>https://outoflovenicoo.github.io/posts/2025-03-19-CompletableFuture%E5%8E%9F%E7%90%86%E5%8F%8A%E5%85%B6%E4%BD%BF%E7%94%A8.html</id>
    <published>2025-03-19T10:19:03.000Z</published>
    <updated>2025-03-19T14:00:00.000Z</updated>
    
    <content type="html"><![CDATA[<h1>思维导图：</h1><p><img src="2025-03-19-CompletableFuture%E5%8E%9F%E7%90%86%E5%8F%8A%E5%85%B6%E4%BD%BF%E7%94%A8/diagram-5060644.png" alt=""></p><h1>深入理解CompletableFuture原理</h1><p><strong>实习的时候用到了<code>CompletableFuture</code>，本着知其然要知其所以然的原则，总结一下<code>CompletableFuture</code>的原理吧。</strong></p><p>在Java的并发编程领域中，我们常常会遇到需要进行异步计算的场景。比如，当我们从数据库获取数据、调用远程服务接口时，如果这些操作在主线程中同步执行，可能会导致主线程阻塞，影响程序的响应性能。这时候，<code>CompletableFuture</code>就派上了大用场，它为我们提供了强大而灵活的异步编程支持。</p><h2 id="一、CompletableFuture实现的接口">一、CompletableFuture实现的接口</h2><p><code>CompletableFuture</code>实现了<code>Future</code>和<code>CompletionStage</code>两个接口。<code>Future</code>接口大家相对比较熟悉，它主要用于表示异步计算的结果。我们可以通过它获取异步任务的执行结果、判断任务是否完成以及取消任务等操作。而<code>CompletionStage</code>接口则为异步编程带来了更多的灵活性和可编排性。它表示异步执行过程中的一个步骤（Stage），一个<code>CompletionStage</code>的完成可能会触发其他一系列<code>CompletionStage</code>的执行。我们可以根据实际业务需求，通过<code>CompletionStage</code>提供的<code>thenApply</code>、<code>thenCompose</code>等函数式编程方法，对这些步骤进行多样化的编排组合，从而实现复杂的异步逻辑。</p><h2 id="二、CompletableFuture的依赖关系">二、CompletableFuture的依赖关系</h2><h3 id="一元依赖">一元依赖</h3><p>当我们的任务只依赖于单个<code>CompletableFuture</code>时，就属于一元依赖的情况。在这种情况下，我们可以使用<code>thenApply</code>、<code>thenAccept</code>、<code>thenCompose</code>等方法。例如，<code>thenApply</code>方法接收一个函数作为参数，当依赖的<code>CompletableFuture</code>完成时，会将其结果作为参数传递给这个函数进行处理，并返回一个新的<code>CompletableFuture</code>，这个新的<code>CompletableFuture</code>的结果就是函数处理后的返回值。<code>thenAccept</code>方法则是在依赖的<code>CompletableFuture</code>完成时，接收其结果进行处理，但不返回新的结果。<code>thenCompose</code>方法与<code>thenApply</code>类似，不过它接收的函数返回值是一个<code>CompletableFuture</code>，这样可以方便地将多个异步操作进行链式组合。</p><h3 id="二元依赖">二元依赖</h3><p>如果我们的任务依赖于两个<code>CompletableFuture</code>，那么可以使用<code>thenCombine</code>等回调方法来实现。<code>thenCombine</code>方法会等待两个<code>CompletableFuture</code>都完成后，将它们的结果作为参数传递给指定的函数进行处理，最终返回一个新的<code>CompletableFuture</code>，其结果是函数处理后的返回值。这种方式可以让我们在两个异步操作都完成后，对它们的结果进行整合处理。</p><h3 id="多元依赖">多元依赖</h3><p>当任务依赖于多个<code>CompletableFuture</code>时，也就是多元依赖的情况。我们可以通过<code>allOf</code>或<code>anyOf</code>方法来实现。<code>allOf</code>方法会等待所有传入的<code>CompletableFuture</code>都完成后才返回，而<code>anyOf</code>方法则是只要有一个传入的<code>CompletableFuture</code>完成就会返回，返回的结果是第一个完成的<code>CompletableFuture</code>的结果。</p><h2 id="三、CompletableFuture的原理">三、CompletableFuture的原理</h2><h3 id="内部字段">内部字段</h3><p><code>CompletableFuture</code>内部包含两个重要字段：<code>result</code>和<code>stack</code> 。<code>result</code>用于存储异步计算的结果，而<code>stack</code>则在处理依赖关系和通知观察者等过程中发挥着关键作用。</p><h3 id="观察者与被观察者模式">观察者与被观察者模式</h3><p><code>CompletableFuture</code>的工作原理类似于观察者与被观察者模式。例如，当我们调用<code>CompletableFuture.allOf(cf1, cf2, cf3)</code>时，这里的<code>cf1</code>、<code>cf2</code>、<code>cf3</code>就是被观察者，而调用<code>allOf</code>方法返回的<code>CompletableFuture</code>（假设为<code>CF</code> ）就是观察者。在执行过程中，<code>CF</code>会先把自己注册到<code>cf1</code>、<code>cf2</code>、<code>cf3</code>中成为观察者。当<code>cf1</code>执行完成后，它会将自己的结果保存在自身内部，同时根据<code>stack</code>中的信息去提醒观察者。只有当所有被观察者（<code>cf1</code>、<code>cf2</code>、<code>cf3</code> ）都执行完成后，观察者<code>CF</code>才会将最终的结果保存到自己的<code>result</code>字段中。</p><h2 id="四、CompletableFuture中的线程问题">四、CompletableFuture中的线程问题</h2><h3 id="代码运行线程">代码运行线程</h3><p>在<code>CompletableFuture</code>中，代码运行在哪个线程上，需要区分同步方法和异步方法。</p><ul><li><p><strong>同步方法（即不带Async后缀的方法）</strong>：如果在注册时，被依赖的操作已经执行完成，那么同步方法会直接由当前线程执行；如果注册时被依赖的操作还未执行完，那么同步方法会由回调线程执行。</p></li><li><p><strong>异步方法（即带Async后缀的方法）</strong>：我们可以选择是否传递线程池参数<code>Executor</code>来让异步方法运行在指定的线程池中。当不传递<code>Executor</code>时，会使用<code>ForkJoinPool</code>中的共用线程池<code>CommonPool</code> 。需要注意的是，<code>CommonPool</code>的大小是CPU核数 - 1，如果应用是IO密集型的，线程数可能会成为性能瓶颈。</p></li></ul><h3 id="线程池相关问题">线程池相关问题</h3><ul><li><p><strong>异步回调要传线程池</strong>：由于<code>CommonPool</code>的大小有限，在一些高并发或IO密集型的场景下，可能无法满足需求。因此，在进行异步回调时，我们需要考虑传递合适的线程池参数，以避免线程资源不足的问题。</p></li><li><p><strong>线程池循环引用会导致死锁</strong>：在使用线程池时，如果出现循环引用的情况，就可能会导致死锁。比如，一个任务依赖另一个任务，而这两个任务又分别在不同的线程池中执行，且存在相互等待的情况，就可能会陷入死锁状态。</p></li><li><p><strong>异步RPC调用注意不要阻塞IO线程池</strong>：在进行异步RPC调用时，要特别注意不要阻塞IO线程池。因为IO线程池通常用于处理网络IO等操作，如果被阻塞，可能会影响整个系统的IO性能，导致响应延迟等问题。</p></li></ul><h2 id="五、设置超时时间">五、设置超时时间</h2><p>在实际应用中，我们常常需要为异步操作设置超时时间，以避免长时间等待。在<code>CompletableFuture</code>中，可以使用<code>applyToEither</code>方法来判断是计算先完成还是先超时。具体实现方式是启动一个<code>ScheduledThreadpoolExecutor</code>线程，在指定的<code>timeout</code>时间后，直接调用<code>CompletableFuture.completeExceptionally(new TimeoutException())</code> ，这样当超过指定时间还未完成计算时，就会抛出<code>TimeoutException</code>异常，从而让我们可以对超时情况进行相应的处理。</p><h2 id="六、使用">六、使用</h2><p>在实习的时候第一次用到了<code>CompletableFuture</code>，那个时候做的是一个官网的文档导出，先下载静态资源文件，下载完之后对其进行打包，再对所有文件进行打包，最后通过邮件发送给管理员，实现一个官网文档私有化的功能。</p><h3 id="流程图：">流程图：</h3><p><img src="2025-03-19-CompletableFuture%E5%8E%9F%E7%90%86%E5%8F%8A%E5%85%B6%E4%BD%BF%E7%94%A8/image-20250419190430184-5060677-5060680.png" alt="image-20250419190430184"></p><h3 id="回忆版伪代码：">回忆版伪代码：</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line"><span class="keyword">import</span> java.util.concurrent.CompletableFuture;</span><br><span class="line"><span class="keyword">import</span> java.util.concurrent.ExecutorService;</span><br><span class="line"><span class="keyword">import</span> java.util.concurrent.Executors;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 假设这些是下载和打包相关的方法，实际使用中需根据具体实现替换</span></span><br><span class="line"><span class="comment">// 下载html文件</span></span><br><span class="line"><span class="keyword">public</span> CompletableFuture&lt;String&gt; <span class="title function_">downloadHtmlFile</span><span class="params">(String documentName)</span> &#123;</span><br><span class="line">    <span class="comment">// 实际下载逻辑，这里返回一个CompletableFuture表示异步操作</span></span><br><span class="line">    <span class="keyword">return</span> CompletableFuture.supplyAsync(() -&gt; &#123;</span><br><span class="line">        <span class="comment">// 模拟下载操作，返回下载后的文件内容或路径等相关信息</span></span><br><span class="line">        <span class="keyword">return</span> <span class="string">&quot;downloaded_html_file_path_for_&quot;</span> + documentName;</span><br><span class="line">    &#125;, executorService);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 下载图片文件</span></span><br><span class="line"><span class="keyword">public</span> CompletableFuture&lt;String&gt; <span class="title function_">downloadImageFile</span><span class="params">(String documentName)</span> &#123;</span><br><span class="line">    <span class="keyword">return</span> CompletableFuture.supplyAsync(() -&gt; &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="string">&quot;downloaded_image_file_path_for_&quot;</span> + documentName;</span><br><span class="line">    &#125;, executorService);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 下载CSS文件</span></span><br><span class="line"><span class="keyword">public</span> CompletableFuture&lt;String&gt; <span class="title function_">downloadCssFile</span><span class="params">(String documentName)</span> &#123;</span><br><span class="line">    <span class="keyword">return</span> CompletableFuture.supplyAsync(() -&gt; &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="string">&quot;downloaded_css_file_path_for_&quot;</span> + documentName;</span><br><span class="line">    &#125;, executorService);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 打包文件</span></span><br><span class="line"><span class="keyword">public</span> CompletableFuture&lt;String&gt; <span class="title function_">packFiles</span><span class="params">(String[] filePaths)</span> &#123;</span><br><span class="line">    <span class="keyword">return</span> CompletableFuture.supplyAsync(() -&gt; &#123;</span><br><span class="line">        <span class="comment">// 实际打包逻辑，返回打包后的文件路径等相关信息</span></span><br><span class="line">        <span class="keyword">return</span> <span class="string">&quot;packed_file_path_for_&quot;</span> + filePaths[<span class="number">0</span>];</span><br><span class="line">    &#125;, executorService);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 发送邮件</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">sendEmail</span><span class="params">(String packedFilePath)</span> &#123;</span><br><span class="line">    <span class="comment">// 实际发送邮件逻辑</span></span><br><span class="line">    System.out.println(<span class="string">&quot;Sending email with file: &quot;</span> + packedFilePath);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Main</span> &#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="type">ExecutorService</span> <span class="variable">executorService</span> <span class="operator">=</span> Executors.newFixedThreadPool(<span class="number">10</span>);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">        <span class="comment">// 假设这里有n个文档，以数组形式表示文档名</span></span><br><span class="line">        String[] documentNames = &#123;<span class="string">&quot;document1&quot;</span>, <span class="string">&quot;document2&quot;</span>, <span class="string">&quot;document3&quot;</span>&#125;; </span><br><span class="line">        CompletableFuture[] allDownloadFutures = <span class="keyword">new</span> <span class="title class_">CompletableFuture</span>[documentNames.length];</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i &lt; documentNames.length; i++) &#123;</span><br><span class="line">            <span class="type">String</span> <span class="variable">documentName</span> <span class="operator">=</span> documentNames[i];</span><br><span class="line">            CompletableFuture&lt;String&gt; htmlFuture = downloadHtmlFile(documentName);</span><br><span class="line">            CompletableFuture&lt;String&gt; imageFuture = downloadImageFile(documentName);</span><br><span class="line">            CompletableFuture&lt;String&gt; cssFuture = downloadCssFile(documentName);</span><br><span class="line"></span><br><span class="line">            CompletableFuture[] subFutures = &#123;htmlFuture, imageFuture, cssFuture&#125;;</span><br><span class="line">            CompletableFuture&lt;String&gt; packFuture = CompletableFuture.allOf(subFutures)</span><br><span class="line">                   .thenApply(v -&gt; &#123;</span><br><span class="line">                        <span class="keyword">try</span> &#123;</span><br><span class="line">                            String[] filePaths = &#123;htmlFuture.get(), imageFuture.get(), cssFuture.get()&#125;;</span><br><span class="line">                            <span class="keyword">return</span> packFiles(filePaths).get();</span><br><span class="line">                        &#125; <span class="keyword">catch</span> (Exception e) &#123;</span><br><span class="line">                            e.printStackTrace();</span><br><span class="line">                            <span class="keyword">return</span> <span class="literal">null</span>;</span><br><span class="line">                        &#125;</span><br><span class="line">                    &#125;);</span><br><span class="line">            allDownloadFutures[i] = packFuture;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        CompletableFuture.allOf(allDownloadFutures)</span><br><span class="line">               .thenRun(() -&gt; &#123;</span><br><span class="line">                    <span class="keyword">try</span> &#123;</span><br><span class="line">                        <span class="keyword">for</span> (CompletableFuture&lt;String&gt; packFuture : allDownloadFutures) &#123;</span><br><span class="line">                            <span class="type">String</span> <span class="variable">packedFilePath</span> <span class="operator">=</span> packFuture.get();</span><br><span class="line">                            sendEmail(packedFilePath);</span><br><span class="line">                        &#125;</span><br><span class="line">                    &#125; <span class="keyword">catch</span> (Exception e) &#123;</span><br><span class="line">                        e.printStackTrace();</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125;);</span><br><span class="line"></span><br><span class="line">        executorService.shutdown();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">### 代码说明</span></span><br><span class="line"><span class="comment">1. **线程池初始化**：创建一个固定大小为10的线程池`executorService`，用于执行异步任务。</span></span><br><span class="line"><span class="comment">2. **下载任务**：定义了`downloadHtmlFile`、`downloadImageFile`、`downloadCssFile`三个方法，分别用于异步下载html、图片和CSS文件，每个方法返回一个`CompletableFuture`。</span></span><br><span class="line"><span class="comment">3. **打包任务**：`packFiles`方法用于将下载的文件进行打包，同样返回一个`CompletableFuture`。</span></span><br><span class="line"><span class="comment">4. **发送邮件**：`sendEmail`方法用于发送包含打包文件的邮件。</span></span><br><span class="line"><span class="comment">5. **主流程**：遍历文档名数组，对每个文档分别发起html、图片和CSS文件的下载任务，通过`CompletableFuture.allOf`等待这些子任务完成后进行打包。所有文档打包完成后，再通过`CompletableFuture.allOf`等待所有打包任务完成，最后依次发送邮件。</span></span><br><span class="line"><span class="comment">6. **线程池关闭**：在所有任务完成后，关闭线程池。 </span></span><br><span class="line"><span class="comment">*/</span></span><br></pre></td></tr></table></figure><h3 id="其它方式实现：">其它方式实现：</h3><ul><li><p><strong>FutureTask</strong>：实现<code>Future</code>与<code>Runnable</code>接口，包装<code>Callable</code>或<code>Runnable</code>对象执行异步任务，能获取结果，但<code>get</code>方法会阻塞，轮询检查又消耗CPU，且任务编排能力有限。 </p></li><li><p><strong>线程池结合Runnable/Callable</strong>：利用<code>ExecutorService</code>创建线程池，提交<code>Runnable</code>（无返回值）或<code>Callable</code>（有返回值）任务执行，可控制线程数量、提高资源利用率，但复杂任务编排时代码较复杂，需手动处理任务顺序与结果传递。 </p></li><li><p><strong>Guava的ListenableFuture</strong>：扩展Java标准<code>Future</code>接口，通过<code>Futures.addCallback()</code>添加回调函数，任务完成时自动触发，避免阻塞，但引入库依赖，处理复杂任务组合不如<code>CompletableFuture</code>直观。 </p></li></ul><h2 id="总结：">总结：</h2><ul><li><p><strong>接口实现</strong>：<code>CompletableFuture</code>实现<code>Future</code>和<code>CompletionStage</code>接口，前者表示异步计算结果，后者可对异步步骤编排组合，提供<code>thenApply</code>等函数式编程方法。</p></li><li><p><strong>依赖关系</strong>：分一元、二元和多元依赖。一元依赖用<code>thenApply</code>等处理单个<code>CompletableFuture</code>；二元依赖通过<code>thenCombine</code>整合两个结果；多元依赖用<code>allOf</code>或<code>anyOf</code>处理多个。</p></li><li><p><strong>原理</strong>：含<code>result</code>（存结果）和<code>stack</code>字段，基于观察者与被观察者模式，被观察者完成时按<code>stack</code>信息通知观察者处理结果。</p></li><li><p><strong>线程问题</strong>：同步方法依依赖操作状态由当前或回调线程执行；异步方法可指定线程池，否则用<code>CommonPool</code>，但在IO密集场景线程数可能成瓶颈。还提及线程池使用注意点，如异步回调传线程池、避免循环引用死锁、异步RPC不阻塞IO线程池。</p></li><li><p><strong>超时设置</strong>：用<code>applyToEither</code>结合<code>ScheduledThreadpoolExecutor</code>实现，超时抛<code>TimeoutException</code>。 </p></li></ul><blockquote><p><a href="https://tech.meituan.com/2022/05/12/principles-and-practices-of-completablefuture.html">CompletableFuture原理与实践-外卖商家端API的异步化</a></p><p><a href="https://blog.csdn.net/u013905744/article/details/109134516">java8中CompletableFuture异步处理超时的方法_completablefuture 超时-CSDN博客</a></p></blockquote>]]></content>
    
    
    <summary type="html">🥧CompletableFuture原理及其使用</summary>
    
    
    
    <category term="学习" scheme="https://outoflovenicoo.github.io/categories/%E5%AD%A6%E4%B9%A0/"/>
    
    
    <category term="JUC" scheme="https://outoflovenicoo.github.io/tags/JUC/"/>
    
    <category term="原理" scheme="https://outoflovenicoo.github.io/tags/%E5%8E%9F%E7%90%86/"/>
    
  </entry>
  
  <entry>
    <title>MySQL分库分表总结</title>
    <link href="https://outoflovenicoo.github.io/posts/2025-03-15-MySQL%E5%88%86%E5%BA%93%E5%88%86%E8%A1%A8%E6%80%BB%E7%BB%93.html"/>
    <id>https://outoflovenicoo.github.io/posts/2025-03-15-MySQL%E5%88%86%E5%BA%93%E5%88%86%E8%A1%A8%E6%80%BB%E7%BB%93.html</id>
    <published>2025-03-15T10:19:03.000Z</published>
    <updated>2025-04-13T14:00:00.000Z</updated>
    
    <content type="html"><![CDATA[<p><img src="2025-03-15-MySQL%E5%88%86%E5%BA%93%E5%88%86%E8%A1%A8%E6%80%BB%E7%BB%93/diagram.png" alt=""></p><h1>个人对MySQL 分库分表技术的总结</h1><p>在当今数据量爆炸式增长的时代，单一数据库实例往往难以满足高性能、高可用性和可扩展性的需求。MySQL 的分库分表技术成为应对海量数据挑战的关键手段。本文将结合思维导图内容，全面剖析 MySQL 分库分表的相关知识。 </p><h2 id="一、主从架构">一、主从架构</h2><p>主从架构是数据库架构优化的重要一步。应用通过数据库中间件与数据库交互，写操作（如数据插入、更新、删除）发送至主库（Master），读操作（如数据查询）则由从库（Slave）承担。这种方式有效分担了访问压力，提升了系统的整体性能和可用性。主库与从库之间通过数据同步机制保持数据一致性，而在数据同步的实现方式中，半同步复制是一种极为关键的技术。</p><h3 id="同步复制">同步复制</h3><ul><li><p>定义与流程：同步复制要求主服务器在提交每个事务前，必须等待一个或多个从服务器同步并确认该事务。主库执行写操作并生成二进制日志（Binlog）后，会将操作发送给从库，从库执行并确认后，主库才向应用程序提交事务。例如，在金融交易系统中，每笔转账操作都需主从库完全一致，主库会等待从库确认后才完成事务提交。</p></li><li><p>优点：数据一致性和可靠性极高。从库与主库数据完全一致，主库故障时，从库数据完整，不会丢失，适合对数据一致性要求极高的场景，如金融账务系统。</p></li><li><p>缺点：性能较低。主库需等待从库确认，尤其在从库多或网络延迟大时，主库响应速度下降，影响系统吞吐量。</p></li></ul><h3 id="异步复制">异步复制</h3><ul><li><p>定义与流程：异步复制是 MySQL 默认复制类型。主服务器执行事务并记录到 Binlog 后，无需等待从服务器确认，直接继续其他操作。从服务器按自身节奏读取应用 Binlog。例如，电商促销时大量商品信息写入，主库记录 Binlog 后立即提交事务，从库随后通过 I/O 线程获取 Binlog 并回放。</p></li><li><p>优点：主服务器性能不受从服务器影响，能保持高吞吐量。适用于高并发写操作场景，如电商商品浏览、日志记录等对性能要求高、数据一致性要求相对较低的场景。</p></li><li><p>缺点：故障时可能导致主从数据不一致。若主库突然宕机，未被从库读取应用的 Binlog 事务将丢失，从库升级为主库后数据不完整。</p></li></ul><h3 id="半同步复制">半同步复制</h3><p>在传统的异步复制中，主库在提交事务时，无需等待从库确认接收二进制日志（Binlog），直接将事务提交并返回给应用。这种方式虽然性能较高，但存在数据丢失风险——若主库突然宕机，未同步到从库的事务将永久丢失。而全同步复制则要求所有从库都确认接收 Binlog 后，主库才提交事务，虽然保证了强一致性，但严重影响性能，尤其在从库数量较多或网络延迟较大时，吞吐量会大幅下降。</p><p>半同步复制（Semisynchronous Replication）则是一种折中的方案，旨在在性能与一致性之间找到平衡。其工作流程如下：</p><ol><li><p><strong>主库发送 Binlog</strong>：主库在执行写操作并生成 Binlog 后，将 Binlog 发送给从库。</p></li><li><p><strong>从库确认接收</strong>：从库接收到 Binlog 后，立即向主库返回确认信息。</p></li><li><p><strong>主库提交事务</strong>：主库在等待至少一个从库的确认接收信息后，才将事务提交并返回给应用。</p></li></ol><p>通过这种方式，半同步复制确保了在主库宕机时，至少有一个从库保存了最新的 Binlog。相比异步复制，它极大地提升了数据的安全性和一致性；相比全同步复制，由于只需等待至少一个从库的确认，性能损耗相对较小，更适合实际生产环境。</p><p>例如，在一个电商交易系统中，若采用异步复制，突发的主库故障可能导致部分订单数据丢失，影响交易完整性；若采用全同步复制，大量从库的确认等待会使订单提交速度变慢，影响用户体验。而半同步复制能在保证订单数据不丢失的前提下，维持较为流畅的交易处理速度。</p><h3 id="主从架构的其他同步方式对比">主从架构的其他同步方式对比</h3><ul><li><p><strong>异步复制</strong>：</p><ul><li><p><strong>优点</strong>：主库提交事务无需等待从库，性能损耗极小，适用于对数据一致性要求不高、追求高吞吐量的场景。</p></li><li><p><strong>缺点</strong>：主库宕机可能导致数据丢失，一致性难以保证。</p></li></ul></li><li><p><strong>全同步复制</strong>：</p><ul><li><p><strong>优点</strong>：所有从库确认后才提交，数据一致性最强。</p></li><li><p><strong>缺点</strong>：性能开销大，从库数量增多或网络不稳定时，主库响应速度大幅下降。</p></li></ul></li><li><p><strong>半同步复制</strong>：</p><ul><li><p><strong>优点</strong>：在保证一定数据一致性（至少一个从库有最新 Binlog）的同时，性能损耗相对较小，平衡了异步与全同步的优缺点。</p></li><li><p><strong>缺点</strong>：若等待从库确认的时间过长，可能退化为异步复制，需合理配置超时时间。</p></li></ul></li></ul><h2 id="二、拆分策略：应对数据增长的核心方法">二、拆分策略：应对数据增长的核心方法</h2><h3 id="垂直拆分">垂直拆分</h3><ul><li><p><strong>垂直分库</strong>：以业务中的表为依据，将不同表拆分到不同数据库中。例如，电商系统中，将用户表、订单表、商品表分别拆分到用户库、订单库、商品库。这样做的优点是使业务逻辑更清晰，便于维护、监控和扩展，同时在高并发下，能降低磁盘 I/O 和网络连接数。 </p></li><li><p><strong>垂直分表</strong>：以表中的字段为依据进行拆分。将不常用的字段、大字段（如文本、图片数据）或热点字段拆分到新表中。例如，将用户表中不常用的个人简介、头像字段拆分出去。垂直分表减少了单表数据量，提升了常用字段的查询效率，避免了 I/O 竞争。 </p></li></ul><h3 id="水平拆分">水平拆分</h3><ul><li><p><strong>水平分库</strong>：将一个数据库中的数据拆分到多个数据库中。每个数据库存储一部分数据，解决了单库海量数据存储和高并发访问的问题。例如，按用户 ID 范围将数据分散到多个库中，提升了系统的扩展性和可用性。 </p></li><li><p><strong>水平分表</strong>：将一个表的数据拆分到多个表中（可在同一个库内，也可在不同库内）。例如，按时间范围将订单表拆分为多个月表或年表。水平分表优化了单一表数据量过大导致的性能问题，降低了 I/O 竞争，减少了锁表几率。 </p></li></ul><h2 id="三、分库分表带来的问题及解决方案">三、分库分表带来的问题及解决方案</h2><h3 id="分布式事务一致性问题">分布式事务一致性问题</h3><p>当一个事务需要操作不同数据库中的表时，分布式事务一致性成为挑战。 </p><ul><li><p><strong>强一致性方案</strong>： </p><ul><li><p><strong>2PC（两阶段提交）</strong>：协调者先询问参与者是否准备好提交事务，参与者回复后，协调者再决定是否提交。优点是保证强一致性，缺点是性能开销大，存在协调者单点故障问题。 </p></li><li><p><strong>3PC（三阶段提交）</strong>：在 2PC 基础上增加预询问阶段，减少协调者单点故障的影响，但实现复杂，仍有性能瓶颈。 </p></li></ul></li><li><p><strong>最终一致性方案</strong>： </p><ul><li><p><strong>TCC（Try - Confirm - Cancel）</strong>：将事务分为尝试、确认、取消三个阶段。优点是灵活性高，适合复杂业务；缺点是开发成本高。 </p></li><li><p><strong>MQ（消息队列）</strong>：通过消息异步处理，实现最终一致性。分为手动确认和双向发送等方式。优点是解耦系统，提升吞吐量；缺点是可能出现消息丢失或重复，需配合补偿机制。 </p></li></ul></li></ul><h3 id="跨节点关联问题">跨节点关联问题</h3><p>当 A 表和 B 表在不同数据库中需要关联时，可采用以下方法： </p><ul><li><p><strong>数据组装（应用层聚合）</strong>：分两次查询，先查主表数据（如订单 ID 列表），再根据关联 ID（如用户 ID）批量查询关联表数据（如用户信息），最后在应用层合并数据。优点是灵活性高，适合复杂查询，减少数据库压力；缺点是开发复杂度增加，多次查询可能影响性能（需结合缓存优化）。 </p></li><li><p><strong>字段冗余（反范式设计）</strong>：在业务表中直接存储关联字段。例如，订单表增加 <code>user_name</code> 字段，避免查询时关联用户表。优点是减少查询时间，消除 JOIN 操作，提升查询性能；缺点是数据一致性维护复杂（如用户改名需同步历史订单），冗余字段过多会导致存储膨胀。 </p></li><li><p><strong>ER 分片</strong>：将存在强关联关系的表（如订单表与订单详情表）分配到同一节点。优点是本地表关联代替跨节点 JOIN，提升查询效率；缺点是需预先规划分片规则，扩写时需迁移关联数据，成本较高。 </p></li><li><p><strong>中间件联邦查询</strong>：使用 Sharding - Sphere、MyCAT 等中间件，将跨库查询分解为多个子查询，合并结果后返回。优点是对应用透明，减少代码侵入，支持复杂 SQL（如 JOIN/UNION）；缺点是可能受分片数量影响查询性能，复杂查询可能耗费内存。 </p></li></ul><h3 id="跨节点进行分页、排序问题">跨节点进行分页、排序问题</h3><ul><li><p><strong>全局查询法</strong>：先查询所有分片数据，在应用层进行二次排序和分页。例如，查询第 3 页数据，先从每个分片取前 3 页数据，再合并排序取第 3 页。优点是数据准确，无需业务改造；缺点是网络传输和内存消耗大，仅适用于分片少的场景。 </p></li><li><p><strong>二次查询法</strong>：以分页查询为例，先查询主键范围，再根据主键查询数据。例如，先查第 10000 条到第 10030 条主键，再根据主键查数据。优点是减少数据传输量，降低 OOM 风险；缺点是子查询性能依赖索引，深分页仍可能较慢。 </p></li><li><p><strong>中间件联邦查询</strong>：如 MyCAT 等中间件，自动处理跨节点分页排序，对应用透明，但复杂查询性能可能受影响。 </p></li></ul><h3 id="主键避重">主键避重</h3><p>为避免不同库表中主键冲突，可采用范围划分等方式。例如，数据库 1 存放 1 - 500，数据库 2 存放 501 - 1000，数据库 3 存放 1001 - 2000，确保每个库的主键范围不重叠。 </p><h2 id="四、总结：分库分表的实践应用">四、总结：分库分表的实践应用</h2><p>在实际项目中，分库分表需根据业务场景选择合适策略。例如，当单表数据量达 1000 万或 20G 以上，且业务请求频繁时，可考虑分库分表。 </p><ul><li><p><strong>水平分库</strong>：解决海量数据存储和高并发问题，如按用户 ID 哈希分片。 </p></li><li><p><strong>水平分表</strong>：优化单表存储和性能，如按时间拆分订单表。 </p></li><li><p><strong>垂直分库</strong>：按业务模块拆分，提升系统可维护性和扩展性。 </p></li><li><p><strong>垂直分表</strong>：分离冷热数据，提升常用字段查询效率。 </p></li></ul><p>常用的分库分表中间件有 Sharding - Sphere、MyCAT 等，它们提供了丰富的分片规则和数据路由功能，简化了分库分表的实现。 </p><p>总之，MySQL 分库分表是应对海量数据的有效手段，但也带来了一系列复杂问题。合理选择拆分策略，结合中间件工具，妥善解决分布式事务、跨节点关联等问题，才能构建高性能、高可用的数据库架构。</p><h2 id="参考博客：">参考博客：</h2><blockquote><p><a href="https://juejin.cn/post/7269953746851266620">MySQL 主从复制 —— 全同步复制、异步复制、半同步复制主从复制方式有:全同步复制、异步复制、半同步复制、增强半同步 - 掘金</a></p><p><a href="https://zq99299.github.io/note-book/back-end-storage/03/01.html">MySQL 存储海量数据的最后一招：分库分表 | MRCODE-BOOK</a></p><p><a href="https://learn.lianglianglee.com/%E4%B8%93%E6%A0%8F/%E5%88%86%E5%B8%83%E5%BC%8F%E6%8A%80%E6%9C%AF%E5%8E%9F%E7%90%86%E4%B8%8E%E5%AE%9E%E6%88%9845%E8%AE%B2-%E5%AE%8C/23%20%E8%AF%BB%E5%86%99%E5%88%86%E7%A6%BB%E5%A6%82%E4%BD%95%E5%9C%A8%E4%B8%9A%E5%8A%A1%E4%B8%AD%E8%90%BD%E5%9C%B0%EF%BC%9F.md">23 读写分离如何在业务中落地?</a></p><p><a href="https://www.51cto.com/article/709614.html">什么是分库分表</a></p><p><a href="https://learn.lianglianglee.com/%E4%B8%93%E6%A0%8F/MySQL%E5%AE%9E%E6%88%98%E5%AE%9D%E5%85%B8/23%20%20%E5%88%86%E5%B8%83%E5%BC%8F%E6%95%B0%E6%8D%AE%E5%BA%93%E8%A1%A8%E7%BB%93%E6%9E%84%E8%AE%BE%E8%AE%A1%EF%BC%9A%E5%A6%82%E4%BD%95%E6%AD%A3%E7%A1%AE%E5%9C%B0%E5%B0%86%E6%95%B0%E6%8D%AE%E5%88%86%E7%89%87%EF%BC%9F.md">23 分布式数据库表结构设计:如何正确地将数据分片?</a></p><p><a href="https://learn.lianglianglee.com/%E4%B8%93%E6%A0%8F/MySQL%E5%AE%9E%E6%88%98%E5%AE%9D%E5%85%B8/25%20%20%E5%88%86%E5%B8%83%E5%BC%8F%E6%95%B0%E6%8D%AE%E5%BA%93%E6%9E%B6%E6%9E%84%E9%80%89%E5%9E%8B%EF%BC%9A%E5%88%86%E5%BA%93%E5%88%86%E8%A1%A8%20or%20%E4%B8%AD%E9%97%B4%E4%BB%B6%20%EF%BC%9F.md">25 分布式数据库架构选型:分库分表 or 中间件 ?</a></p></blockquote>]]></content>
    
    
    <summary type="html">🥧MySQL分库分表总结</summary>
    
    
    
    <category term="学习" scheme="https://outoflovenicoo.github.io/categories/%E5%AD%A6%E4%B9%A0/"/>
    
    
    <category term="MySQL" scheme="https://outoflovenicoo.github.io/tags/MySQL/"/>
    
  </entry>
  
  <entry>
    <title>算法模板总结</title>
    <link href="https://outoflovenicoo.github.io/posts/2025-03-12-%E7%AE%97%E6%B3%95%E6%A8%A1%E6%9D%BF%E6%80%BB%E7%BB%93.html"/>
    <id>https://outoflovenicoo.github.io/posts/2025-03-12-%E7%AE%97%E6%B3%95%E6%A8%A1%E6%9D%BF%E6%80%BB%E7%BB%93.html</id>
    <published>2025-03-12T10:19:03.000Z</published>
    <updated>2025-04-13T14:00:00.000Z</updated>
    
    <content type="html"><![CDATA[<h1>1.树算法</h1><p><a href="https://blog.csdn.net/sinat_39377093/article/details/141069217?ops_request_misc=%257B%2522request%255Fid%2522%253A%25223d2890518563c1027b9d4e253d57f34a%2522%252C%2522scm%2522%253A%252220140713.130102334..%2522%257D&amp;request_id=3d2890518563c1027b9d4e253d57f34a&amp;biz_id=0&amp;utm_medium=distribute.pc_search_result.none-task-blog-2~all~sobaiduend~default-1-141069217-null-null.142%5Ev101%5Epc_search_result_base3&amp;utm_term=%E6%A0%91%E7%AE%97%E6%B3%95%E6%80%BB%E7%BB%93&amp;spm=1018.2226.3001.4187">数据结构与算法总结——树_数据结构与算法树-CSDN博客</a></p><h1>1.回溯法</h1><h2 id="（1）大致思路">（1）大致思路</h2><p>用一个 path 数组记录路径上的字母。</p><p><strong>回溯三问：</strong></p><ul><li><p>当前操作？枚举 path [i] 要填入的字母</p></li><li><p>子问题？构造字符串≥i 的部分</p></li><li><p>下一个子问题？构造字符串≥i + 1 的部分<br>dfs (i) → dfs (i + 1)</p></li></ul><h2 id="（2）子集型回溯—选或不选">（2）子集型回溯—选或不选</h2><p><a href="https://leetcode.cn/problems/subsets/description/">78. 子集 - 力扣（LeetCode）</a></p><p><a href="https://leetcode.cn/problems/palindrome-partitioning/description/">131. 分割回文串 - 力扣（LeetCode）</a></p><p><a href="https://leetcode.cn/problems/letter-combinations-of-a-phone-number/description/">17. 电话号码的字母组合 - 力扣（LeetCode）</a></p><p><img src="2025-03-12-%E7%AE%97%E6%B3%95%E6%A8%A1%E6%9D%BF%E6%80%BB%E7%BB%93/image-9.png" alt=""></p><h2 id="（3）组合类回溯—没顺序，需要去重">（3）组合类回溯—没顺序，需要去重</h2><p><img src="2025-03-12-%E7%AE%97%E6%B3%95%E6%A8%A1%E6%9D%BF%E6%80%BB%E7%BB%93/image-10.png" alt=""></p><h2 id="（4）排列型回溯—有顺序，要用额外数组">（4）排列型回溯—有顺序，要用额外数组</h2><p><img src="2025-03-12-%E7%AE%97%E6%B3%95%E6%A8%A1%E6%9D%BF%E6%80%BB%E7%BB%93/image-7.png" alt=""></p><p><img src="2025-03-12-%E7%AE%97%E6%B3%95%E6%A8%A1%E6%9D%BF%E6%80%BB%E7%BB%93/image-5.png" alt=""></p><h1>2.二分法</h1><blockquote><p>核心就是找一个区间（开闭区间）与target的关系</p></blockquote><p>⭐️:找到要分的东西，不一定是数组下标</p><h2 id="①找-、-、-、">①找&gt;=、&gt;、&lt;=、&lt;</h2><p><a href="https://leetcode.cn/problems/find-first-and-last-position-of-element-in-sorted-array/description/">34. 在排序数组中查找元素的第一个和最后一个位置 - 力扣（LeetCode）</a></p><p><a href="https://leetcode.cn/problems/find-peak-element/description/">162. 寻找峰值 - 力扣（LeetCode）</a></p><p>⭐️开区间写法，很牛叉</p><p><a href="https://leetcode.cn/problems/range-frequency-queries/submissions/600459253/">2080. 区间内查询数字的频率 - 力扣（LeetCode）</a></p><h2 id="②「最大化最小值」或者「最小化最大值」">②「最大化最小值」或者「最小化最大值」</h2><p><a href="https://leetcode.cn/problems/maximum-tastiness-of-candy-basket/solutions/2031994/er-fen-da-an-by-endlesscheng-r418/">2517. 礼盒的最大甜蜜度 - 力扣（LeetCode）</a></p><p><a href="https://leetcode.cn/problems/magnetic-force-between-two-balls/description/?envType=daily-question&amp;envId=2025-02-14">1552. 两球之间的磁力 - 力扣（LeetCode）</a></p><h1>3.滑动窗口</h1><h2 id="定长滑动窗口">定长滑动窗口</h2><p>入-&gt;更新-&gt;出</p><p><a href="https://leetcode.cn/problems/maximum-number-of-vowels-in-a-substring-of-given-length/">1456. 定长子串中元音的最大数目</a></p><h2 id="不定长滑动窗口">不定长滑动窗口</h2><p>不定长滑动窗口主要分为三类：求最长子数组，求最短子数组，以及求子数组个数。</p><p>✅求最长子数组：入-&gt;判断（使用while缩小范围）-&gt;更新</p><p><a href="https://leetcode.cn/problems/maximum-length-substring-with-two-occurrences/">3090. 每个字符最多出现两次的最长子字符串</a></p><p>✅求最短子数组：入-&gt;判断（使用while缩小范围）-&gt;更新</p><p><a href="https://leetcode.cn/problems/minimum-size-subarray-sum/">209. 长度最小的子数组</a></p><p>✅求子数组的个数</p><p><a href="https://leetcode.cn/problems/subarray-product-less-than-k/">713. 乘积小于 K 的子数组</a></p><h2 id="多指针">多指针</h2><p><a href="https://leetcode.cn/problems/binary-subarrays-with-sum/">930. 和相同的二元子数组</a></p><h1>4.记忆化搜索</h1><p><a href="https://leetcode.cn/problems/length-of-longest-v-shaped-diagonal-segment/description/">3459. 最长 V 形对角线段的长度 - 力扣（LeetCode）</a></p><p>记忆化搜索的记忆化可以用map，也可以用数组，本题用map会超时</p><h1>5.数据结构</h1><h2 id="单调栈">单调栈</h2><p>单纯的单调栈并不难。难的是怎么用，在哪里用</p><p><a href="https://leetcode.cn/problems/largest-rectangle-in-histogram/">84. 柱状图中最大的矩形</a></p><blockquote><p>本题关键在于如何快速找到<strong>每个柱子的左边和右边第一个比它小的下标</strong>。</p><p><strong>单调栈的性质</strong>：</p><ul><li><p>单调栈可以帮助我们在一次遍历中快速确定“下一个更小”的元素。</p></li><li><p>具体来说，当我们从左向右扫描时，我们希望栈内的元素是单调递增的；一旦遇到一个较小的值，就说明栈顶的元素找到了右边界。</p></li><li><p>同理，从右向左扫描时也可以得到每个柱子的左边界。<br>这种“下一个更小元素”的问题，在算法题中非常常见，使用单调栈是经典方法。当你看到需要在一维数组中寻找每个位置的左右边界问题，就很容易联想到单调栈。</p></li></ul><p><strong>单调栈用于解决找上一个更小/上一个更大的元素</strong></p><p>找上一个更大的元素（把更小的弹出）：是单调递减栈，如：<a href="https://leetcode.cn/problems/daily-temperatures/description/?envType=study-plan-v2&amp;envId=top-100-liked">739. 每日温度 - 力扣（LeetCode）</a></p><p>找上一个更小的元素（把更大的弹出）：是单调递增栈，如：<a href="https://leetcode.cn/problems/largest-rectangle-in-histogram/description/?envType=study-plan-v2&amp;envId=top-100-liked">84. 柱状图中最大的矩形 - 力扣（LeetCode）</a></p></blockquote><h2 id="并查集">并查集</h2><p> <a href="https://www.bilibili.com/video/BV1jv411a7LK/?share_source=copy_web&amp;vd_source=ec71810e8cb652d640f76be4d4d0878e">图论——并查集(详细版)_哔哩哔哩_bilibili</a></p><blockquote><p>处理不相交集合的合并问题,并查集常用来解决连通性问题。</p><p>大白话就是当我们需要判断两个元素是否在同一个集合里的时候，我们就要想到用并查集。</p></blockquote><h1>6.图论算法</h1><h2 id="①DFS模板">①DFS模板</h2><p><a href="https://leetcode.cn/problems/number-of-islands/">200. 岛屿数量</a></p><h2 id="②BFS模板">②BFS模板</h2><p><a href="https://leetcode.cn/problems/rotting-oranges/">994. 腐烂的橘子</a></p><h1>7.位运算</h1><h2 id="快速幂模板">快速幂模板</h2><h1>8.常用数据结构（前缀和/差分/栈/队列/堆/字典树/并查集/树状数组/线段树）</h1><p><a href="https://leetcode.cn/circle/discuss/mOr1u6/">分享丨【题单】常用数据结构（前缀和/差分/栈/队列/堆/字典树/并查集/树状数组/线段树） - 力扣（LeetCode）</a></p><h1>9.动态规划</h1><h2 id="9-1背包问题">9.1背包问题</h2><h3 id="（1）01背包（只能选一次）">（1）01背包（只能选一次）</h3><p>0-1 背包：有 n 个物品，第 i 个物品的体积为 w[i]，价值为 v[i]，每个物品至多选一个，求体积和不超过 capacity 时的最大价值和 </p><p><img src="2025-03-12-%E7%AE%97%E6%B3%95%E6%A8%A1%E6%9D%BF%E6%80%BB%E7%BB%93/image-8.png" alt=""></p><p><img src="2025-03-12-%E7%AE%97%E6%B3%95%E6%A8%A1%E6%9D%BF%E6%80%BB%E7%BB%93/image-6.png" alt=""></p><h3 id="（2）完全背包（完全任意选）">（2）完全背包（完全任意选）</h3><p><img src="2025-03-12-%E7%AE%97%E6%B3%95%E6%A8%A1%E6%9D%BF%E6%80%BB%E7%BB%93/image-4.png" alt=""></p><p>每种物品可以任意选，所以这里不是递归到i-1而是递归到i</p><p><img src="2025-03-12-%E7%AE%97%E6%B3%95%E6%A8%A1%E6%9D%BF%E6%80%BB%E7%BB%93/image-3.png" alt=""></p><p>从前往后遍历不会覆盖</p><h3 id="（3）常见变形-01背包">（3）常见变形(01背包)</h3><p>正好为target:</p><p><img src="2025-03-12-%E7%AE%97%E6%B3%95%E6%A8%A1%E6%9D%BF%E6%80%BB%E7%BB%93/image-2.png" alt=""></p><p>至多为target</p><p><img src="2025-03-12-%E7%AE%97%E6%B3%95%E6%A8%A1%E6%9D%BF%E6%80%BB%E7%BB%93/image-20250420194647355.png" alt="image-20250420194647355"></p><p>至少为target</p><p><img src="2025-03-12-%E7%AE%97%E6%B3%95%E6%A8%A1%E6%9D%BF%E6%80%BB%E7%BB%93/image.png" alt=""></p>]]></content>
    
    
    <summary type="html">🥧本人的算法模板总结</summary>
    
    
    
    <category term="算法" scheme="https://outoflovenicoo.github.io/categories/%E7%AE%97%E6%B3%95/"/>
    
    
    <category term="算法" scheme="https://outoflovenicoo.github.io/tags/%E7%AE%97%E6%B3%95/"/>
    
  </entry>
  
  <entry>
    <title>SoundMentor-多线程优化PPT任务执行</title>
    <link href="https://outoflovenicoo.github.io/posts/2025-03-10-SoundMentor-%E5%A4%9A%E7%BA%BF%E7%A8%8B%E4%BC%98%E5%8C%96PPT%E4%BB%BB%E5%8A%A1%E6%89%A7%E8%A1%8C.html"/>
    <id>https://outoflovenicoo.github.io/posts/2025-03-10-SoundMentor-%E5%A4%9A%E7%BA%BF%E7%A8%8B%E4%BC%98%E5%8C%96PPT%E4%BB%BB%E5%8A%A1%E6%89%A7%E8%A1%8C.html</id>
    <published>2025-03-10T10:19:03.000Z</published>
    <updated>2025-03-10T14:00:00.000Z</updated>
    
    <content type="html"><![CDATA[<p><strong>在最近做的ai语音合成项目中，有一个需求是：用户上传ppt，用ppt的url请求创建ppt讲解合成任务，这里需要关联用户和ppt，还需要下载解析ppt，拿到每一页做处理，并解析出每一页的内容向mq发送消息异步请求python大模型，还需做任务，ppt详情入库操作。</strong></p><p>这里一个ppt会有很多页，每一页都需要做两次数据库操作加mq消息发送，如果页码较多，那响应速度会很慢，所以这里引入一个自定义的单例线程池bean，通过线程池来并发执行每一页的任务，加速任务的执行，并且每页的任务异步执行，不阻塞主线程，且能减少线程开销，控制线程资源。</p><h2 id="自定义线程池">自定义线程池</h2><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Configuration</span></span><br><span class="line"><span class="meta">@Slf4j</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">ThreadPoolConfig</span> &#123;</span><br><span class="line">    <span class="meta">@Bean(&quot;task-thread-pool-executor&quot;)</span></span><br><span class="line">    <span class="keyword">public</span> ThreadPoolExecutor <span class="title function_">threadPoolExecutor</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="type">ThreadPoolExecutor</span> <span class="variable">threadPoolExecutor</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">ThreadPoolExecutor</span>(</span><br><span class="line">                <span class="number">10</span>,</span><br><span class="line">                <span class="number">50</span>,</span><br><span class="line">                <span class="number">60</span>,</span><br><span class="line">                TimeUnit.SECONDS,</span><br><span class="line">                <span class="keyword">new</span> <span class="title class_">ArrayBlockingQueue</span>&lt;Runnable&gt;(<span class="number">300</span>),</span><br><span class="line">                (r, executor) -&gt; &#123;</span><br><span class="line">                    log.info(<span class="string">&quot;线程池已满，任务&#123;&#125;,被丢弃&quot;</span>, r.toString());</span><br><span class="line">                &#125;</span><br><span class="line">        );</span><br><span class="line">        <span class="keyword">return</span> threadPoolExecutor;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="创建ppt讲解生成任务"><em>创建ppt讲解生成任务</em></h2><p>如果不采用多线程的方式，每次执行任务操作两次数据库 + mq发送，ppt页码一多可能就会很慢，采用多线程能优化它的执行速度。在经过测试后，发现用线程池比直接串行提高了50%的响应速度</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 创建ppt讲解生成任务</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param</span> param</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@return</span></span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="meta">@Override</span></span><br><span class="line"><span class="keyword">public</span> Integer <span class="title function_">createPPTSummary</span><span class="params">(CreatePPTSummaryTaskParam param)</span> &#123;</span><br><span class="line">    <span class="type">String</span> <span class="variable">pptUrl</span> <span class="operator">=</span> param.getPptUrl();</span><br><span class="line">    <span class="type">XMLSlideShow</span> <span class="variable">xmlSlideShow</span> <span class="operator">=</span> PPTXUtil.loadPPTX(pptUrl);</span><br><span class="line">    List&lt;XSLFSlide&gt; slides = xmlSlideShow.getSlides();</span><br><span class="line">    <span class="type">UserPptRelDO</span> <span class="variable">userPptRelDO</span> <span class="operator">=</span> userPptRelMapper.selectOne(<span class="keyword">new</span> <span class="title class_">LambdaQueryWrapper</span>&lt;UserPptRelDO&gt;()</span><br><span class="line">            .eq(UserPptRelDO::getPptUrl, pptUrl)</span><br><span class="line">            .eq(UserPptRelDO::getUserId, userInfoApi.getUser().getId()));</span><br><span class="line">    <span class="keyword">if</span> (Objects.isNull(userPptRelDO))</span><br><span class="line">    &#123;</span><br><span class="line">        userPptRelDO = <span class="keyword">new</span> <span class="title class_">UserPptRelDO</span>();</span><br><span class="line">        userPptRelDO.setPptUrl(pptUrl);</span><br><span class="line">        userPptRelDO.setUserId(userInfoApi.getUser().getId());</span><br><span class="line">        userPptRelDO.setPageCount(slides.size());</span><br><span class="line">        userPptRelDO.setCreateTime(LocalDateTime.now());</span><br><span class="line">        userPptRelMapper.insert(userPptRelDO);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i &lt; slides.size(); i++) &#123;</span><br><span class="line">        <span class="type">Integer</span> <span class="variable">userPptId</span> <span class="operator">=</span> userPptRelDO.getId();</span><br><span class="line">        <span class="type">Integer</span> <span class="variable">page</span> <span class="operator">=</span> i;</span><br><span class="line">        <span class="type">XSLFSlide</span> <span class="variable">slide</span> <span class="operator">=</span> slides.get(page);</span><br><span class="line">        threadPoolExecutor.execute(()-&gt;&#123;</span><br><span class="line">            <span class="keyword">try</span> &#123;</span><br><span class="line">                taskExec(userPptId,page,slide);</span><br><span class="line">            &#125; <span class="keyword">catch</span> (Exception e) &#123;</span><br><span class="line">                log.error(<span class="string">&quot;ppt&#123;&#125;的&#123;&#125;页任务执行失败,请重试&quot;</span>,userPptId,page);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> userPptRelDO.getId();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="PPT讲解任务执行">PPT讲解任务执行</h2><p>读入PPT，把PPT分成每一页，将每一页的信息插入到PPT详情表，最后多线程异步发MQ让Python进行讲解生成。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * ppt页生成讲解任务执行</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param</span> userPptId ppt标识</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param</span> page 页码</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param</span> slide ppt页对象</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="meta">@Transactional(rollbackFor = Exception.class)</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">taskExec</span><span class="params">(Integer userPptId, Integer page,XSLFSlide slide)</span> <span class="keyword">throws</span> Exception</span><br><span class="line">&#123;</span><br><span class="line">    <span class="type">TaskDO</span> <span class="variable">taskDO</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">TaskDO</span>();</span><br><span class="line">    <span class="type">PPTPageSummaryTaskDTO</span> <span class="variable">pptPageSummaryTaskDTO</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">PPTPageSummaryTaskDTO</span>();</span><br><span class="line">    pptPageSummaryTaskDTO.setUserPptId(userPptId);</span><br><span class="line">    pptPageSummaryTaskDTO.setPage(page);</span><br><span class="line">    pptPageSummaryTaskDTO.setContent(PPTXUtil.getSlideInfo(slide));</span><br><span class="line">    taskDO.setTaskDetail(JSON.toJSONString(pptPageSummaryTaskDTO));</span><br><span class="line">    taskDO.setType(TaskTypeEnum.PPT_SUMMARY.getCode());</span><br><span class="line">    taskDO.setUpdateTime(LocalDateTime.now());</span><br><span class="line">    taskDO.setCreateTime(LocalDateTime.now());</span><br><span class="line">    taskDO.setStatus(TaskStatusEnum.CREATED.getCode());</span><br><span class="line">    taskMapper.insert(taskDO);</span><br><span class="line">    TaskMessageDTO&lt;PPTPageSummaryTaskDTO&gt; taskMessage = <span class="keyword">new</span> <span class="title class_">TaskMessageDTO</span>&lt;&gt;();</span><br><span class="line">    taskMessage.setId(taskDO.getId());</span><br><span class="line">    taskMessage.setType(TaskTypeEnum.PPT_SUMMARY.getCode());</span><br><span class="line">    taskMessage.setStatus(TaskStatusEnum.CREATED.getCode());</span><br><span class="line">    taskMessage.setMessageBody(pptPageSummaryTaskDTO);</span><br><span class="line">    taskMessage.setCreateTime(LocalDateTime.now());</span><br><span class="line">    mqProducer.send(DirectRabbitConfig.EXCHANGE_NAME_PPT_SUMMARY, DirectRabbitConfig.ROUTING_KEY_PPT_SUMMARY,taskMessage);</span><br><span class="line">    <span class="type">UserPptDetailDO</span> <span class="variable">userPptDetailDO</span> <span class="operator">=</span> userPptDetailMapper.selectOne(<span class="keyword">new</span> <span class="title class_">LambdaQueryWrapper</span>&lt;UserPptDetailDO&gt;()</span><br><span class="line">            .eq(UserPptDetailDO::getUserPptId, userPptId)</span><br><span class="line">            .eq(UserPptDetailDO::getPptPage, page));</span><br><span class="line">    <span class="keyword">if</span>(Objects.isNull(userPptDetailDO))</span><br><span class="line">    &#123;</span><br><span class="line">        userPptDetailDO = <span class="keyword">new</span> <span class="title class_">UserPptDetailDO</span>();</span><br><span class="line">        userPptDetailDO.setUserPptId(userPptId);</span><br><span class="line">        userPptDetailDO.setPptPage(page);</span><br><span class="line">        userPptDetailDO.setCreateTime(LocalDateTime.now());</span><br><span class="line">        userPptDetailDO.setLastTaskId(taskDO.getId());</span><br><span class="line">        <span class="comment">//上传并添加预览图</span></span><br><span class="line">        <span class="type">InputStream</span> <span class="variable">inputStream</span> <span class="operator">=</span> PPTXUtil.convertSlideToImage(slide);</span><br><span class="line">        <span class="type">String</span> <span class="variable">imgUrl</span> <span class="operator">=</span> fileService.uploadFileToMinio(inputStream, FileTypeEnum.PNG, UUID.randomUUID().toString());</span><br><span class="line">        userPptDetailDO.setImgUrl(imgUrl);</span><br><span class="line">        userPptDetailMapper.insert(userPptDetailDO);</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        userPptDetailDO.setLastTaskId(taskDO.getId());</span><br><span class="line">        userPptDetailMapper.updateById(userPptDetailDO);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="创建ppt讲解语音生成任务"><em>创建ppt讲解语音生成任务</em></h2><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 创建ppt讲解语音生成任务</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param</span> param</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@return</span></span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="meta">@Override</span></span><br><span class="line"><span class="keyword">public</span> Integer <span class="title function_">createPPTSummaryVoice</span><span class="params">(CreatePPTSummaryVoiceParam param)</span> &#123;</span><br><span class="line">    <span class="type">UserSoundRelDO</span> <span class="variable">sound</span> <span class="operator">=</span> userSoundRelService.getById(param.getUserSoundId());</span><br><span class="line">    <span class="keyword">if</span>(Objects.isNull(sound))</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">throw</span>  <span class="keyword">new</span> <span class="title class_">BizException</span>(ResultCodeEnum.INVALID_PARAM.getCode(),<span class="string">&quot;声音库不存在&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span>(!sound.getUserId().equals(<span class="number">0</span>))</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">throw</span> <span class="keyword">new</span> <span class="title class_">BizException</span>(ResultCodeEnum.INVALID_PARAM.getCode(),<span class="string">&quot;目前服务器暂不支持自定义声音库&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="type">String</span> <span class="variable">apiParam</span> <span class="operator">=</span> sound.getApiParam();</span><br><span class="line">    List&lt;UserPptDetailDO&gt; userPptDetailDOS = userPptDetailMapper.selectList(<span class="keyword">new</span> <span class="title class_">LambdaQueryWrapper</span>&lt;UserPptDetailDO&gt;().eq(UserPptDetailDO::getUserPptId, param.getUserPptId()));</span><br><span class="line">    <span class="keyword">for</span> (UserPptDetailDO userPptDetailDO : userPptDetailDOS) &#123;</span><br><span class="line">        threadPoolExecutor.execute(()-&gt;&#123;</span><br><span class="line">            <span class="keyword">try</span> &#123;</span><br><span class="line">                taskExec(userPptDetailDO,apiParam,param.getRate());</span><br><span class="line">            &#125; <span class="keyword">catch</span> (Exception e) &#123;</span><br><span class="line">               log.info(<span class="string">&quot;ppt&#123;&#125;的&#123;&#125;页任务执行失败,请重试&quot;</span>,userPptDetailDO.getUserPptId(),userPptDetailDO.getPptPage());</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> param.getUserPptId();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="PPT语音生成任务执行">PPT语音生成任务执行</h2><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * ppt页生成讲解语音任务执行</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param</span> userPptDetailDO</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param</span> apiParam</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param</span> rate</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="meta">@Transactional(rollbackFor = Exception.class)</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">taskExec</span><span class="params">(UserPptDetailDO userPptDetailDO,String apiParam, Integer rate)</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="type">String</span> <span class="variable">summary</span> <span class="operator">=</span> userPptDetailDO.getSummary();</span><br><span class="line">    <span class="keyword">if</span>(StringUtils.isEmpty(summary))</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">throw</span> <span class="keyword">new</span> <span class="title class_">BizException</span>(ResultCodeEnum.INVALID_PARAM.getCode(),<span class="string">&quot;ppt&quot;</span>+userPptDetailDO.getUserPptId()+<span class="string">&quot;的&quot;</span>+userPptDetailDO.getPptPage()+<span class="string">&quot;页没有讲解&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="type">PPTSummaryVoiceMsgDTO</span> <span class="variable">pptSummaryVoiceMsgDTO</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">PPTSummaryVoiceMsgDTO</span>();</span><br><span class="line">    pptSummaryVoiceMsgDTO.setUserPptId(userPptDetailDO.getUserPptId());</span><br><span class="line">    pptSummaryVoiceMsgDTO.setPage(userPptDetailDO.getPptPage());</span><br><span class="line">    pptSummaryVoiceMsgDTO.setText(summary);</span><br><span class="line">    pptSummaryVoiceMsgDTO.setVoiceName(apiParam);</span><br><span class="line">    pptSummaryVoiceMsgDTO.setRate(rate);</span><br><span class="line">    <span class="type">TaskDO</span> <span class="variable">taskDO</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">TaskDO</span>();</span><br><span class="line">    taskDO.setType(TaskTypeEnum.PPT_SUMMARY_VOICE.getCode());</span><br><span class="line">    taskDO.setStatus(TaskStatusEnum.CREATED.getCode());</span><br><span class="line">    taskDO.setTaskDetail(JSON.toJSONString(pptSummaryVoiceMsgDTO));</span><br><span class="line">    taskDO.setCreateTime(LocalDateTime.now());</span><br><span class="line">    taskDO.setUpdateTime(LocalDateTime.now());</span><br><span class="line">    taskMapper.insert(taskDO);</span><br><span class="line">    userPptDetailDO.setLastTaskId(taskDO.getId());</span><br><span class="line">    userPptDetailMapper.updateById(userPptDetailDO);</span><br><span class="line">    TaskMessageDTO&lt;PPTSummaryVoiceMsgDTO&gt; message = <span class="keyword">new</span> <span class="title class_">TaskMessageDTO</span>&lt;&gt;();</span><br><span class="line">    message.setId(taskDO.getId());</span><br><span class="line">    message.setType(TaskTypeEnum.PPT_SUMMARY_VOICE.getCode());</span><br><span class="line">    message.setStatus(TaskStatusEnum.CREATED.getCode());</span><br><span class="line">    message.setMessageBody(pptSummaryVoiceMsgDTO);</span><br><span class="line">    message.setCreateTime(LocalDateTime.now());</span><br><span class="line">    mqProducer.send(DirectRabbitConfig.EXCHANGE_NAME_PPT_SUMMARY_VOICE, DirectRabbitConfig.ROUTING_KEY_PPT_SUMMARY_VOICE,message);</span><br><span class="line">    log.info(<span class="string">&quot;消息ID:&#123;&#125;,发送成功！-----------&gt;&gt; &#123;&#125;&quot;</span>,taskDO.getId(),message.toString());</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="MQ返回结果处理">MQ返回结果处理</h2><p><img src="2025-03-10-SoundMentor-%E5%A4%9A%E7%BA%BF%E7%A8%8B%E4%BC%98%E5%8C%96PPT%E4%BB%BB%E5%8A%A1%E6%89%A7%E8%A1%8C/image.png" alt=""></p><p>利用工厂+策略模式，对不同的消息类型进行不同的处理：</p><p><img src="2025-03-10-SoundMentor-%E5%A4%9A%E7%BA%BF%E7%A8%8B%E4%BC%98%E5%8C%96PPT%E4%BB%BB%E5%8A%A1%E6%89%A7%E8%A1%8C/image-1.png" alt=""></p><h3 id="普通TTS处理">普通TTS处理</h3><p><img src="2025-03-10-SoundMentor-%E5%A4%9A%E7%BA%BF%E7%A8%8B%E4%BC%98%E5%8C%96PPT%E4%BB%BB%E5%8A%A1%E6%89%A7%E8%A1%8C/image-2.png" alt=""></p><h3 id="PPT总结任务处理">PPT总结任务处理</h3><p><img src="2025-03-10-SoundMentor-%E5%A4%9A%E7%BA%BF%E7%A8%8B%E4%BC%98%E5%8C%96PPT%E4%BB%BB%E5%8A%A1%E6%89%A7%E8%A1%8C/image-3.png" alt=""></p><h3 id="PPT声音生成处理">PPT声音生成处理</h3><p><img src="2025-03-10-SoundMentor-%E5%A4%9A%E7%BA%BF%E7%A8%8B%E4%BC%98%E5%8C%96PPT%E4%BB%BB%E5%8A%A1%E6%89%A7%E8%A1%8C/image-4.png" alt=""></p><h3 id="声音训练处理">声音训练处理</h3><p><img src="2025-03-10-SoundMentor-%E5%A4%9A%E7%BA%BF%E7%A8%8B%E4%BC%98%E5%8C%96PPT%E4%BB%BB%E5%8A%A1%E6%89%A7%E8%A1%8C/image-5.png" alt=""></p><h2 id="有声PPT的合成">有声PPT的合成</h2><p>先下载原始ppt文件到临时目录下，用CountDownLatch协调任务完成，下载每一页的MP3并插入到PPT里面，最后上传打包。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> String <span class="title function_">getPpt</span><span class="params">(Integer userPptId)</span> &#123;</span><br><span class="line">    List&lt;UserPptDetailDO&gt; userPptDetailDOS = userPptDetailMapper.selectList(<span class="keyword">new</span> <span class="title class_">LambdaQueryWrapper</span>&lt;UserPptDetailDO&gt;()</span><br><span class="line">            .eq(UserPptDetailDO::getUserPptId, userPptId)</span><br><span class="line">            .orderByAsc(UserPptDetailDO::getPptPage));</span><br><span class="line">    <span class="keyword">if</span>(CollectionUtils.isEmpty(userPptDetailDOS))</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">throw</span> <span class="keyword">new</span> <span class="title class_">BizException</span>(ResultCodeEnum.INVALID_PARAM.getCode(),<span class="string">&quot;该ppt还未执行讲解生成&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="type">UserPptRelDO</span> <span class="variable">userPptRelDO</span> <span class="operator">=</span> userPptRelMapper.selectById(userPptId);</span><br><span class="line">    <span class="type">String</span> <span class="variable">pptUrl</span> <span class="operator">=</span> userPptRelDO.getPptUrl();</span><br><span class="line">    <span class="type">XMLSlideShow</span> <span class="variable">pptx</span> <span class="operator">=</span> PPTXUtil.loadPPTX(pptUrl);</span><br><span class="line">    <span class="type">String</span> <span class="variable">folderName</span> <span class="operator">=</span> <span class="string">&quot;temp/&quot;</span>+UUID.fastUUID();</span><br><span class="line">    FileUtil.createFolder(folderName);</span><br><span class="line">    <span class="keyword">try</span>(<span class="type">FileOutputStream</span> <span class="variable">outputStream</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">FileOutputStream</span>(folderName+<span class="string">&quot;/ppt.pptx&quot;</span>))</span><br><span class="line">    &#123;</span><br><span class="line">        HttpUtil.download(pptUrl,outputStream,<span class="literal">true</span>);</span><br><span class="line">        outputStream.flush();</span><br><span class="line">    &#125; <span class="keyword">catch</span> (Exception e) &#123;</span><br><span class="line">        <span class="keyword">throw</span> <span class="keyword">new</span> <span class="title class_">BizException</span>(ResultCodeEnum.FILE_ERROR.getCode(),<span class="string">&quot;下载ppt失败&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">try</span>&#123;</span><br><span class="line">        <span class="type">CountDownLatch</span> <span class="variable">countDownLatch</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">CountDownLatch</span>(userPptDetailDOS.size());</span><br><span class="line">        userPptDetailDOS.forEach(userPptDetailDO -&gt; &#123;</span><br><span class="line">            threadPoolExecutor.execute(() -&gt;&#123;</span><br><span class="line">                <span class="keyword">try</span>(<span class="type">FileOutputStream</span> <span class="variable">fileOutputStream</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">FileOutputStream</span>(folderName+<span class="string">&quot;/&quot;</span>+userPptDetailDO.getPptPage()+<span class="string">&quot;.mp3&quot;</span>)) &#123;</span><br><span class="line">                    HttpUtil.download(userPptDetailDO.getSoundUrl(),fileOutputStream,<span class="literal">true</span>);</span><br><span class="line">                    fileOutputStream.flush();</span><br><span class="line">                    PPTXUtil.addAudioToSlide(pptx,userPptDetailDO.getPptPage(),userPptDetailDO.getPptPage()+<span class="string">&quot;.mp3&quot;</span>);</span><br><span class="line">                &#125; <span class="keyword">catch</span> (Exception e) &#123;</span><br><span class="line">                    log.error(<span class="string">&quot;ppt&#123;&#125;的&#123;&#125;页音频插入失败&quot;</span>, userPptId, userPptDetailDO.getPptPage());</span><br><span class="line">                &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">                    countDownLatch.countDown();</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;);</span><br><span class="line">        &#125;);</span><br><span class="line">        countDownLatch.await(<span class="number">1</span>, TimeUnit.MINUTES);</span><br><span class="line">        PPTXUtil.savePPT(pptx,folderName+<span class="string">&quot;/ppt.pptx&quot;</span>);</span><br><span class="line">        <span class="type">InputStream</span> <span class="variable">inputStream</span> <span class="operator">=</span> FileUtil.zipFolder(folderName);</span><br><span class="line">        <span class="keyword">return</span> fileService.uploadFileToMinio(inputStream, FileTypeEnum.ZIP, UUID.fastUUID().toString());</span><br><span class="line">    &#125; <span class="keyword">catch</span> (Exception e) &#123;</span><br><span class="line">        <span class="keyword">throw</span> <span class="keyword">new</span> <span class="title class_">BizException</span>(ResultCodeEnum.FILE_ERROR.getCode(),<span class="string">&quot;生成有声ppt失败&quot;</span>);</span><br><span class="line">    &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            FileUtils.deleteDirectory(<span class="keyword">new</span> <span class="title class_">File</span>(folderName));</span><br><span class="line">        &#125; <span class="keyword">catch</span> (IOException e) &#123;</span><br><span class="line">            <span class="keyword">throw</span> <span class="keyword">new</span> <span class="title class_">BizException</span>(ResultCodeEnum.FILE_ERROR.getCode(),<span class="string">&quot;删除临时文件失败&quot;</span>);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
    
    
    <summary type="html">🥧SoundMentor-多线程优化PPT任务执行</summary>
    
    
    
    <category term="项目" scheme="https://outoflovenicoo.github.io/categories/%E9%A1%B9%E7%9B%AE/"/>
    
    
    <category term="项目" scheme="https://outoflovenicoo.github.io/tags/%E9%A1%B9%E7%9B%AE/"/>
    
  </entry>
  
  <entry>
    <title>SoundMentor-组织管理相关</title>
    <link href="https://outoflovenicoo.github.io/posts/2025-03-10-SoundMentor-%E7%BB%84%E7%BB%87%E7%AE%A1%E7%90%86%E7%9B%B8%E5%85%B3.html"/>
    <id>https://outoflovenicoo.github.io/posts/2025-03-10-SoundMentor-%E7%BB%84%E7%BB%87%E7%AE%A1%E7%90%86%E7%9B%B8%E5%85%B3.html</id>
    <published>2025-03-10T10:19:03.000Z</published>
    <updated>2025-03-10T14:00:00.000Z</updated>
    
    <content type="html"><![CDATA[<h2 id="1-组织相关的表">1.组织相关的表</h2><p><img src="2025-03-10-SoundMentor-%E7%BB%84%E7%BB%87%E7%AE%A1%E7%90%86%E7%9B%B8%E5%85%B3/image-1.png" alt=""></p><p><strong>通过RBAC控制组织权限</strong></p><p><img src="2025-03-10-SoundMentor-%E7%BB%84%E7%BB%87%E7%AE%A1%E7%90%86%E7%9B%B8%E5%85%B3/image.png" alt=""></p><p><img src="2025-03-10-SoundMentor-%E7%BB%84%E7%BB%87%E7%AE%A1%E7%90%86%E7%9B%B8%E5%85%B3/diagram.png" alt=""></p><h2 id="2-通过分享码加入组织">2.通过分享码加入组织</h2><p>这里用乐观锁，防止高并发下的人员溢出</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 通过分享码进入组织</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param</span> dto</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="meta">@Override</span></span><br><span class="line"><span class="meta">@Transactional(rollbackFor = Exception.class)</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">join</span><span class="params">(JoinOrganizationDTO dto)</span> &#123;</span><br><span class="line">    <span class="type">String</span> <span class="variable">shareCode</span> <span class="operator">=</span> dto.getShareCode();</span><br><span class="line">    <span class="type">Integer</span> <span class="variable">organizationId</span> <span class="operator">=</span> dto.getOrganizationId();</span><br><span class="line">    <span class="type">String</span> <span class="variable">s</span> <span class="operator">=</span> redisTemplate.opsForValue().get(SoundMentorConstant.ORGANIZATION_SHARE_CODE_KEY + organizationId);</span><br><span class="line">    <span class="keyword">if</span>(Objects.isNull(s))</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">throw</span> <span class="keyword">new</span> <span class="title class_">BizException</span>(ResultCodeEnum.INVALID_PARAM.getCode(),<span class="string">&quot;分享码不存在或已经失效&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span>(!StringUtils.equals(shareCode,s))</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">throw</span> <span class="keyword">new</span> <span class="title class_">BizException</span>(ResultCodeEnum.INVALID_PARAM.getCode(),<span class="string">&quot;分享码不正确&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="type">OrganizationDO</span> <span class="variable">organization</span> <span class="operator">=</span> <span class="built_in">this</span>.getById(organizationId);</span><br><span class="line">    <span class="keyword">if</span>(Objects.isNull(organization))</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">throw</span> <span class="keyword">new</span> <span class="title class_">BizException</span>(ResultCodeEnum.INVALID_PARAM.getCode(),<span class="string">&quot;组织不存在&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="type">OrganizationUserDO</span> <span class="variable">one</span> <span class="operator">=</span> ouService.lambdaQuery()</span><br><span class="line">            .eq(OrganizationUserDO::getOrganizationId, organizationId)</span><br><span class="line">            .eq(OrganizationUserDO::getUserId, userInfoApi.getUser().getId())</span><br><span class="line">            .one();</span><br><span class="line">    <span class="keyword">if</span> (!Objects.isNull(one))</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">throw</span> <span class="keyword">new</span> <span class="title class_">BizException</span>(ResultCodeEnum.INTERNAL_ERROR.getCode(),<span class="string">&quot;您已经加入该组织&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="type">boolean</span> <span class="variable">update</span> <span class="operator">=</span> <span class="built_in">this</span>.lambdaUpdate()</span><br><span class="line">            .setSql(<span class="string">&quot;spare_capacity=spare_capacity-1&quot;</span>)</span><br><span class="line">            .eq(OrganizationDO::getId, organizationId)</span><br><span class="line">            .gt(OrganizationDO::getSpareCapacity, <span class="number">0</span>)</span><br><span class="line">            .update();</span><br><span class="line">    <span class="keyword">if</span>(!update)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">throw</span> <span class="keyword">new</span> <span class="title class_">BizException</span>(ResultCodeEnum.INTERNAL_ERROR.getCode(),<span class="string">&quot;组织容量已满&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="type">OrganizationUserDO</span> <span class="variable">organizationUserDO</span> <span class="operator">=</span> OrganizationUserDO.builder()</span><br><span class="line">            .organizationId(organizationId)</span><br><span class="line">            .userId(userInfoApi.getUser().getId())</span><br><span class="line">            .organizationRole(OrganizationRole.USER.getCode())</span><br><span class="line">            .createTime(LocalDateTime.now())</span><br><span class="line">            .build();</span><br><span class="line">    ouService.save(organizationUserDO);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
    
    
    <summary type="html">🥧SoundMentor-组织管理相关</summary>
    
    
    
    <category term="项目" scheme="https://outoflovenicoo.github.io/categories/%E9%A1%B9%E7%9B%AE/"/>
    
    
    <category term="项目" scheme="https://outoflovenicoo.github.io/tags/%E9%A1%B9%E7%9B%AE/"/>
    
  </entry>
  
  <entry>
    <title>联合索引学习笔记</title>
    <link href="https://outoflovenicoo.github.io/posts/2025-03-09-%E8%81%94%E5%90%88%E7%B4%A2%E5%BC%95%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0.html"/>
    <id>https://outoflovenicoo.github.io/posts/2025-03-09-%E8%81%94%E5%90%88%E7%B4%A2%E5%BC%95%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0.html</id>
    <published>2025-03-09T10:19:03.000Z</published>
    <updated>2025-03-23T14:00:00.000Z</updated>
    
    <content type="html"><![CDATA[<h1>联合索引底层以及内幕</h1><p><a href="https://mp.weixin.qq.com/s/8qemhRg5MgXs1So5YCv0fQ">联合索引底层</a></p><p><a href="https://blog.csdn.net/wangye135/article/details/140389620">MySQL覆盖索引和索引跳跃扫描-CSDN博客</a></p><p><img src="2025-03-09-%E8%81%94%E5%90%88%E7%B4%A2%E5%BC%95%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/image-20250407160156273-4012927.png" alt="image-20250407160156273"></p><h3 id="被问到过一个面试题：">被问到过一个面试题：</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">select a,c from t <span class="type">where</span> <span class="variable">a</span> <span class="operator">=</span> <span class="number">1</span> and b= <span class="number">2</span> order by c desc</span><br></pre></td></tr></table></figure><p>应该设置什么索引，c的升序和降序会有什么影响，哪个更快一点。</p><h3 id="升序索引与降序索引对查询性能的影响">升序索引与降序索引对查询性能的影响</h3><h4 id="1-查询排序方向与索引排序方向一致">1. 查询排序方向与索引排序方向一致</h4><ul><li><strong>升序索引用于升序查询</strong>：当创建的索引是 <code>(a, b, c ASC)</code>（<code>ASC</code> 表示升序，可省略），并且查询语句是 <code>ORDER BY c ASC</code> 时，数据库可以直接按照索引中 <code>c</code> 列的顺序来返回结果，无需额外的排序操作，这样能显著提升查询效率。因为索引已经按照升序排列好了，数据库可以直接从索引中获取有序的数据。</li><li><strong>降序索引用于降序查询</strong>：如果创建的索引是 <code>(a, b, c DESC)</code>，而查询语句是 <code>ORDER BY c DESC</code>，数据库同样可以直接利用索引中 <code>c</code> 列的降序排列来返回结果，避免了额外的排序开销。</li></ul><h4 id="2-查询排序方向与索引排序方向不一致">2. 查询排序方向与索引排序方向不一致</h4><ul><li><strong>升序索引用于降序查询</strong>：当使用 <code>(a, b, c ASC)</code> 索引，而查询语句是 <code>ORDER BY c DESC</code> 时，数据库可能无法直接利用索引的顺序，需要对从索引中获取的数据进行额外的降序排序操作。这会增加查询的时间和资源消耗，尤其是在处理大量数据时，性能下降会更明显。</li><li><strong>降序索引用于升序查询</strong>：类似地，若使用 <code>(a, b, c DESC)</code> 索引，而查询是 <code>ORDER BY c ASC</code>，数据库也需要对数据进行额外的升序排序，导致性能降低。</li></ul><h3 id="哪个更快取决于具体场景">哪个更快取决于具体场景</h3><ul><li><strong>如果查询中</strong> **<code>ORDER BY c</code>**的方向固定：<ul><li>若查询总是 <code>ORDER BY c ASC</code>，那么创建升序索引 <code>(a, b, c)</code> 会更快，因为可以直接利用索引的顺序。</li><li>若查询总是 <code>ORDER BY c DESC</code>，则创建降序索引 <code>(a, b, c DESC)</code> 更合适，能避免额外的排序操作。</li></ul></li><li><strong>如果查询中</strong> **<code>ORDER BY c</code>**的方向不固定：<ul><li>在某些数据库（如 MySQL 8.0 及以上版本）中，可以同时创建升序和降序索引，但这会增加索引维护的开销，因为每次插入、更新或删除数据时，都需要同时更新多个索引。</li><li>也可以考虑只创建一个升序索引，让数据库在需要降序排序时进行额外的排序操作。在数据量较小的情况下，这种额外排序的开销可能并不明显。</li></ul></li></ul><p><strong>示例代码</strong></p><p><strong>升序索引</strong></p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">-- 创建升序索引</span></span><br><span class="line"><span class="keyword">CREATE</span> INDEX idx_a_b_c_asc <span class="keyword">ON</span> t (a, b, c);</span><br><span class="line"></span><br><span class="line"><span class="comment">-- 升序查询</span></span><br><span class="line"><span class="keyword">SELECT</span> a, c <span class="keyword">FROM</span> t <span class="keyword">WHERE</span> a <span class="operator">=</span> <span class="number">1</span> <span class="keyword">AND</span> b <span class="operator">=</span> <span class="number">2</span> <span class="keyword">ORDER</span> <span class="keyword">BY</span> c <span class="keyword">ASC</span>;</span><br></pre></td></tr></table></figure><p><strong>降序索引</strong></p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">-- 创建降序索引</span></span><br><span class="line"><span class="keyword">CREATE</span> INDEX idx_a_b_c_desc <span class="keyword">ON</span> t (a, b, c <span class="keyword">DESC</span>);</span><br><span class="line"></span><br><span class="line"><span class="comment">-- 降序查询</span></span><br><span class="line"><span class="keyword">SELECT</span> a, c <span class="keyword">FROM</span> t <span class="keyword">WHERE</span> a <span class="operator">=</span> <span class="number">1</span> <span class="keyword">AND</span> b <span class="operator">=</span> <span class="number">2</span> <span class="keyword">ORDER</span> <span class="keyword">BY</span> c <span class="keyword">DESC</span>;</span><br></pre></td></tr></table></figure><p>综上所述，选择升序索引还是降序索引取决于查询中 <code>ORDER BY</code> 子句的排序方向。</p>]]></content>
    
    
    <summary type="html">🥧联合索引学习</summary>
    
    
    
    <category term="学习" scheme="https://outoflovenicoo.github.io/categories/%E5%AD%A6%E4%B9%A0/"/>
    
    
    <category term="MySQL" scheme="https://outoflovenicoo.github.io/tags/MySQL/"/>
    
  </entry>
  
  <entry>
    <title>个人对零拷贝技术的理解</title>
    <link href="https://outoflovenicoo.github.io/posts/2025-03-09-%E4%B8%AA%E4%BA%BA%E5%AF%B9%E9%9B%B6%E6%8B%B7%E8%B4%9D%E6%8A%80%E6%9C%AF%E7%9A%84%E7%90%86%E8%A7%A3.html"/>
    <id>https://outoflovenicoo.github.io/posts/2025-03-09-%E4%B8%AA%E4%BA%BA%E5%AF%B9%E9%9B%B6%E6%8B%B7%E8%B4%9D%E6%8A%80%E6%9C%AF%E7%9A%84%E7%90%86%E8%A7%A3.html</id>
    <published>2025-03-09T10:19:03.000Z</published>
    <updated>2025-03-23T14:00:00.000Z</updated>
    
    <content type="html"><![CDATA[<h1>思维导图</h1><p><img src="2025-03-09-%E4%B8%AA%E4%BA%BA%E5%AF%B9%E9%9B%B6%E6%8B%B7%E8%B4%9D%E6%8A%80%E6%9C%AF%E7%9A%84%E7%90%86%E8%A7%A3/image-20250414160743861.png" alt="image-20250414160743861"></p><h3 id="个人对零拷贝技术的理解：告别冗余拷贝，释放系统性能">个人对零拷贝技术的理解：告别冗余拷贝，释放系统性能</h3><p>在计算机系统中，磁盘和网络传输往往是性能的瓶颈之一。传统的文件传输方式虽然逻辑简单，但在高并发场景下会因频繁的上下文切换和数据拷贝导致严重的性能损耗。而**零拷贝（Zero-copy）**技术的出现，正是为了解决这一问题。本文将从硬件协作到内核优化，逐步拆解零拷贝技术的原理与应用。</p><hr><h4 id="一、从DMA技术说起：让CPU“解放双手”">一、从DMA技术说起：让CPU“解放双手”</h4><p>在早期计算机中，数据的传输完全依赖CPU。例如，当磁盘需要向内存传输数据时，CPU需要逐个字节地从磁盘控制器缓冲区读取数据，再写入内存。这种“全程陪跑”的方式让CPU无法处理其他任务，效率极低。</p><p><strong>DMA（直接内存访问）技术</strong>的引入彻底改变了这一局面。DMA控制器接管了数据搬运的工作，CPU只需告诉DMA“从哪里搬、搬到哪里”，后续的数据传输由DMA独立完成。这一过程无需CPU参与，从而释放了CPU资源。</p><p><strong>DMA的工作流程</strong>：</p><ol><li>用户进程发起I/O请求；</li><li>DMA将磁盘数据直接搬运到内核缓冲区；</li><li>数据就绪后，DMA通知CPU将数据从内核缓冲区拷贝到用户空间。</li></ol><p>至此，CPU只需在传输的开始和结束时介入，中间的数据搬运工作全部由DMA完成。</p><hr><h4 id="二、传统文件传输的“四宗罪”">二、传统文件传输的“四宗罪”</h4><p>传统文件传输通过<code>read()</code>和<code>write()</code>系统调用实现，看似简单的两行代码，却隐藏着巨大的性能问题：</p><ol><li><strong>4次上下文切换</strong>：每次系统调用涉及2次用户态与内核态的切换，两次调用共4次切换。</li><li><strong>4次数据拷贝</strong>：<br>• DMA将磁盘数据拷贝到内核缓冲区；<br>• CPU将内核数据拷贝到用户缓冲区；<br>• CPU将用户数据拷贝到Socket内核缓冲区；<br>• DMA将Socket缓冲区数据拷贝到网卡。</li></ol><p>这4次拷贝中，<strong>两次CPU参与的拷贝是冗余的</strong>，尤其是当用户不需要修改数据时，用户缓冲区的存在反而成了累赘。</p><hr><h4 id="三、零拷贝技术：如何实现“零”冗余？">三、零拷贝技术：如何实现“零”冗余？</h4><p>零拷贝的核心目标是<strong>减少上下文切换和数据拷贝次数</strong>，具体通过两种方式实现：</p><h5 id="1-mmap-write：减少一次数据拷贝">1. <code>mmap + write</code>：减少一次数据拷贝</h5><p><code>mmap()</code>系统调用将内核缓冲区映射到用户空间，使得用户进程与内核共享数据，省去了从内核到用户缓冲区的拷贝。但仍有3次数据拷贝（两次DMA，一次CPU），且需要4次上下文切换。</p><h5 id="2-sendfile-：系统调用的终极优化">2. <code>sendfile()</code>：系统调用的终极优化</h5><p>Linux 2.1引入的<code>sendfile()</code>系统调用，将读取和发送合并为一次操作：<br>• <strong>2次上下文切换</strong>（1次系统调用）；<br>• <strong>3次数据拷贝</strong>（DMA拷贝磁盘到内核、CPU拷贝内核到Socket缓冲区、DMA拷贝到网卡）。</p><p>若网卡支持<strong>SG-DMA（分散-聚集DMA）</strong>，则可进一步将CPU拷贝优化掉，仅需2次DMA拷贝，真正实现“零拷贝”。</p><hr><h4 id="四、PageCache：零拷贝的“加速器”">四、PageCache：零拷贝的“加速器”</h4><p>零拷贝依赖内核的**PageCache（页缓存）**技术，它通过两种机制提升性能：</p><ol><li><strong>缓存热点数据</strong>：最近访问的数据保留在内存中，减少磁盘访问。</li><li><strong>预读机制</strong>：根据局部性原理，提前加载后续可能访问的数据。</li></ol><p>然而，PageCache对<strong>大文件传输并不友好</strong>：<br>• 大文件会挤占缓存空间，影响小文件性能；<br>• 大文件的数据复用率低，预读反而浪费资源。</p><p><strong>解决方案</strong>：针对大文件，采用<strong>异步I/O + 直接I/O</strong>，绕过PageCache，直接由磁盘到用户空间。</p><hr><h4 id="五、实践指南：何时用零拷贝？何时用直接I-O？">五、实践指南：何时用零拷贝？何时用直接I/O？</h4><p>• <strong>小文件传输</strong>：优先使用零拷贝（如<code>sendfile</code>），结合PageCache加速。<br>• <strong>大文件传输</strong>：使用异步I/O + 直接I/O，避免PageCache污染。</p><p><strong>Nginx配置示例</strong>：</p><figure class="highlight nginx"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="section">location</span> /video/ &#123;</span><br><span class="line">    <span class="attribute">sendfile</span> <span class="literal">on</span>;       <span class="comment"># 小文件用零拷贝</span></span><br><span class="line">    <span class="attribute">aio</span> <span class="literal">on</span>;            <span class="comment"># 大文件用异步I/O</span></span><br><span class="line">    <span class="attribute">directio</span> <span class="number">1024m</span>;    <span class="comment"># 超过1GB的文件启用直接I/O</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><hr><h4 id="六、总结">六、总结</h4><p>零拷贝技术通过减少CPU参与的数据拷贝和上下文切换，显著提升了文件传输效率。其核心思想是：</p><ol><li><strong>硬件协作</strong>：DMA承担数据搬运，释放CPU；</li><li><strong>内核优化</strong>：合并系统调用，利用PageCache加速；</li><li><strong>场景适配</strong>：区分大小文件，选择最优方案。</li></ol><p>在高并发场景下，合理使用零拷贝（如Kafka、Nginx）可大幅提升吞吐量，而大文件传输则需另辟蹊径。</p>]]></content>
    
    
    <summary type="html">🥧个人对零拷贝技术的理解</summary>
    
    
    
    <category term="学习" scheme="https://outoflovenicoo.github.io/categories/%E5%AD%A6%E4%B9%A0/"/>
    
    
    <category term="操作系统" scheme="https://outoflovenicoo.github.io/tags/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/"/>
    
  </entry>
  
  <entry>
    <title>MySQL如何存储数据</title>
    <link href="https://outoflovenicoo.github.io/posts/2025-03-09-MySQL%E5%A6%82%E4%BD%95%E5%AD%98%E5%82%A8%E6%95%B0%E6%8D%AE.html"/>
    <id>https://outoflovenicoo.github.io/posts/2025-03-09-MySQL%E5%A6%82%E4%BD%95%E5%AD%98%E5%82%A8%E6%95%B0%E6%8D%AE.html</id>
    <published>2025-03-09T10:19:03.000Z</published>
    <updated>2025-03-23T14:00:00.000Z</updated>
    
    <content type="html"><![CDATA[<h1>InnoDB存储引擎如何存储数据</h1><h2 id="思维导图："><strong>思维导图：</strong></h2><p><img src="2025-03-09-MySQL%E5%A6%82%E4%BD%95%E5%AD%98%E5%82%A8%E6%95%B0%E6%8D%AE/1.png" alt="img"></p><p>在MySQL数据库的世界里，InnoDB存储引擎堪称是数据存储的&quot;心脏&quot;。今天，我们就以一位数据库工程师的视角，揭开这个&quot;心脏&quot;的运作奥秘。准备好了吗？让我们沿着数据存储的脉络，开启一场技术探秘之旅！</p><h2 id="一、MySQL数据存储基石：InnoDB的精密设计">一、MySQL数据存储基石：InnoDB的精密设计</h2><p>如果把数据库比作图书馆，InnoDB就是那个既懂分类又善管理的图书管理员。它通过精心设计的文件系统，将数据有序地存放在磁盘上。</p><h3 id="（一）磁盘文件里的-身份证-与-藏书阁">（一）磁盘文件里的&quot;身份证&quot;与&quot;藏书阁&quot;</h3><p><img src="2025-03-09-MySQL%E5%A6%82%E4%BD%95%E5%AD%98%E5%82%A8%E6%95%B0%E6%8D%AE/2.png" alt="img"></p><p>当我们新建一个订单表<code>order</code>时，系统会悄悄生成几个关键文件：<br>• <strong>opt文件</strong>：就像是数据库的&quot;身份证&quot;，记录着默认的字符集（比如UTF-8）和校验规则。它确保中文不会变成乱码，数字比较时不会出错。<br>• <strong>frm文件</strong>：可以理解为&quot;书架标签&quot;，存储着表结构的定义。每次你DESC查看表结构时，系统其实就是在读取这个文件。<br>• <strong>idb文件</strong>：这才是真正的&quot;藏书阁&quot;。以<code>order.idb</code>为例，它存储着订单表的所有数据。就像现代图书馆的智能书架，MySQL 5.6.6之后默认每个表都有独立的.idb文件，这样要维护某个书架（表）时，再也不用搬动整个图书馆的藏书了。</p><p>举个真实案例：某电商平台发现订单表查询变慢，DBA通过<code>ALTER TABLE order ENGINE=InnoDB</code>重建表空间后，发现.idb文件体积缩小了30%，这正是独立表空间的优势体现。</p><h3 id="（二）表空间的俄罗斯套娃结构">（二）表空间的俄罗斯套娃结构</h3><p>打开这个&quot;藏书阁&quot;，你会发现一个精妙的存储体系：</p><p><img src="2025-03-09-MySQL%E5%A6%82%E4%BD%95%E5%AD%98%E5%82%A8%E6%95%B0%E6%8D%AE/3.png" alt="img"></p><figure class="highlight"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">表空间 → 段 → 区 → 页 → 行</span><br></pre></td></tr></table></figure><p>就像图书馆的分区管理：<br>• <strong>段（Segment）</strong>：类似图书馆的楼层分区（索引区、数据区）<br>• <strong>区（Extent）</strong>：每个楼层里的藏书区，由连续64个页组成（1MB）<br>• <strong>页（Page）</strong>：最基本的存储单元，相当于书架隔层（16KB）<br>• <strong>行（Row）</strong>：每本书就是一行数据</p><p>这种结构设计有个精妙之处：当需要新增数据时，InnoDB不是随意找个空位，而是整区整区地分配空间。就像图书馆扩建时直接增加整个书架区，而不是这里加一本那里塞一册。</p><h2 id="二、行格式">二、行格式</h2><p>如果说表空间是图书馆，那么行格式就是书籍的排版规范。InnoDB支持多种行格式，我们以最常用的Compact格式为例，看看它是如何将数据&quot;装订成册&quot;的。</p><h3 id="（一）变长字段的">（一）变长字段的</h3><p>假设我们有一张用户表：</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">CREATE TABLE</span> users (</span><br><span class="line">    id <span class="type">INT</span> <span class="keyword">NOT NULL</span>,</span><br><span class="line">    name <span class="type">VARCHAR</span>(<span class="number">20</span>),</span><br><span class="line">    email <span class="type">VARCHAR</span>(<span class="number">50</span>)</span><br><span class="line">);</span><br></pre></td></tr></table></figure><p>当插入一条记录：</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">INSERT INTO</span> users <span class="keyword">VALUES</span>(<span class="number">1</span>, <span class="string">&#x27;张三&#x27;</span>, <span class="string">&#x27;zhangsan@example.com&#x27;</span>);</span><br></pre></td></tr></table></figure><p>Compact行格式会先在数据行头部放置两把&quot;尺子&quot;：</p><ol><li><p><strong>变长字段长度列表</strong>：逆序记录每个变长字段的实际长度<br>• email长度23字节（ASCII每个字符1字节）<br>• name长度4字节（每个中文字符3字节？不！这里有个常见误区，实际存储长度取决于字符集）<br>• 存储方式：<code>[23,4]</code>的逆序十六进制<code>0x17 0x04</code></p></li><li><p><strong>NULL值标记位图</strong>：<br>• 三个字段都不允许NULL，所以这个列表不存在<br>• 如果允许NULL，会用位图标记哪些字段是NULL（1表示NULL）</p></li></ol><p>这里有个有趣的测试：将name字段改为CHAR(20)，实际存储长度会变成60字节（假设UTF8MB4字符集），而VARCHAR(20)实际存储长度根据内容变化。这就是CHAR类型在存储空间上的&quot;以空间换时间&quot;策略。</p><h3 id="（二）NULL值的存储">（二）NULL值的存储</h3><p>当表中存在允许NULL的字段时，Compact行格式会施展它的&quot;隐身术&quot;：</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">CREATE TABLE</span> orders (</span><br><span class="line">    id <span class="type">INT</span> <span class="keyword">PRIMARY KEY</span>,</span><br><span class="line">    product <span class="type">VARCHAR</span>(<span class="number">100</span>),</span><br><span class="line">    buyer <span class="type">VARCHAR</span>(<span class="number">50</span>) <span class="keyword">NULL</span></span><br><span class="line">);</span><br></pre></td></tr></table></figure><p>假设插入：</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">INSERT INTO</span> orders <span class="keyword">VALUES</span>(<span class="number">1001</span>, <span class="string">&#x27;智能手机&#x27;</span>, <span class="keyword">NULL</span>);</span><br></pre></td></tr></table></figure><p>此时：</p><ol><li>NULL值列表用1字节表示：二进制<code>00000010</code>（逆序排列，第二位表示buyer为NULL）</li><li>实际数据区不存储NULL字段的值</li><li>省去了存储&quot;NULL&quot;字符串的空间</li></ol><p>根据统计，当表中存在多个可为NULL的字段时，这种设计可节省约5%的存储空间。某社交平台用户表优化后，仅NULL优化就减少了20GB的存储空间！</p><h2 id="三、当数据膨胀时的-分页存储术">三、当数据膨胀时的&quot;分页存储术&quot;</h2><p>想象一本百科全书太厚无法放入书架隔层，这时候就需要分册存放。InnoDB的行溢出机制就是这种智慧的数字版。</p><h3 id="（一）行溢出的临界点计算">（一）行溢出的临界点计算</h3><p>每个页（16KB）能存储多少数据？我们通过公式计算：</p><figure class="highlight abnf"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">最大行长度 <span class="operator">=</span> 页大小(<span class="number">16384</span>) - 行头信息(约<span class="number">56</span>字节) ≈ <span class="number">16328</span>字节</span><br></pre></td></tr></table></figure><p>当某行数据超过这个阈值时，就会触发行溢出。比如一个包含10个TEXT字段的表，每条记录都可能需要溢出存储。</p><h3 id="（二）溢出页的-目录索引">（二）溢出页的&quot;目录索引&quot;</h3><p>当发生行溢出时，Compact行格式会：</p><ol><li>在原始页保留768字节的&quot;书签&quot;</li><li>剩余数据存入溢出页</li><li>用20字节的指针记录溢出页地址</li><li>多个溢出页通过链表连接</li></ol><p>这就像图书馆的书籍目录：<br>• 主书架存放目录页（包含各分册位置）<br>• 实际内容存放在多个分册书架</p><p>某论坛系统曾因大文本字段导致频繁行溢出，通过将大字段拆分到扩展表，查询性能提升了3倍。</p><h2 id="四、行格式设计">四、行格式设计</h2><h3 id="（一）Compact-vs-Dynamic：选择的智慧">（一）Compact vs Dynamic：选择的智慧</h3><p>MySQL 8.0默认使用Dynamic行格式，它在处理溢出时更激进：<br>• 仅保留20字节指针<br>• 所有变长字段数据优先存溢出页<br>• 更适合现代应用的大数据字段场景</p><p>选择建议：<br>• 频繁更新的大字段表 → Dynamic<br>• 需要兼容旧版本 → Compact<br>• 压缩需求 → Compressed</p><h3 id="（二）字符集的隐藏陷阱">（二）字符集的隐藏陷阱</h3><p>当计算varchar(n)最大长度时，字符集的影响常被忽视：<br>• UTF8MB4字符集：每个字符最多4字节<br>• 实际最大n值 = (65535 - 长度列表 - NULL列表) / 4</p><p>例如允许NULL的单字段表：</p><figure class="highlight tap"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">(65535 -<span class="number"> 2 </span>- 1) /<span class="number"> 4 </span>≈ 16383字符</span><br></pre></td></tr></table></figure><p>某国际化电商就曾因未考虑字符集，导致地址字段被截断，损失百万订单。</p><h2 id="五、性能优化">五、性能优化</h2><ol><li><strong>NULL值优化</strong>：将允许NULL的字段改为NOT NULL DEFAULT ‘’，可节省NULL列表空间</li><li><strong>大字段分离</strong>：将BLOB/TEXT字段拆分到扩展表</li><li><strong>行格式转换</strong>：<code>ALTER TABLE ... ROW_FORMAT=DYNAMIC</code></li><li><strong>页压缩</strong>：对历史数据表启用页压缩</li><li><strong>字符集选择</strong>：中文环境优先考虑UTF8MB4而非UTF8</li></ol><p>某金融系统通过上述优化组合拳，使核心交易表的TPS从1500提升到5200，效果显著。</p><h2 id="结语：存储之道的三重境界">结语：存储之道的三重境界</h2><p>理解InnoDB的存储机制，就像修炼数据库的内功心法：</p><ol><li><strong>见山是山</strong>：看懂文件结构和行格式</li><li><strong>见山不是山</strong>：理解设计哲学与取舍权衡</li><li><strong>见山还是山</strong>：能根据业务特征定制存储方案</li></ol><p>当我们翻开InnoDB的存储宝典，看到的不仅是冷冰冰的数据结构，更是一群工程师对效率与可靠性的极致追求。下次当你执行一条SELECT语句时，不妨想象一下，这简单的查询背后，正有一支精密的&quot;存储交响乐团&quot;在为你演奏。</p><h1>参考博客：</h1><p><a href="https://xiaolincoding.com/mysql/base/row_format.html#%E6%80%BB%E7%BB%93">MySQL 一行记录是怎么存储的？</a></p>]]></content>
    
    
    <summary type="html">🥧MySQL如何存储数据</summary>
    
    
    
    <category term="学习" scheme="https://outoflovenicoo.github.io/categories/%E5%AD%A6%E4%B9%A0/"/>
    
    
    <category term="MySQL" scheme="https://outoflovenicoo.github.io/tags/MySQL/"/>
    
  </entry>
  
  <entry>
    <title>高性能网络模式</title>
    <link href="https://outoflovenicoo.github.io/posts/2025-03-09-%E9%AB%98%E6%80%A7%E8%83%BD%E7%BD%91%E7%BB%9C%E6%A8%A1%E5%BC%8F.html"/>
    <id>https://outoflovenicoo.github.io/posts/2025-03-09-%E9%AB%98%E6%80%A7%E8%83%BD%E7%BD%91%E7%BB%9C%E6%A8%A1%E5%BC%8F.html</id>
    <published>2025-03-09T10:19:03.000Z</published>
    <updated>2025-03-23T14:00:00.000Z</updated>
    
    <content type="html"><![CDATA[<h1>高性能网络模式：深入理解 Reactor 与 Proactor</h1><p>在构建高并发服务器时，传统的“一连接一线程”模型会面临性能瓶颈和资源浪费问题。<strong>I/O 多路复用技术</strong>的出现解决了这一难题，而基于此技术演化出的 <strong>Reactor</strong> 和 <strong>Proactor</strong> 模式，则成为了高性能网络编程的核心架构。本文将从设计思想、实现方案到应用场景，为你揭开这两种模式的神秘面纱。</p><h1>思维导图：</h1><p><img src="2025-03-09-%E9%AB%98%E6%80%A7%E8%83%BD%E7%BD%91%E7%BB%9C%E6%A8%A1%E5%BC%8F/image-20250414161555385.png" alt="image-20250414161555385"></p><hr><h2 id="一、Reactor-模式：同步非阻塞的事件驱动模型">一、Reactor 模式：同步非阻塞的事件驱动模型</h2><h3 id="1-核心思想">1. 核心思想</h3><p>Reactor 模式通过 <strong>事件分发机制</strong> 实现高效处理多连接。其核心由两个组件构成：<br>• <strong>Reactor</strong>：负责监听和分发事件（如连接建立、数据可读/写）<br>• <strong>处理资源池</strong>：线程/进程池负责具体业务处理</p><p><strong>类比现实场景</strong>：<br>Reactor 如同餐厅的接待员，持续监听客户请求（事件）。当新顾客到来（连接建立）时，接待员安排服务员（Handler）接待；当顾客点餐（数据到达）时，服务员开始处理订单。</p><hr><h3 id="2-三种经典实现方案">2. 三种经典实现方案</h3><h4 id="方案-1：单-Reactor-单进程-线程">方案 1：单 Reactor 单进程/线程</h4><p><strong>架构组成</strong>：<br>• 单个进程/线程内包含三个核心对象：<br>• <strong>Reactor</strong>：通过 <code>select</code>/<code>epoll</code> 监听所有事件<br>• <strong>Acceptor</strong>：处理新连接建立<br>• <strong>Handler</strong>：处理已建立连接的读写请求</p><p><strong>工作流程</strong>：</p><ol><li>Reactor 监听所有事件，将连接建立事件分发给 Acceptor</li><li>Acceptor 调用 <code>accept()</code> 创建新连接，并生成对应的 Handler</li><li>Handler 处理数据读写（<code>read → 业务处理 → send</code>）</li></ol><p><strong>特点</strong>：<br>• 实现简单，无进程间通信开销<br>• 无法利用多核 CPU，业务处理必须非阻塞<br>• <strong>典型应用</strong>：Redis 6.0 前版本</p><hr><h4 id="方案-2：单-Reactor-多线程">方案 2：单 Reactor 多线程</h4><p><strong>架构改进</strong>：<br>• 主线程保留 Reactor 和 Acceptor<br>• 引入线程池处理业务逻辑：<br>• Handler 仅负责非阻塞 I/O 操作<br>• 子线程处理业务后将结果返回主线程</p><p><strong>工作流程</strong>：</p><ol><li>Reactor 监听事件，连接建立后由 Acceptor 创建 Handler</li><li>Handler 读取数据后，将数据提交给线程池处理</li><li>子线程完成业务逻辑，通过共享队列返回结果</li><li>主线程的 Handler 将结果发送给客户端</li></ol><p><strong>痛点</strong>：<br>• Reactor 单点可能成为性能瓶颈<br>• 需处理多线程资源共享问题<br>• <strong>典型应用</strong>：早期 Memcache</p><hr><h4 id="方案-3：多-Reactor-多进程-线程">方案 3：多 Reactor 多进程/线程</h4><p><strong>架构设计</strong>：<br>• <strong>MainReactor</strong>：主线程/进程，仅处理新连接建立<br>• <strong>SubReactor</strong>：子线程/进程池，每个子单元管理一组连接<br>• <strong>Handler</strong>：绑定到 SubReactor 处理具体连接</p><p><strong>工作流程</strong>：</p><ol><li>MainReactor 接收新连接，按负载均衡策略分配给 SubReactor</li><li>SubReactor 将连接加入自己的监听队列</li><li>事件触发时，SubReactor 调用对应 Handler 处理数据流</li></ol><p><strong>优势</strong>：<br>• 主从分工明确，扩展性强<br>• 避免单点性能瓶颈<br>• <strong>典型应用</strong>：Netty（多线程）、Nginx（多进程变体）</p><hr><h2 id="二、Proactor-模式：异步非阻塞的终极方案">二、Proactor 模式：异步非阻塞的终极方案</h2><h3 id="1-核心思想-2">1. 核心思想</h3><p>Proactor 是真正的 <strong>异步 I/O 模型</strong>，其特点在于：<br>• <strong>操作系统完成 I/O 操作</strong>：包括数据从内核到用户空间的拷贝<br>• <strong>应用层只关注业务逻辑</strong>：处理已完成的 I/O 事件</p><p><strong>现实类比</strong>：<br>Proactor 如同外卖平台，骑手（系统内核）直接将餐品送到你家（数据就绪），你只需处理用餐（业务逻辑）即可。</p><hr><h3 id="2-工作流程">2. 工作流程</h3><ol><li><strong>注册异步操作</strong>：应用通过 <code>aio_read</code> 等接口发起请求，指定数据缓冲区</li><li><strong>系统内核执行 I/O</strong>：从网卡读取数据并自动拷贝到用户空间</li><li><strong>完成通知</strong>：内核通过回调通知 Proactor</li><li><strong>业务处理</strong>：Proactor 调用 Handler 处理数据</li></ol><hr><h3 id="3-平台支持差异">3. 平台支持差异</h3><table><thead><tr><th><strong>平台</strong></th><th><strong>实现方式</strong></th><th><strong>特点</strong></th></tr></thead><tbody><tr><td>Linux</td><td>模拟异步 I/O（如 <code>aio</code>）</td><td>仅支持文件操作，网络性能受限</td></tr><tr><td>Windows</td><td>原生支持 IOCP（完成端口）</td><td>真正异步，适合高性能网络服务</td></tr></tbody></table><hr><h2 id="三、Reactor-vs-Proactor-关键区别">三、Reactor vs Proactor 关键区别</h2><table><thead><tr><th><strong>特性</strong></th><th><strong>Reactor</strong></th><th><strong>Proactor</strong></th></tr></thead><tbody><tr><td><strong>事件类型</strong></td><td>通知&quot;可读/可写&quot;（需应用主动处理数据）</td><td>通知&quot;数据已就绪&quot;（数据已存入应用缓冲区）</td></tr><tr><td><strong>数据处理</strong></td><td>应用层调用 <code>read</code>/<code>write</code> 完成 I/O 操作</td><td>系统自动完成数据读写</td></tr><tr><td><strong>性能瓶颈</strong></td><td>依赖非阻塞 I/O 和线程模型优化</td><td>依赖操作系统异步支持</td></tr><tr><td><strong>编程复杂度</strong></td><td>需处理非阻塞 I/O 状态和半包问题</td><td>只需关注业务逻辑</td></tr><tr><td><strong>典型应用</strong></td><td>Redis、Nginx、Netty</td><td>Windows IOCP 服务器</td></tr></tbody></table><hr><h2 id="四、如何选择网络模型？">四、如何选择网络模型？</h2><h3 id="1-Reactor-适用场景">1. Reactor 适用场景</h3><p>• <strong>跨平台需求</strong>（尤其是 Linux 环境）<br>• <strong>业务逻辑轻量</strong>（如微秒级处理）<br>• <strong>高并发连接</strong>（如百万级长连接）<br>• <strong>经典案例</strong>：<br>• Redis：单 Reactor 处理内存级快速操作<br>• Netty：多 Reactor 应对高并发网络请求</p><h3 id="2-Proactor-适用场景">2. Proactor 适用场景</h3><p>• <strong>Windows 平台高性能服务</strong><br>• <strong>大数据量传输</strong>（如视频流处理）<br>• <strong>简化业务层开发</strong><br>• <strong>经典案例</strong>：<br>• IIS 服务器：基于 IOCP 实现高效 HTTP 服务<br>• 金融交易系统：低延迟处理高频交易数据</p><hr><h2 id="五、总结">五、总结</h2><p><strong>Reactor 的本质</strong>：</p><blockquote><p>“事件就绪时通知你处理” —— 应用程序仍需主动完成数据读写。</p></blockquote><p><strong>Proactor 的精髓</strong>：</p><blockquote><p>“事件处理完通知你结果” —— 操作系统包揽脏活累活，应用层专注业务。</p></blockquote><p><strong>技术选型建议</strong>：<br>• 在 Linux 体系下，Reactor 仍是主流选择，结合 <code>epoll</code> 和线程池优化可达到 C10M 并发。<br>• Windows 平台优先考虑 Proactor（IOCP），充分发挥异步性能优势。<br>• 现代框架如 Netty 通过分层设计屏蔽底层差异，开发者可基于 API 统一编程模型。</p><p>理解这些底层网络模式是很重要的。因为无论是优化现有系统，还是设计新架构，Reactor 和 Proactor 的思想都将持续指引我们突破性能瓶颈。</p>]]></content>
    
    
    <summary type="html">🥧高性能网络模式</summary>
    
    
    
    <category term="学习" scheme="https://outoflovenicoo.github.io/categories/%E5%AD%A6%E4%B9%A0/"/>
    
    
    <category term="操作系统" scheme="https://outoflovenicoo.github.io/tags/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/"/>
    
  </entry>
  
</feed>
