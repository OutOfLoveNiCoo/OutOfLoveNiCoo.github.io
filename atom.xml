<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
  <title>OutOfLove🥝</title>
  
  
  <link href="https://outoflovenicoo.github.io/atom.xml" rel="self"/>
  
  <link href="https://outoflovenicoo.github.io/"/>
  <updated>2025-04-22T14:00:00.000Z</updated>
  <id>https://outoflovenicoo.github.io/</id>
  
  <author>
    <name>OutOfLove🥝</name>
    
  </author>
  
  <generator uri="https://hexo.io/">Hexo</generator>
  
  <entry>
    <title>MQ可靠性、有序性、幂等性等问题</title>
    <link href="https://outoflovenicoo.github.io/posts/2025-04-22-MQ%E5%8F%AF%E9%9D%A0%E6%80%A7%E3%80%81%E6%9C%89%E5%BA%8F%E6%80%A7%E3%80%81%E5%B9%82%E7%AD%89%E6%80%A7%E7%AD%89%E9%97%AE%E9%A2%98.html"/>
    <id>https://outoflovenicoo.github.io/posts/2025-04-22-MQ%E5%8F%AF%E9%9D%A0%E6%80%A7%E3%80%81%E6%9C%89%E5%BA%8F%E6%80%A7%E3%80%81%E5%B9%82%E7%AD%89%E6%80%A7%E7%AD%89%E9%97%AE%E9%A2%98.html</id>
    <published>2025-04-22T10:19:03.000Z</published>
    <updated>2025-04-22T14:00:00.000Z</updated>
    
    <content type="html"><![CDATA[<p>在面试饿了么的时候，问到了比较多的MQ场景题，感觉挺深的，现在总结下，方便以后经常复习。</p><h2 id="思维导图：">思维导图：</h2><p><img src="2025-04-22-MQ%E5%8F%AF%E9%9D%A0%E6%80%A7%E3%80%81%E6%9C%89%E5%BA%8F%E6%80%A7%E3%80%81%E5%B9%82%E7%AD%89%E6%80%A7%E7%AD%89%E9%97%AE%E9%A2%98/diagram.png" alt=""></p><p>在分布式系统中，消息中间件（MQ）扮演着至关重要的角色，它能有效解耦系统组件、异步处理任务并提升系统的可扩展性。但在实际应用中，消息丢失、重复、积压以及有序性等问题也随之而来。本文将结合思维导图内容，详细梳理 MQ 的核心技术与解决方案。 </p><h2 id="一、确保消息不丢失">一、确保消息不丢失</h2><h3 id="生产者层面">生产者层面</h3><ul><li><p><strong>事务与 confirm 机制</strong>：开启 RabbitMQ 事务，确保消息生产阶段的可靠性；同时使用 confirm 机制，让生产者知晓消息是否成功抵达 MQ 服务器，若未确认则可重发。 </p></li><li><p><strong>消息持久化</strong>：将消息标记为持久化，确保 MQ 服务器重启后消息不丢失。需注意队列、交换机也需配置持久化，以保证完整的持久化链路。 </p></li></ul><h3 id="MQ-本身处理单点故障">MQ 本身处理单点故障</h3><ul><li><p><strong>单节点模式</strong>：结构简单，非集群环境下，节点宕机则业务受影响，仅适用于简单场景。 </p></li><li><p><strong>普通模式</strong>：消息仅存在于当前节点，若节点宕机，未消费的消息可能丢失，需依赖持久化且重启后恢复。 </p></li><li><p><strong>镜像模式</strong>：消息同步到其他节点，提升高可用性，但会降低吞吐量，适用于对消息可靠性要求高的场景。 </p></li></ul><h3 id="消费者层面">消费者层面</h3><p>采用手动 ACK 机制，消费者处理完业务逻辑后再确认消息，避免因处理过程中宕机导致消息丢失。 </p><p><img src="2025-04-22-MQ%E5%8F%AF%E9%9D%A0%E6%80%A7%E3%80%81%E6%9C%89%E5%BA%8F%E6%80%A7%E3%80%81%E5%B9%82%E7%AD%89%E6%80%A7%E7%AD%89%E9%97%AE%E9%A2%98/image.png" alt=""></p><p>消费完可以发一条消息让上游感知到下游的任务执行状态，通过分布式ID保证消息只执行一次。</p><h2 id="二、消息常见问题处理">二、消息常见问题处理</h2><h3 id="消息重复与幂等性">消息重复与幂等性</h3><p>在消息补偿机制触发时，重复消息难以避免。通过引入分布式 ID，确保消费端对重复消息的处理具有幂等性。即无论消息接收多少次，处理结果与只处理一次一致，避免业务逻辑混乱。 </p><h3 id="消息积压">消息积压</h3><p>消息积压通常因消费者处理能力不足或故障导致。可通过增加消费者实例、优化消费逻辑提升处理速度，或在 MQ 端调整队列配置、采用批量消费等方式缓解。 </p><h3 id="消息有序性">消息有序性</h3><p>在分布式环境下，网络延迟、节点性能差异等因素易导致消息到达顺序与发送顺序不一致。例如，电商系统中订单创建、支付、发货等消息若顺序错乱，会引发业务逻辑错误。以下是保证消息有序性的详细方案：</p><h4 id="解决方案一：拆分多个-queue，每个-queue-一个-consumer">解决方案一：拆分多个 queue，每个 queue 一个 consumer</h4><p>将需要顺序处理的同类消息发送至同一个 queue。如电商订单系统中，每个订单的相关消息（创建、支付、发货）发送到特定 queue，每个 queue 仅由一个 consumer 处理，确保单个 queue 内消息有序。此方案缺点是 queue 数量可能过多，管理复杂，且吞吐量受单个 consumer 处理能力限制。可在消费者内部采用多线程提升处理效率，但需注意线程安全，确保同一 queue 消息处理顺序。</p><h4 id="解决方案二：一个-queue-对应一个-consumer，内部用内存队列排队">解决方案二：一个 queue 对应一个 consumer，内部用内存队列排队</h4><p>consumer 从 queue 接收消息后，存入内存队列，按顺序分发给底层 worker 处理，保证全局有序。但此方案中 consumer 成为单点，若宕机影响较大。可通过 consumer 集群解决，但需协调内存队列状态，增加实现复杂度。</p><h4 id="利用-MQ-自身有序特性（以-RocketMQ-为例）">利用 MQ 自身有序特性（以 RocketMQ 为例）</h4><p><img src="2025-04-22-MQ%E5%8F%AF%E9%9D%A0%E6%80%A7%E3%80%81%E6%9C%89%E5%BA%8F%E6%80%A7%E3%80%81%E5%B9%82%E7%AD%89%E6%80%A7%E7%AD%89%E9%97%AE%E9%A2%98/image-1.png" alt=""></p><p>RocketMQ 支持有序消息特性，生产者发送消息时指定队列，将同一业务流程的消息发送到同一队列，消费者按顺序消费该队列消息，确保消息有序性。此方式在代码层面，生产者需指定队列，消费者监听对应队列，实现相对简洁且高效。</p><p>个人总结，选择消息有序性方案需结合业务场景。高并发且部分有序的场景，拆分队列更合适；严格全局有序场景，可采用单个 queue 加内存队列或利用 MQ 自身有序特性，在保证业务需求的同时，权衡系统复杂度与性能。</p><h2 id="三、MQ-技术选型：以-RabbitMQ-与-RocketMQ-为例">三、MQ 技术选型：以 RabbitMQ 与 RocketMQ 为例</h2><h3 id="MessageQueue-相关模式">MessageQueue 相关模式</h3><ul><li><p><strong>广播模式</strong>：一个队列被多个消费者监听，同一 ConsumerGroup 下每个消费者处理全部消息，适用于通知推送等小流量场景。 </p></li><li><p><strong>消息拉取模式</strong>：分为拉取式（pull）和推送式（push）。Pull 需消费者主动轮询，实时性差但可控；Push 封装了轮询，实时性强但资源占用高。 </p></li><li><p><strong>消息消费模式</strong>： </p><ul><li><p>广播模式（一对多）：同一 ConsumerGroup 下所有消费者都接收同一 Topic 消息。 </p></li><li><p>集群模式（一对一）：同一 ConsumerGroup 下消费者平分 Topic 消息，每条消息仅消费一次。 </p></li></ul></li><li><p><strong>Queue 分配算法</strong>：如平均分配等，确保消费者合理负载。 </p></li></ul><h3 id="RabbitMQ-与-RocketMQ-的区别">RabbitMQ 与 RocketMQ 的区别</h3><ul><li><p><strong>协议支持</strong>：RabbitMQ 遵循 AMQP 协议，具有高度标准化与通用性，便于与支持该协议的工具、系统集成；RocketMQ 采用自定义协议，在设计上更聚焦于高性能与低延迟，能针对特定场景进行优化。 </p></li><li><p><strong>性能表现</strong>：RocketMQ 在高吞吐量、低延迟场景下表现优异，适合处理海量消息的互联网场景，如电商大促期间的订单消息、物流通知等；RabbitMQ 在中等并发量下表现稳定，但高并发时吞吐量相对有限，更适合企业级应用中对消息可靠性要求高、业务逻辑复杂但流量并非超大规模的场景。 </p></li><li><p><strong>可靠性与高可用性</strong>：RabbitMQ 的镜像模式可实现消息在节点间同步，保障高可用性，但会牺牲部分吞吐量；RocketMQ 通过主从架构、Dledger 机制等实现高可用，同时保持较高的消息处理性能，且支持消息持久化到磁盘，确保数据不丢失。 </p></li><li><p><strong>生态与社区</strong>：RabbitMQ 社区成熟，插件丰富，可轻松扩展功能（如消息监控、复杂路由等）；RocketMQ 社区活跃度高，在国内互联网公司应用广泛，对中文文档与国内技术支持更友好，且不断演进新特性（如延迟消息、事务消息的优化）。 </p></li><li><p><strong>应用场景</strong>：RabbitMQ 常用于金融支付、企业 ERP 等对协议标准性、可靠性要求高且业务逻辑复杂的场景；RocketMQ 则更多应用于互联网领域，如电商、物流、社交平台的实时消息推送、异步订单处理、流量削峰填谷等场景。 </p></li></ul><h2 id="四、其他关键问题">四、其他关键问题</h2><h3 id="如何选型消息中间件？">如何选型消息中间件？</h3><p>需综合考量吞吐量、延迟、可靠性、集群能力、生态支持等。例如 RocketMQ 适合高吞吐、低延迟场景，RabbitMQ 适合对可靠性要求高且业务复杂的场景。 </p><h3 id="队列模型与发布订阅模型区别">队列模型与发布订阅模型区别</h3><ul><li><p>队列模型：多个消费者竞争消费队列中消息，每条消息仅被一个消费者处理。 </p></li><li><p>发布订阅模型：消息发布到 Topic，多个订阅者（消费者组）都能收到完整消息副本，适用于一对多通信。 </p></li></ul><h3 id="消息队列实现高吞吐的原因">消息队列实现高吞吐的原因</h3><ul><li><p>异步处理：解耦生产与消费，无需等待。 </p></li><li><p>批量处理：支持批量发送与消费，减少交互次数。 </p></li><li><p>内存缓存：利用内存快速读写，结合持久化保证数据安全。 </p></li></ul><h3 id="序列化、传输协议与内存管理">序列化、传输协议与内存管理</h3><ul><li><p>序列化：选择高效的序列化方式（如 Protobuf），减少数据体积与处理开销。 </p></li><li><p>传输协议：如 RocketMQ 采用自定义协议，兼顾性能与功能；RabbitMQ 支持 AMQP 协议，通用性强。 </p></li><li><p>内存管理：合理控制消息缓存，避免内存溢出，通过分页、过期消息清理等机制优化。 </p></li></ul><h2 id="参考博客：">参考博客：</h2><blockquote><p><a href="https://cloud.tencent.com/developer/article/2342719">RabbitMQ消息丢失的场景，如何保证消息不丢失？</a></p><p><a href="https://blog.csdn.net/weixin_42039228/article/details/123526391">RabbitMQ如何保证消息的顺序性【重点】-CSDN博客</a></p><p><a href="https://xie.infoq.cn/article/c84491a814f99c7b9965732b1">消息队列（五）如何保证消息的顺序性？_Java_奈何花开_InfoQ写作社区</a></p><p><a href="https://blog.csdn.net/smallspot/article/details/105650948">MQ选型:ActiveMQ、RocketMQ、RabbitMQ、Kafka对比_rocketmq和rabbitmq哪个用的多-CSDN博客</a></p><p><a href="https://blog.csdn.net/weixin_48133130/article/details/134126430?ops_request_misc=%257B%2522request%255Fid%2522%253A%25226b0326d502eea4f750ef128acf68a7b1%2522%252C%2522scm%2522%253A%252220140713.130102334..%2522%257D&amp;request_id=6b0326d502eea4f750ef128acf68a7b1&amp;biz_id=0&amp;utm_medium=distribute.pc_search_result.none-task-blog-2~all~top_positive~default-1-134126430-null-null.142%5Ev102%5Epc_search_result_base3&amp;utm_term=RocketMQ&amp;spm=1018.2226.3001.4187">RocketMQ分布式消息队列（最详细）-CSDN博客</a></p></blockquote>]]></content>
    
    
    <summary type="html">🥧MQ可靠性、有序性、幂等性等问题</summary>
    
    
    
    <category term="学习" scheme="https://outoflovenicoo.github.io/categories/%E5%AD%A6%E4%B9%A0/"/>
    
    
    <category term="前沿" scheme="https://outoflovenicoo.github.io/tags/%E5%89%8D%E6%B2%BF/"/>
    
  </entry>
  
  <entry>
    <title>新的技术-MCP原理和使用</title>
    <link href="https://outoflovenicoo.github.io/posts/2025-04-20-%E6%96%B0%E7%9A%84%E6%8A%80%E6%9C%AF-MCP%E5%8E%9F%E7%90%86%E5%92%8C%E4%BD%BF%E7%94%A8.html"/>
    <id>https://outoflovenicoo.github.io/posts/2025-04-20-%E6%96%B0%E7%9A%84%E6%8A%80%E6%9C%AF-MCP%E5%8E%9F%E7%90%86%E5%92%8C%E4%BD%BF%E7%94%A8.html</id>
    <published>2025-04-20T10:19:03.000Z</published>
    <updated>2025-04-20T14:00:00.000Z</updated>
    
    <content type="html"><![CDATA[<h1 id="MCP介绍与原理："><a href="#MCP介绍与原理：" class="headerlink" title="MCP介绍与原理："></a>MCP介绍与原理：</h1><h2 id="1-介绍"><a href="#1-介绍" class="headerlink" title="1.介绍"></a>1.介绍</h2><p>​    MCP（Model Context Protocol，模型上下文协议） ，2024年11月底，由 Anthropic 推出的一种开放标准，旨在统一大型语言模型（LLM）与外部数据源和工具之间的通信协议。MCP 的主要目的在于解决当前 AI 模型因数据孤岛限制而无法充分发挥潜力的难题，MCP 使得 AI 应用能够安全地访问和操作本地及远程数据，为 AI 应用提供了连接万物的接口。</p><p>​    MCP 可以直接在 AI 与数据（包括本地数据和互联网数据）之间架起一座桥梁，通过 MCP 服务器和 MCP 客户端，大家只要都遵循这套协议，就能实现“万物互联”。</p><p>​    有了MCP，可以和数据和文件系统、开发工具、Web 和浏览器自动化、生产力和通信、各种社区生态能力全部集成，实现强大的协作工作能力，它的价值远不可估量。</p><p><img src="2025-04-20-新的技术-MCP原理和使用/v2-fa3cdcd616cd3dc22732fa3f529cc7f7_1440w.jpg" alt="img"></p><h3 id="MCP-与-Function-Calling-的区别"><a href="#MCP-与-Function-Calling-的区别" class="headerlink" title="MCP 与 Function Calling 的区别"></a><strong>MCP 与 Function Calling 的区别</strong></h3><p>这两种技术都旨在增强 AI 模型与外部数据的交互能力，但 MCP 不止可以增强 AI 模型，还可以是其他的应用系统。</p><p><img src="2025-04-20-新的技术-MCP原理和使用/v2-b82dc0e2da4a258438b84484d1af8319_1440w.jpg" alt="img"></p><h2 id="2-工作原理"><a href="#2-工作原理" class="headerlink" title="2.工作原理"></a>2.工作原理</h2><p>MCP 协议采用了一种独特的架构设计，它将 LLM 与资源之间的通信划分为三个主要部分：客户端、服务器和资源。</p><p>客户端负责发送请求给 MCP 服务器，服务器则将这些请求转发给相应的资源。这种分层的设计使得 MCP 协议能够更好地控制访问权限，确保只有经过授权的用户才能访问特定的资源。</p><p>以下是 MCP 的基本工作流程：</p><ul><li><p>初始化连接：客户端向服务器发送连接请求，建立通信通道。</p></li><li><p>发送请求：客户端根据需求构建请求消息，并发送给服务器。</p></li><li><p>处理请求：服务器接收到请求后，解析请求内容，执行相应的操作（如查询数据库、读取文件等）。</p></li><li><p>返回结果：服务器将处理结果封装成响应消息，发送回客户端。</p></li><li><p>断开连接：任务完成后，客户端可以主动关闭连接或等待服务器超时关闭。</p><p><img src="2025-04-20-新的技术-MCP原理和使用/v2-bb82edf5b8651051be151c279e7679e1_1440w-20250420103956741.jpg" alt="img"></p></li></ul><h3 id="MCP-核心架构"><a href="#MCP-核心架构" class="headerlink" title="MCP 核心架构"></a>MCP 核心架构</h3><p>MCP 遵循客户端-服务器架构（client-server），其中包含以下几个核心概念：</p><ul><li><p>MCP 主机（MCP Hosts）：发起请求的 LLM 应用程序（例如 <a href="https://zhida.zhihu.com/search?content_id=254488153&amp;content_type=Article&amp;match_order=1&amp;q=Claude+Desktop&amp;zhida_source=entity">Claude Desktop</a>、IDE 或 AI 工具）。</p></li><li><p>MCP 客户端（MCP Clients）：在主机程序内部，与 MCP server 保持 1:1 的连接。</p></li><li><p>MCP 服务器（MCP Servers）：为 MCP client 提供上下文、工具和 prompt 信息。</p></li><li><p>本地资源（Local Resources）：本地计算机中可供 MCP server 安全访问的资源（例如文件、数据库）。</p></li><li><p>远程资源（Remote Resources）：MCP server 可以连接到的远程资源（例如通过 API）。</p><p><img src="2025-04-20-新的技术-MCP原理和使用/v2-492a176fa0a06b585e752dc676d28b77_1440w.jpg" alt="img"></p></li></ul><h3 id="MCP-client-和-MCP-server"><a href="#MCP-client-和-MCP-server" class="headerlink" title="MCP client 和 MCP server"></a>MCP client 和 MCP server</h3><p>MCP client 充当 LLM 和 MCP server 之间的桥梁，MCP client 的工作流程如下：</p><ul><li>MCP client 首先从 MCP server 获取可用的工具列表。</li><li>将用户的查询连同工具描述通过 function calling 一起发送给 LLM。</li><li>LLM 决定是否需要使用工具以及使用哪些工具。</li><li>如果需要使用工具，MCP client 会通过 MCP server 执行相应的工具调用。</li><li>工具调用的结果会被发送回 LLM。</li><li>LLM 基于所有信息生成自然语言响应。</li><li>最后将响应展示给用户。</li></ul><p>MCP server 是 MCP 架构中的关键组件，它可以提供 3 种主要类型的功能：</p><ul><li>资源（Resources）：类似文件的数据，可以被客户端读取，如 API 响应或文件内容。</li><li>工具（Tools）：可以被 LLM 调用的函数（需要用户批准）。</li><li>提示（Prompts）：预先编写的模板，帮助用户完成特定任务。</li></ul><h3 id="通信机制"><a href="#通信机制" class="headerlink" title="通信机制"></a><strong>通信机制</strong></h3><p>MCP 协议支持两种主要的通信机制：基于标准输入输出的本地通信和基于<a href="https://zhida.zhihu.com/search?content_id=254488153&amp;content_type=Article&amp;match_order=1&amp;q=SSE&amp;zhida_source=entity">SSE</a>（<a href="https://link.zhihu.com/?target=https%3A//en.wikipedia.org/wiki/Server-sent_events">Server-Sent Events</a>）的远程通信。</p><p>这两种机制都使用 <a href="https://link.zhihu.com/?target=https%3A//www.jsonrpc.org/specification">JSON-RPC 2.0</a> 格式进行消息传输，确保了通信的标准化和可扩展性。</p><ul><li>本地通信<strong>：</strong>通过 stdio 传输数据，适用于在同一台机器上运行的客户端和服务器之间的通信。</li><li>远程通信<strong>：</strong>利用 SSE 与 HTTP 结合，实现跨网络的实时数据传输，适用于需要访问远程资源或分布式部署的场景。</li></ul><h2 id="3-MCP个人实践"><a href="#3-MCP个人实践" class="headerlink" title="3.MCP个人实践"></a>3.MCP个人实践</h2><h3 id="前言："><a href="#前言：" class="headerlink" title="前言："></a>前言：</h3><ol><li><p>安装 Claude Desktop： 确保已在 macOS 或 Windows 系统上安装最新版本的 Claude Desktop。</p><p>这一部分需要一个国外邮箱和国外手机号，国外手机号可以使用sms-activate获得。</p></li><li><p>配置 MCP 服务器： 在 Claude Desktop 的配置文件中，配置入口Claude Desktop—&gt;菜单—&gt;Settings—&gt;Developer—&gt;Edit Config：</p><p><img src="2025-04-20-新的技术-MCP原理和使用/image-20250420104518943.png" alt="image-20250420104518943"></p></li></ol><p><img src="2025-04-20-新的技术-MCP原理和使用/image-20250420104634339.png" alt="image-20250420104634339"></p><p>配置后，下面会出现锤子</p><p><img src="2025-04-20-新的技术-MCP原理和使用/image-20250420104729266.png" alt="image-20250420104729266"></p><h3 id="一、控制本地文件"><a href="#一、控制本地文件" class="headerlink" title="一、控制本地文件"></a>一、控制本地文件</h3><p><img src="2025-04-20-新的技术-MCP原理和使用/image-20250420104755519.png" alt="image-20250420104755519"></p><h3 id="二、实时搜索"><a href="#二、实时搜索" class="headerlink" title="二、实时搜索"></a>二、实时搜索</h3><p><strong>接入tavily实现实时搜索</strong></p><p><img src="2025-04-20-新的技术-MCP原理和使用/image-20250420104856401.png" alt="image-20250420104856401"></p><h2 id="参考博客："><a href="#参考博客：" class="headerlink" title="参考博客："></a>参考博客：</h2><p><a href="https://www.claudemcp.com/zh/docs/quickstart">ClaudeMcp使用文档</a></p><p><a href="https://zhuanlan.zhihu.com/p/27327515233">MCP原理详解</a></p><p><a href="https://blog.csdn.net/m0_37996629/article/details/146456420?ops_request_misc=%7B%22request%5Fid%22%3A%22f7bc1da06e0c3b4d1920f3cdec516773%22%2C%22scm%22%3A%2220140713.130102334..%22%7D&amp;request_id=f7bc1da06e0c3b4d1920f3cdec516773&amp;biz_id=0&amp;utm_medium=distribute.pc_search_result.none-task-blog-2~all~ElasticSearch~search_v2-6-146456420-null-null.142^v102^pc_search_result_base3&amp;utm_term=Claude %2B MCP&amp;spm=1018.2226.3001.4187">抢先体验:Claude + MCP 零成本实现网络搜索+网页爬虫_claude desktop下载-CSDN博客</a></p>]]></content>
    
    
    <summary type="html">🥧新的技术-MCP原理和使用</summary>
    
    
    
    <category term="学习" scheme="https://outoflovenicoo.github.io/categories/%E5%AD%A6%E4%B9%A0/"/>
    
    
    <category term="前沿" scheme="https://outoflovenicoo.github.io/tags/%E5%89%8D%E6%B2%BF/"/>
    
  </entry>
  
  <entry>
    <title>并发编程的内存泄漏与内存溢出问题</title>
    <link href="https://outoflovenicoo.github.io/posts/2025-04-19-%E5%B9%B6%E5%8F%91%E7%BC%96%E7%A8%8B%E7%9A%84%E5%86%85%E5%AD%98%E6%B3%84%E6%BC%8F%E4%B8%8E%E5%86%85%E5%AD%98%E6%BA%A2%E5%87%BA%E9%97%AE%E9%A2%98.html"/>
    <id>https://outoflovenicoo.github.io/posts/2025-04-19-%E5%B9%B6%E5%8F%91%E7%BC%96%E7%A8%8B%E7%9A%84%E5%86%85%E5%AD%98%E6%B3%84%E6%BC%8F%E4%B8%8E%E5%86%85%E5%AD%98%E6%BA%A2%E5%87%BA%E9%97%AE%E9%A2%98.html</id>
    <published>2025-04-19T10:19:03.000Z</published>
    <updated>2025-04-19T14:00:00.000Z</updated>
    
    <content type="html"><![CDATA[<h1>思维导图</h1><p><img src="2025-04-19-%E5%B9%B6%E5%8F%91%E7%BC%96%E7%A8%8B%E7%9A%84%E5%86%85%E5%AD%98%E6%B3%84%E6%BC%8F%E4%B8%8E%E5%86%85%E5%AD%98%E6%BA%A2%E5%87%BA%E9%97%AE%E9%A2%98/diagram.png" alt=""></p><p>在Java编程中，内存泄漏和内存溢出是常见且需要重点关注的问题。它们会导致程序性能下降，甚至崩溃。本文将详细介绍这两个概念、常见原因、表现迹象及解决方法。</p><h2 id="一、内存泄漏">一、内存泄漏</h2><h3 id="1-常见原因">1. 常见原因</h3><ul><li><p><strong>静态属性导致内存泄漏</strong>：静态变量生命周期长，若引用了大对象或长时间不用的对象，易导致内存泄漏。例如，静态集合类不断添加元素却不清理。</p></li><li><p><strong>未关闭的资源</strong>：数据库连接、文件流、网络连接等资源使用后未关闭，会一直占用内存。即使程序不再使用这些资源，垃圾回收器也无法回收，因为资源的引用未释放。</p></li><li><p><strong>使用ThreadLocal后未手动清理</strong>：ThreadLocal为每个线程提供独立变量副本，但若使用后不调用<code>remove</code>方法，线程长期存活时，ThreadLocal关联的对象会一直存在，占用内存。</p></li><li><p><strong>线程泄漏</strong>：线程结束后，相关资源未正确释放。如线程池中的线程未正确关闭，一直占用内存资源。</p></li></ul><h3 id="2-迹象">2. 迹象</h3><ul><li><p><strong>内存占用不断增加</strong>：观察程序内存占用，若持续上升且不释放，很可能存在内存泄漏。随着时间推移，内存占用越来越高，最终可能导致内存溢出。</p></li><li><p><strong>长时间运行后性能下降</strong>：程序运行一段时间后变慢，因内存泄漏使系统可用内存减少，垃圾回收频繁，影响程序执行效率。</p></li><li><p><strong>频繁的垃圾回收</strong>：尤其是Full GC频繁发生，说明内存中存在大量无法被回收的对象，可能是内存泄漏导致。</p></li></ul><h3 id="3-解决方法">3. 解决方法</h3><ul><li><p><strong>正确关闭资源</strong>：</p><ul><li><p>对于支持<code>try - with - resources</code>的资源（如<code>AutoCloseable</code>实现类），使用该语句自动关闭资源，确保资源使用后及时释放。</p></li><li><p>对于不支持的资源（如某些旧版数据库连接），在<code>finally</code>块中手动关闭，保证即使出现异常，资源也能释放。</p></li></ul></li><li><p><strong>使用ThreadLocal后手动清理</strong>：在使用完ThreadLocal变量后，及时调用<code>remove</code>方法，清除线程本地存储的变量，避免内存占用。</p></li><li><p><strong>避免线程泄漏</strong>：在线程不再需要时，调用<code>Thread</code>的<code>interrupt</code>方法或其他合适方式停止线程，确保线程相关资源正确关闭，如关闭线程池中的空闲线程。</p></li></ul><h2 id="二、内存溢出">二、内存溢出</h2><h3 id="1-常见原因-2">1. 常见原因</h3><ul><li><p><strong>大量对象创建</strong>：程序中循环或频繁创建大量对象，且未及时回收，超过JVM堆内存限制，导致内存溢出。例如，一次性加载大量数据到内存中创建对象。</p></li><li><p><strong>持久引用</strong>：如缓存、集合等数据结构长时间持有对象引用，即使对象不再使用，也无法被垃圾回收器回收，造成内存占用累积。</p></li><li><p><strong>递归调用</strong>：深度递归可能导致栈内存耗尽，出现<code>StackOverflowError</code>，这也是一种内存溢出情况。</p></li></ul><h3 id="2-JVM内存结构中的溢出情况">2. JVM内存结构中的溢出情况</h3><ul><li><p><strong>堆溢出</strong>：错误信息<code>java.lang.OutOfMemoryError: java heap space</code>。当堆中创建的对象过多，垃圾回收无法及时回收，且堆内存达到最大限制（通过<code>-Xmx</code>设置）时发生。</p></li><li><p><strong>方法区溢出</strong>：JDK 1.8前为<code>java.lang.OutOfMemoryError: PermGen space</code>，JDK 1.8后为<code>java.lang.OutOfMemoryError: Metaspace</code>。加载的类、常量过多，超过方法区内存限制时出现。</p></li><li><p><strong>直接内存溢出</strong>：错误信息<code>java.lang.OutOfMemoryError: Direct buffer memory</code>。使用<code>ByteBuffer.allocateDirect()</code>等分配直接内存时，若未正确管理（如未调用<code>clear</code>），直接内存使用过多导致溢出。</p></li></ul><h3 id="3-解决方法-2">3. 解决方法</h3><ul><li><p><strong>定位问题</strong>：通过<code>top</code>等命令定位到占用内存高的线程，分析其堆存储文件（如使用<code>jmap</code>生成堆转储文件，用<code>jhat</code>或其他工具分析），确定具体导致溢出的对象和代码。</p></li><li><p><strong>检查数据加载</strong>：若因一次从数据库取出过多数据导致内存中对象过多，修改查询方式，采用分页查询等，减少一次性加载的数据量。</p></li><li><p><strong>排查内存泄漏</strong>：检查<code>List</code>、<code>Map</code>等集合对象是否使用后未清除元素，确保不再使用的对象能被垃圾回收。例如，及时清除缓存中过期的数据。</p></li><li><p><strong>调整JVM参数</strong>：若启动参数中内存设定过小（<code>-Xms</code>、<code>-Xmx</code>），适当增加内存。但需注意，增加内存不是万能的，还需结合代码优化，避免无限制消耗内存。</p></li></ul><p>内存泄漏和内存溢出是Java程序中需要重点关注的问题。通过了解其原因、表现和解决方法，能更好地优化程序，提高稳定性和性能。在开发中，要养成良好的编码习惯，及时释放资源，合理管理对象引用，定期监控程序内存使用情况，以便及时发现和解决问题。 </p><h2 id="参考博客：">参考博客：</h2><p><a href="https://xiaolincoding.com/interview/jvm.html#%E5%86%85%E5%AD%98%E6%B3%84%E6%BC%8F%E5%92%8C%E5%86%85%E5%AD%98%E6%BA%A2%E5%87%BA%E7%9A%84%E7%90%86%E8%A7%A3">Java虚拟机面试题</a></p><p><a href="https://www.cnblogs.com/flydean/p/17722512.html">www.cnblogs.com</a></p>]]></content>
    
    
    <summary type="html">🥧并发编程的内存泄漏与内存溢出问题</summary>
    
    
    
    <category term="学习" scheme="https://outoflovenicoo.github.io/categories/%E5%AD%A6%E4%B9%A0/"/>
    
    
    <category term="JUC" scheme="https://outoflovenicoo.github.io/tags/JUC/"/>
    
    <category term="思维导图" scheme="https://outoflovenicoo.github.io/tags/%E6%80%9D%E7%BB%B4%E5%AF%BC%E5%9B%BE/"/>
    
  </entry>
  
  <entry>
    <title>华为416批次笔试</title>
    <link href="https://outoflovenicoo.github.io/posts/2025-04-17-%E5%8D%8E%E4%B8%BA416%E6%89%B9%E6%AC%A1%E7%AC%94%E8%AF%95.html"/>
    <id>https://outoflovenicoo.github.io/posts/2025-04-17-%E5%8D%8E%E4%B8%BA416%E6%89%B9%E6%AC%A1%E7%AC%94%E8%AF%95.html</id>
    <published>2025-04-17T10:19:03.000Z</published>
    <updated>2025-04-17T14:00:00.000Z</updated>
    
    <content type="html"><![CDATA[<h1>2025年4月16日华为笔试复盘</h1><p>​这场笔试做的很糟糕，三道题一道也没a出来，不过幸好最后及格了，我觉得需要复盘一下为什么做的这么糟糕。</p><p>​题目来源网站：CodeFun:<a href="https://codefun2000.com/pset/673c82a4d67fed3f6531c8e1">https://codefun2000.com/pset/673c82a4d67fed3f6531c8e1</a></p><h2 id="第一题">第一题</h2><p><a href="https://codefun2000.com/p/P2845">https://codefun2000.com/p/P2845</a></p><p><img src="2025-04-17-%E5%8D%8E%E4%B8%BA416%E6%89%B9%E6%AC%A1%E7%AC%94%E8%AF%95/image-20250418102041869.png" alt="image-20250418102041869"></p><p><img src="2025-04-17-%E5%8D%8E%E4%B8%BA416%E6%89%B9%E6%AC%A1%E7%AC%94%E8%AF%95/image-20250418102120394.png" alt="image-20250418102120394"></p><p>其实看到这一题，我第一眼就想到用位运算，但是位运算不知道该怎么样去遍历，因为答案可能有多个行叠加。所以我采取了一个比较通用的dfs方法去遍历所有可能(但是没注意到m,n的长度最大为1000，位运算肯定超时)。</p><p>这是当时的做法（回忆版）</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> java.util.*;</span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Main</span> &#123;</span><br><span class="line">    <span class="keyword">static</span> <span class="type">int</span>[][] cases;</span><br><span class="line">    <span class="keyword">static</span> <span class="type">int</span> minCount;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">        <span class="type">Scanner</span> <span class="variable">sc</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Scanner</span>(System.in);</span><br><span class="line">        <span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> sc.nextInt();</span><br><span class="line">        <span class="type">int</span> <span class="variable">j</span> <span class="operator">=</span> sc.nextInt();</span><br><span class="line">        cases = <span class="keyword">new</span> <span class="title class_">int</span>[i][j];</span><br><span class="line">        </span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">x</span> <span class="operator">=</span> <span class="number">0</span>; x &lt; i; x++) &#123;</span><br><span class="line">            <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">y</span> <span class="operator">=</span> <span class="number">0</span>; y &lt; j; y++) &#123;</span><br><span class="line">                cases[x][y] = sc.nextInt();</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">        <span class="type">boolean</span>[] covered = <span class="keyword">new</span> <span class="title class_">boolean</span>[j];</span><br><span class="line">        <span class="type">int</span> <span class="variable">count</span> <span class="operator">=</span> <span class="number">0</span>;  </span><br><span class="line">        dfs(covered,<span class="number">0</span>,<span class="number">0</span>,<span class="number">0</span>);</span><br><span class="line">        System.out.println(allCovered ? count : -<span class="number">1</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">// DFS</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">dfs</span><span class="params">(<span class="type">boolean</span>[] covered, <span class="type">int</span> caseIndex, <span class="type">int</span> selected, <span class="type">int</span> coveredCount)</span> &#123;</span><br><span class="line">        <span class="comment">// 判断当前是否已经覆盖了所有模块</span></span><br><span class="line">        <span class="keyword">if</span> (coveredCount == covered.length) &#123;</span><br><span class="line">            minCount = Math.min(minCount, selected); <span class="comment">// 更新最小测试用例数</span></span><br><span class="line">            <span class="keyword">return</span>;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 如果当前已选择的测试用例数量已经大于或等于最小值，剪枝</span></span><br><span class="line">        <span class="keyword">if</span> (selected &gt;= minCount) &#123;</span><br><span class="line">            <span class="keyword">return</span>;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 递归选择每个测试用例</span></span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> caseIndex; i &lt; cases.length; i++) &#123;</span><br><span class="line">            <span class="type">boolean</span>[] newCov = Arrays.copyOf(covered, covered.length); <span class="comment">// 复制当前已覆盖的模块</span></span><br><span class="line">            <span class="type">int</span> <span class="variable">newCovCount</span> <span class="operator">=</span> coveredCount;</span><br><span class="line"></span><br><span class="line">            <span class="comment">// 更新覆盖状态</span></span><br><span class="line">            <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">j</span> <span class="operator">=</span> <span class="number">0</span>; j &lt; cases[i].length; j++) &#123;</span><br><span class="line">                <span class="keyword">if</span> (cases[i][j] == <span class="number">1</span> &amp;&amp; !newCov[j]) &#123;</span><br><span class="line">                    newCov[j] = <span class="literal">true</span>;</span><br><span class="line">                    newCovCount++;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">            dfs(newCov, i + <span class="number">1</span>, selected + <span class="number">1</span>, newCovCount);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br></pre></td></tr></table></figure><p>不出意外超时了，最后只通过了25%😭，这道题做了半天没a出来，<strong>进而影响了下一道题</strong>。</p><p>再来说一下这道题的正确做法吧，转化成集合去遍历，这里没想到</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> java.util.Scanner;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Main</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">        <span class="type">Scanner</span> <span class="variable">sc</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Scanner</span>(System.in);</span><br><span class="line">        <span class="comment">// 读取测试用例总数 n 和模块总数 m</span></span><br><span class="line">        <span class="type">int</span> <span class="variable">n</span> <span class="operator">=</span> sc.nextInt();</span><br><span class="line">        <span class="type">int</span> <span class="variable">m</span> <span class="operator">=</span> sc.nextInt();</span><br><span class="line">        <span class="type">int</span>[] tests = <span class="keyword">new</span> <span class="title class_">int</span>[n];</span><br><span class="line">        </span><br><span class="line">        <span class="comment">// 将每个测试用例转换为位掩码表示</span></span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i &lt; n; i++) &#123;</span><br><span class="line">            <span class="type">int</span> <span class="variable">mask</span> <span class="operator">=</span> <span class="number">0</span>;</span><br><span class="line">            <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">j</span> <span class="operator">=</span> <span class="number">0</span>; j &lt; m; j++) &#123;</span><br><span class="line">                <span class="type">int</span> <span class="variable">x</span> <span class="operator">=</span> sc.nextInt();</span><br><span class="line">                <span class="keyword">if</span> (x == <span class="number">1</span>) &#123;</span><br><span class="line">                    mask |= (<span class="number">1</span> &lt;&lt; j);</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">            tests[i] = mask;</span><br><span class="line">        &#125;</span><br><span class="line">        </span><br><span class="line">        <span class="comment">// 目标掩码：所有模块都被覆盖（低 m 位全为 1）</span></span><br><span class="line">        <span class="type">int</span> <span class="variable">target</span> <span class="operator">=</span> (<span class="number">1</span> &lt;&lt; m) - <span class="number">1</span>;</span><br><span class="line">        <span class="type">int</span> <span class="variable">ans</span> <span class="operator">=</span> Integer.MAX_VALUE;</span><br><span class="line">        </span><br><span class="line">        <span class="comment">// 枚举所有可能的测试用例子集（采用二进制枚举）</span></span><br><span class="line">      <span class="comment">/*</span></span><br><span class="line"><span class="comment">      暴力枚举，这里没想到</span></span><br><span class="line"><span class="comment">      0 0 0 都不选</span></span><br><span class="line"><span class="comment">      0 0 1 选第一个</span></span><br><span class="line"><span class="comment">      0 1 1 选第一个第二个</span></span><br><span class="line"><span class="comment">      1 1 1 全选</span></span><br><span class="line"><span class="comment">      */</span></span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">s</span> <span class="operator">=</span> <span class="number">0</span>; s &lt; (<span class="number">1</span> &lt;&lt; n); s++) &#123;</span><br><span class="line">            <span class="type">int</span> <span class="variable">unionMask</span> <span class="operator">=</span> <span class="number">0</span>;</span><br><span class="line">            <span class="type">int</span> <span class="variable">cnt</span> <span class="operator">=</span> <span class="number">0</span>;</span><br><span class="line">            <span class="comment">// 遍历子集中的每个测试用例，将其覆盖情况合并</span></span><br><span class="line">            <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i &lt; n; i++) &#123;</span><br><span class="line">              <span class="comment">// 选当前行</span></span><br><span class="line">                <span class="keyword">if</span> ((s &amp; (<span class="number">1</span> &lt;&lt; i)) != <span class="number">0</span>) &#123;</span><br><span class="line">                    unionMask |= tests[i];</span><br><span class="line">                    cnt++;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="comment">// 如果当前子集能够覆盖所有模块，则更新答案</span></span><br><span class="line">            <span class="keyword">if</span> (unionMask == target) &#123;</span><br><span class="line">                ans = Math.min(ans, cnt);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        </span><br><span class="line">        <span class="comment">// 如果没有满足要求的子集，输出 -1；否则输出最小用例数</span></span><br><span class="line">        System.out.println(ans == Integer.MAX_VALUE ? -<span class="number">1</span> : ans);</span><br><span class="line">        sc.close();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br></pre></td></tr></table></figure><h2 id="第二题">第二题</h2><p><a href="https://codefun2000.com/p/P2846">https://codefun2000.com/p/P2846</a></p><p><img src="2025-04-17-%E5%8D%8E%E4%B8%BA416%E6%89%B9%E6%AC%A1%E7%AC%94%E8%AF%95/image-20250418105640610.png" alt="image-20250418105640610"></p><p><img src="2025-04-17-%E5%8D%8E%E4%B8%BA416%E6%89%B9%E6%AC%A1%E7%AC%94%E8%AF%95/image-20250418105657826.png" alt="image-20250418105657826"></p><p>因为第一题没a出来，导致做这题的思路都很乱。一开始想用一个TreeSet去存储图的信息，发现这样做不对。</p><p>然后想着用一个HashMap去存领接表，但是感觉图的构建很麻烦，这是一个双向图，整个思路都是乱的，想先写BFS的代码，写到一半意思到时间可能快不够了，继续做这题做不出来这次笔试就过不了，没办法，只能舍弃了，直接输出“NA”骗了7%的分，惭愧😭。</p><p>后面做完第三题再来看第二题，发现DFS应该也能做，但是没时间了。。。主要是这题图的构建要复杂一点。</p><p><strong>正确做法：</strong></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br><span class="line">132</span><br><span class="line">133</span><br><span class="line">134</span><br><span class="line">135</span><br><span class="line">136</span><br><span class="line">137</span><br><span class="line">138</span><br><span class="line">139</span><br><span class="line">140</span><br><span class="line">141</span><br><span class="line">142</span><br><span class="line">143</span><br><span class="line">144</span><br><span class="line">145</span><br><span class="line">146</span><br><span class="line">147</span><br><span class="line">148</span><br><span class="line">149</span><br><span class="line">150</span><br><span class="line">151</span><br><span class="line">152</span><br><span class="line">153</span><br><span class="line">154</span><br><span class="line">155</span><br><span class="line">156</span><br><span class="line">157</span><br><span class="line">158</span><br><span class="line">159</span><br><span class="line">160</span><br><span class="line">161</span><br><span class="line">162</span><br><span class="line">163</span><br><span class="line">164</span><br><span class="line">165</span><br><span class="line">166</span><br><span class="line">167</span><br><span class="line">168</span><br><span class="line">169</span><br><span class="line">170</span><br><span class="line">171</span><br><span class="line">172</span><br><span class="line">173</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> java.util.*;</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">RouteFinder</span> &#123;</span><br><span class="line">    <span class="comment">// 线路数量</span></span><br><span class="line">    <span class="keyword">static</span> <span class="type">int</span> N;</span><br><span class="line">    <span class="comment">// 起点站</span></span><br><span class="line">    <span class="keyword">static</span> String start;</span><br><span class="line">    <span class="comment">// 终点站</span></span><br><span class="line">    <span class="keyword">static</span> String target;</span><br><span class="line">    <span class="comment">// 存储线路之间的换乘信息，键为线路编号，值为该线路可换乘的线路及换乘站信息</span></span><br><span class="line">    <span class="keyword">static</span> Map&lt;Integer, List&lt;Route&gt;&gt; mp = <span class="keyword">new</span> <span class="title class_">HashMap</span>&lt;&gt;();</span><br><span class="line">    <span class="comment">// 存储每个站点所在的线路，键为站点名称，值为包含该站点的线路编号列表</span></span><br><span class="line">    <span class="keyword">static</span> Map&lt;String, List&lt;Integer&gt;&gt; mp1 = <span class="keyword">new</span> <span class="title class_">HashMap</span>&lt;&gt;();</span><br><span class="line">    <span class="comment">// 记录换乘次数，初始化为 -1</span></span><br><span class="line">    <span class="keyword">static</span> <span class="type">int</span> <span class="variable">cnt</span> <span class="operator">=</span> -<span class="number">1</span>;</span><br><span class="line">    <span class="comment">// 标记是否找到可达路线</span></span><br><span class="line">    <span class="keyword">static</span> <span class="type">boolean</span> <span class="variable">flag</span> <span class="operator">=</span> <span class="literal">false</span>;</span><br><span class="line">    <span class="comment">// 记录到达终点站所在的线路编号</span></span><br><span class="line">    <span class="keyword">static</span> <span class="type">int</span> targ;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 内部类，用于存储线路和换乘站信息</span></span><br><span class="line">    <span class="keyword">static</span> <span class="keyword">class</span> <span class="title class_">Route</span> &#123;</span><br><span class="line">        <span class="comment">// 可换乘的线路编号</span></span><br><span class="line">        <span class="type">int</span> line;</span><br><span class="line">        <span class="comment">// 换乘站名称</span></span><br><span class="line">        String station;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 构造函数，初始化线路和换乘站信息</span></span><br><span class="line">        Route(<span class="type">int</span> line, String station) &#123;</span><br><span class="line">            <span class="built_in">this</span>.line = line;</span><br><span class="line">            <span class="built_in">this</span>.station = station;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 广度优先搜索函数，用于查找从起点站到终点站的最短换乘路线</span></span><br><span class="line">    <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">bfs</span><span class="params">(<span class="type">int</span>[] visited, Set&lt;Integer&gt; tar, <span class="type">int</span>[] father)</span> &#123;</span><br><span class="line">        <span class="comment">// 创建一个队列，用于存储待访问的线路编号</span></span><br><span class="line">        Queue&lt;Integer&gt; qu = <span class="keyword">new</span> <span class="title class_">LinkedList</span>&lt;&gt;();</span><br><span class="line">        <span class="comment">// 将起点站所在的所有线路编号加入队列，并标记为已访问</span></span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> x : mp1.get(start)) &#123;</span><br><span class="line">            qu.add(x);</span><br><span class="line">            visited[x] = <span class="number">1</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">// 当队列不为空且未找到可达路线时，继续搜索</span></span><br><span class="line">        <span class="keyword">while</span> (!qu.isEmpty() &amp;&amp; !flag) &#123;</span><br><span class="line">            <span class="comment">// 换乘次数加 1</span></span><br><span class="line">            cnt++;</span><br><span class="line">            <span class="comment">// 获取当前队列的大小，即当前层的线路数量</span></span><br><span class="line">            <span class="type">int</span> <span class="variable">size</span> <span class="operator">=</span> qu.size();</span><br><span class="line">            <span class="comment">// 遍历当前层的所有线路</span></span><br><span class="line">            <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i &lt; size; i++) &#123;</span><br><span class="line">                <span class="comment">// 取出队列头部的线路编号</span></span><br><span class="line">                <span class="type">int</span> <span class="variable">tmp</span> <span class="operator">=</span> qu.poll();</span><br><span class="line">                <span class="comment">// 如果该线路是终点站所在的线路，标记找到可达路线，记录线路编号并跳出循环</span></span><br><span class="line">                <span class="keyword">if</span> (tar.contains(tmp)) &#123;</span><br><span class="line">                    targ = tmp;</span><br><span class="line">                    flag = <span class="literal">true</span>;</span><br><span class="line">                    <span class="keyword">break</span>;</span><br><span class="line">                &#125;</span><br><span class="line">                <span class="comment">// 遍历该线路可换乘的所有线路</span></span><br><span class="line">                <span class="keyword">for</span> (Route next : mp.getOrDefault(tmp, <span class="keyword">new</span> <span class="title class_">ArrayList</span>&lt;&gt;())) &#123;</span><br><span class="line">                    <span class="comment">// 如果该线路已被访问过，跳过</span></span><br><span class="line">                    <span class="keyword">if</span> (visited[next.line] == <span class="number">1</span>) <span class="keyword">continue</span>;</span><br><span class="line">                    <span class="comment">// 标记该线路为已访问</span></span><br><span class="line">                    visited[next.line] = <span class="number">1</span>;</span><br><span class="line">                    <span class="comment">// 将该线路加入队列</span></span><br><span class="line">                    qu.add(next.line);</span><br><span class="line">                    <span class="comment">// 记录该线路的父线路编号</span></span><br><span class="line">                    father[next.line] = tmp;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">        <span class="comment">// 创建 Scanner 对象，用于读取用户输入</span></span><br><span class="line">        <span class="type">Scanner</span> <span class="variable">scanner</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Scanner</span>(System.in);</span><br><span class="line">        <span class="comment">// 读取线路数量</span></span><br><span class="line">        N = scanner.nextInt();</span><br><span class="line">        <span class="comment">// 消耗掉换行符</span></span><br><span class="line">        scanner.nextLine();</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 二维数组，用于存储线路之间的换乘站信息</span></span><br><span class="line">        String[][] graph = <span class="keyword">new</span> <span class="title class_">String</span>[N][N];</span><br><span class="line">        <span class="comment">// 初始化二维数组，将所有元素设置为 &quot;*&quot;</span></span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i &lt; N; i++) &#123;</span><br><span class="line">            Arrays.fill(graph[i], <span class="string">&quot;*&quot;</span>);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 遍历每条线路</span></span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i &lt; N; i++) &#123;</span><br><span class="line">            <span class="comment">// 读取该线路上的所有站点信息</span></span><br><span class="line">            <span class="type">String</span> <span class="variable">s</span> <span class="operator">=</span> scanner.nextLine();</span><br><span class="line">            <span class="comment">// 将站点信息按空格分割成数组</span></span><br><span class="line">            String[] stations = s.split(<span class="string">&quot; &quot;</span>);</span><br><span class="line">            <span class="comment">// 遍历该线路上的每个站点</span></span><br><span class="line">            <span class="keyword">for</span> (String tmp : stations) &#123;</span><br><span class="line">                <span class="comment">// 如果该站点已经存在于 mp1 中，说明该站点是换乘站</span></span><br><span class="line">                <span class="keyword">if</span> (mp1.containsKey(tmp)) &#123;</span><br><span class="line">                    <span class="comment">// 获取该站点所在的所有线路编号列表</span></span><br><span class="line">                    List&lt;Integer&gt; a = mp1.get(tmp);</span><br><span class="line">                    <span class="comment">// 遍历该站点所在的所有线路</span></span><br><span class="line">                    <span class="keyword">for</span> (<span class="type">int</span> j : a) &#123;</span><br><span class="line">                        <span class="comment">// 更新 mp 中线路之间的换乘信息</span></span><br><span class="line">                        mp.computeIfAbsent(i, k -&gt; <span class="keyword">new</span> <span class="title class_">ArrayList</span>&lt;&gt;()).add(<span class="keyword">new</span> <span class="title class_">Route</span>(j, tmp));</span><br><span class="line">                        <span class="comment">// 更新 graph 中线路之间的换乘站信息</span></span><br><span class="line">                        graph[i][j] = tmp;</span><br><span class="line">                        <span class="comment">// 由于是双向图，更新反向的换乘信息</span></span><br><span class="line">                        mp.computeIfAbsent(j, k -&gt; <span class="keyword">new</span> <span class="title class_">ArrayList</span>&lt;&gt;()).add(<span class="keyword">new</span> <span class="title class_">Route</span>(i, tmp));</span><br><span class="line">                        graph[j][i] = tmp;</span><br><span class="line">                    &#125;</span><br><span class="line">                    <span class="comment">// 将当前线路编号加入该站点所在的线路编号列表</span></span><br><span class="line">                    mp1.get(tmp).add(i);</span><br><span class="line">                &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                    <span class="comment">// 如果该站点是第一次出现，创建一个新的线路编号列表，并将当前线路编号加入其中</span></span><br><span class="line">                    List&lt;Integer&gt; list = <span class="keyword">new</span> <span class="title class_">ArrayList</span>&lt;&gt;();</span><br><span class="line">                    list.add(i);</span><br><span class="line">                    <span class="comment">// 将该站点及其所在的线路编号列表存入 mp1 中</span></span><br><span class="line">                    mp1.put(tmp, list);</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 读取起点站和终点站名称</span></span><br><span class="line">        start = scanner.next();</span><br><span class="line">        target = scanner.next();</span><br><span class="line">        <span class="comment">// 用于标记线路是否已被访问过的数组</span></span><br><span class="line">        <span class="type">int</span>[] visited = <span class="keyword">new</span> <span class="title class_">int</span>[N];</span><br><span class="line">        <span class="comment">// 用于记录每个线路的父线路编号的数组，初始化为 -1</span></span><br><span class="line">        <span class="type">int</span>[] father = <span class="keyword">new</span> <span class="title class_">int</span>[N];</span><br><span class="line">        Arrays.fill(father, -<span class="number">1</span>);</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 如果起点站或终点站不在任何线路上，输出 &quot;NA&quot;</span></span><br><span class="line">        <span class="keyword">if</span> (!mp1.containsKey(start) || !mp1.containsKey(target)) &#123;</span><br><span class="line">            System.out.println(<span class="string">&quot;NA&quot;</span>);</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            <span class="comment">// 创建一个集合，存储终点站所在的所有线路编号</span></span><br><span class="line">            Set&lt;Integer&gt; tar = <span class="keyword">new</span> <span class="title class_">HashSet</span>&lt;&gt;(mp1.get(target));</span><br><span class="line">            <span class="comment">// 调用广度优先搜索函数进行搜索</span></span><br><span class="line">            bfs(visited, tar, father);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 如果未找到可达路线，输出 &quot;NA&quot;</span></span><br><span class="line">        <span class="keyword">if</span> (!flag) &#123;</span><br><span class="line">            System.out.println(<span class="string">&quot;NA&quot;</span>);</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            <span class="comment">// 用于存储最终的路线信息</span></span><br><span class="line">            List&lt;String&gt; result = <span class="keyword">new</span> <span class="title class_">ArrayList</span>&lt;&gt;();</span><br><span class="line">            <span class="comment">// 从终点站所在的线路开始回溯</span></span><br><span class="line">            <span class="type">int</span> <span class="variable">u</span> <span class="operator">=</span> targ;</span><br><span class="line">            <span class="comment">// 将终点站加入结果列表</span></span><br><span class="line">            result.add(target);</span><br><span class="line">            <span class="comment">// 回溯路线，直到找到起点站所在的线路</span></span><br><span class="line">            <span class="keyword">while</span> (father[u] != -<span class="number">1</span>) &#123;</span><br><span class="line">                <span class="comment">// 将换乘站加入结果列表</span></span><br><span class="line">                result.add(graph[father[u]][u]);</span><br><span class="line">                <span class="comment">// 更新当前线路为父线路</span></span><br><span class="line">                u = father[u];</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="comment">// 将起点站加入结果列表</span></span><br><span class="line">            result.add(start);</span><br><span class="line">            <span class="comment">// 获取结果列表的大小</span></span><br><span class="line">            <span class="type">int</span> <span class="variable">n</span> <span class="operator">=</span> result.size();</span><br><span class="line">            <span class="comment">// 输出路线信息，用 &quot;-&quot; 连接各个站点</span></span><br><span class="line">            <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> n - <span class="number">1</span>; i &gt; <span class="number">0</span>; i--) &#123;</span><br><span class="line">                System.out.print(result.get(i) + <span class="string">&quot;-&quot;</span>);</span><br><span class="line">            &#125;</span><br><span class="line">            System.out.println(result.get(<span class="number">0</span>));</span><br><span class="line">            <span class="comment">// 输出总换乘次数（包括起点站和终点站）</span></span><br><span class="line">            System.out.println(<span class="number">2</span> + cnt);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;    </span><br></pre></td></tr></table></figure><h2 id="第三题">第三题</h2><p><img src="2025-04-17-%E5%8D%8E%E4%B8%BA416%E6%89%B9%E6%AC%A1%E7%AC%94%E8%AF%95/image-20250418110705215.png" alt="image-20250418110705215"></p><p><img src="2025-04-17-%E5%8D%8E%E4%B8%BA416%E6%89%B9%E6%AC%A1%E7%AC%94%E8%AF%95/image-20250418110727624.png" alt="image-20250418110727624"></p><p>这道题感觉比前面两题简单多了，有点像LeetCode和合并区间那道题，但是这里排序不能按照字典序进行排，索引比较朴素的思想是将ip地址转化成一个数进行排序。</p><p>我的做法：很奇怪，感觉没啥问题就只a了0.55</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> codefun.com.HuaWei;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> java.util.ArrayList;</span><br><span class="line"><span class="keyword">import</span> java.util.List;</span><br><span class="line"><span class="keyword">import</span> java.util.*;</span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">P2847</span> &#123;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 辅助方法：将IPv4地址转化为整数</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="type">long</span> <span class="title function_">ipToInt</span><span class="params">(String ip)</span> &#123;</span><br><span class="line">        String[] parts = ip.split(<span class="string">&quot;\\.&quot;</span>);</span><br><span class="line">        <span class="type">long</span> <span class="variable">result</span> <span class="operator">=</span> <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i &lt; <span class="number">4</span>; i++) &#123;</span><br><span class="line">            result += Integer.parseInt(parts[i]) * Math.pow(<span class="number">256</span>, <span class="number">3</span> - i);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> result;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> String <span class="title function_">intToIp</span><span class="params">(<span class="type">long</span> ipInt)</span> &#123;</span><br><span class="line">        <span class="type">int</span> <span class="variable">part1</span> <span class="operator">=</span> (<span class="type">int</span>) (ipInt / (<span class="type">int</span>)Math.pow(<span class="number">256</span>,<span class="number">3</span>));</span><br><span class="line">        <span class="type">int</span> <span class="variable">part2</span> <span class="operator">=</span> (<span class="type">int</span>)(ipInt / (<span class="type">int</span>)Math.pow(<span class="number">256</span>,<span class="number">2</span>)) % <span class="number">256</span>;</span><br><span class="line">        <span class="type">int</span> <span class="variable">part3</span> <span class="operator">=</span> (<span class="type">int</span>) ((ipInt / <span class="number">256</span>) % <span class="number">256</span>);</span><br><span class="line">        <span class="type">int</span> <span class="variable">part4</span> <span class="operator">=</span> (<span class="type">int</span>) (ipInt % <span class="number">256</span>);</span><br><span class="line">        <span class="keyword">return</span> part1 + <span class="string">&quot;.&quot;</span> + part2 + <span class="string">&quot;.&quot;</span> + part3 + <span class="string">&quot;.&quot;</span> + part4;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">        <span class="type">Scanner</span> <span class="variable">scanner</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Scanner</span>(System.in);</span><br><span class="line">        <span class="type">int</span> <span class="variable">N</span> <span class="operator">=</span> Integer.parseInt(scanner.nextLine());</span><br><span class="line">        List&lt;<span class="type">long</span>[]&gt; ipRanges = <span class="keyword">new</span> <span class="title class_">ArrayList</span>&lt;&gt;();</span><br><span class="line">        </span><br><span class="line">        <span class="comment">// 读取IP区间</span></span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i &lt; N; i++) &#123;</span><br><span class="line">            <span class="type">String</span> <span class="variable">line</span> <span class="operator">=</span> scanner.nextLine();</span><br><span class="line">            String[] parts = line.split(<span class="string">&quot; &quot;</span>);</span><br><span class="line">            <span class="type">long</span> <span class="variable">startIp</span> <span class="operator">=</span> ipToInt(parts[<span class="number">0</span>]);</span><br><span class="line">            <span class="type">long</span> <span class="variable">endIp</span> <span class="operator">=</span> ipToInt(parts[<span class="number">1</span>]);</span><br><span class="line">            ipRanges.add(<span class="keyword">new</span> <span class="title class_">long</span>[]&#123;startIp, endIp&#125;);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 按照业务需求进行排序</span></span><br><span class="line">        <span class="comment">// 排序规则: 先按IP占用数量 (endIp - startIp + 1)，再按起始IP排序</span></span><br><span class="line">        ipRanges.sort((a, b) -&gt; &#123;</span><br><span class="line">            <span class="type">long</span> <span class="variable">lenA</span> <span class="operator">=</span> a[<span class="number">1</span>] - a[<span class="number">0</span>] + <span class="number">1</span>;</span><br><span class="line">            <span class="type">long</span> <span class="variable">lenB</span> <span class="operator">=</span> b[<span class="number">1</span>] - b[<span class="number">0</span>] + <span class="number">1</span>;</span><br><span class="line">            <span class="keyword">if</span> (lenA == lenB) &#123;</span><br><span class="line">                <span class="keyword">return</span> Long.compare(a[<span class="number">0</span>], b[<span class="number">0</span>]);</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">return</span> Long.compare(lenA, lenB);</span><br><span class="line">        &#125;);</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 贪心算法，选择不重叠的区间</span></span><br><span class="line">        List&lt;<span class="type">long</span>[]&gt; result = <span class="keyword">new</span> <span class="title class_">ArrayList</span>&lt;&gt;();</span><br><span class="line">        <span class="type">long</span> <span class="variable">lastEnd</span> <span class="operator">=</span> -<span class="number">1</span>;</span><br><span class="line">        </span><br><span class="line">        <span class="keyword">for</span> (<span class="type">long</span>[] range : ipRanges) &#123;</span><br><span class="line">            <span class="keyword">if</span> (range[<span class="number">0</span>] &gt; lastEnd) &#123;</span><br><span class="line">                result.add(range);</span><br><span class="line">                lastEnd = range[<span class="number">1</span>];</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        </span><br><span class="line">        <span class="keyword">for</span> (<span class="type">long</span>[] range : result) &#123;</span><br><span class="line">            System.out.println(intToIp(range[<span class="number">0</span>]) + <span class="string">&quot; &quot;</span> + intToIp(range[<span class="number">1</span>]));</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure><p><strong>正确解法：</strong></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> codefun.com.HuaWei;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> java.util.*;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">P2847</span> &#123;</span><br><span class="line">    <span class="comment">// 将IPv4地址转化为整数，使用位运算保证精确性</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="type">long</span> <span class="title function_">ipToInt</span><span class="params">(String ip)</span> &#123;</span><br><span class="line">        String[] parts = ip.split(<span class="string">&quot;\\.&quot;</span>);</span><br><span class="line">        <span class="type">long</span> <span class="variable">result</span> <span class="operator">=</span> <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i &lt; <span class="number">4</span>; i++) &#123;</span><br><span class="line">            result |= (Long.parseLong(parts[i]) &lt;&lt; (<span class="number">24</span> - <span class="number">8</span> * i));</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> result;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 将整数转换回IPv4地址</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> String <span class="title function_">intToIp</span><span class="params">(<span class="type">long</span> ipInt)</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> ((ipInt &gt;&gt; <span class="number">24</span>) &amp; <span class="number">0xFF</span>) + <span class="string">&quot;.&quot;</span> +</span><br><span class="line">                ((ipInt &gt;&gt; <span class="number">16</span>) &amp; <span class="number">0xFF</span>) + <span class="string">&quot;.&quot;</span> +</span><br><span class="line">                ((ipInt &gt;&gt; <span class="number">8</span>) &amp; <span class="number">0xFF</span>) + <span class="string">&quot;.&quot;</span> +</span><br><span class="line">                (ipInt &amp; <span class="number">0xFF</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">        <span class="type">Scanner</span> <span class="variable">scanner</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Scanner</span>(System.in);</span><br><span class="line">        <span class="type">int</span> <span class="variable">N</span> <span class="operator">=</span> Integer.parseInt(scanner.nextLine().trim());  <span class="comment">// 读取业务数量</span></span><br><span class="line">        List&lt;<span class="type">long</span>[]&gt; ipRanges = <span class="keyword">new</span> <span class="title class_">ArrayList</span>&lt;&gt;();</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 读取每个业务的起始和结束IP，将其转为整数存储</span></span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i &lt; N; i++) &#123;</span><br><span class="line">            String[] parts = scanner.nextLine().split(<span class="string">&quot; &quot;</span>);</span><br><span class="line">            <span class="type">long</span> <span class="variable">start</span> <span class="operator">=</span> ipToInt(parts[<span class="number">0</span>]);</span><br><span class="line">            <span class="type">long</span> <span class="variable">end</span> <span class="operator">=</span> ipToInt(parts[<span class="number">1</span>]);</span><br><span class="line">            ipRanges.add(<span class="keyword">new</span> <span class="title class_">long</span>[]&#123;start, end&#125;);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 排序规则：</span></span><br><span class="line">        <span class="comment">// 1) 按结束IP升序</span></span><br><span class="line">        <span class="comment">// 2) 若结束IP相同，按区间长度(端点差+1)升序</span></span><br><span class="line">        <span class="comment">// 3) 若长度相同，按起始IP升序</span></span><br><span class="line">        ipRanges.sort((a, b) -&gt; &#123;</span><br><span class="line">            <span class="keyword">if</span> (a[<span class="number">1</span>] != b[<span class="number">1</span>]) &#123;</span><br><span class="line">                <span class="keyword">return</span> Long.compare(a[<span class="number">1</span>], b[<span class="number">1</span>]);</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="type">long</span> <span class="variable">lenA</span> <span class="operator">=</span> a[<span class="number">1</span>] - a[<span class="number">0</span>] + <span class="number">1</span>;</span><br><span class="line">            <span class="type">long</span> <span class="variable">lenB</span> <span class="operator">=</span> b[<span class="number">1</span>] - b[<span class="number">0</span>] + <span class="number">1</span>;</span><br><span class="line">            <span class="keyword">if</span> (lenA != lenB) &#123;</span><br><span class="line">                <span class="keyword">return</span> Long.compare(lenA, lenB);</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">return</span> Long.compare(a[<span class="number">0</span>], b[<span class="number">0</span>]);</span><br><span class="line">        &#125;);</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 贪心选择：选择不重叠、最早结束的区间以最大化业务数量</span></span><br><span class="line">        List&lt;<span class="type">long</span>[]&gt; result = <span class="keyword">new</span> <span class="title class_">ArrayList</span>&lt;&gt;();</span><br><span class="line">        <span class="type">long</span> <span class="variable">lastEnd</span> <span class="operator">=</span> -<span class="number">1</span>;</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">long</span>[] range : ipRanges) &#123;</span><br><span class="line">            <span class="keyword">if</span> (range[<span class="number">0</span>] &gt; lastEnd) &#123;</span><br><span class="line">                result.add(range);</span><br><span class="line">                lastEnd = range[<span class="number">1</span>];</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 输出最终规划的IP区间</span></span><br><span class="line">        <span class="keyword">for</span> (<span class="type">long</span>[] r : result) &#123;</span><br><span class="line">            System.out.println(intToIp(r[<span class="number">0</span>]) + <span class="string">&quot; &quot;</span> + intToIp(r[<span class="number">1</span>]));</span><br><span class="line">        &#125;</span><br><span class="line">        scanner.close();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure><p>主要改动了以下几处：</p><ol><li><p><strong>IP 转换方法优化</strong></p><ul><li><p>原来在 <code>ipToInt</code> 和 <code>intToIp</code> 中使用了 <code>Math.pow</code>，返回 <code>double</code> 再转 <code>long</code>，存在精度隐患。</p></li><li><p>要改成了位移运算：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">result |= (Long.parseLong(parts[i]) &lt;&lt; (<span class="number">24</span> - <span class="number">8</span> * i));</span><br></pre></td></tr></table></figure><p>和</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">((ipInt &gt;&gt; <span class="number">24</span>) &amp; <span class="number">0xFF</span>)</span><br></pre></td></tr></table></figure><p>这样既更高效，也完全精确。</p></li></ul></li><li><p><strong>排序规则</strong></p><ul><li>原先只按“区间长度（len）”和“起始 IP”排序，忽略了“结束 IP”对贪心选择的影响。</li><li>新版改为三层优先级：</li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 1) 按结束 IP 升序  </span></span><br><span class="line"><span class="comment">// 2) 若结束 IP 相同，再按区间长度升序  </span></span><br><span class="line"><span class="comment">// 3) 若长度相同，再按起始 IP 升序</span></span><br></pre></td></tr></table></figure><p>这样能保证贪心算法每次都选最早结束、最小占用的区间，以满足“最多业务数”、“最少地址量”和“起始最小”三重要求。</p></li></ol><p>这些改动确保了：</p><ul><li>IP 转换无精度误差</li><li>排序严格符合题意的三重比较</li><li>贪心算法能真正输出示例中预期的两个区间。</li></ul><p>反思：没有考虑数据精度对结果的影响。只是运气好过了0.55</p><h2 id="总结：">总结：</h2><p>这次算法做的不太好，主要有以下这个原因：</p><ul><li>​1.不敢用IDE写，用记事本导致写的优点磕磕绊绊</li><li>​2.第一题没做出来影响了心态，然后做第二题脑袋一团浆糊。</li><li>​3.做这场笔试之前，刷了很多次华为笔试真题。自己平时做感觉没问题，在考场上做却错漏百出，只能说平时和考场还是不一样。</li><li>​4.太想进华为，导致做笔试压力很大。心情不平和影响了自己的思路。</li></ul><p>总而言之，继续多刷算法，继续加油！</p>]]></content>
    
    
    <summary type="html">🥧华为416批次笔试</summary>
    
    
    
    <category term="算法" scheme="https://outoflovenicoo.github.io/categories/%E7%AE%97%E6%B3%95/"/>
    
    
    <category term="算法" scheme="https://outoflovenicoo.github.io/tags/%E7%AE%97%E6%B3%95/"/>
    
  </entry>
  
  <entry>
    <title>Java集合学习</title>
    <link href="https://outoflovenicoo.github.io/posts/2025-04-17-Java%E9%9B%86%E5%90%88%E5%AD%A6%E4%B9%A0.html"/>
    <id>https://outoflovenicoo.github.io/posts/2025-04-17-Java%E9%9B%86%E5%90%88%E5%AD%A6%E4%B9%A0.html</id>
    <published>2025-04-17T10:19:03.000Z</published>
    <updated>2025-04-17T14:00:00.000Z</updated>
    
    <content type="html"><![CDATA[<h1>Java集合学习</h1><h2 id="个人总结思维导图：">个人总结思维导图：</h2><p><img src="2025-04-17-Java%E9%9B%86%E5%90%88%E5%AD%A6%E4%B9%A0/image-20250419111601404.png" alt="image-20250419111601404"></p><p>​在腾讯面试的过程中，被问到了一些基础问题，Java的集合框架。当时回答的有点不太好，很多概念都有点模糊，根本原因是没有自己总结过，所以现在特地总结一下，当然这个总结可能还不完善，后续会不断迭代优化。</p><h2 id="单列集合部分">单列集合部分</h2><h3 id="ArrayList">ArrayList</h3><p>​ArrayList是<code>List</code>接口的一个实现类。它的默认初始容量为0，当首次添加元素时，其容量会扩充到10。这种动态扩容的机制使得ArrayList在存储元素时具有一定的灵活性，适合元素数量不确定的场景。</p><h3 id="HashSet">HashSet</h3><p>​HashSet是<code>Set</code>接口的实现类，其实现原理基于哈希值。当向HashSet中加入对象时，会先计算对象的<code>hashcode</code>值来判断对象加入的位置，同时也会与其他已加入对象的<code>hashcode</code>值作比较。如果没有相同的<code>hashcode</code>值，HashSet会假设对象没有重复出现；但如果发现有相同<code>hashcode</code>值的对象，这时会调用<code>equals()</code>方法来检查对象是否真的相同，若两者相同，HashSet就不会让加入操作成功，以此保证集合中元素的唯一性。</p><h3 id="Queue与Deque">Queue与Deque</h3><p>​<code>Queue</code>（队列）接口有多种实现，比如<code>PriorityQueue</code>（优先队列）和<code>BlockingQueue</code>（阻塞队列，其下又细分<code>ArrayBlockingQueue</code>、<code>LinkedBlockingQueue</code>等）。<code>Deque</code>（双端队列）接口也有对应的实现类，如<code>ArrayDeque</code>（每次扩容为原来的2倍+1）和<code>LinkedList</code>，这些实现类为不同的队列操作需求提供了支持。</p><h3 id="Stack">Stack</h3><p><code>Stack</code>（栈）不推荐使用，主要有两个原因。一是其线程安全机制低效且冗余，在多线程环境下性能不佳；二是它有着不合理的继承关系，<code>Stack</code>继承自<code>Vector</code>，而<code>Vector</code>本质上是一个基于数组的动态数组，是“可增长的对象数组”，并非专门为栈（LIFO，后进先出）设计的数据结构，这种设计上的不合理导致<code>Stack</code>在实际应用中存在诸多问题。</p><h2 id="双列集合部分">双列集合部分</h2><h3 id="HashMap详解">HashMap详解</h3><h4 id="实现原理">实现原理</h4><p>​HashMap的工作原理基于哈希表。它通过计算键的哈希值，并将其转化为数组索引，从而快速定位键值对的存储位置。在理想情况下，哈希函数能将键均匀分布到哈希表中，以最小化哈希冲突。在Java 1.7中，HashMap主要使用链表来解决哈希冲突，将具有相同哈希值的键值对链接在一起；但在Java 1.8中，为了进一步提高性能，当链表长度和数组长度超过一定阈值时，链表会转换为红黑树。红黑树作为一种自平衡的二叉搜索树，能够在哈希冲突较多时提供更快的查找、插入和删除操作功能。这样，HashMap结合哈希表、链表和红黑树的原理，实现了高效的键值对存储和查找功能。</p><h4 id="扩容机制">扩容机制</h4><p>​HashMap的扩容触发条件有两个：一是元素个数大于负载因子乘以桶大小；二是桶内元素个数大于8且桶的个数小于64时也会触发扩容。扩容时，会重新计算元素的位置，计算方式为<code>(n-1) &amp; hash</code>（<code>n</code>为新的容量），新的位置要么是原来的位置，要么是原来的位置加上旧容量。</p><p>​需要注意的是，HashMap扩容时，不会对元素对象本身进行复制，而是将元素对象的引用迁移到新的哈希表中，然后根据新的容量重新计算元素在新哈希表中的位置。</p><h3 id="ConcurrentHashMap在JDK8中的实现">ConcurrentHashMap在JDK8中的实现</h3><h4 id="put方法安全机制">put方法安全机制</h4><p>​在JDK8中，ConcurrentHashMap采用了分段锁，同时使用CAS（Compare and Swap，比较并交换）和<code>synchronized</code>来保证线程安全。其<code>put</code>方法的安全保证步骤如下：首先计算哈希值；接着判断数组是否初始化；然后根据哈希值定位到对应的桶位置；再判断桶是否为空，若为空则使用CAS操作尝试将新节点插入到该位置，若CAS操作成功，插入完成，若失败，说明有其他线程已经插入了节点，继续后续步骤；之后检查桶头节点的哈希值是否为<code>MOVED</code>（表示该桶正在进行扩容迁移），若是则协助进行扩容；最后加锁插入或更新，对桶的头节点使用<code>synchronized</code>关键字加锁，然后遍历链表或红黑树，若找到相同的键，更新其值，若未找到，将新节点插入到链表尾部（链表长度小于8）或插入到红黑树中（链表长度大于等于8且数组长度大于等于64），若插入后链表长度达到8且数组长度小于64，进行数组扩容；若数组长度大于等于64，将链表转换为红黑树。</p><h4 id="扩容机制-2">扩容机制</h4><p>​ConcurrentHashMap的扩容机制较为复杂。初始化迁移任务时，当一个线程发现需要扩容时，会先创建一个新的数组，其容量是原数组的两倍，同时，会将<code>sizeCtl</code>设置为一个负数，表示正在进行扩容操作，并记录参与扩容的线程数。多线程协助迁移时，ConcurrentHashMap支持多线程协助进行扩容操作，每个线程会领取一个或多个桶的迁移任务，将原数组中对应桶的节点迁移到新数组中，在迁移过程中，使用<code>ForwardingNode</code>节点标记原数组中已经迁移完成的桶，其他线程在访问这些桶时，会自动跳转到新数组中继续操作。链表迁移时，对于链表节点，会根据节点的哈希值重新计算在新数组中的位置，将链表拆分成两个链表，分别放入新数组的不同位置。红黑树迁移时，对于红黑树节点，同样会根据哈希值重新计算位置，可能会将红黑树拆分成两个链表或红黑树，再放入新数组中。当所有的迁移任务都完成后，将新数组替换原数组，扩容操作结束，同时，将<code>sizeCtl</code>更新为新的阈值。</p><h3 id="HashMap与HashTable的区别">HashMap与HashTable的区别</h3><h4 id="线程安全">线程安全</h4><p>​HashTable是线程安全的，它的<code>put</code>、<code>get</code>等方法都使用<code>synchronized</code>关键字进行同步控制；而HashMap是非线程安全的，在多线程环境下如果不进行额外的同步控制，可能会出现数据不一致等问题。</p><h4 id="对null键值的支持">对null键值的支持</h4><p>​HashMap允许键和值为<code>null</code>，但是只能有一个<code>null</code>键，值可以有多个<code>null</code>；而HashTable不允许键或值为<code>null</code>，若尝试将<code>null</code>键或值放入HashTable中，会抛出<code>NullPointerException</code>。</p><h4 id="初始容量与扩容">初始容量与扩容</h4><p>​HashMap的初始容量为16（默认情况下），负载因子为0.75；HashTable的初始容量为11，负载因子同样为0.75。在扩容方面，HashMap扩容时新容量是原容量的2倍；HashTable扩容时新容量是原容量的2倍+1。</p><h4 id="哈希值计算">哈希值计算</h4><p>​HashMap在计算哈希值时，对哈希值进行了高位运算，以优化哈希值在数组中的分布，减少哈希冲突；而HashTable直接使用键的<code>hashCode()</code>方法返回的值作为哈希值，没有进行额外的处理。</p><p>总之，Java集合框架中的这些知识点在实际开发中非常重要，理解它们的实现原理和特性，能够帮助我们更合理地选择和使用集合类，写出高效、稳定的代码。</p><h2 id="参考博客">参考博客</h2><p><a href="https://javabetter.cn/collection/hashmap.html#_05%E3%80%81%E5%B0%8F%E7%BB%93">HashMap详解</a></p><p><a href="https://javaguide.cn/java/collection/hashmap-source-code.html">HashMap源码</a></p>]]></content>
    
    
    <summary type="html">🥧Java集合学习</summary>
    
    
    
    <category term="学习" scheme="https://outoflovenicoo.github.io/categories/%E5%AD%A6%E4%B9%A0/"/>
    
    
    <category term="思维导图" scheme="https://outoflovenicoo.github.io/tags/%E6%80%9D%E7%BB%B4%E5%AF%BC%E5%9B%BE/"/>
    
  </entry>
  
  <entry>
    <title>MySQL用B+树读取数据，从磁盘中读和从SSD中读有什么不同的影响</title>
    <link href="https://outoflovenicoo.github.io/posts/2025-04-17-MySQL%E7%94%A8B+%E6%A0%91%E8%AF%BB%E5%8F%96%E6%95%B0%E6%8D%AE%EF%BC%8C%E4%BB%8E%E7%A3%81%E7%9B%98%E4%B8%AD%E8%AF%BB%E5%92%8C%E4%BB%8ESSD%E4%B8%AD%E8%AF%BB%E6%9C%89%E4%BB%80%E4%B9%88%E4%B8%8D%E5%90%8C%E7%9A%84%E5%BD%B1%E5%93%8D.html"/>
    <id>https://outoflovenicoo.github.io/posts/2025-04-17-MySQL%E7%94%A8B+%E6%A0%91%E8%AF%BB%E5%8F%96%E6%95%B0%E6%8D%AE%EF%BC%8C%E4%BB%8E%E7%A3%81%E7%9B%98%E4%B8%AD%E8%AF%BB%E5%92%8C%E4%BB%8ESSD%E4%B8%AD%E8%AF%BB%E6%9C%89%E4%BB%80%E4%B9%88%E4%B8%8D%E5%90%8C%E7%9A%84%E5%BD%B1%E5%93%8D.html</id>
    <published>2025-04-17T10:19:03.000Z</published>
    <updated>2025-04-17T14:00:00.000Z</updated>
    
    <content type="html"><![CDATA[<p>面试腾讯的时候问到过一道题：MySQL用B+树读取数据，从磁盘中读和从SSD中读有什么不同的影响。这可把我问蒙了，SSD有点不记得了，现在复盘下。</p><h3 id="一、物理特性与读写原理"><strong>一、物理特性与读写原理</strong></h3><p><img src="2025-04-17-MySQL%E7%94%A8B+%E6%A0%91%E8%AF%BB%E5%8F%96%E6%95%B0%E6%8D%AE%EF%BC%8C%E4%BB%8E%E7%A3%81%E7%9B%98%E4%B8%AD%E8%AF%BB%E5%92%8C%E4%BB%8ESSD%E4%B8%AD%E8%AF%BB%E6%9C%89%E4%BB%80%E4%B9%88%E4%B8%8D%E5%90%8C%E7%9A%84%E5%BD%B1%E5%93%8D/image-1.png" alt=""></p><h4 id="1-磁盘读写">1.磁盘读写</h4><h5 id="读取数据过程">读取数据过程</h5><ol><li><p>寻道（Seek）</p><ul><li><p>当操作系统或应用程序请求读取数据时，磁盘控制器首先确定数据所在的逻辑地址（通常对应为 柱面号、磁头号、扇区号）。</p></li><li><p>磁头臂驱动磁头在盘片表面径向移动，定位到目标磁道（柱面）。</p></li><li><p>耗时因素：寻道时间取决于磁头移动距离，是随机访问（如随机 IO）的主要延迟来源（平均寻道时间约 5~15ms）。</p></li></ul></li><li><p>旋转定位（Rotational Latency）</p><ul><li><p>磁头到达目标磁道后，等待目标扇区旋转到磁头下方。</p></li><li><p>耗时因素：取决于磁盘转速（如 7200 转 / 分钟的磁盘，平均旋转延迟约 4.17ms）。</p></li></ul></li><li><p>数据传输（Data Transfer）</p><ul><li><p>磁头读取扇区中的磁性信号，转换为电信号后通过数据总线传输到磁盘缓存（Cache）。</p></li><li><p>若数据需提供给主机，再通过接口（如 SATA、NVMe）传输到内存。</p></li><li><p>传输速率：受限于磁盘转速和磁道密度，顺序读取速率较高（约 100~200MB/s），随机读取因寻道和旋转延迟大幅下降。</p></li></ul></li><li><p>错误校验</p><ul><li>读取数据时通过校验码（如 CRC）验证数据完整性，若出错则尝试重试或标记坏块。</li></ul></li></ol><h5 id="写入数据过程">写入数据过程</h5><ol><li><p>寻道与旋转定位</p><ul><li>与读取过程类似，先定位到目标磁道和扇区。</li></ul></li><li><p>数据写入</p><ul><li><p>磁头通过电流改变盘片表面磁性颗粒的极性，记录数据（0/1）。</p></li><li><p>写入前可能需要擦除原有数据（部分磁盘支持覆盖写入，但频繁擦写会影响寿命，不过 HDD 无此问题，因基于磁性而非闪存）。</p></li></ul></li><li><p>缓存与持久化</p><ul><li>数据先写入磁盘缓存，再由磁盘控制器决定何时写入盘片（异步写入时可能延迟，需依赖电池备份缓存确保断电不丢失）。</li></ul></li></ol><h4 id="2-SSD读写">2.SSD读写</h4><p><a href="https://blog.csdn.net/fuhanghang/article/details/134941585?ops_request_misc=%257B%2522request%255Fid%2522%253A%252291f7df9daec3edaee205dfda406a40d9%2522%252C%2522scm%2522%253A%252220140713.130102334..%2522%257D&amp;request_id=91f7df9daec3edaee205dfda406a40d9&amp;biz_id=0&amp;utm_medium=distribute.pc_search_result.none-task-blog-2~all~ElasticSearch~search_v2-9-134941585-null-null.142%5Ev102%5Epc_search_result_base3&amp;utm_term=SSD%E8%AF%BB%E5%8F%96%E6%95%B0%E6%8D%AE%E6%96%B9%E5%BC%8F&amp;spm=1018.2226.3001.4187">深入浅出SSD-CSDN博客</a></p><p><img src="2025-04-17-MySQL%E7%94%A8B+%E6%A0%91%E8%AF%BB%E5%8F%96%E6%95%B0%E6%8D%AE%EF%BC%8C%E4%BB%8E%E7%A3%81%E7%9B%98%E4%B8%AD%E8%AF%BB%E5%92%8C%E4%BB%8ESSD%E4%B8%AD%E8%AF%BB%E6%9C%89%E4%BB%80%E4%B9%88%E4%B8%8D%E5%90%8C%E7%9A%84%E5%BD%B1%E5%93%8D/image.png" alt=""></p><h5 id="SSD-数据读取数据">SSD 数据读取数据</h5><ol><li><p>逻辑地址到物理地址的转换（地址映射）</p><ul><li><p>当操作系统请求读取数据时，首先发送逻辑地址（LBA，Logical Block Address）。</p></li><li><p>主控通过FTL（Flash Translation Layer，闪存转换层）将逻辑地址转换为 NAND 闪存中的物理地址（包括芯片编号、块号、页号）。</p></li><li><p>FTL 维护一张动态映射表（通常存储在 DRAM 缓存中），记录逻辑地址与物理地址的对应关系，支持磨损均衡（将写入分散到不同块，避免某些块过度磨损）。</p></li></ul></li><li><p>数据读取操作（从 NAND 闪存中读取）</p><ul><li><p>选中目标页：主控向目标 NAND 芯片发送命令，通过 行地址译码器（X Decoder）选中目标块，再通过列地址译码器（Y Decoder） 选中目标页。</p></li><li><p>读取电荷信号：NAND 存储单元通过电荷电压表示数据（如 SLC 的高电压代表 1，低电压代表 0）。读取时，控制电路向单元施加读取电压，检测晶体管的导通状态，判断存储的是 1 还是 0。</p></li><li><p>信号放大与纠错：</p><ul><li><p>由于电荷可能因时间或电压波动出现衰减，读取的信号需通过 **sense amplifier（敏感放大器）** 放大并模数转换（ADC）。</p></li><li><p>主控通过 **ECC（错误校验码）** 对数据进行纠错，确保读取的准确性（SSD 内置硬件级 ECC，可纠正单比特或多比特错误）。</p></li></ul></li></ul></li><li><p>数据传输到主机</p><ul><li><p>读取的数据先暂存到 NAND 芯片的页缓存（Page Buffer），再通过 SSD 内部总线传输到主控的 DRAM 缓存。</p></li><li><p>主控将数据打包，通过接口（如 SATA、NVMe）传输到主机内存（RAM），完成读取操作。</p></li></ul></li></ol><h5 id="SSD写操作："><strong>SSD写操作：</strong></h5><p>主机通过接口发送写命令给SSD，SSD接收到该命令后执行，并接收主机要写入的数据。数据一般会先缓存在SSD内部的RAM中，FTL会为每个逻辑数据块分配一个闪存地址，当数据凑到一定数量后，FTL便会发送写闪存请求给后端，然后后端根据写请求，把缓存中的数据写到对应的闪存空间。由于闪存不能覆盖写，闪存块需擦除才能写入。主机发来的某个数据块，它不是写在闪存固定位置，SSD可以为其分配任何可能的闪存空间写入。因此，SSD内部需要FTL这样一个东西，完成逻辑数据块到闪存物理空间的转换或者映射。</p><p>举例：假设SSD容量为128GB，逻辑数据块大小为4KB，所以该SSD一共有128GB/4KB=32M个逻辑数据块。每个逻辑块都有一个映射，即每个逻辑块在闪存空间都有一个存储位置。闪存地址大小如果用4字节表示，那么存储32M个逻辑数据块在闪存中的地址则需要32M×4B=128MB大小的映射表。</p><p>正因为SSD内部维护了一张逻辑地址到物理地址转换的映射表，当主机发来读命令时，SSD能根据需要读取的逻辑数据块查找该映射表，获取这些逻辑数据在闪存空间所在的位置，后端便能从闪存上把对应数据读到SSD内部缓存空间，然后前端负责把这些数据返回给主机。</p><h3 id="二、对MySQL-B-树查询的具体影响"><strong>二、对MySQL B+树查询的具体影响</strong></h3><h4 id="1-随机IO性能差异"><strong>1. 随机IO性能差异</strong></h4><ul><li><p><strong>B+树的查询特性</strong>：B+树的查询过程是逐层遍历索引节点（从根节点到叶子节点），每次节点访问对应一次磁盘/SSD的IO操作。对于非聚集索引，查询可能需要多次随机IO（如回表查询）。</p></li><li><p><strong>磁盘（HDD）的瓶颈</strong>：  </p><ul><li><p>机械结构导致随机IO性能极低，尤其是在高并发场景下，大量随机IO会引发严重的寻道竞争和队列延迟。  </p></li><li><p>例如：一次简单的索引查询可能需要3-5次随机IO，若HDD的随机IOPS（每秒操作次数）仅为100-200次，则每秒最多处理约40-60次查询（假设每次查询需3次IO）。</p></li></ul></li><li><p><strong>SSD的优势</strong>：  </p><ul><li><p>无机械延迟，随机IOPS可达数万甚至数十万次，能快速响应大量索引节点的随机访问。  </p></li><li><p>同样以3次IO的查询为例，SSD的随机IOPS若为10万次，则每秒可处理约3万次查询，性能提升近百倍。</p></li></ul></li></ul><h4 id="2-顺序IO与预读机制"><strong>2. 顺序IO与预读机制</strong></h4><ul><li><p><strong>MySQL的预读机制</strong>：系统会提前将相邻的数据块预读入内存（如InnoDB的<code>read_ahead_threshold</code>参数），以减少IO次数。</p></li><li><p><strong>磁盘（HDD）的表现</strong>：  </p><ul><li><p>顺序读写性能较好，预读机制能有效减少部分随机IO。  </p></li><li><p>但预读依赖数据的连续性，若索引节点碎片化严重（如频繁删除数据），预读效率会下降。</p></li></ul></li><li><p><strong>SSD的表现</strong>：  </p><ul><li><p>顺序读写速度更快，预读效率更高。  </p></li><li><p>即使索引碎片化，随机IO的低延迟仍能弥补预读不足的问题。</p></li></ul></li></ul><h4 id="3-响应时间与吞吐量"><strong>3. 响应时间与吞吐量</strong></h4><ul><li><p><strong>磁盘（HDD）</strong>：  </p><ul><li><p>单次查询的响应时间通常*毫秒级，吞吐量受限于机械结构，难以应对高并发场景。  </p></li><li><p>适合小规模、低并发的应用（如单机测试环境）。</p></li></ul></li><li><p><strong>SSD</strong>：  </p><ul><li><p>单次查询的响应时间可降至微秒级，吞吐量显著提升，支持高并发的在线事务处理（OLTP）。  </p></li><li><p>例如：在oltpbench测试中，使用SSD的MySQL数据库吞吐量可比HDD提升5-10倍。</p></li></ul></li></ul><h4 id="4-耐用性与写操作影响"><strong>4. 耐用性与写操作影响</strong></h4><ul><li><p><strong>磁盘（HDD）</strong>：  </p><ul><li><p>机械结构易受物理震动影响，长期高负载下可能导致磁头或盘片损坏。  </p></li><li><p>写操作对读取性能无直接影响（除非触发磁盘碎片整理）。</p></li></ul></li><li><p><strong>SSD</strong>：  </p><ul><li><p>无机械损耗，但NAND闪存存在写入次数限制（寿命由PE次数决定，如TLC闪存约1000-3000次PE）。  </p></li><li><p>频繁的写操作（如索引更新）可能缩短SSD寿命，但现代SSD通过磨损均衡（Wear Leveling）和垃圾回收（GC）机制已大幅缓解此问题。  </p></li><li><p>对读取性能无直接影响，但写入密集型场景需关注SSD的剩余寿命。</p></li></ul></li></ul><h3 id="三、实际应用场景建议"><strong>三、实际应用场景建议</strong></h3><table><thead><tr><th><strong>场景</strong></th><th><strong>推荐存储介质</strong></th><th><strong>理由</strong></th></tr></thead><tbody><tr><td><strong>高并发OLTP系统</strong></td><td>SSD</td><td>随机IO性能优势显著，大幅降低查询延迟，提升吞吐量。</td></tr><tr><td><strong>数据仓库/OLAP系统</strong></td><td>SSD或HDD</td><td>若以顺序查询为主，HDD性价比更高；若包含大量索引或实时查询，优先选SSD。</td></tr><tr><td><strong>低成本单机环境</strong></td><td>HDD</td><td>适合小型数据库或开发测试场景，成本低但性能有限。</td></tr><tr><td><strong>混合负载系统</strong></td><td>分层存储</td><td>热数据（高频查询的索引和数据）存SSD，冷数据存HDD或云存储（如MySQL InnoDB Cluster）。</td></tr></tbody></table><h3 id="四、优化建议"><strong>四、优化建议</strong></h3><ol><li><p><strong>针对SSD的优化</strong>：  </p><ul><li><p>启用InnoDB的<code>innodb_flush_neighbors</code>参数（设为0以减少随机写）。  </p></li><li><p>定期执行<code>OPTIMIZE TABLE</code>或<code>ALTER TABLE</code>整理索引碎片（但避免过度操作影响SSD寿命）。  </p></li><li><p>选择支持TRIM命令的SSD，并确保操作系统已启用TRIM（释放无效块，提升性能）。</p></li></ul></li><li><p><strong>针对HDD的优化</strong>：  </p><ul><li><p>增大InnoDB缓冲池（<code>innodb_buffer_pool_size</code>），尽量将热数据缓存到内存，减少磁盘访问。  </p></li><li><p>定期进行磁盘碎片整理，提升顺序IO效率。  </p></li><li><p>避免高并发随机查询，优先使用覆盖索引减少回表。</p></li></ul></li></ol><h3 id="总结"><strong>总结</strong></h3><ul><li><p><strong>核心差异</strong>：SSD通过消除机械延迟，大幅提升随机IO性能，显著降低B+树查询的响应时间，尤其适合高并发场景；HDD则受限于机械结构，随机IO成为性能瓶颈，但顺序读写和成本优势仍适用于特定场景。  </p></li><li><p>HDD​：</p><ul><li><p>B+ 树的节点大小通常与磁盘块对齐（如 16KB），以最小化单次 IO 代价。</p></li><li><p>优化策略倾向于减少树的高度（如增加节点容量），降低随机 IO 次数。</p></li><li><p>需要依赖预读（Read-ahead）机制提前加载相邻数据，掩盖 HDD 顺序读取的延迟。</p></li></ul></li><li><p>SSD​：</p><ul><li><p>节点大小可能更灵活（SSD 的“页”通常为 4-16KB，但随机读取成本低）。</p></li><li><p>树的高度对延迟影响较小，可容忍稍高的层数以换取更紧凑的节点结构(增加空间利用率)，因为IO成本低。</p></li><li><p>预读机制的收益降低（随机读取足够快），可能更关注并发 IO 或异步访问优化。</p></li></ul></li></ul>]]></content>
    
    
    <summary type="html">🥧MySQL用B+树读取数据，从磁盘中读和从SSD中读有什么不同的影响</summary>
    
    
    
    <category term="学习" scheme="https://outoflovenicoo.github.io/categories/%E5%AD%A6%E4%B9%A0/"/>
    
    
    <category term="MySQL" scheme="https://outoflovenicoo.github.io/tags/MySQL/"/>
    
    <category term="操作系统" scheme="https://outoflovenicoo.github.io/tags/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/"/>
    
  </entry>
  
  <entry>
    <title>深入探讨多线程操作数组背后的CPU伪共享与MESI协议</title>
    <link href="https://outoflovenicoo.github.io/posts/2025-04-01-%E6%B7%B1%E5%85%A5%E6%8E%A2%E8%AE%A8%E5%A4%9A%E7%BA%BF%E7%A8%8B%E6%93%8D%E4%BD%9C%E6%95%B0%E7%BB%84%E8%83%8C%E5%90%8E%E7%9A%84CPU%E4%BC%AA%E5%85%B1%E4%BA%AB%E4%B8%8EMESI%E5%8D%8F%E8%AE%AE.html"/>
    <id>https://outoflovenicoo.github.io/posts/2025-04-01-%E6%B7%B1%E5%85%A5%E6%8E%A2%E8%AE%A8%E5%A4%9A%E7%BA%BF%E7%A8%8B%E6%93%8D%E4%BD%9C%E6%95%B0%E7%BB%84%E8%83%8C%E5%90%8E%E7%9A%84CPU%E4%BC%AA%E5%85%B1%E4%BA%AB%E4%B8%8EMESI%E5%8D%8F%E8%AE%AE.html</id>
    <published>2025-04-01T10:19:03.000Z</published>
    <updated>2025-04-12T14:00:00.000Z</updated>
    
    <content type="html"><![CDATA[<h2 id="思维导图：">思维导图：</h2><p><img src="2025-04-01-%E6%B7%B1%E5%85%A5%E6%8E%A2%E8%AE%A8%E5%A4%9A%E7%BA%BF%E7%A8%8B%E6%93%8D%E4%BD%9C%E6%95%B0%E7%BB%84%E8%83%8C%E5%90%8E%E7%9A%84CPU%E4%BC%AA%E5%85%B1%E4%BA%AB%E4%B8%8EMESI%E5%8D%8F%E8%AE%AE/diagram.png" alt=""></p><h2 id="前言：">前言：</h2><p>这是一道腾讯的面试题，通过这个问题我理解了CPU缓存的一致性怎么保障的，具体场景如下：</p><p>当我们面对这样一个场景：n个线程去操纵数组的n个元素，编号为i的线程只会操作下标为i的数组元素 <code>arr[i]++</code>，看似每个线程各司其职，互不干扰，然而实际运行中却可能出现性能问题。这背后涉及CPU缓存结构、伪共享问题、MESI协议以及CPU Cache数据的写入方式，下面我们逐步分析。</p><h2 id="一、CPU缓存结构：L1、L2、L3">一、CPU缓存结构：L1、L2、L3</h2><p>在现代多核CPU架构中，缓存系统分为多个层级：</p><ul><li><p><strong>L1缓存</strong>：每个CPU核心都有独立的L1缓存，且进一步细分为L1数据缓存（存放数据）和L1指令缓存（存放指令）。它的速度最快，但容量最小，通常只有几十KB。例如，在一些CPU中，L1数据缓存和指令缓存可能各为32KB。</p></li><li><p><strong>L2缓存</strong>：同样每个核心独立拥有，容量比L1大，速度稍慢于L1。一般为几百KB到几MB不等，例如某些CPU的L2缓存可能是256KB或512KB。它的作用是在L1未命中时，为核心提供数据和指令。</p></li><li><p><strong>L3缓存</strong>：通常为多个核心共享，容量更大，速度相对L1、L2更慢。L3缓存可以达到几MB甚至几十MB，例如一些高端CPU的L3缓存可能为12MB或更高。它作为更大范围的缓存池，减少核心对内存的直接访问。</p></li></ul><p>数据在内存与缓存之间以 **Cache Line**（缓存行，通常为64字节）为单位传输。当CPU读取数据时，会将包含目标数据的整个Cache Line读入缓存。</p><h2 id="二、CPU-Cache数据的写入方式">二、CPU Cache数据的写入方式</h2><h3 id="写直达（Write-Through）">写直达（Write - Through）</h3><p>写直达是指CPU在写入数据到Cache时，会同时将数据写入内存。具体流程为：当CPU执行写入数据操作时，先检查数据是否在CPU Cache中。如果在，直接将数据写入Cache Block；如果不在，则先将数据写入内存，再完成操作。这种方式的优点是能保证内存和Cache中的数据始终一致，但每次写入都需要访问内存，会增加内存总线的流量，降低写入效率。在多线程伪共享场景中，写直达会频繁触发内存写入操作，引发更多的总线事务，导致其他核心更频繁地感知到Cache Line的变化，加剧伪共享带来的性能损耗。</p><h3 id="写回（Write-Back）">写回（Write - Back）</h3><p>写回策略下，CPU先将数据写入Cache Block，并标记该Cache Block为“脏”（已修改）。当Cache Block需要被替换（例如新的数据要存入，而Cache已满）时，才将脏数据写回内存。具体流程为：CPU将数据写入Cache Block后，检查数据是否在其他CPU Cache中。如果不在，直接标记Cache Block为脏；如果在，则需要先使其他核心中相同的Cache Line失效（通过MESI协议），然后标记当前Cache Block为脏。写回方式减少了内存写入次数，提升了写入效率，但存在数据不一致的风险（在数据写回内存前，内存中的数据是旧的）。在伪共享场景中，写回虽然减少了内存写入，但一个核心对Cache Block的修改（标记为脏）会通过MESI协议使其他核心的相同Cache Line失效，当其他核心后续操作同属一个Cache Line的元素时，需要重新读取数据，这一过程依然会产生缓存状态切换和数据同步开销。</p><h2 id="三、伪共享问题：隐藏的性能杀手">三、伪共享问题：隐藏的性能杀手</h2><h3 id="伪共享的定义与成因">伪共享的定义与成因</h3><p>伪共享指多个线程操作不同变量，但这些变量因存储在同一个Cache Line中，导致彼此的操作互相影响。例如，在上述多线程操作数组的场景中，假设数组在内存中连续存储，一个Cache Line（64字节）可以存放16个 <code>int</code> 类型的数组元素（每个 <code>int</code> 占4字节）。若线程A操作 <code>arr[i]</code>，线程B操作 <code>arr[j]</code>（<code>i</code> 与 <code>j</code> 对应的元素在同一个Cache Line），尽管逻辑上两者无直接关联，但硬件层面的缓存机制会让它们产生交互。</p><h3 id="伪共享如何影响性能">伪共享如何影响性能</h3><p>当一个线程修改Cache Line中的数据（如 <code>arr[i]++</code>），根据MESI协议，该Cache Line状态会变为“已修改”（写回策略）或触发内存写入（写直达策略），其他核心中相同的Cache Line会被标记为“已失效”。若其他线程此时要操作同属一个Cache Line的其他元素，需重新从内存或其他核心获取数据，这一过程涉及缓存状态的频繁切换（如从“共享”到“已失效”再到重新加载）、数据同步以及总线通信开销。即使这些线程操作的是不同变量，也会因伪共享导致大量不必要的缓存同步操作，严重影响程序性能。</p><h2 id="四、MESI协议：缓存一致性的保障">四、MESI协议：缓存一致性的保障</h2><p>MESI协议定义了Cache Line的四种状态，用于保证多核CPU缓存一致性：</p><ul><li><p><strong>独占（Exclusive）</strong>：该Cache Line只在当前核心缓存中，且数据与内存一致。此时其他核心没有该Cache Line的副本。</p></li><li><p><strong>共享（Shared）</strong>：多个核心缓存中都有该Cache Line，且数据与内存一致。多个核心可以同时读取该Cache Line中的数据。</p></li><li><p><strong>已修改（Modified）</strong>：该Cache Line在当前核心缓存中被修改，与内存不一致。其他核心若要读取该数据，需先从当前核心获取最新数据，当前核心会在适当时候将数据写回内存。</p></li><li><p><strong>已失效（Invalidated）</strong>：该Cache Line在当前核心缓存中失效，需从内存或其他核心重新获取数据。</p></li></ul><p>在伪共享场景中，一个核心对Cache Line的修改会触发MESI协议的状态变更，导致其他核心的相同Cache Line失效，进而引发一系列数据同步操作，这就是伪共享影响性能的底层机制。</p><h2 id="五、解决伪共享：让缓存行“各司其职”">五、解决伪共享：让缓存行“各司其职”</h2><p>最直接的解决方式是通过字节填充，确保每个数组元素或相关变量单独占据一个Cache Line。在Java中，可以使用 <code>@Contended</code> 注解（需开启JVM参数 <code>-XX:-RestrictContended</code>）来实现。例如：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> sun.misc.Contended;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">ArrayExample</span> &#123;</span><br><span class="line">    <span class="meta">@Contended</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">volatile</span> <span class="type">long</span>[] arr;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="title function_">ArrayExample</span><span class="params">(<span class="type">int</span> size)</span> &#123;</span><br><span class="line">        arr = <span class="keyword">new</span> <span class="title class_">long</span>[size];</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">increment</span><span class="params">(<span class="type">int</span> i)</span> &#123;</span><br><span class="line">        arr[i]++;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>或者手动添加填充字段：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">PaddedLong</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">volatile</span> <span class="type">long</span> value;</span><br><span class="line">    <span class="comment">// 填充7个long类型字段，共56字节，加上value本身8字节，刚好占满一个64字节的Cache Line</span></span><br><span class="line">    <span class="keyword">private</span> <span class="type">long</span> p1, p2, p3, p4, p5, p6, p7; </span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">ArrayExample</span> &#123;</span><br><span class="line">    <span class="keyword">private</span> PaddedLong[] arr;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="title function_">ArrayExample</span><span class="params">(<span class="type">int</span> size)</span> &#123;</span><br><span class="line">        arr = <span class="keyword">new</span> <span class="title class_">PaddedLong</span>[size];</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i &lt; size; i++) &#123;</span><br><span class="line">            arr[i] = <span class="keyword">new</span> <span class="title class_">PaddedLong</span>();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">increment</span><span class="params">(<span class="type">int</span> i)</span> &#123;</span><br><span class="line">        arr[i].value++;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>通过上述方式，每个元素或包含元素的对象能独立占据Cache Line，避免因伪共享导致的性能损耗。</p><p>总结来看，多线程操作数组元素时，看似简单的逻辑在底层硬件（CPU缓存结构、Cache数据写入方式）与缓存协议（MESI协议）的影响下可能产生性能问题。其实在实际开发中，我们很少会多线程去操作一个数组，不过这个问题让我对CPU缓存一致性有了更深的理解，很有意义。</p><h2 id="参考博客：">参考博客：</h2><p><a href="https://xiaolincoding.com/os/1_hardware/cpu_mesi.html#cpu-cache-%E7%9A%84%E6%95%B0%E6%8D%AE%E5%86%99%E5%85%A5">2.4 CPU 缓存一致性</a></p><p><a href="https://mp.weixin.qq.com/s/PDUqwAIaUxNkbjvRfovaCg">十张图介绍MESI</a></p>]]></content>
    
    
    <summary type="html">🥧深入探讨多线程操作数组背后的CPU伪共享与MESI协议</summary>
    
    
    
    <category term="学习" scheme="https://outoflovenicoo.github.io/categories/%E5%AD%A6%E4%B9%A0/"/>
    
    
    <category term="思维导图" scheme="https://outoflovenicoo.github.io/tags/%E6%80%9D%E7%BB%B4%E5%AF%BC%E5%9B%BE/"/>
    
  </entry>
  
  <entry>
    <title>根据字符串数组构建一颗二叉树</title>
    <link href="https://outoflovenicoo.github.io/posts/2025-03-25-%E6%A0%B9%E6%8D%AE%E5%AD%97%E7%AC%A6%E4%B8%B2%E6%95%B0%E7%BB%84%E6%9E%84%E5%BB%BA%E4%B8%80%E9%A2%97%E4%BA%8C%E5%8F%89%E6%A0%91.html"/>
    <id>https://outoflovenicoo.github.io/posts/2025-03-25-%E6%A0%B9%E6%8D%AE%E5%AD%97%E7%AC%A6%E4%B8%B2%E6%95%B0%E7%BB%84%E6%9E%84%E5%BB%BA%E4%B8%80%E9%A2%97%E4%BA%8C%E5%8F%89%E6%A0%91.html</id>
    <published>2025-03-25T07:19:03.000Z</published>
    <updated>2025-03-25T14:00:00.000Z</updated>
    
    <content type="html"><![CDATA[<p><strong>在面试手撕的时候，经常需要根据输入的字符串构建一颗树，由于第一次做，磕磕绊绊才写出来，这里记录一下吧</strong></p><h3 id="样例">样例</h3><p>根据字符串 <code>[1,2,3,null,4,null,5]</code> 构建二叉树时，需按照 <strong>层序遍历顺序</strong> 解析节点值，其中 <code>null</code> 表示空节点。以下是构建过程和结果：</p><h3 id="构建规则"><strong>构建规则</strong></h3><ol><li><strong>根节点</strong>：字符串中第一个非 <code>null</code> 的值（此处为 <code>1</code>）。</li><li><strong>层序填充</strong>：从根节点开始，按 <strong>左子节点 → 右子节点</strong> 的顺序依次填充后续节点：<ol><li>若当前节点为 <code>null</code>，则跳过其左右子节点。</li><li>空值（<code>null</code>）仅表示节点不存在，不参与树结构。</li></ol></li></ol><h3 id="详细构建步骤"><strong>详细构建步骤</strong></h3><h4 id="第-1-层（根节点）"><strong>第 1 层（根节点）</strong></h4><ul><li>节点值：<code>1</code>根节点为 <code>1</code>，对应位置 <code>i=0</code>。</li></ul><h4 id="第-2-层（根节点的左右子节点）"><strong>第 2 层（根节点的左右子节点）</strong></h4><ul><li>左子节点：位置 <code>i=1</code>，值为 <code>2</code>，非空，作为 <code>1</code> 的左子节点。</li><li>右子节点：位置 <code>i=2</code>，值为 <code>3</code>，非空，作为 <code>1</code> 的右子节点。</li></ul><h4 id="第-3-层（第-2-层节点的左右子节点）"><strong>第 3 层（第 2 层节点的左右子节点）</strong></h4><ul><li><strong>节点</strong> **<code>2</code>**的子节点：<ul><li>左子节点：位置 <code>i=3</code>，值为 <code>null</code>，跳过。</li><li>右子节点：位置 <code>i=4</code>，值为 <code>4</code>，非空，作为 <code>2</code> 的右子节点。</li></ul></li><li><strong>节点</strong> <strong><code>3</code></strong> 的子节点：<ul><li>左子节点：位置 <code>i=5</code>，值为 <code>null</code>，跳过。</li><li>右子节点：位置 <code>i=6</code>，值为 <code>5</code>，非空，作为 <code>3</code> 的右子节点。</li></ul></li></ul><h4 id="后续节点"><strong>后续节点</strong></h4><p>字符串中剩余内容（末尾逗号）可忽略，无有效节点。</p><h3 id="最终二叉-树结构"><strong>最终二叉****树结构</strong></h3><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">  1</span><br><span class="line"> / \</span><br><span class="line">2   3</span><br><span class="line"> \   \</span><br><span class="line">  4   5</span><br></pre></td></tr></table></figure><ul><li><strong>根节点</strong>：<code>1</code></li><li><strong>左子树</strong>：以 <code>2</code> 为根，其右子节点为 <code>4</code>。</li><li><strong>右子树</strong>：以 <code>3</code> 为根，其右子节点为 <code>5</code>。</li></ul><h3 id="验证层序遍历"><strong>验证层序遍历</strong></h3><p>构建后的二叉树层序遍历结果与输入字符串一致（忽略 <code>null</code> 后的有效节点）：</p><p><code>[1, 2, 3, 4, 5]</code>，符合预期。</p><h3 id="代码：">代码：</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> java.util.LinkedList;</span><br><span class="line"><span class="keyword">import</span> java.util.Queue;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 定义二叉树节点类</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">TreeNode</span> &#123;</span><br><span class="line">    <span class="type">int</span> val;</span><br><span class="line">    TreeNode left;</span><br><span class="line">    TreeNode right;</span><br><span class="line">    TreeNode(<span class="type">int</span> x) &#123; val = x; &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">BuildBinaryTree</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> TreeNode <span class="title function_">buildTree</span><span class="params">(String str)</span> &#123;</span><br><span class="line">        <span class="comment">// 去除首尾的方括号</span></span><br><span class="line">        str = str.substring(<span class="number">1</span>, str.length() - <span class="number">1</span>);</span><br><span class="line">        <span class="keyword">if</span> (str.isEmpty()) &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">null</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        String[] values = str.split(<span class="string">&quot;,&quot;</span>);</span><br><span class="line">        <span class="type">TreeNode</span> <span class="variable">root</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">TreeNode</span>(Integer.parseInt(values[<span class="number">0</span>]));</span><br><span class="line">        Queue&lt;TreeNode&gt; queue = <span class="keyword">new</span> <span class="title class_">LinkedList</span>&lt;&gt;();</span><br><span class="line">        queue.offer(root);</span><br><span class="line">        <span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">1</span>;</span><br><span class="line">        <span class="keyword">while</span> (!queue.isEmpty() &amp;&amp; i &lt; values.length) &#123;</span><br><span class="line">            <span class="type">TreeNode</span> <span class="variable">node</span> <span class="operator">=</span> queue.poll();</span><br><span class="line">            <span class="keyword">if</span> (!values[i].equals(<span class="string">&quot;null&quot;</span>)) &#123;</span><br><span class="line">                node.left = <span class="keyword">new</span> <span class="title class_">TreeNode</span>(Integer.parseInt(values[i]));</span><br><span class="line">                queue.offer(node.left);</span><br><span class="line">            &#125;</span><br><span class="line">            i++;</span><br><span class="line">            <span class="keyword">if</span> (i &lt; values.length &amp;&amp; !values[i].equals(<span class="string">&quot;null&quot;</span>)) &#123;</span><br><span class="line">                node.right = <span class="keyword">new</span> <span class="title class_">TreeNode</span>(Integer.parseInt(values[i]));</span><br><span class="line">                queue.offer(node.right);</span><br><span class="line">            &#125;</span><br><span class="line">            i++;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> root;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">        <span class="type">String</span> <span class="variable">input</span> <span class="operator">=</span> <span class="string">&quot;[1,2,3,null,4,null,5]&quot;</span>;</span><br><span class="line">        <span class="type">TreeNode</span> <span class="variable">root</span> <span class="operator">=</span> buildTree(input);</span><br><span class="line">        <span class="comment">// 这里可以添加遍历二叉树的代码来验证结果</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;    </span><br></pre></td></tr></table></figure>]]></content>
    
    
    <summary type="html">🥧根据字符串数组构建一颗二叉树</summary>
    
    
    
    <category term="算法" scheme="https://outoflovenicoo.github.io/categories/%E7%AE%97%E6%B3%95/"/>
    
    
    <category term="算法" scheme="https://outoflovenicoo.github.io/tags/%E7%AE%97%E6%B3%95/"/>
    
  </entry>
  
  <entry>
    <title>Guava的eventBus的原理</title>
    <link href="https://outoflovenicoo.github.io/posts/2025-03-20-Guava%E7%9A%84eventBus%E7%9A%84%E5%8E%9F%E7%90%86.html"/>
    <id>https://outoflovenicoo.github.io/posts/2025-03-20-Guava%E7%9A%84eventBus%E7%9A%84%E5%8E%9F%E7%90%86.html</id>
    <published>2025-03-20T10:19:03.000Z</published>
    <updated>2025-03-20T14:00:00.000Z</updated>
    
    <content type="html"><![CDATA[<h1>Guava的eventBus的原理</h1><p><img src="2025-03-20-Guava%E7%9A%84eventBus%E7%9A%84%E5%8E%9F%E7%90%86/diagram.png" alt=""></p><p>在Java应用开发中，同一JVM内的事件通知场景普遍存在。相较于分布式消息队列（MQ），Guava提供的EventBus框架以轻量、便捷的特点成为首选。本文将从架构设计、运行机制、使用场景及注意事项等方面，深入解析EventBus的核心原理。</p><h2 id="一、EventBus的架构组成">一、EventBus的架构组成</h2><p>EventBus由以下核心模块构成：</p><ol><li><p><strong>事件发送器</strong>  </p><ul><li><p><strong>EventBus</strong>：同步事件发送器，默认使用<code>DirectExecutor</code>直接在当前线程执行事件处理逻辑。  </p></li><li><p><strong>AsyncEventBus</strong>：异步事件发送器，需传入自定义线程池（如<code>ThreadPoolExecutor</code>），通过线程池实现异步调度。  </p></li></ul></li><li><p><strong>事件载体（Event）</strong>事件是通知的最小单元，可定义任意类型的POJO作为事件（如<code>LoginEvent</code>、<code>RegisterEvent</code>）。  </p></li><li><p><strong>订阅者注册器（SubscriberRegistry）</strong>负责管理订阅者与事件的映射关系，通过反射扫描订阅者类中被<code>@Subscribe</code>注解标记的方法，并将其与事件类型绑定到<code>Multimap&lt;Class&lt;?&gt;, Subscriber&gt;</code>集合中。  </p></li><li><p><strong>事件分发器（Dispatcher）</strong>  </p><ul><li><p><strong>PerThreadQueuedDispatcher</strong>（EventBus默认）：基于线程本地队列（<code>ThreadLocal&lt;Queue&lt;Event&gt;&gt;</code>）实现同步分发，按顺序处理事件。  </p></li><li><p><strong>LegacyAsyncDispatcher</strong>（AsyncEventBus默认）：通过线程池异步执行事件处理逻辑。  </p></li></ul></li><li><p><strong>订阅者（Subscriber）</strong>  </p><ul><li><p><strong>Subscriber</strong>：无同步修饰的订阅者，适用于线程安全的事件处理方法（需通过<code>@AllowConcurrentEvents</code>注解声明）。  </p></li><li><p><strong>SynchronizedSubscriber</strong>：自动添加<code>synchronized</code>同步块的订阅者，确保非线程安全方法在并发场景下的串行执行。</p></li></ul></li></ol><h2 id="二、核心运行流程解析">二、核心运行流程解析</h2><h3 id="1-初始化与注册">1. 初始化与注册</h3><ul><li><p><strong>创建EventBus实例</strong>  </p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 同步EventBus</span></span><br><span class="line"><span class="type">EventBus</span> <span class="variable">eventBus</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">EventBus</span>(); </span><br><span class="line"><span class="comment">// 异步EventBus（需指定线程池）</span></span><br><span class="line"><span class="type">ThreadPoolExecutor</span> <span class="variable">executor</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">ThreadPoolExecutor</span>(<span class="number">5</span>, <span class="number">20</span>, <span class="number">30</span>, TimeUnit.SECONDS, <span class="keyword">new</span> <span class="title class_">LinkedBlockingQueue</span>&lt;&gt;(<span class="number">20</span>));</span><br><span class="line"><span class="type">AsyncEventBus</span> <span class="variable">asyncEventBus</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">AsyncEventBus</span>(executor);</span><br></pre></td></tr></table></figure></li><li><p><strong>注册订阅者</strong>通过<code>eventBus.register(listener)</code>方法将订阅者对象注册到框架中。底层通过反射遍历<code>listener</code>的所有方法，提取被<code>@Subscribe</code>标记的方法，封装为<code>Subscriber</code>对象，并按事件类型存储到<code>SubscriberRegistry</code>的<code>Multimap</code>中。</p></li></ul><h3 id="2-事件发送与处理">2. 事件发送与处理</h3><ul><li><p><strong>事件发布</strong>调用<code>eventBus.post(event)</code>触发事件分发：  </p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">eventBus.post(<span class="keyword">new</span> <span class="title class_">LoginEvent</span>(<span class="string">&quot;user&quot;</span>, <span class="string">&quot;password&quot;</span>));</span><br></pre></td></tr></table></figure></li><li><p><strong>分发逻辑</strong>  </p><ul><li><p><strong>同步模式（EventBus）</strong>：通过<code>PerThreadQueuedDispatcher</code>将事件存入当前线程的本地队列，按顺序逐个调用订阅者的处理方法，同步阻塞直至所有处理完成。  </p></li><li><p><strong>异步模式（AsyncEventBus）</strong>：通过<code>LegacyAsyncDispatcher</code>将事件处理逻辑提交到线程池，由线程池异步执行，发送线程无需等待结果。  </p></li></ul></li><li><p><strong>死亡事件（DeadEvent）</strong>若事件未被任何订阅者处理，EventBus会自动将其包装为<code>DeadEvent</code>并重新发布，可通过订阅<code>DeadEvent</code>捕获未处理的事件。</p></li></ul><h3 id="3-线程安全与并发控制">3. 线程安全与并发控制</h3><ul><li><p><strong>订阅者方法的线程安全</strong>  </p><ul><li><p>若方法被<code>@AllowConcurrentEvents</code>注解标记，EventBus会创建普通<code>Subscriber</code>，允许并发执行（需自行保证线程安全）。  </p></li><li><p>未标记注解的方法会被包装为<code>SynchronizedSubscriber</code>，通过<code>synchronized</code>关键字确保同一订阅者实例的方法串行执行，可能成为高并发场景的性能瓶颈。</p></li></ul></li></ul><h2 id="三、典型使用场景与代码示例">三、典型使用场景与代码示例</h2><h3 id="1-配置与初始化">1. 配置与初始化</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Configuration</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">EventBusConfig</span> &#123;</span><br><span class="line">    <span class="meta">@Bean</span></span><br><span class="line">    <span class="keyword">public</span> AsyncEventBus <span class="title function_">asyncEventBus</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="type">ThreadPoolExecutor</span> <span class="variable">executor</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">ThreadPoolExecutor</span>(</span><br><span class="line">            <span class="number">5</span>, <span class="number">20</span>, <span class="number">30</span>, TimeUnit.SECONDS,</span><br><span class="line">            <span class="keyword">new</span> <span class="title class_">LinkedBlockingQueue</span>&lt;&gt;(<span class="number">20</span>),</span><br><span class="line">            <span class="keyword">new</span> <span class="title class_">ThreadPoolExecutor</span>.CallerRunsPolicy() <span class="comment">// 拒绝策略示例</span></span><br><span class="line">        );</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">new</span> <span class="title class_">AsyncEventBus</span>(executor);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="2-订阅者定义">2. 订阅者定义</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Component</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">EventListener</span> &#123;</span><br><span class="line">    <span class="comment">// 同步处理登录事件</span></span><br><span class="line">    <span class="meta">@Subscribe</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">handleLoginEvent</span><span class="params">(LoginEvent event)</span> &#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;Received login event: &quot;</span> + event.getUsername());</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 异步处理注册事件（需AsyncEventBus）</span></span><br><span class="line">    <span class="meta">@Subscribe</span></span><br><span class="line">    <span class="meta">@AllowConcurrentEvents</span> <span class="comment">// 声明线程安全，允许并发处理</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">handleRegisterEvent</span><span class="params">(RegisterEvent event)</span> &#123;</span><br><span class="line">        <span class="comment">// 耗时操作示例</span></span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            Thread.sleep(<span class="number">1000</span>);</span><br><span class="line">        &#125; <span class="keyword">catch</span> (InterruptedException e) &#123;</span><br><span class="line">            Thread.currentThread().interrupt();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="3-事件发送">3. 事件发送</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Service</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">EventPublisher</span> &#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">final</span> EventBus eventBus;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="title function_">EventPublisher</span><span class="params">(EventBus eventBus)</span> &#123;</span><br><span class="line">        <span class="built_in">this</span>.eventBus = eventBus;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">publishLoginEvent</span><span class="params">(String username, String password)</span> &#123;</span><br><span class="line">        eventBus.post(<span class="keyword">new</span> <span class="title class_">LoginEvent</span>(username, password));</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="四、注意事项与性能优化">四、注意事项与性能优化</h2><ul><li><p><strong>线程池配置</strong>  </p><ul><li><p>异步模式下需合理设置线程池参数（如核心线程数、队列容量、拒绝策略），避免任务堆积或线程耗尽。  </p></li><li><p>建议为不同类型的事件分配独立线程池，防止高耗时事件阻塞其他事件处理。  </p></li></ul></li><li><p><strong>反射开销</strong>  </p><ul><li>订阅者注册过程依赖反射，高频率注册/注销场景可能影响性能，建议在系统启动阶段完成所有订阅者注册。  </li></ul></li><li><p><strong>并发控制</strong>  </p><ul><li>非线程安全的订阅者方法（未使用<code>@AllowConcurrentEvents</code>）会被自动同步，高并发时需评估串行执行的性能影响，必要时通过线程安全的数据结构或异步拆分优化。  </li></ul></li><li><p><strong>异常处理</strong>  </p><ul><li>事件处理方法若抛出异常，会被EventBus捕获并记录，但不会中断其他订阅者的执行。建议在方法内部添加try-catch块，避免未预期异常导致系统不稳定。  </li></ul></li></ul><h2 id="五、总结">五、总结</h2><p>Guava EventBus通过简洁的发布-订阅模式，为JVM内的事件通信提供了高效解决方案。理解其架构设计（如同步/异步分发机制、订阅者注册原理）和线程安全策略，能帮助开发者在实际项目中合理选择EventBus或AsyncEventBus，并通过优化线程池配置、减少反射开销等手段提升系统性能。在微服务或复杂业务场景中，结合分布式消息队列（如Kafka、RabbitMQ）与EventBus，可进一步构建层次化的事件驱动架构。</p><h2 id="参考博客：">参考博客：</h2><p><a href="https://cloud.tencent.com/developer/article/1377032">Guava原理深度解析</a></p>]]></content>
    
    
    <summary type="html">🥧Guava的eventBus的原理</summary>
    
    
    
    <category term="学习" scheme="https://outoflovenicoo.github.io/categories/%E5%AD%A6%E4%B9%A0/"/>
    
    
    <category term="原理" scheme="https://outoflovenicoo.github.io/tags/%E5%8E%9F%E7%90%86/"/>
    
  </entry>
  
  <entry>
    <title>CompletableFuture原理及其使用</title>
    <link href="https://outoflovenicoo.github.io/posts/2025-03-19-CompletableFuture%E5%8E%9F%E7%90%86%E5%8F%8A%E5%85%B6%E4%BD%BF%E7%94%A8.html"/>
    <id>https://outoflovenicoo.github.io/posts/2025-03-19-CompletableFuture%E5%8E%9F%E7%90%86%E5%8F%8A%E5%85%B6%E4%BD%BF%E7%94%A8.html</id>
    <published>2025-03-19T10:19:03.000Z</published>
    <updated>2025-03-19T14:00:00.000Z</updated>
    
    <content type="html"><![CDATA[<h1>思维导图：</h1><p><img src="2025-03-19-CompletableFuture%E5%8E%9F%E7%90%86%E5%8F%8A%E5%85%B6%E4%BD%BF%E7%94%A8/diagram-5060644.png" alt=""></p><h1>深入理解CompletableFuture原理</h1><p><strong>实习的时候用到了<code>CompletableFuture</code>，本着知其然要知其所以然的原则，总结一下<code>CompletableFuture</code>的原理吧。</strong></p><p>在Java的并发编程领域中，我们常常会遇到需要进行异步计算的场景。比如，当我们从数据库获取数据、调用远程服务接口时，如果这些操作在主线程中同步执行，可能会导致主线程阻塞，影响程序的响应性能。这时候，<code>CompletableFuture</code>就派上了大用场，它为我们提供了强大而灵活的异步编程支持。</p><h2 id="一、CompletableFuture实现的接口">一、CompletableFuture实现的接口</h2><p><code>CompletableFuture</code>实现了<code>Future</code>和<code>CompletionStage</code>两个接口。<code>Future</code>接口大家相对比较熟悉，它主要用于表示异步计算的结果。我们可以通过它获取异步任务的执行结果、判断任务是否完成以及取消任务等操作。而<code>CompletionStage</code>接口则为异步编程带来了更多的灵活性和可编排性。它表示异步执行过程中的一个步骤（Stage），一个<code>CompletionStage</code>的完成可能会触发其他一系列<code>CompletionStage</code>的执行。我们可以根据实际业务需求，通过<code>CompletionStage</code>提供的<code>thenApply</code>、<code>thenCompose</code>等函数式编程方法，对这些步骤进行多样化的编排组合，从而实现复杂的异步逻辑。</p><h2 id="二、CompletableFuture的依赖关系">二、CompletableFuture的依赖关系</h2><h3 id="一元依赖">一元依赖</h3><p>当我们的任务只依赖于单个<code>CompletableFuture</code>时，就属于一元依赖的情况。在这种情况下，我们可以使用<code>thenApply</code>、<code>thenAccept</code>、<code>thenCompose</code>等方法。例如，<code>thenApply</code>方法接收一个函数作为参数，当依赖的<code>CompletableFuture</code>完成时，会将其结果作为参数传递给这个函数进行处理，并返回一个新的<code>CompletableFuture</code>，这个新的<code>CompletableFuture</code>的结果就是函数处理后的返回值。<code>thenAccept</code>方法则是在依赖的<code>CompletableFuture</code>完成时，接收其结果进行处理，但不返回新的结果。<code>thenCompose</code>方法与<code>thenApply</code>类似，不过它接收的函数返回值是一个<code>CompletableFuture</code>，这样可以方便地将多个异步操作进行链式组合。</p><h3 id="二元依赖">二元依赖</h3><p>如果我们的任务依赖于两个<code>CompletableFuture</code>，那么可以使用<code>thenCombine</code>等回调方法来实现。<code>thenCombine</code>方法会等待两个<code>CompletableFuture</code>都完成后，将它们的结果作为参数传递给指定的函数进行处理，最终返回一个新的<code>CompletableFuture</code>，其结果是函数处理后的返回值。这种方式可以让我们在两个异步操作都完成后，对它们的结果进行整合处理。</p><h3 id="多元依赖">多元依赖</h3><p>当任务依赖于多个<code>CompletableFuture</code>时，也就是多元依赖的情况。我们可以通过<code>allOf</code>或<code>anyOf</code>方法来实现。<code>allOf</code>方法会等待所有传入的<code>CompletableFuture</code>都完成后才返回，而<code>anyOf</code>方法则是只要有一个传入的<code>CompletableFuture</code>完成就会返回，返回的结果是第一个完成的<code>CompletableFuture</code>的结果。</p><h2 id="三、CompletableFuture的原理">三、CompletableFuture的原理</h2><h3 id="内部字段">内部字段</h3><p><code>CompletableFuture</code>内部包含两个重要字段：<code>result</code>和<code>stack</code> 。<code>result</code>用于存储异步计算的结果，而<code>stack</code>则在处理依赖关系和通知观察者等过程中发挥着关键作用。</p><h3 id="观察者与被观察者模式">观察者与被观察者模式</h3><p><code>CompletableFuture</code>的工作原理类似于观察者与被观察者模式。例如，当我们调用<code>CompletableFuture.allOf(cf1, cf2, cf3)</code>时，这里的<code>cf1</code>、<code>cf2</code>、<code>cf3</code>就是被观察者，而调用<code>allOf</code>方法返回的<code>CompletableFuture</code>（假设为<code>CF</code> ）就是观察者。在执行过程中，<code>CF</code>会先把自己注册到<code>cf1</code>、<code>cf2</code>、<code>cf3</code>中成为观察者。当<code>cf1</code>执行完成后，它会将自己的结果保存在自身内部，同时根据<code>stack</code>中的信息去提醒观察者。只有当所有被观察者（<code>cf1</code>、<code>cf2</code>、<code>cf3</code> ）都执行完成后，观察者<code>CF</code>才会将最终的结果保存到自己的<code>result</code>字段中。</p><h2 id="四、CompletableFuture中的线程问题">四、CompletableFuture中的线程问题</h2><h3 id="代码运行线程">代码运行线程</h3><p>在<code>CompletableFuture</code>中，代码运行在哪个线程上，需要区分同步方法和异步方法。</p><ul><li><p><strong>同步方法（即不带Async后缀的方法）</strong>：如果在注册时，被依赖的操作已经执行完成，那么同步方法会直接由当前线程执行；如果注册时被依赖的操作还未执行完，那么同步方法会由回调线程执行。</p></li><li><p><strong>异步方法（即带Async后缀的方法）</strong>：我们可以选择是否传递线程池参数<code>Executor</code>来让异步方法运行在指定的线程池中。当不传递<code>Executor</code>时，会使用<code>ForkJoinPool</code>中的共用线程池<code>CommonPool</code> 。需要注意的是，<code>CommonPool</code>的大小是CPU核数 - 1，如果应用是IO密集型的，线程数可能会成为性能瓶颈。</p></li></ul><h3 id="线程池相关问题">线程池相关问题</h3><ul><li><p><strong>异步回调要传线程池</strong>：由于<code>CommonPool</code>的大小有限，在一些高并发或IO密集型的场景下，可能无法满足需求。因此，在进行异步回调时，我们需要考虑传递合适的线程池参数，以避免线程资源不足的问题。</p></li><li><p><strong>线程池循环引用会导致死锁</strong>：在使用线程池时，如果出现循环引用的情况，就可能会导致死锁。比如，一个任务依赖另一个任务，而这两个任务又分别在不同的线程池中执行，且存在相互等待的情况，就可能会陷入死锁状态。</p></li><li><p><strong>异步RPC调用注意不要阻塞IO线程池</strong>：在进行异步RPC调用时，要特别注意不要阻塞IO线程池。因为IO线程池通常用于处理网络IO等操作，如果被阻塞，可能会影响整个系统的IO性能，导致响应延迟等问题。</p></li></ul><h2 id="五、设置超时时间">五、设置超时时间</h2><p>在实际应用中，我们常常需要为异步操作设置超时时间，以避免长时间等待。在<code>CompletableFuture</code>中，可以使用<code>applyToEither</code>方法来判断是计算先完成还是先超时。具体实现方式是启动一个<code>ScheduledThreadpoolExecutor</code>线程，在指定的<code>timeout</code>时间后，直接调用<code>CompletableFuture.completeExceptionally(new TimeoutException())</code> ，这样当超过指定时间还未完成计算时，就会抛出<code>TimeoutException</code>异常，从而让我们可以对超时情况进行相应的处理。</p><h2 id="六、使用">六、使用</h2><p>在实习的时候第一次用到了<code>CompletableFuture</code>，那个时候做的是一个官网的文档导出，先下载静态资源文件，下载完之后对其进行打包，再对所有文件进行打包，最后通过邮件发送给管理员，实现一个官网文档私有化的功能。</p><h3 id="流程图：">流程图：</h3><p><img src="2025-03-19-CompletableFuture%E5%8E%9F%E7%90%86%E5%8F%8A%E5%85%B6%E4%BD%BF%E7%94%A8/image-20250419190430184-5060677-5060680.png" alt="image-20250419190430184"></p><h3 id="回忆版伪代码：">回忆版伪代码：</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line"><span class="keyword">import</span> java.util.concurrent.CompletableFuture;</span><br><span class="line"><span class="keyword">import</span> java.util.concurrent.ExecutorService;</span><br><span class="line"><span class="keyword">import</span> java.util.concurrent.Executors;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 假设这些是下载和打包相关的方法，实际使用中需根据具体实现替换</span></span><br><span class="line"><span class="comment">// 下载html文件</span></span><br><span class="line"><span class="keyword">public</span> CompletableFuture&lt;String&gt; <span class="title function_">downloadHtmlFile</span><span class="params">(String documentName)</span> &#123;</span><br><span class="line">    <span class="comment">// 实际下载逻辑，这里返回一个CompletableFuture表示异步操作</span></span><br><span class="line">    <span class="keyword">return</span> CompletableFuture.supplyAsync(() -&gt; &#123;</span><br><span class="line">        <span class="comment">// 模拟下载操作，返回下载后的文件内容或路径等相关信息</span></span><br><span class="line">        <span class="keyword">return</span> <span class="string">&quot;downloaded_html_file_path_for_&quot;</span> + documentName;</span><br><span class="line">    &#125;, executorService);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 下载图片文件</span></span><br><span class="line"><span class="keyword">public</span> CompletableFuture&lt;String&gt; <span class="title function_">downloadImageFile</span><span class="params">(String documentName)</span> &#123;</span><br><span class="line">    <span class="keyword">return</span> CompletableFuture.supplyAsync(() -&gt; &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="string">&quot;downloaded_image_file_path_for_&quot;</span> + documentName;</span><br><span class="line">    &#125;, executorService);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 下载CSS文件</span></span><br><span class="line"><span class="keyword">public</span> CompletableFuture&lt;String&gt; <span class="title function_">downloadCssFile</span><span class="params">(String documentName)</span> &#123;</span><br><span class="line">    <span class="keyword">return</span> CompletableFuture.supplyAsync(() -&gt; &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="string">&quot;downloaded_css_file_path_for_&quot;</span> + documentName;</span><br><span class="line">    &#125;, executorService);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 打包文件</span></span><br><span class="line"><span class="keyword">public</span> CompletableFuture&lt;String&gt; <span class="title function_">packFiles</span><span class="params">(String[] filePaths)</span> &#123;</span><br><span class="line">    <span class="keyword">return</span> CompletableFuture.supplyAsync(() -&gt; &#123;</span><br><span class="line">        <span class="comment">// 实际打包逻辑，返回打包后的文件路径等相关信息</span></span><br><span class="line">        <span class="keyword">return</span> <span class="string">&quot;packed_file_path_for_&quot;</span> + filePaths[<span class="number">0</span>];</span><br><span class="line">    &#125;, executorService);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 发送邮件</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">sendEmail</span><span class="params">(String packedFilePath)</span> &#123;</span><br><span class="line">    <span class="comment">// 实际发送邮件逻辑</span></span><br><span class="line">    System.out.println(<span class="string">&quot;Sending email with file: &quot;</span> + packedFilePath);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Main</span> &#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="type">ExecutorService</span> <span class="variable">executorService</span> <span class="operator">=</span> Executors.newFixedThreadPool(<span class="number">10</span>);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">        <span class="comment">// 假设这里有n个文档，以数组形式表示文档名</span></span><br><span class="line">        String[] documentNames = &#123;<span class="string">&quot;document1&quot;</span>, <span class="string">&quot;document2&quot;</span>, <span class="string">&quot;document3&quot;</span>&#125;; </span><br><span class="line">        CompletableFuture[] allDownloadFutures = <span class="keyword">new</span> <span class="title class_">CompletableFuture</span>[documentNames.length];</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i &lt; documentNames.length; i++) &#123;</span><br><span class="line">            <span class="type">String</span> <span class="variable">documentName</span> <span class="operator">=</span> documentNames[i];</span><br><span class="line">            CompletableFuture&lt;String&gt; htmlFuture = downloadHtmlFile(documentName);</span><br><span class="line">            CompletableFuture&lt;String&gt; imageFuture = downloadImageFile(documentName);</span><br><span class="line">            CompletableFuture&lt;String&gt; cssFuture = downloadCssFile(documentName);</span><br><span class="line"></span><br><span class="line">            CompletableFuture[] subFutures = &#123;htmlFuture, imageFuture, cssFuture&#125;;</span><br><span class="line">            CompletableFuture&lt;String&gt; packFuture = CompletableFuture.allOf(subFutures)</span><br><span class="line">                   .thenApply(v -&gt; &#123;</span><br><span class="line">                        <span class="keyword">try</span> &#123;</span><br><span class="line">                            String[] filePaths = &#123;htmlFuture.get(), imageFuture.get(), cssFuture.get()&#125;;</span><br><span class="line">                            <span class="keyword">return</span> packFiles(filePaths).get();</span><br><span class="line">                        &#125; <span class="keyword">catch</span> (Exception e) &#123;</span><br><span class="line">                            e.printStackTrace();</span><br><span class="line">                            <span class="keyword">return</span> <span class="literal">null</span>;</span><br><span class="line">                        &#125;</span><br><span class="line">                    &#125;);</span><br><span class="line">            allDownloadFutures[i] = packFuture;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        CompletableFuture.allOf(allDownloadFutures)</span><br><span class="line">               .thenRun(() -&gt; &#123;</span><br><span class="line">                    <span class="keyword">try</span> &#123;</span><br><span class="line">                        <span class="keyword">for</span> (CompletableFuture&lt;String&gt; packFuture : allDownloadFutures) &#123;</span><br><span class="line">                            <span class="type">String</span> <span class="variable">packedFilePath</span> <span class="operator">=</span> packFuture.get();</span><br><span class="line">                            sendEmail(packedFilePath);</span><br><span class="line">                        &#125;</span><br><span class="line">                    &#125; <span class="keyword">catch</span> (Exception e) &#123;</span><br><span class="line">                        e.printStackTrace();</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125;);</span><br><span class="line"></span><br><span class="line">        executorService.shutdown();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">### 代码说明</span></span><br><span class="line"><span class="comment">1. **线程池初始化**：创建一个固定大小为10的线程池`executorService`，用于执行异步任务。</span></span><br><span class="line"><span class="comment">2. **下载任务**：定义了`downloadHtmlFile`、`downloadImageFile`、`downloadCssFile`三个方法，分别用于异步下载html、图片和CSS文件，每个方法返回一个`CompletableFuture`。</span></span><br><span class="line"><span class="comment">3. **打包任务**：`packFiles`方法用于将下载的文件进行打包，同样返回一个`CompletableFuture`。</span></span><br><span class="line"><span class="comment">4. **发送邮件**：`sendEmail`方法用于发送包含打包文件的邮件。</span></span><br><span class="line"><span class="comment">5. **主流程**：遍历文档名数组，对每个文档分别发起html、图片和CSS文件的下载任务，通过`CompletableFuture.allOf`等待这些子任务完成后进行打包。所有文档打包完成后，再通过`CompletableFuture.allOf`等待所有打包任务完成，最后依次发送邮件。</span></span><br><span class="line"><span class="comment">6. **线程池关闭**：在所有任务完成后，关闭线程池。 </span></span><br><span class="line"><span class="comment">*/</span></span><br></pre></td></tr></table></figure><h3 id="其它方式实现：">其它方式实现：</h3><ul><li><p><strong>FutureTask</strong>：实现<code>Future</code>与<code>Runnable</code>接口，包装<code>Callable</code>或<code>Runnable</code>对象执行异步任务，能获取结果，但<code>get</code>方法会阻塞，轮询检查又消耗CPU，且任务编排能力有限。 </p></li><li><p><strong>线程池结合Runnable/Callable</strong>：利用<code>ExecutorService</code>创建线程池，提交<code>Runnable</code>（无返回值）或<code>Callable</code>（有返回值）任务执行，可控制线程数量、提高资源利用率，但复杂任务编排时代码较复杂，需手动处理任务顺序与结果传递。 </p></li><li><p><strong>Guava的ListenableFuture</strong>：扩展Java标准<code>Future</code>接口，通过<code>Futures.addCallback()</code>添加回调函数，任务完成时自动触发，避免阻塞，但引入库依赖，处理复杂任务组合不如<code>CompletableFuture</code>直观。 </p></li></ul><h2 id="总结：">总结：</h2><ul><li><p><strong>接口实现</strong>：<code>CompletableFuture</code>实现<code>Future</code>和<code>CompletionStage</code>接口，前者表示异步计算结果，后者可对异步步骤编排组合，提供<code>thenApply</code>等函数式编程方法。</p></li><li><p><strong>依赖关系</strong>：分一元、二元和多元依赖。一元依赖用<code>thenApply</code>等处理单个<code>CompletableFuture</code>；二元依赖通过<code>thenCombine</code>整合两个结果；多元依赖用<code>allOf</code>或<code>anyOf</code>处理多个。</p></li><li><p><strong>原理</strong>：含<code>result</code>（存结果）和<code>stack</code>字段，基于观察者与被观察者模式，被观察者完成时按<code>stack</code>信息通知观察者处理结果。</p></li><li><p><strong>线程问题</strong>：同步方法依依赖操作状态由当前或回调线程执行；异步方法可指定线程池，否则用<code>CommonPool</code>，但在IO密集场景线程数可能成瓶颈。还提及线程池使用注意点，如异步回调传线程池、避免循环引用死锁、异步RPC不阻塞IO线程池。</p></li><li><p><strong>超时设置</strong>：用<code>applyToEither</code>结合<code>ScheduledThreadpoolExecutor</code>实现，超时抛<code>TimeoutException</code>。 </p></li></ul><blockquote><p><a href="https://tech.meituan.com/2022/05/12/principles-and-practices-of-completablefuture.html">CompletableFuture原理与实践-外卖商家端API的异步化</a></p><p><a href="https://blog.csdn.net/u013905744/article/details/109134516">java8中CompletableFuture异步处理超时的方法_completablefuture 超时-CSDN博客</a></p></blockquote>]]></content>
    
    
    <summary type="html">🥧CompletableFuture原理及其使用</summary>
    
    
    
    <category term="学习" scheme="https://outoflovenicoo.github.io/categories/%E5%AD%A6%E4%B9%A0/"/>
    
    
    <category term="JUC" scheme="https://outoflovenicoo.github.io/tags/JUC/"/>
    
    <category term="原理" scheme="https://outoflovenicoo.github.io/tags/%E5%8E%9F%E7%90%86/"/>
    
  </entry>
  
  <entry>
    <title>算法模板总结</title>
    <link href="https://outoflovenicoo.github.io/posts/2025-03-12-%E7%AE%97%E6%B3%95%E6%A8%A1%E6%9D%BF%E6%80%BB%E7%BB%93.html"/>
    <id>https://outoflovenicoo.github.io/posts/2025-03-12-%E7%AE%97%E6%B3%95%E6%A8%A1%E6%9D%BF%E6%80%BB%E7%BB%93.html</id>
    <published>2025-03-12T10:19:03.000Z</published>
    <updated>2025-04-13T14:00:00.000Z</updated>
    
    <content type="html"><![CDATA[<h1>1.树算法</h1><p><a href="https://blog.csdn.net/sinat_39377093/article/details/141069217?ops_request_misc=%257B%2522request%255Fid%2522%253A%25223d2890518563c1027b9d4e253d57f34a%2522%252C%2522scm%2522%253A%252220140713.130102334..%2522%257D&amp;request_id=3d2890518563c1027b9d4e253d57f34a&amp;biz_id=0&amp;utm_medium=distribute.pc_search_result.none-task-blog-2~all~sobaiduend~default-1-141069217-null-null.142%5Ev101%5Epc_search_result_base3&amp;utm_term=%E6%A0%91%E7%AE%97%E6%B3%95%E6%80%BB%E7%BB%93&amp;spm=1018.2226.3001.4187">数据结构与算法总结——树_数据结构与算法树-CSDN博客</a></p><h1>1.回溯法</h1><h2 id="（1）大致思路">（1）大致思路</h2><p>用一个 path 数组记录路径上的字母。</p><p><strong>回溯三问：</strong></p><ul><li><p>当前操作？枚举 path [i] 要填入的字母</p></li><li><p>子问题？构造字符串≥i 的部分</p></li><li><p>下一个子问题？构造字符串≥i + 1 的部分<br>dfs (i) → dfs (i + 1)</p></li></ul><h2 id="（2）子集型回溯—选或不选">（2）子集型回溯—选或不选</h2><p><a href="https://leetcode.cn/problems/subsets/description/">78. 子集 - 力扣（LeetCode）</a></p><p><a href="https://leetcode.cn/problems/palindrome-partitioning/description/">131. 分割回文串 - 力扣（LeetCode）</a></p><p><a href="https://leetcode.cn/problems/letter-combinations-of-a-phone-number/description/">17. 电话号码的字母组合 - 力扣（LeetCode）</a></p><p><img src="2025-03-12-%E7%AE%97%E6%B3%95%E6%A8%A1%E6%9D%BF%E6%80%BB%E7%BB%93/image-9.png" alt=""></p><h2 id="（3）组合类回溯—没顺序，需要去重">（3）组合类回溯—没顺序，需要去重</h2><p><img src="2025-03-12-%E7%AE%97%E6%B3%95%E6%A8%A1%E6%9D%BF%E6%80%BB%E7%BB%93/image-10.png" alt=""></p><h2 id="（4）排列型回溯—有顺序，要用额外数组">（4）排列型回溯—有顺序，要用额外数组</h2><p><img src="2025-03-12-%E7%AE%97%E6%B3%95%E6%A8%A1%E6%9D%BF%E6%80%BB%E7%BB%93/image-7.png" alt=""></p><p><img src="2025-03-12-%E7%AE%97%E6%B3%95%E6%A8%A1%E6%9D%BF%E6%80%BB%E7%BB%93/image-5.png" alt=""></p><h1>2.二分法</h1><blockquote><p>核心就是找一个区间（开闭区间）与target的关系</p></blockquote><p>⭐️:找到要分的东西，不一定是数组下标</p><h2 id="①找-、-、-、">①找&gt;=、&gt;、&lt;=、&lt;</h2><p><a href="https://leetcode.cn/problems/find-first-and-last-position-of-element-in-sorted-array/description/">34. 在排序数组中查找元素的第一个和最后一个位置 - 力扣（LeetCode）</a></p><p><a href="https://leetcode.cn/problems/find-peak-element/description/">162. 寻找峰值 - 力扣（LeetCode）</a></p><p>⭐️开区间写法，很牛叉</p><p><a href="https://leetcode.cn/problems/range-frequency-queries/submissions/600459253/">2080. 区间内查询数字的频率 - 力扣（LeetCode）</a></p><h2 id="②「最大化最小值」或者「最小化最大值」">②「最大化最小值」或者「最小化最大值」</h2><p><a href="https://leetcode.cn/problems/maximum-tastiness-of-candy-basket/solutions/2031994/er-fen-da-an-by-endlesscheng-r418/">2517. 礼盒的最大甜蜜度 - 力扣（LeetCode）</a></p><p><a href="https://leetcode.cn/problems/magnetic-force-between-two-balls/description/?envType=daily-question&amp;envId=2025-02-14">1552. 两球之间的磁力 - 力扣（LeetCode）</a></p><h1>3.滑动窗口</h1><h2 id="定长滑动窗口">定长滑动窗口</h2><p>入-&gt;更新-&gt;出</p><p><a href="https://leetcode.cn/problems/maximum-number-of-vowels-in-a-substring-of-given-length/">1456. 定长子串中元音的最大数目</a></p><h2 id="不定长滑动窗口">不定长滑动窗口</h2><p>不定长滑动窗口主要分为三类：求最长子数组，求最短子数组，以及求子数组个数。</p><p>✅求最长子数组：入-&gt;判断（使用while缩小范围）-&gt;更新</p><p><a href="https://leetcode.cn/problems/maximum-length-substring-with-two-occurrences/">3090. 每个字符最多出现两次的最长子字符串</a></p><p>✅求最短子数组：入-&gt;判断（使用while缩小范围）-&gt;更新</p><p><a href="https://leetcode.cn/problems/minimum-size-subarray-sum/">209. 长度最小的子数组</a></p><p>✅求子数组的个数</p><p><a href="https://leetcode.cn/problems/subarray-product-less-than-k/">713. 乘积小于 K 的子数组</a></p><h2 id="多指针">多指针</h2><p><a href="https://leetcode.cn/problems/binary-subarrays-with-sum/">930. 和相同的二元子数组</a></p><h1>4.记忆化搜索</h1><p><a href="https://leetcode.cn/problems/length-of-longest-v-shaped-diagonal-segment/description/">3459. 最长 V 形对角线段的长度 - 力扣（LeetCode）</a></p><p>记忆化搜索的记忆化可以用map，也可以用数组，本题用map会超时</p><h1>5.数据结构</h1><h2 id="单调栈">单调栈</h2><p>单纯的单调栈并不难。难的是怎么用，在哪里用</p><p><a href="https://leetcode.cn/problems/largest-rectangle-in-histogram/">84. 柱状图中最大的矩形</a></p><blockquote><p>本题关键在于如何快速找到<strong>每个柱子的左边和右边第一个比它小的下标</strong>。</p><p><strong>单调栈的性质</strong>：</p><ul><li><p>单调栈可以帮助我们在一次遍历中快速确定“下一个更小”的元素。</p></li><li><p>具体来说，当我们从左向右扫描时，我们希望栈内的元素是单调递增的；一旦遇到一个较小的值，就说明栈顶的元素找到了右边界。</p></li><li><p>同理，从右向左扫描时也可以得到每个柱子的左边界。<br>这种“下一个更小元素”的问题，在算法题中非常常见，使用单调栈是经典方法。当你看到需要在一维数组中寻找每个位置的左右边界问题，就很容易联想到单调栈。</p></li></ul><p><strong>单调栈用于解决找上一个更小/上一个更大的元素</strong></p><p>找上一个更大的元素（把更小的弹出）：是单调递减栈，如：<a href="https://leetcode.cn/problems/daily-temperatures/description/?envType=study-plan-v2&amp;envId=top-100-liked">739. 每日温度 - 力扣（LeetCode）</a></p><p>找上一个更小的元素（把更大的弹出）：是单调递增栈，如：<a href="https://leetcode.cn/problems/largest-rectangle-in-histogram/description/?envType=study-plan-v2&amp;envId=top-100-liked">84. 柱状图中最大的矩形 - 力扣（LeetCode）</a></p></blockquote><h2 id="并查集">并查集</h2><p> <a href="https://www.bilibili.com/video/BV1jv411a7LK/?share_source=copy_web&amp;vd_source=ec71810e8cb652d640f76be4d4d0878e">图论——并查集(详细版)_哔哩哔哩_bilibili</a></p><blockquote><p>处理不相交集合的合并问题,并查集常用来解决连通性问题。</p><p>大白话就是当我们需要判断两个元素是否在同一个集合里的时候，我们就要想到用并查集。</p></blockquote><h1>6.图论算法</h1><h2 id="①DFS模板">①DFS模板</h2><p><a href="https://leetcode.cn/problems/number-of-islands/">200. 岛屿数量</a></p><h2 id="②BFS模板">②BFS模板</h2><p><a href="https://leetcode.cn/problems/rotting-oranges/">994. 腐烂的橘子</a></p><h1>7.位运算</h1><h2 id="快速幂模板">快速幂模板</h2><h1>8.常用数据结构（前缀和/差分/栈/队列/堆/字典树/并查集/树状数组/线段树）</h1><p><a href="https://leetcode.cn/circle/discuss/mOr1u6/">分享丨【题单】常用数据结构（前缀和/差分/栈/队列/堆/字典树/并查集/树状数组/线段树） - 力扣（LeetCode）</a></p><h1>9.动态规划</h1><h2 id="9-1背包问题">9.1背包问题</h2><h3 id="（1）01背包（只能选一次）">（1）01背包（只能选一次）</h3><p>0-1 背包：有 n 个物品，第 i 个物品的体积为 w[i]，价值为 v[i]，每个物品至多选一个，求体积和不超过 capacity 时的最大价值和 </p><p><img src="2025-03-12-%E7%AE%97%E6%B3%95%E6%A8%A1%E6%9D%BF%E6%80%BB%E7%BB%93/image-8.png" alt=""></p><p><img src="2025-03-12-%E7%AE%97%E6%B3%95%E6%A8%A1%E6%9D%BF%E6%80%BB%E7%BB%93/image-6.png" alt=""></p><h3 id="（2）完全背包（完全任意选）">（2）完全背包（完全任意选）</h3><p><img src="2025-03-12-%E7%AE%97%E6%B3%95%E6%A8%A1%E6%9D%BF%E6%80%BB%E7%BB%93/image-4.png" alt=""></p><p>每种物品可以任意选，所以这里不是递归到i-1而是递归到i</p><p><img src="2025-03-12-%E7%AE%97%E6%B3%95%E6%A8%A1%E6%9D%BF%E6%80%BB%E7%BB%93/image-3.png" alt=""></p><p>从前往后遍历不会覆盖</p><h3 id="（3）常见变形-01背包">（3）常见变形(01背包)</h3><p>正好为target:</p><p><img src="2025-03-12-%E7%AE%97%E6%B3%95%E6%A8%A1%E6%9D%BF%E6%80%BB%E7%BB%93/image-2.png" alt=""></p><p>至多为target</p><p><img src="2025-03-12-%E7%AE%97%E6%B3%95%E6%A8%A1%E6%9D%BF%E6%80%BB%E7%BB%93/image-20250420194647355.png" alt="image-20250420194647355"></p><p>至少为target</p><p><img src="2025-03-12-%E7%AE%97%E6%B3%95%E6%A8%A1%E6%9D%BF%E6%80%BB%E7%BB%93/image.png" alt=""></p>]]></content>
    
    
    <summary type="html">🥧本人的算法模板总结</summary>
    
    
    
    <category term="算法" scheme="https://outoflovenicoo.github.io/categories/%E7%AE%97%E6%B3%95/"/>
    
    
    <category term="算法" scheme="https://outoflovenicoo.github.io/tags/%E7%AE%97%E6%B3%95/"/>
    
  </entry>
  
  <entry>
    <title>SoundMentor-组织管理相关</title>
    <link href="https://outoflovenicoo.github.io/posts/2025-03-10-SoundMentor-%E7%BB%84%E7%BB%87%E7%AE%A1%E7%90%86%E7%9B%B8%E5%85%B3.html"/>
    <id>https://outoflovenicoo.github.io/posts/2025-03-10-SoundMentor-%E7%BB%84%E7%BB%87%E7%AE%A1%E7%90%86%E7%9B%B8%E5%85%B3.html</id>
    <published>2025-03-10T10:19:03.000Z</published>
    <updated>2025-03-10T14:00:00.000Z</updated>
    
    <content type="html"><![CDATA[<h2 id="1-组织相关的表">1.组织相关的表</h2><p><img src="2025-03-10-SoundMentor-%E7%BB%84%E7%BB%87%E7%AE%A1%E7%90%86%E7%9B%B8%E5%85%B3/image-1.png" alt=""></p><p><strong>通过RBAC控制组织权限</strong></p><p><img src="2025-03-10-SoundMentor-%E7%BB%84%E7%BB%87%E7%AE%A1%E7%90%86%E7%9B%B8%E5%85%B3/image.png" alt=""></p><p><img src="2025-03-10-SoundMentor-%E7%BB%84%E7%BB%87%E7%AE%A1%E7%90%86%E7%9B%B8%E5%85%B3/diagram.png" alt=""></p><h2 id="2-通过分享码加入组织">2.通过分享码加入组织</h2><p>这里用乐观锁，防止高并发下的人员溢出</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 通过分享码进入组织</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param</span> dto</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="meta">@Override</span></span><br><span class="line"><span class="meta">@Transactional(rollbackFor = Exception.class)</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">join</span><span class="params">(JoinOrganizationDTO dto)</span> &#123;</span><br><span class="line">    <span class="type">String</span> <span class="variable">shareCode</span> <span class="operator">=</span> dto.getShareCode();</span><br><span class="line">    <span class="type">Integer</span> <span class="variable">organizationId</span> <span class="operator">=</span> dto.getOrganizationId();</span><br><span class="line">    <span class="type">String</span> <span class="variable">s</span> <span class="operator">=</span> redisTemplate.opsForValue().get(SoundMentorConstant.ORGANIZATION_SHARE_CODE_KEY + organizationId);</span><br><span class="line">    <span class="keyword">if</span>(Objects.isNull(s))</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">throw</span> <span class="keyword">new</span> <span class="title class_">BizException</span>(ResultCodeEnum.INVALID_PARAM.getCode(),<span class="string">&quot;分享码不存在或已经失效&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span>(!StringUtils.equals(shareCode,s))</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">throw</span> <span class="keyword">new</span> <span class="title class_">BizException</span>(ResultCodeEnum.INVALID_PARAM.getCode(),<span class="string">&quot;分享码不正确&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="type">OrganizationDO</span> <span class="variable">organization</span> <span class="operator">=</span> <span class="built_in">this</span>.getById(organizationId);</span><br><span class="line">    <span class="keyword">if</span>(Objects.isNull(organization))</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">throw</span> <span class="keyword">new</span> <span class="title class_">BizException</span>(ResultCodeEnum.INVALID_PARAM.getCode(),<span class="string">&quot;组织不存在&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="type">OrganizationUserDO</span> <span class="variable">one</span> <span class="operator">=</span> ouService.lambdaQuery()</span><br><span class="line">            .eq(OrganizationUserDO::getOrganizationId, organizationId)</span><br><span class="line">            .eq(OrganizationUserDO::getUserId, userInfoApi.getUser().getId())</span><br><span class="line">            .one();</span><br><span class="line">    <span class="keyword">if</span> (!Objects.isNull(one))</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">throw</span> <span class="keyword">new</span> <span class="title class_">BizException</span>(ResultCodeEnum.INTERNAL_ERROR.getCode(),<span class="string">&quot;您已经加入该组织&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="type">boolean</span> <span class="variable">update</span> <span class="operator">=</span> <span class="built_in">this</span>.lambdaUpdate()</span><br><span class="line">            .setSql(<span class="string">&quot;spare_capacity=spare_capacity-1&quot;</span>)</span><br><span class="line">            .eq(OrganizationDO::getId, organizationId)</span><br><span class="line">            .gt(OrganizationDO::getSpareCapacity, <span class="number">0</span>)</span><br><span class="line">            .update();</span><br><span class="line">    <span class="keyword">if</span>(!update)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">throw</span> <span class="keyword">new</span> <span class="title class_">BizException</span>(ResultCodeEnum.INTERNAL_ERROR.getCode(),<span class="string">&quot;组织容量已满&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="type">OrganizationUserDO</span> <span class="variable">organizationUserDO</span> <span class="operator">=</span> OrganizationUserDO.builder()</span><br><span class="line">            .organizationId(organizationId)</span><br><span class="line">            .userId(userInfoApi.getUser().getId())</span><br><span class="line">            .organizationRole(OrganizationRole.USER.getCode())</span><br><span class="line">            .createTime(LocalDateTime.now())</span><br><span class="line">            .build();</span><br><span class="line">    ouService.save(organizationUserDO);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
    
    
    <summary type="html">🥧SoundMentor-组织管理相关</summary>
    
    
    
    <category term="项目" scheme="https://outoflovenicoo.github.io/categories/%E9%A1%B9%E7%9B%AE/"/>
    
    
    <category term="项目" scheme="https://outoflovenicoo.github.io/tags/%E9%A1%B9%E7%9B%AE/"/>
    
  </entry>
  
  <entry>
    <title>SoundMentor-多线程优化PPT任务执行</title>
    <link href="https://outoflovenicoo.github.io/posts/2025-03-10-SoundMentor-%E5%A4%9A%E7%BA%BF%E7%A8%8B%E4%BC%98%E5%8C%96PPT%E4%BB%BB%E5%8A%A1%E6%89%A7%E8%A1%8C.html"/>
    <id>https://outoflovenicoo.github.io/posts/2025-03-10-SoundMentor-%E5%A4%9A%E7%BA%BF%E7%A8%8B%E4%BC%98%E5%8C%96PPT%E4%BB%BB%E5%8A%A1%E6%89%A7%E8%A1%8C.html</id>
    <published>2025-03-10T10:19:03.000Z</published>
    <updated>2025-03-10T14:00:00.000Z</updated>
    
    <content type="html"><![CDATA[<p><strong>在最近做的ai语音合成项目中，有一个需求是：用户上传ppt，用ppt的url请求创建ppt讲解合成任务，这里需要关联用户和ppt，还需要下载解析ppt，拿到每一页做处理，并解析出每一页的内容向mq发送消息异步请求python大模型，还需做任务，ppt详情入库操作。</strong></p><p>这里一个ppt会有很多页，每一页都需要做两次数据库操作加mq消息发送，如果页码较多，那响应速度会很慢，所以这里引入一个自定义的单例线程池bean，通过线程池来并发执行每一页的任务，加速任务的执行，并且每页的任务异步执行，不阻塞主线程，且能减少线程开销，控制线程资源。</p><h2 id="自定义线程池">自定义线程池</h2><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Configuration</span></span><br><span class="line"><span class="meta">@Slf4j</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">ThreadPoolConfig</span> &#123;</span><br><span class="line">    <span class="meta">@Bean(&quot;task-thread-pool-executor&quot;)</span></span><br><span class="line">    <span class="keyword">public</span> ThreadPoolExecutor <span class="title function_">threadPoolExecutor</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="type">ThreadPoolExecutor</span> <span class="variable">threadPoolExecutor</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">ThreadPoolExecutor</span>(</span><br><span class="line">                <span class="number">10</span>,</span><br><span class="line">                <span class="number">50</span>,</span><br><span class="line">                <span class="number">60</span>,</span><br><span class="line">                TimeUnit.SECONDS,</span><br><span class="line">                <span class="keyword">new</span> <span class="title class_">ArrayBlockingQueue</span>&lt;Runnable&gt;(<span class="number">300</span>),</span><br><span class="line">                (r, executor) -&gt; &#123;</span><br><span class="line">                    log.info(<span class="string">&quot;线程池已满，任务&#123;&#125;,被丢弃&quot;</span>, r.toString());</span><br><span class="line">                &#125;</span><br><span class="line">        );</span><br><span class="line">        <span class="keyword">return</span> threadPoolExecutor;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="创建ppt讲解生成任务"><em>创建ppt讲解生成任务</em></h2><p>如果不采用多线程的方式，每次执行任务操作两次数据库 + mq发送，ppt页码一多可能就会很慢，采用多线程能优化它的执行速度。在经过测试后，发现用线程池比直接串行提高了50%的响应速度</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 创建ppt讲解生成任务</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param</span> param</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@return</span></span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="meta">@Override</span></span><br><span class="line"><span class="keyword">public</span> Integer <span class="title function_">createPPTSummary</span><span class="params">(CreatePPTSummaryTaskParam param)</span> &#123;</span><br><span class="line">    <span class="type">String</span> <span class="variable">pptUrl</span> <span class="operator">=</span> param.getPptUrl();</span><br><span class="line">    <span class="type">XMLSlideShow</span> <span class="variable">xmlSlideShow</span> <span class="operator">=</span> PPTXUtil.loadPPTX(pptUrl);</span><br><span class="line">    List&lt;XSLFSlide&gt; slides = xmlSlideShow.getSlides();</span><br><span class="line">    <span class="type">UserPptRelDO</span> <span class="variable">userPptRelDO</span> <span class="operator">=</span> userPptRelMapper.selectOne(<span class="keyword">new</span> <span class="title class_">LambdaQueryWrapper</span>&lt;UserPptRelDO&gt;()</span><br><span class="line">            .eq(UserPptRelDO::getPptUrl, pptUrl)</span><br><span class="line">            .eq(UserPptRelDO::getUserId, userInfoApi.getUser().getId()));</span><br><span class="line">    <span class="keyword">if</span> (Objects.isNull(userPptRelDO))</span><br><span class="line">    &#123;</span><br><span class="line">        userPptRelDO = <span class="keyword">new</span> <span class="title class_">UserPptRelDO</span>();</span><br><span class="line">        userPptRelDO.setPptUrl(pptUrl);</span><br><span class="line">        userPptRelDO.setUserId(userInfoApi.getUser().getId());</span><br><span class="line">        userPptRelDO.setPageCount(slides.size());</span><br><span class="line">        userPptRelDO.setCreateTime(LocalDateTime.now());</span><br><span class="line">        userPptRelMapper.insert(userPptRelDO);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i &lt; slides.size(); i++) &#123;</span><br><span class="line">        <span class="type">Integer</span> <span class="variable">userPptId</span> <span class="operator">=</span> userPptRelDO.getId();</span><br><span class="line">        <span class="type">Integer</span> <span class="variable">page</span> <span class="operator">=</span> i;</span><br><span class="line">        <span class="type">XSLFSlide</span> <span class="variable">slide</span> <span class="operator">=</span> slides.get(page);</span><br><span class="line">        threadPoolExecutor.execute(()-&gt;&#123;</span><br><span class="line">            <span class="keyword">try</span> &#123;</span><br><span class="line">                taskExec(userPptId,page,slide);</span><br><span class="line">            &#125; <span class="keyword">catch</span> (Exception e) &#123;</span><br><span class="line">                log.error(<span class="string">&quot;ppt&#123;&#125;的&#123;&#125;页任务执行失败,请重试&quot;</span>,userPptId,page);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> userPptRelDO.getId();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="PPT讲解任务执行">PPT讲解任务执行</h2><p>读入PPT，把PPT分成每一页，将每一页的信息插入到PPT详情表，最后多线程异步发MQ让Python进行讲解生成。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * ppt页生成讲解任务执行</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param</span> userPptId ppt标识</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param</span> page 页码</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param</span> slide ppt页对象</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="meta">@Transactional(rollbackFor = Exception.class)</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">taskExec</span><span class="params">(Integer userPptId, Integer page,XSLFSlide slide)</span> <span class="keyword">throws</span> Exception</span><br><span class="line">&#123;</span><br><span class="line">    <span class="type">TaskDO</span> <span class="variable">taskDO</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">TaskDO</span>();</span><br><span class="line">    <span class="type">PPTPageSummaryTaskDTO</span> <span class="variable">pptPageSummaryTaskDTO</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">PPTPageSummaryTaskDTO</span>();</span><br><span class="line">    pptPageSummaryTaskDTO.setUserPptId(userPptId);</span><br><span class="line">    pptPageSummaryTaskDTO.setPage(page);</span><br><span class="line">    pptPageSummaryTaskDTO.setContent(PPTXUtil.getSlideInfo(slide));</span><br><span class="line">    taskDO.setTaskDetail(JSON.toJSONString(pptPageSummaryTaskDTO));</span><br><span class="line">    taskDO.setType(TaskTypeEnum.PPT_SUMMARY.getCode());</span><br><span class="line">    taskDO.setUpdateTime(LocalDateTime.now());</span><br><span class="line">    taskDO.setCreateTime(LocalDateTime.now());</span><br><span class="line">    taskDO.setStatus(TaskStatusEnum.CREATED.getCode());</span><br><span class="line">    taskMapper.insert(taskDO);</span><br><span class="line">    TaskMessageDTO&lt;PPTPageSummaryTaskDTO&gt; taskMessage = <span class="keyword">new</span> <span class="title class_">TaskMessageDTO</span>&lt;&gt;();</span><br><span class="line">    taskMessage.setId(taskDO.getId());</span><br><span class="line">    taskMessage.setType(TaskTypeEnum.PPT_SUMMARY.getCode());</span><br><span class="line">    taskMessage.setStatus(TaskStatusEnum.CREATED.getCode());</span><br><span class="line">    taskMessage.setMessageBody(pptPageSummaryTaskDTO);</span><br><span class="line">    taskMessage.setCreateTime(LocalDateTime.now());</span><br><span class="line">    mqProducer.send(DirectRabbitConfig.EXCHANGE_NAME_PPT_SUMMARY, DirectRabbitConfig.ROUTING_KEY_PPT_SUMMARY,taskMessage);</span><br><span class="line">    <span class="type">UserPptDetailDO</span> <span class="variable">userPptDetailDO</span> <span class="operator">=</span> userPptDetailMapper.selectOne(<span class="keyword">new</span> <span class="title class_">LambdaQueryWrapper</span>&lt;UserPptDetailDO&gt;()</span><br><span class="line">            .eq(UserPptDetailDO::getUserPptId, userPptId)</span><br><span class="line">            .eq(UserPptDetailDO::getPptPage, page));</span><br><span class="line">    <span class="keyword">if</span>(Objects.isNull(userPptDetailDO))</span><br><span class="line">    &#123;</span><br><span class="line">        userPptDetailDO = <span class="keyword">new</span> <span class="title class_">UserPptDetailDO</span>();</span><br><span class="line">        userPptDetailDO.setUserPptId(userPptId);</span><br><span class="line">        userPptDetailDO.setPptPage(page);</span><br><span class="line">        userPptDetailDO.setCreateTime(LocalDateTime.now());</span><br><span class="line">        userPptDetailDO.setLastTaskId(taskDO.getId());</span><br><span class="line">        <span class="comment">//上传并添加预览图</span></span><br><span class="line">        <span class="type">InputStream</span> <span class="variable">inputStream</span> <span class="operator">=</span> PPTXUtil.convertSlideToImage(slide);</span><br><span class="line">        <span class="type">String</span> <span class="variable">imgUrl</span> <span class="operator">=</span> fileService.uploadFileToMinio(inputStream, FileTypeEnum.PNG, UUID.randomUUID().toString());</span><br><span class="line">        userPptDetailDO.setImgUrl(imgUrl);</span><br><span class="line">        userPptDetailMapper.insert(userPptDetailDO);</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        userPptDetailDO.setLastTaskId(taskDO.getId());</span><br><span class="line">        userPptDetailMapper.updateById(userPptDetailDO);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="创建ppt讲解语音生成任务"><em>创建ppt讲解语音生成任务</em></h2><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 创建ppt讲解语音生成任务</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param</span> param</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@return</span></span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="meta">@Override</span></span><br><span class="line"><span class="keyword">public</span> Integer <span class="title function_">createPPTSummaryVoice</span><span class="params">(CreatePPTSummaryVoiceParam param)</span> &#123;</span><br><span class="line">    <span class="type">UserSoundRelDO</span> <span class="variable">sound</span> <span class="operator">=</span> userSoundRelService.getById(param.getUserSoundId());</span><br><span class="line">    <span class="keyword">if</span>(Objects.isNull(sound))</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">throw</span>  <span class="keyword">new</span> <span class="title class_">BizException</span>(ResultCodeEnum.INVALID_PARAM.getCode(),<span class="string">&quot;声音库不存在&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span>(!sound.getUserId().equals(<span class="number">0</span>))</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">throw</span> <span class="keyword">new</span> <span class="title class_">BizException</span>(ResultCodeEnum.INVALID_PARAM.getCode(),<span class="string">&quot;目前服务器暂不支持自定义声音库&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="type">String</span> <span class="variable">apiParam</span> <span class="operator">=</span> sound.getApiParam();</span><br><span class="line">    List&lt;UserPptDetailDO&gt; userPptDetailDOS = userPptDetailMapper.selectList(<span class="keyword">new</span> <span class="title class_">LambdaQueryWrapper</span>&lt;UserPptDetailDO&gt;().eq(UserPptDetailDO::getUserPptId, param.getUserPptId()));</span><br><span class="line">    <span class="keyword">for</span> (UserPptDetailDO userPptDetailDO : userPptDetailDOS) &#123;</span><br><span class="line">        threadPoolExecutor.execute(()-&gt;&#123;</span><br><span class="line">            <span class="keyword">try</span> &#123;</span><br><span class="line">                taskExec(userPptDetailDO,apiParam,param.getRate());</span><br><span class="line">            &#125; <span class="keyword">catch</span> (Exception e) &#123;</span><br><span class="line">               log.info(<span class="string">&quot;ppt&#123;&#125;的&#123;&#125;页任务执行失败,请重试&quot;</span>,userPptDetailDO.getUserPptId(),userPptDetailDO.getPptPage());</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> param.getUserPptId();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="PPT语音生成任务执行">PPT语音生成任务执行</h2><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * ppt页生成讲解语音任务执行</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param</span> userPptDetailDO</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param</span> apiParam</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param</span> rate</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="meta">@Transactional(rollbackFor = Exception.class)</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">taskExec</span><span class="params">(UserPptDetailDO userPptDetailDO,String apiParam, Integer rate)</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="type">String</span> <span class="variable">summary</span> <span class="operator">=</span> userPptDetailDO.getSummary();</span><br><span class="line">    <span class="keyword">if</span>(StringUtils.isEmpty(summary))</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">throw</span> <span class="keyword">new</span> <span class="title class_">BizException</span>(ResultCodeEnum.INVALID_PARAM.getCode(),<span class="string">&quot;ppt&quot;</span>+userPptDetailDO.getUserPptId()+<span class="string">&quot;的&quot;</span>+userPptDetailDO.getPptPage()+<span class="string">&quot;页没有讲解&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="type">PPTSummaryVoiceMsgDTO</span> <span class="variable">pptSummaryVoiceMsgDTO</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">PPTSummaryVoiceMsgDTO</span>();</span><br><span class="line">    pptSummaryVoiceMsgDTO.setUserPptId(userPptDetailDO.getUserPptId());</span><br><span class="line">    pptSummaryVoiceMsgDTO.setPage(userPptDetailDO.getPptPage());</span><br><span class="line">    pptSummaryVoiceMsgDTO.setText(summary);</span><br><span class="line">    pptSummaryVoiceMsgDTO.setVoiceName(apiParam);</span><br><span class="line">    pptSummaryVoiceMsgDTO.setRate(rate);</span><br><span class="line">    <span class="type">TaskDO</span> <span class="variable">taskDO</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">TaskDO</span>();</span><br><span class="line">    taskDO.setType(TaskTypeEnum.PPT_SUMMARY_VOICE.getCode());</span><br><span class="line">    taskDO.setStatus(TaskStatusEnum.CREATED.getCode());</span><br><span class="line">    taskDO.setTaskDetail(JSON.toJSONString(pptSummaryVoiceMsgDTO));</span><br><span class="line">    taskDO.setCreateTime(LocalDateTime.now());</span><br><span class="line">    taskDO.setUpdateTime(LocalDateTime.now());</span><br><span class="line">    taskMapper.insert(taskDO);</span><br><span class="line">    userPptDetailDO.setLastTaskId(taskDO.getId());</span><br><span class="line">    userPptDetailMapper.updateById(userPptDetailDO);</span><br><span class="line">    TaskMessageDTO&lt;PPTSummaryVoiceMsgDTO&gt; message = <span class="keyword">new</span> <span class="title class_">TaskMessageDTO</span>&lt;&gt;();</span><br><span class="line">    message.setId(taskDO.getId());</span><br><span class="line">    message.setType(TaskTypeEnum.PPT_SUMMARY_VOICE.getCode());</span><br><span class="line">    message.setStatus(TaskStatusEnum.CREATED.getCode());</span><br><span class="line">    message.setMessageBody(pptSummaryVoiceMsgDTO);</span><br><span class="line">    message.setCreateTime(LocalDateTime.now());</span><br><span class="line">    mqProducer.send(DirectRabbitConfig.EXCHANGE_NAME_PPT_SUMMARY_VOICE, DirectRabbitConfig.ROUTING_KEY_PPT_SUMMARY_VOICE,message);</span><br><span class="line">    log.info(<span class="string">&quot;消息ID:&#123;&#125;,发送成功！-----------&gt;&gt; &#123;&#125;&quot;</span>,taskDO.getId(),message.toString());</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="MQ返回结果处理">MQ返回结果处理</h2><p><img src="2025-03-10-SoundMentor-%E5%A4%9A%E7%BA%BF%E7%A8%8B%E4%BC%98%E5%8C%96PPT%E4%BB%BB%E5%8A%A1%E6%89%A7%E8%A1%8C/image.png" alt=""></p><p>利用工厂+策略模式，对不同的消息类型进行不同的处理：</p><p><img src="2025-03-10-SoundMentor-%E5%A4%9A%E7%BA%BF%E7%A8%8B%E4%BC%98%E5%8C%96PPT%E4%BB%BB%E5%8A%A1%E6%89%A7%E8%A1%8C/image-1.png" alt=""></p><h3 id="普通TTS处理">普通TTS处理</h3><p><img src="2025-03-10-SoundMentor-%E5%A4%9A%E7%BA%BF%E7%A8%8B%E4%BC%98%E5%8C%96PPT%E4%BB%BB%E5%8A%A1%E6%89%A7%E8%A1%8C/image-2.png" alt=""></p><h3 id="PPT总结任务处理">PPT总结任务处理</h3><p><img src="2025-03-10-SoundMentor-%E5%A4%9A%E7%BA%BF%E7%A8%8B%E4%BC%98%E5%8C%96PPT%E4%BB%BB%E5%8A%A1%E6%89%A7%E8%A1%8C/image-3.png" alt=""></p><h3 id="PPT声音生成处理">PPT声音生成处理</h3><p><img src="2025-03-10-SoundMentor-%E5%A4%9A%E7%BA%BF%E7%A8%8B%E4%BC%98%E5%8C%96PPT%E4%BB%BB%E5%8A%A1%E6%89%A7%E8%A1%8C/image-4.png" alt=""></p><h3 id="声音训练处理">声音训练处理</h3><p><img src="2025-03-10-SoundMentor-%E5%A4%9A%E7%BA%BF%E7%A8%8B%E4%BC%98%E5%8C%96PPT%E4%BB%BB%E5%8A%A1%E6%89%A7%E8%A1%8C/image-5.png" alt=""></p><h2 id="有声PPT的合成">有声PPT的合成</h2><p>先下载原始ppt文件到临时目录下，用CountDownLatch协调任务完成，下载每一页的MP3并插入到PPT里面，最后上传打包。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> String <span class="title function_">getPpt</span><span class="params">(Integer userPptId)</span> &#123;</span><br><span class="line">    List&lt;UserPptDetailDO&gt; userPptDetailDOS = userPptDetailMapper.selectList(<span class="keyword">new</span> <span class="title class_">LambdaQueryWrapper</span>&lt;UserPptDetailDO&gt;()</span><br><span class="line">            .eq(UserPptDetailDO::getUserPptId, userPptId)</span><br><span class="line">            .orderByAsc(UserPptDetailDO::getPptPage));</span><br><span class="line">    <span class="keyword">if</span>(CollectionUtils.isEmpty(userPptDetailDOS))</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">throw</span> <span class="keyword">new</span> <span class="title class_">BizException</span>(ResultCodeEnum.INVALID_PARAM.getCode(),<span class="string">&quot;该ppt还未执行讲解生成&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="type">UserPptRelDO</span> <span class="variable">userPptRelDO</span> <span class="operator">=</span> userPptRelMapper.selectById(userPptId);</span><br><span class="line">    <span class="type">String</span> <span class="variable">pptUrl</span> <span class="operator">=</span> userPptRelDO.getPptUrl();</span><br><span class="line">    <span class="type">XMLSlideShow</span> <span class="variable">pptx</span> <span class="operator">=</span> PPTXUtil.loadPPTX(pptUrl);</span><br><span class="line">    <span class="type">String</span> <span class="variable">folderName</span> <span class="operator">=</span> <span class="string">&quot;temp/&quot;</span>+UUID.fastUUID();</span><br><span class="line">    FileUtil.createFolder(folderName);</span><br><span class="line">    <span class="keyword">try</span>(<span class="type">FileOutputStream</span> <span class="variable">outputStream</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">FileOutputStream</span>(folderName+<span class="string">&quot;/ppt.pptx&quot;</span>))</span><br><span class="line">    &#123;</span><br><span class="line">        HttpUtil.download(pptUrl,outputStream,<span class="literal">true</span>);</span><br><span class="line">        outputStream.flush();</span><br><span class="line">    &#125; <span class="keyword">catch</span> (Exception e) &#123;</span><br><span class="line">        <span class="keyword">throw</span> <span class="keyword">new</span> <span class="title class_">BizException</span>(ResultCodeEnum.FILE_ERROR.getCode(),<span class="string">&quot;下载ppt失败&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">try</span>&#123;</span><br><span class="line">        <span class="type">CountDownLatch</span> <span class="variable">countDownLatch</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">CountDownLatch</span>(userPptDetailDOS.size());</span><br><span class="line">        userPptDetailDOS.forEach(userPptDetailDO -&gt; &#123;</span><br><span class="line">            threadPoolExecutor.execute(() -&gt;&#123;</span><br><span class="line">                <span class="keyword">try</span>(<span class="type">FileOutputStream</span> <span class="variable">fileOutputStream</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">FileOutputStream</span>(folderName+<span class="string">&quot;/&quot;</span>+userPptDetailDO.getPptPage()+<span class="string">&quot;.mp3&quot;</span>)) &#123;</span><br><span class="line">                    HttpUtil.download(userPptDetailDO.getSoundUrl(),fileOutputStream,<span class="literal">true</span>);</span><br><span class="line">                    fileOutputStream.flush();</span><br><span class="line">                    PPTXUtil.addAudioToSlide(pptx,userPptDetailDO.getPptPage(),userPptDetailDO.getPptPage()+<span class="string">&quot;.mp3&quot;</span>);</span><br><span class="line">                &#125; <span class="keyword">catch</span> (Exception e) &#123;</span><br><span class="line">                    log.error(<span class="string">&quot;ppt&#123;&#125;的&#123;&#125;页音频插入失败&quot;</span>, userPptId, userPptDetailDO.getPptPage());</span><br><span class="line">                &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">                    countDownLatch.countDown();</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;);</span><br><span class="line">        &#125;);</span><br><span class="line">        countDownLatch.await(<span class="number">1</span>, TimeUnit.MINUTES);</span><br><span class="line">        PPTXUtil.savePPT(pptx,folderName+<span class="string">&quot;/ppt.pptx&quot;</span>);</span><br><span class="line">        <span class="type">InputStream</span> <span class="variable">inputStream</span> <span class="operator">=</span> FileUtil.zipFolder(folderName);</span><br><span class="line">        <span class="keyword">return</span> fileService.uploadFileToMinio(inputStream, FileTypeEnum.ZIP, UUID.fastUUID().toString());</span><br><span class="line">    &#125; <span class="keyword">catch</span> (Exception e) &#123;</span><br><span class="line">        <span class="keyword">throw</span> <span class="keyword">new</span> <span class="title class_">BizException</span>(ResultCodeEnum.FILE_ERROR.getCode(),<span class="string">&quot;生成有声ppt失败&quot;</span>);</span><br><span class="line">    &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            FileUtils.deleteDirectory(<span class="keyword">new</span> <span class="title class_">File</span>(folderName));</span><br><span class="line">        &#125; <span class="keyword">catch</span> (IOException e) &#123;</span><br><span class="line">            <span class="keyword">throw</span> <span class="keyword">new</span> <span class="title class_">BizException</span>(ResultCodeEnum.FILE_ERROR.getCode(),<span class="string">&quot;删除临时文件失败&quot;</span>);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
    
    
    <summary type="html">🥧SoundMentor-多线程优化PPT任务执行</summary>
    
    
    
    <category term="项目" scheme="https://outoflovenicoo.github.io/categories/%E9%A1%B9%E7%9B%AE/"/>
    
    
    <category term="项目" scheme="https://outoflovenicoo.github.io/tags/%E9%A1%B9%E7%9B%AE/"/>
    
  </entry>
  
  <entry>
    <title>个人对零拷贝技术的理解</title>
    <link href="https://outoflovenicoo.github.io/posts/2025-03-09-%E4%B8%AA%E4%BA%BA%E5%AF%B9%E9%9B%B6%E6%8B%B7%E8%B4%9D%E6%8A%80%E6%9C%AF%E7%9A%84%E7%90%86%E8%A7%A3.html"/>
    <id>https://outoflovenicoo.github.io/posts/2025-03-09-%E4%B8%AA%E4%BA%BA%E5%AF%B9%E9%9B%B6%E6%8B%B7%E8%B4%9D%E6%8A%80%E6%9C%AF%E7%9A%84%E7%90%86%E8%A7%A3.html</id>
    <published>2025-03-09T10:19:03.000Z</published>
    <updated>2025-03-23T14:00:00.000Z</updated>
    
    <content type="html"><![CDATA[<h1 id="思维导图"><a href="#思维导图" class="headerlink" title="思维导图"></a>思维导图</h1><p><img src="2025-03-09-个人对零拷贝技术的理解/image-20250414160743861.png" alt="image-20250414160743861"></p><h3 id="个人对零拷贝技术的理解：告别冗余拷贝，释放系统性能"><a href="#个人对零拷贝技术的理解：告别冗余拷贝，释放系统性能" class="headerlink" title="个人对零拷贝技术的理解：告别冗余拷贝，释放系统性能"></a>个人对零拷贝技术的理解：告别冗余拷贝，释放系统性能</h3><p>在计算机系统中，磁盘和网络传输往往是性能的瓶颈之一。传统的文件传输方式虽然逻辑简单，但在高并发场景下会因频繁的上下文切换和数据拷贝导致严重的性能损耗。而<strong>零拷贝（Zero-copy）</strong>技术的出现，正是为了解决这一问题。本文将从硬件协作到内核优化，逐步拆解零拷贝技术的原理与应用。</p><hr><h4 id="一、从DMA技术说起：让CPU“解放双手”"><a href="#一、从DMA技术说起：让CPU“解放双手”" class="headerlink" title="一、从DMA技术说起：让CPU“解放双手”"></a>一、从DMA技术说起：让CPU“解放双手”</h4><p>在早期计算机中，数据的传输完全依赖CPU。例如，当磁盘需要向内存传输数据时，CPU需要逐个字节地从磁盘控制器缓冲区读取数据，再写入内存。这种“全程陪跑”的方式让CPU无法处理其他任务，效率极低。</p><p><strong>DMA（直接内存访问）技术</strong>的引入彻底改变了这一局面。DMA控制器接管了数据搬运的工作，CPU只需告诉DMA“从哪里搬、搬到哪里”，后续的数据传输由DMA独立完成。这一过程无需CPU参与，从而释放了CPU资源。</p><p><strong>DMA的工作流程</strong>：  </p><ol><li>用户进程发起I/O请求；  </li><li>DMA将磁盘数据直接搬运到内核缓冲区；  </li><li>数据就绪后，DMA通知CPU将数据从内核缓冲区拷贝到用户空间。  </li></ol><p>至此，CPU只需在传输的开始和结束时介入，中间的数据搬运工作全部由DMA完成。</p><hr><h4 id="二、传统文件传输的“四宗罪”"><a href="#二、传统文件传输的“四宗罪”" class="headerlink" title="二、传统文件传输的“四宗罪”"></a>二、传统文件传输的“四宗罪”</h4><p>传统文件传输通过<code>read()</code>和<code>write()</code>系统调用实现，看似简单的两行代码，却隐藏着巨大的性能问题：  </p><ol><li><strong>4次上下文切换</strong>：每次系统调用涉及2次用户态与内核态的切换，两次调用共4次切换。  </li><li><strong>4次数据拷贝</strong>：<br>• DMA将磁盘数据拷贝到内核缓冲区；<br>• CPU将内核数据拷贝到用户缓冲区；<br>• CPU将用户数据拷贝到Socket内核缓冲区；<br>• DMA将Socket缓冲区数据拷贝到网卡。  </li></ol><p>这4次拷贝中，<strong>两次CPU参与的拷贝是冗余的</strong>，尤其是当用户不需要修改数据时，用户缓冲区的存在反而成了累赘。</p><hr><h4 id="三、零拷贝技术：如何实现“零”冗余？"><a href="#三、零拷贝技术：如何实现“零”冗余？" class="headerlink" title="三、零拷贝技术：如何实现“零”冗余？"></a>三、零拷贝技术：如何实现“零”冗余？</h4><p>零拷贝的核心目标是<strong>减少上下文切换和数据拷贝次数</strong>，具体通过两种方式实现：</p><h5 id="1-mmap-write：减少一次数据拷贝"><a href="#1-mmap-write：减少一次数据拷贝" class="headerlink" title="1. mmap + write：减少一次数据拷贝"></a>1. <code>mmap + write</code>：减少一次数据拷贝</h5><p><code>mmap()</code>系统调用将内核缓冲区映射到用户空间，使得用户进程与内核共享数据，省去了从内核到用户缓冲区的拷贝。但仍有3次数据拷贝（两次DMA，一次CPU），且需要4次上下文切换。</p><h5 id="2-sendfile-：系统调用的终极优化"><a href="#2-sendfile-：系统调用的终极优化" class="headerlink" title="2. sendfile()：系统调用的终极优化"></a>2. <code>sendfile()</code>：系统调用的终极优化</h5><p>Linux 2.1引入的<code>sendfile()</code>系统调用，将读取和发送合并为一次操作：<br>• <strong>2次上下文切换</strong>（1次系统调用）；<br>• <strong>3次数据拷贝</strong>（DMA拷贝磁盘到内核、CPU拷贝内核到Socket缓冲区、DMA拷贝到网卡）。  </p><p>若网卡支持<strong>SG-DMA（分散-聚集DMA）</strong>，则可进一步将CPU拷贝优化掉，仅需2次DMA拷贝，真正实现“零拷贝”。</p><hr><h4 id="四、PageCache：零拷贝的“加速器”"><a href="#四、PageCache：零拷贝的“加速器”" class="headerlink" title="四、PageCache：零拷贝的“加速器”"></a>四、PageCache：零拷贝的“加速器”</h4><p>零拷贝依赖内核的<strong>PageCache（页缓存）</strong>技术，它通过两种机制提升性能：  </p><ol><li><strong>缓存热点数据</strong>：最近访问的数据保留在内存中，减少磁盘访问。  </li><li><strong>预读机制</strong>：根据局部性原理，提前加载后续可能访问的数据。  </li></ol><p>然而，PageCache对<strong>大文件传输并不友好</strong>：<br>• 大文件会挤占缓存空间，影响小文件性能；<br>• 大文件的数据复用率低，预读反而浪费资源。  </p><p><strong>解决方案</strong>：针对大文件，采用<strong>异步I/O + 直接I/O</strong>，绕过PageCache，直接由磁盘到用户空间。</p><hr><h4 id="五、实践指南：何时用零拷贝？何时用直接I-O？"><a href="#五、实践指南：何时用零拷贝？何时用直接I-O？" class="headerlink" title="五、实践指南：何时用零拷贝？何时用直接I/O？"></a>五、实践指南：何时用零拷贝？何时用直接I/O？</h4><p>• <strong>小文件传输</strong>：优先使用零拷贝（如<code>sendfile</code>），结合PageCache加速。<br>• <strong>大文件传输</strong>：使用异步I/O + 直接I/O，避免PageCache污染。  </p><p><strong>Nginx配置示例</strong>：<br><figure class="highlight nginx"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="section">location</span> /video/ &#123;</span><br><span class="line">    <span class="attribute">sendfile</span> <span class="literal">on</span>;       <span class="comment"># 小文件用零拷贝</span></span><br><span class="line">    <span class="attribute">aio</span> <span class="literal">on</span>;            <span class="comment"># 大文件用异步I/O</span></span><br><span class="line">    <span class="attribute">directio</span> <span class="number">1024m</span>;    <span class="comment"># 超过1GB的文件启用直接I/O</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><hr><h4 id="六、总结"><a href="#六、总结" class="headerlink" title="六、总结"></a>六、总结</h4><p>零拷贝技术通过减少CPU参与的数据拷贝和上下文切换，显著提升了文件传输效率。其核心思想是：  </p><ol><li><strong>硬件协作</strong>：DMA承担数据搬运，释放CPU；  </li><li><strong>内核优化</strong>：合并系统调用，利用PageCache加速；  </li><li><strong>场景适配</strong>：区分大小文件，选择最优方案。  </li></ol><p>在高并发场景下，合理使用零拷贝（如Kafka、Nginx）可大幅提升吞吐量，而大文件传输则需另辟蹊径。</p>]]></content>
    
    
    <summary type="html">🥧个人对零拷贝技术的理解</summary>
    
    
    
    <category term="学习" scheme="https://outoflovenicoo.github.io/categories/%E5%AD%A6%E4%B9%A0/"/>
    
    
    <category term="操作系统" scheme="https://outoflovenicoo.github.io/tags/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/"/>
    
  </entry>
  
  <entry>
    <title>高性能网络模式</title>
    <link href="https://outoflovenicoo.github.io/posts/2025-03-09-%E9%AB%98%E6%80%A7%E8%83%BD%E7%BD%91%E7%BB%9C%E6%A8%A1%E5%BC%8F.html"/>
    <id>https://outoflovenicoo.github.io/posts/2025-03-09-%E9%AB%98%E6%80%A7%E8%83%BD%E7%BD%91%E7%BB%9C%E6%A8%A1%E5%BC%8F.html</id>
    <published>2025-03-09T10:19:03.000Z</published>
    <updated>2025-03-23T14:00:00.000Z</updated>
    
    <content type="html"><![CDATA[<h1 id="高性能网络模式：深入理解-Reactor-与-Proactor"><a href="#高性能网络模式：深入理解-Reactor-与-Proactor" class="headerlink" title="高性能网络模式：深入理解 Reactor 与 Proactor"></a>高性能网络模式：深入理解 Reactor 与 Proactor</h1><p>在构建高并发服务器时，传统的“一连接一线程”模型会面临性能瓶颈和资源浪费问题。<strong>I/O 多路复用技术</strong>的出现解决了这一难题，而基于此技术演化出的 <strong>Reactor</strong> 和 <strong>Proactor</strong> 模式，则成为了高性能网络编程的核心架构。本文将从设计思想、实现方案到应用场景，为你揭开这两种模式的神秘面纱。</p><h1 id="思维导图："><a href="#思维导图：" class="headerlink" title="思维导图："></a>思维导图：</h1><p><img src="2025-03-09-高性能网络模式/image-20250414161555385.png" alt="image-20250414161555385"></p><hr><h2 id="一、Reactor-模式：同步非阻塞的事件驱动模型"><a href="#一、Reactor-模式：同步非阻塞的事件驱动模型" class="headerlink" title="一、Reactor 模式：同步非阻塞的事件驱动模型"></a>一、Reactor 模式：同步非阻塞的事件驱动模型</h2><h3 id="1-核心思想"><a href="#1-核心思想" class="headerlink" title="1. 核心思想"></a>1. 核心思想</h3><p>Reactor 模式通过 <strong>事件分发机制</strong> 实现高效处理多连接。其核心由两个组件构成：<br>• <strong>Reactor</strong>：负责监听和分发事件（如连接建立、数据可读/写）<br>• <strong>处理资源池</strong>：线程/进程池负责具体业务处理</p><p><strong>类比现实场景</strong>：<br>Reactor 如同餐厅的接待员，持续监听客户请求（事件）。当新顾客到来（连接建立）时，接待员安排服务员（Handler）接待；当顾客点餐（数据到达）时，服务员开始处理订单。</p><hr><h3 id="2-三种经典实现方案"><a href="#2-三种经典实现方案" class="headerlink" title="2. 三种经典实现方案"></a>2. 三种经典实现方案</h3><h4 id="方案-1：单-Reactor-单进程-线程"><a href="#方案-1：单-Reactor-单进程-线程" class="headerlink" title="方案 1：单 Reactor 单进程/线程"></a>方案 1：单 Reactor 单进程/线程</h4><p><strong>架构组成</strong>：<br>• 单个进程/线程内包含三个核心对象：<br>  • <strong>Reactor</strong>：通过 <code>select</code>/<code>epoll</code> 监听所有事件<br>  • <strong>Acceptor</strong>：处理新连接建立<br>  • <strong>Handler</strong>：处理已建立连接的读写请求</p><p><strong>工作流程</strong>：  </p><ol><li>Reactor 监听所有事件，将连接建立事件分发给 Acceptor</li><li>Acceptor 调用 <code>accept()</code> 创建新连接，并生成对应的 Handler</li><li>Handler 处理数据读写（<code>read → 业务处理 → send</code>）</li></ol><p><strong>特点</strong>：<br>• 实现简单，无进程间通信开销<br>• 无法利用多核 CPU，业务处理必须非阻塞<br>• <strong>典型应用</strong>：Redis 6.0 前版本</p><hr><h4 id="方案-2：单-Reactor-多线程"><a href="#方案-2：单-Reactor-多线程" class="headerlink" title="方案 2：单 Reactor 多线程"></a>方案 2：单 Reactor 多线程</h4><p><strong>架构改进</strong>：<br>• 主线程保留 Reactor 和 Acceptor<br>• 引入线程池处理业务逻辑：<br>  • Handler 仅负责非阻塞 I/O 操作<br>  • 子线程处理业务后将结果返回主线程</p><p><strong>工作流程</strong>：  </p><ol><li>Reactor 监听事件，连接建立后由 Acceptor 创建 Handler</li><li>Handler 读取数据后，将数据提交给线程池处理</li><li>子线程完成业务逻辑，通过共享队列返回结果</li><li>主线程的 Handler 将结果发送给客户端</li></ol><p><strong>痛点</strong>：<br>• Reactor 单点可能成为性能瓶颈<br>• 需处理多线程资源共享问题<br>• <strong>典型应用</strong>：早期 Memcache</p><hr><h4 id="方案-3：多-Reactor-多进程-线程"><a href="#方案-3：多-Reactor-多进程-线程" class="headerlink" title="方案 3：多 Reactor 多进程/线程"></a>方案 3：多 Reactor 多进程/线程</h4><p><strong>架构设计</strong>：<br>• <strong>MainReactor</strong>：主线程/进程，仅处理新连接建立<br>• <strong>SubReactor</strong>：子线程/进程池，每个子单元管理一组连接<br>• <strong>Handler</strong>：绑定到 SubReactor 处理具体连接</p><p><strong>工作流程</strong>：  </p><ol><li>MainReactor 接收新连接，按负载均衡策略分配给 SubReactor</li><li>SubReactor 将连接加入自己的监听队列</li><li>事件触发时，SubReactor 调用对应 Handler 处理数据流</li></ol><p><strong>优势</strong>：<br>• 主从分工明确，扩展性强<br>• 避免单点性能瓶颈<br>• <strong>典型应用</strong>：Netty（多线程）、Nginx（多进程变体）</p><hr><h2 id="二、Proactor-模式：异步非阻塞的终极方案"><a href="#二、Proactor-模式：异步非阻塞的终极方案" class="headerlink" title="二、Proactor 模式：异步非阻塞的终极方案"></a>二、Proactor 模式：异步非阻塞的终极方案</h2><h3 id="1-核心思想-1"><a href="#1-核心思想-1" class="headerlink" title="1. 核心思想"></a>1. 核心思想</h3><p>Proactor 是真正的 <strong>异步 I/O 模型</strong>，其特点在于：<br>• <strong>操作系统完成 I/O 操作</strong>：包括数据从内核到用户空间的拷贝<br>• <strong>应用层只关注业务逻辑</strong>：处理已完成的 I/O 事件</p><p><strong>现实类比</strong>：<br>Proactor 如同外卖平台，骑手（系统内核）直接将餐品送到你家（数据就绪），你只需处理用餐（业务逻辑）即可。</p><hr><h3 id="2-工作流程"><a href="#2-工作流程" class="headerlink" title="2. 工作流程"></a>2. 工作流程</h3><ol><li><strong>注册异步操作</strong>：应用通过 <code>aio_read</code> 等接口发起请求，指定数据缓冲区</li><li><strong>系统内核执行 I/O</strong>：从网卡读取数据并自动拷贝到用户空间</li><li><strong>完成通知</strong>：内核通过回调通知 Proactor</li><li><strong>业务处理</strong>：Proactor 调用 Handler 处理数据</li></ol><hr><h3 id="3-平台支持差异"><a href="#3-平台支持差异" class="headerlink" title="3. 平台支持差异"></a>3. 平台支持差异</h3><div class="table-container"><table><thead><tr><th><strong>平台</strong></th><th><strong>实现方式</strong></th><th><strong>特点</strong></th></tr></thead><tbody><tr><td>Linux</td><td>模拟异步 I/O（如 <code>aio</code>）</td><td>仅支持文件操作，网络性能受限</td></tr><tr><td>Windows</td><td>原生支持 IOCP（完成端口）</td><td>真正异步，适合高性能网络服务</td></tr></tbody></table></div><hr><h2 id="三、Reactor-vs-Proactor-关键区别"><a href="#三、Reactor-vs-Proactor-关键区别" class="headerlink" title="三、Reactor vs Proactor 关键区别"></a>三、Reactor vs Proactor 关键区别</h2><div class="table-container"><table><thead><tr><th><strong>特性</strong></th><th><strong>Reactor</strong></th><th><strong>Proactor</strong></th></tr></thead><tbody><tr><td><strong>事件类型</strong></td><td>通知”可读/可写”（需应用主动处理数据）</td><td>通知”数据已就绪”（数据已存入应用缓冲区）</td></tr><tr><td><strong>数据处理</strong></td><td>应用层调用 <code>read</code>/<code>write</code> 完成 I/O 操作</td><td>系统自动完成数据读写</td></tr><tr><td><strong>性能瓶颈</strong></td><td>依赖非阻塞 I/O 和线程模型优化</td><td>依赖操作系统异步支持</td></tr><tr><td><strong>编程复杂度</strong></td><td>需处理非阻塞 I/O 状态和半包问题</td><td>只需关注业务逻辑</td></tr><tr><td><strong>典型应用</strong></td><td>Redis、Nginx、Netty</td><td>Windows IOCP 服务器</td></tr></tbody></table></div><hr><h2 id="四、如何选择网络模型？"><a href="#四、如何选择网络模型？" class="headerlink" title="四、如何选择网络模型？"></a>四、如何选择网络模型？</h2><h3 id="1-Reactor-适用场景"><a href="#1-Reactor-适用场景" class="headerlink" title="1. Reactor 适用场景"></a>1. Reactor 适用场景</h3><p>• <strong>跨平台需求</strong>（尤其是 Linux 环境）<br>• <strong>业务逻辑轻量</strong>（如微秒级处理）<br>• <strong>高并发连接</strong>（如百万级长连接）<br>• <strong>经典案例</strong>：<br>  • Redis：单 Reactor 处理内存级快速操作<br>  • Netty：多 Reactor 应对高并发网络请求</p><h3 id="2-Proactor-适用场景"><a href="#2-Proactor-适用场景" class="headerlink" title="2. Proactor 适用场景"></a>2. Proactor 适用场景</h3><p>• <strong>Windows 平台高性能服务</strong><br>• <strong>大数据量传输</strong>（如视频流处理）<br>• <strong>简化业务层开发</strong><br>• <strong>经典案例</strong>：<br>  • IIS 服务器：基于 IOCP 实现高效 HTTP 服务<br>  • 金融交易系统：低延迟处理高频交易数据</p><hr><h2 id="五、总结"><a href="#五、总结" class="headerlink" title="五、总结"></a>五、总结</h2><p><strong>Reactor 的本质</strong>：  </p><blockquote><p>“事件就绪时通知你处理” —— 应用程序仍需主动完成数据读写。</p></blockquote><p><strong>Proactor 的精髓</strong>：  </p><blockquote><p>“事件处理完通知你结果” —— 操作系统包揽脏活累活，应用层专注业务。</p></blockquote><p><strong>技术选型建议</strong>：<br>• 在 Linux 体系下，Reactor 仍是主流选择，结合 <code>epoll</code> 和线程池优化可达到 C10M 并发。<br>• Windows 平台优先考虑 Proactor（IOCP），充分发挥异步性能优势。<br>• 现代框架如 Netty 通过分层设计屏蔽底层差异，开发者可基于 API 统一编程模型。</p><p>理解这些底层网络模式是很重要的。因为无论是优化现有系统，还是设计新架构，Reactor 和 Proactor 的思想都将持续指引我们突破性能瓶颈。</p>]]></content>
    
    
    <summary type="html">🥧高性能网络模式</summary>
    
    
    
    <category term="学习" scheme="https://outoflovenicoo.github.io/categories/%E5%AD%A6%E4%B9%A0/"/>
    
    
    <category term="操作系统" scheme="https://outoflovenicoo.github.io/tags/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/"/>
    
  </entry>
  
  <entry>
    <title>MySQL如何存储数据</title>
    <link href="https://outoflovenicoo.github.io/posts/2025-03-09-MySQL%E5%A6%82%E4%BD%95%E5%AD%98%E5%82%A8%E6%95%B0%E6%8D%AE.html"/>
    <id>https://outoflovenicoo.github.io/posts/2025-03-09-MySQL%E5%A6%82%E4%BD%95%E5%AD%98%E5%82%A8%E6%95%B0%E6%8D%AE.html</id>
    <published>2025-03-09T10:19:03.000Z</published>
    <updated>2025-03-23T14:00:00.000Z</updated>
    
    <content type="html"><![CDATA[<h1 id="InnoDB存储引擎如何存储数据"><a href="#InnoDB存储引擎如何存储数据" class="headerlink" title="InnoDB存储引擎如何存储数据"></a>InnoDB存储引擎如何存储数据</h1><h2 id="思维导图："><a href="#思维导图：" class="headerlink" title="思维导图："></a><strong>思维导图：</strong></h2><p><img src="2025-03-09-MySQL如何存储数据/1.png" alt="img"></p><p>在MySQL数据库的世界里，InnoDB存储引擎堪称是数据存储的”心脏”。今天，我们就以一位数据库工程师的视角，揭开这个”心脏”的运作奥秘。准备好了吗？让我们沿着数据存储的脉络，开启一场技术探秘之旅！</p><h2 id="一、MySQL数据存储基石：InnoDB的精密设计"><a href="#一、MySQL数据存储基石：InnoDB的精密设计" class="headerlink" title="一、MySQL数据存储基石：InnoDB的精密设计"></a>一、MySQL数据存储基石：InnoDB的精密设计</h2><p>如果把数据库比作图书馆，InnoDB就是那个既懂分类又善管理的图书管理员。它通过精心设计的文件系统，将数据有序地存放在磁盘上。</p><h3 id="（一）磁盘文件里的”身份证”与”藏书阁”"><a href="#（一）磁盘文件里的”身份证”与”藏书阁”" class="headerlink" title="（一）磁盘文件里的”身份证”与”藏书阁”"></a>（一）磁盘文件里的”身份证”与”藏书阁”</h3><p><img src="2025-03-09-MySQL如何存储数据/2.png" alt="img"></p><p>当我们新建一个订单表<code>order</code>时，系统会悄悄生成几个关键文件：<br>• <strong>opt文件</strong>：就像是数据库的”身份证”，记录着默认的字符集（比如UTF-8）和校验规则。它确保中文不会变成乱码，数字比较时不会出错。<br>• <strong>frm文件</strong>：可以理解为”书架标签”，存储着表结构的定义。每次你DESC查看表结构时，系统其实就是在读取这个文件。<br>• <strong>idb文件</strong>：这才是真正的”藏书阁”。以<code>order.idb</code>为例，它存储着订单表的所有数据。就像现代图书馆的智能书架，MySQL 5.6.6之后默认每个表都有独立的.idb文件，这样要维护某个书架（表）时，再也不用搬动整个图书馆的藏书了。</p><p>举个真实案例：某电商平台发现订单表查询变慢，DBA通过<code>ALTER TABLE order ENGINE=InnoDB</code>重建表空间后，发现.idb文件体积缩小了30%，这正是独立表空间的优势体现。</p><h3 id="（二）表空间的俄罗斯套娃结构"><a href="#（二）表空间的俄罗斯套娃结构" class="headerlink" title="（二）表空间的俄罗斯套娃结构"></a>（二）表空间的俄罗斯套娃结构</h3><p>打开这个”藏书阁”，你会发现一个精妙的存储体系：</p><p><img src="2025-03-09-MySQL如何存储数据/3.png" alt="img"></p><figure class="highlight"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">表空间 → 段 → 区 → 页 → 行</span><br></pre></td></tr></table></figure><p>就像图书馆的分区管理：<br>• <strong>段（Segment）</strong>：类似图书馆的楼层分区（索引区、数据区）<br>• <strong>区（Extent）</strong>：每个楼层里的藏书区，由连续64个页组成（1MB）<br>• <strong>页（Page）</strong>：最基本的存储单元，相当于书架隔层（16KB）<br>• <strong>行（Row）</strong>：每本书就是一行数据</p><p>这种结构设计有个精妙之处：当需要新增数据时，InnoDB不是随意找个空位，而是整区整区地分配空间。就像图书馆扩建时直接增加整个书架区，而不是这里加一本那里塞一册。</p><h2 id="二、行格式"><a href="#二、行格式" class="headerlink" title="二、行格式"></a>二、行格式</h2><p>如果说表空间是图书馆，那么行格式就是书籍的排版规范。InnoDB支持多种行格式，我们以最常用的Compact格式为例，看看它是如何将数据”装订成册”的。</p><h3 id="（一）变长字段的"><a href="#（一）变长字段的" class="headerlink" title="（一）变长字段的"></a>（一）变长字段的</h3><p>假设我们有一张用户表：<br><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">CREATE TABLE</span> users (</span><br><span class="line">    id <span class="type">INT</span> <span class="keyword">NOT NULL</span>,</span><br><span class="line">    name <span class="type">VARCHAR</span>(<span class="number">20</span>),</span><br><span class="line">    email <span class="type">VARCHAR</span>(<span class="number">50</span>)</span><br><span class="line">);</span><br></pre></td></tr></table></figure><br>当插入一条记录：<br><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">INSERT INTO</span> users <span class="keyword">VALUES</span>(<span class="number">1</span>, <span class="string">&#x27;张三&#x27;</span>, <span class="string">&#x27;zhangsan@example.com&#x27;</span>);</span><br></pre></td></tr></table></figure><br>Compact行格式会先在数据行头部放置两把”尺子”：</p><ol><li><p><strong>变长字段长度列表</strong>：逆序记录每个变长字段的实际长度<br>• email长度23字节（ASCII每个字符1字节）<br>• name长度4字节（每个中文字符3字节？不！这里有个常见误区，实际存储长度取决于字符集）<br>• 存储方式：<code>[23,4]</code>的逆序十六进制<code>0x17 0x04</code></p></li><li><p><strong>NULL值标记位图</strong>：<br>• 三个字段都不允许NULL，所以这个列表不存在<br>• 如果允许NULL，会用位图标记哪些字段是NULL（1表示NULL）</p></li></ol><p>这里有个有趣的测试：将name字段改为CHAR(20)，实际存储长度会变成60字节（假设UTF8MB4字符集），而VARCHAR(20)实际存储长度根据内容变化。这就是CHAR类型在存储空间上的”以空间换时间”策略。</p><h3 id="（二）NULL值的存储"><a href="#（二）NULL值的存储" class="headerlink" title="（二）NULL值的存储"></a>（二）NULL值的存储</h3><p>当表中存在允许NULL的字段时，Compact行格式会施展它的”隐身术”：<br><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">CREATE TABLE</span> orders (</span><br><span class="line">    id <span class="type">INT</span> <span class="keyword">PRIMARY KEY</span>,</span><br><span class="line">    product <span class="type">VARCHAR</span>(<span class="number">100</span>),</span><br><span class="line">    buyer <span class="type">VARCHAR</span>(<span class="number">50</span>) <span class="keyword">NULL</span></span><br><span class="line">);</span><br></pre></td></tr></table></figure><br>假设插入：<br><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">INSERT INTO</span> orders <span class="keyword">VALUES</span>(<span class="number">1001</span>, <span class="string">&#x27;智能手机&#x27;</span>, <span class="keyword">NULL</span>);</span><br></pre></td></tr></table></figure><br>此时：</p><ol><li>NULL值列表用1字节表示：二进制<code>00000010</code>（逆序排列，第二位表示buyer为NULL）</li><li>实际数据区不存储NULL字段的值</li><li>省去了存储”NULL”字符串的空间</li></ol><p>根据统计，当表中存在多个可为NULL的字段时，这种设计可节省约5%的存储空间。某社交平台用户表优化后，仅NULL优化就减少了20GB的存储空间！</p><h2 id="三、当数据膨胀时的”分页存储术”"><a href="#三、当数据膨胀时的”分页存储术”" class="headerlink" title="三、当数据膨胀时的”分页存储术”"></a>三、当数据膨胀时的”分页存储术”</h2><p>想象一本百科全书太厚无法放入书架隔层，这时候就需要分册存放。InnoDB的行溢出机制就是这种智慧的数字版。</p><h3 id="（一）行溢出的临界点计算"><a href="#（一）行溢出的临界点计算" class="headerlink" title="（一）行溢出的临界点计算"></a>（一）行溢出的临界点计算</h3><p>每个页（16KB）能存储多少数据？我们通过公式计算：<br><figure class="highlight abnf"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">最大行长度 <span class="operator">=</span> 页大小(<span class="number">16384</span>) - 行头信息(约<span class="number">56</span>字节) ≈ <span class="number">16328</span>字节</span><br></pre></td></tr></table></figure><br>当某行数据超过这个阈值时，就会触发行溢出。比如一个包含10个TEXT字段的表，每条记录都可能需要溢出存储。</p><h3 id="（二）溢出页的”目录索引”"><a href="#（二）溢出页的”目录索引”" class="headerlink" title="（二）溢出页的”目录索引”"></a>（二）溢出页的”目录索引”</h3><p>当发生行溢出时，Compact行格式会：</p><ol><li>在原始页保留768字节的”书签”</li><li>剩余数据存入溢出页</li><li>用20字节的指针记录溢出页地址</li><li>多个溢出页通过链表连接</li></ol><p>这就像图书馆的书籍目录：<br>• 主书架存放目录页（包含各分册位置）<br>• 实际内容存放在多个分册书架</p><p>某论坛系统曾因大文本字段导致频繁行溢出，通过将大字段拆分到扩展表，查询性能提升了3倍。</p><h2 id="四、行格式设计"><a href="#四、行格式设计" class="headerlink" title="四、行格式设计"></a>四、行格式设计</h2><h3 id="（一）Compact-vs-Dynamic：选择的智慧"><a href="#（一）Compact-vs-Dynamic：选择的智慧" class="headerlink" title="（一）Compact vs Dynamic：选择的智慧"></a>（一）Compact vs Dynamic：选择的智慧</h3><p>MySQL 8.0默认使用Dynamic行格式，它在处理溢出时更激进：<br>• 仅保留20字节指针<br>• 所有变长字段数据优先存溢出页<br>• 更适合现代应用的大数据字段场景</p><p>选择建议：<br>• 频繁更新的大字段表 → Dynamic<br>• 需要兼容旧版本 → Compact<br>• 压缩需求 → Compressed</p><h3 id="（二）字符集的隐藏陷阱"><a href="#（二）字符集的隐藏陷阱" class="headerlink" title="（二）字符集的隐藏陷阱"></a>（二）字符集的隐藏陷阱</h3><p>当计算varchar(n)最大长度时，字符集的影响常被忽视：<br>• UTF8MB4字符集：每个字符最多4字节<br>• 实际最大n值 = (65535 - 长度列表 - NULL列表) / 4</p><p>例如允许NULL的单字段表：<br><figure class="highlight tap"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">(65535 -<span class="number"> 2 </span>- 1) /<span class="number"> 4 </span>≈ 16383字符</span><br></pre></td></tr></table></figure><br>某国际化电商就曾因未考虑字符集，导致地址字段被截断，损失百万订单。</p><h2 id="五、性能优化"><a href="#五、性能优化" class="headerlink" title="五、性能优化"></a>五、性能优化</h2><ol><li><strong>NULL值优化</strong>：将允许NULL的字段改为NOT NULL DEFAULT ‘’，可节省NULL列表空间</li><li><strong>大字段分离</strong>：将BLOB/TEXT字段拆分到扩展表</li><li><strong>行格式转换</strong>：<code>ALTER TABLE ... ROW_FORMAT=DYNAMIC</code></li><li><strong>页压缩</strong>：对历史数据表启用页压缩</li><li><strong>字符集选择</strong>：中文环境优先考虑UTF8MB4而非UTF8</li></ol><p>某金融系统通过上述优化组合拳，使核心交易表的TPS从1500提升到5200，效果显著。</p><h2 id="结语：存储之道的三重境界"><a href="#结语：存储之道的三重境界" class="headerlink" title="结语：存储之道的三重境界"></a>结语：存储之道的三重境界</h2><p>理解InnoDB的存储机制，就像修炼数据库的内功心法：</p><ol><li><strong>见山是山</strong>：看懂文件结构和行格式</li><li><strong>见山不是山</strong>：理解设计哲学与取舍权衡</li><li><strong>见山还是山</strong>：能根据业务特征定制存储方案</li></ol><p>当我们翻开InnoDB的存储宝典，看到的不仅是冷冰冰的数据结构，更是一群工程师对效率与可靠性的极致追求。下次当你执行一条SELECT语句时，不妨想象一下，这简单的查询背后，正有一支精密的”存储交响乐团”在为你演奏。</p><h1 id="参考博客："><a href="#参考博客：" class="headerlink" title="参考博客："></a>参考博客：</h1><p><a href="https://xiaolincoding.com/mysql/base/row_format.html#总结">MySQL 一行记录是怎么存储的？</a></p>]]></content>
    
    
    <summary type="html">🥧MySQL如何存储数据</summary>
    
    
    
    <category term="学习" scheme="https://outoflovenicoo.github.io/categories/%E5%AD%A6%E4%B9%A0/"/>
    
    
    <category term="MySQL" scheme="https://outoflovenicoo.github.io/tags/MySQL/"/>
    
  </entry>
  
  <entry>
    <title>联合索引学习笔记</title>
    <link href="https://outoflovenicoo.github.io/posts/2025-03-09-%E8%81%94%E5%90%88%E7%B4%A2%E5%BC%95%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0.html"/>
    <id>https://outoflovenicoo.github.io/posts/2025-03-09-%E8%81%94%E5%90%88%E7%B4%A2%E5%BC%95%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0.html</id>
    <published>2025-03-09T10:19:03.000Z</published>
    <updated>2025-03-23T14:00:00.000Z</updated>
    
    <content type="html"><![CDATA[<h1 id="联合索引底层以及内幕"><a href="#联合索引底层以及内幕" class="headerlink" title="联合索引底层以及内幕"></a>联合索引底层以及内幕</h1><p><a href="https://mp.weixin.qq.com/s/8qemhRg5MgXs1So5YCv0fQ">联合索引底层</a></p><p><a href="https://blog.csdn.net/wangye135/article/details/140389620">MySQL覆盖索引和索引跳跃扫描-CSDN博客</a></p><p><img src="2025-03-09-联合索引学习笔记/image-20250407160156273-4012927.png" alt="image-20250407160156273"></p><h3 id="被问到过一个面试题："><a href="#被问到过一个面试题：" class="headerlink" title="被问到过一个面试题："></a>被问到过一个面试题：</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">select a,c from t <span class="type">where</span> <span class="variable">a</span> <span class="operator">=</span> <span class="number">1</span> and b= <span class="number">2</span> order by c desc</span><br></pre></td></tr></table></figure><p>应该设置什么索引，c的升序和降序会有什么影响，哪个更快一点。</p><h3 id="升序索引与降序索引对查询性能的影响"><a href="#升序索引与降序索引对查询性能的影响" class="headerlink" title="升序索引与降序索引对查询性能的影响"></a>升序索引与降序索引对查询性能的影响</h3><h4 id="1-查询排序方向与索引排序方向一致"><a href="#1-查询排序方向与索引排序方向一致" class="headerlink" title="1. 查询排序方向与索引排序方向一致"></a>1. 查询排序方向与索引排序方向一致</h4><ul><li><strong>升序索引用于升序查询</strong>：当创建的索引是 <code>(a, b, c ASC)</code>（<code>ASC</code> 表示升序，可省略），并且查询语句是 <code>ORDER BY c ASC</code> 时，数据库可以直接按照索引中 <code>c</code> 列的顺序来返回结果，无需额外的排序操作，这样能显著提升查询效率。因为索引已经按照升序排列好了，数据库可以直接从索引中获取有序的数据。</li><li><strong>降序索引用于降序查询</strong>：如果创建的索引是 <code>(a, b, c DESC)</code>，而查询语句是 <code>ORDER BY c DESC</code>，数据库同样可以直接利用索引中 <code>c</code> 列的降序排列来返回结果，避免了额外的排序开销。</li></ul><h4 id="2-查询排序方向与索引排序方向不一致"><a href="#2-查询排序方向与索引排序方向不一致" class="headerlink" title="2. 查询排序方向与索引排序方向不一致"></a>2. 查询排序方向与索引排序方向不一致</h4><ul><li><strong>升序索引用于降序查询</strong>：当使用 <code>(a, b, c ASC)</code> 索引，而查询语句是 <code>ORDER BY c DESC</code> 时，数据库可能无法直接利用索引的顺序，需要对从索引中获取的数据进行额外的降序排序操作。这会增加查询的时间和资源消耗，尤其是在处理大量数据时，性能下降会更明显。</li><li><strong>降序索引用于升序查询</strong>：类似地，若使用 <code>(a, b, c DESC)</code> 索引，而查询是 <code>ORDER BY c ASC</code>，数据库也需要对数据进行额外的升序排序，导致性能降低。</li></ul><h3 id="哪个更快取决于具体场景"><a href="#哪个更快取决于具体场景" class="headerlink" title="哪个更快取决于具体场景"></a>哪个更快取决于具体场景</h3><ul><li><strong>如果查询中</strong> <strong><code>ORDER BY c</code></strong>的方向固定：<ul><li>若查询总是 <code>ORDER BY c ASC</code>，那么创建升序索引 <code>(a, b, c)</code> 会更快，因为可以直接利用索引的顺序。</li><li>若查询总是 <code>ORDER BY c DESC</code>，则创建降序索引 <code>(a, b, c DESC)</code> 更合适，能避免额外的排序操作。</li></ul></li><li><strong>如果查询中</strong> <strong><code>ORDER BY c</code></strong>的方向不固定：<ul><li>在某些数据库（如 MySQL 8.0 及以上版本）中，可以同时创建升序和降序索引，但这会增加索引维护的开销，因为每次插入、更新或删除数据时，都需要同时更新多个索引。</li><li>也可以考虑只创建一个升序索引，让数据库在需要降序排序时进行额外的排序操作。在数据量较小的情况下，这种额外排序的开销可能并不明显。</li></ul></li></ul><p><strong>示例代码</strong></p><p><strong>升序索引</strong></p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">-- 创建升序索引</span></span><br><span class="line"><span class="keyword">CREATE</span> INDEX idx_a_b_c_asc <span class="keyword">ON</span> t (a, b, c);</span><br><span class="line"></span><br><span class="line"><span class="comment">-- 升序查询</span></span><br><span class="line"><span class="keyword">SELECT</span> a, c <span class="keyword">FROM</span> t <span class="keyword">WHERE</span> a <span class="operator">=</span> <span class="number">1</span> <span class="keyword">AND</span> b <span class="operator">=</span> <span class="number">2</span> <span class="keyword">ORDER</span> <span class="keyword">BY</span> c <span class="keyword">ASC</span>;</span><br></pre></td></tr></table></figure><p><strong>降序索引</strong></p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">-- 创建降序索引</span></span><br><span class="line"><span class="keyword">CREATE</span> INDEX idx_a_b_c_desc <span class="keyword">ON</span> t (a, b, c <span class="keyword">DESC</span>);</span><br><span class="line"></span><br><span class="line"><span class="comment">-- 降序查询</span></span><br><span class="line"><span class="keyword">SELECT</span> a, c <span class="keyword">FROM</span> t <span class="keyword">WHERE</span> a <span class="operator">=</span> <span class="number">1</span> <span class="keyword">AND</span> b <span class="operator">=</span> <span class="number">2</span> <span class="keyword">ORDER</span> <span class="keyword">BY</span> c <span class="keyword">DESC</span>;</span><br></pre></td></tr></table></figure><p>综上所述，选择升序索引还是降序索引取决于查询中 <code>ORDER BY</code> 子句的排序方向。</p>]]></content>
    
    
    <summary type="html">🥧联合索引学习</summary>
    
    
    
    <category term="学习" scheme="https://outoflovenicoo.github.io/categories/%E5%AD%A6%E4%B9%A0/"/>
    
    
    <category term="MySQL" scheme="https://outoflovenicoo.github.io/tags/MySQL/"/>
    
  </entry>
  
  <entry>
    <title>个人对DeepSeek原理的理解</title>
    <link href="https://outoflovenicoo.github.io/posts/2025-02-20-%E4%B8%AA%E4%BA%BA%E5%AF%B9DeepSeek%E5%8E%9F%E7%90%86%E7%9A%84%E7%90%86%E8%A7%A3.html"/>
    <id>https://outoflovenicoo.github.io/posts/2025-02-20-%E4%B8%AA%E4%BA%BA%E5%AF%B9DeepSeek%E5%8E%9F%E7%90%86%E7%9A%84%E7%90%86%E8%A7%A3.html</id>
    <published>2025-02-20T10:19:03.000Z</published>
    <updated>2025-02-20T14:00:00.000Z</updated>
    
    <content type="html"><![CDATA[<p><img src="2025-02-20-%E4%B8%AA%E4%BA%BA%E5%AF%B9DeepSeek%E5%8E%9F%E7%90%86%E7%9A%84%E7%90%86%E8%A7%A3/diagram.png" alt=""></p><h1>深入理解DeepSeek：从训练到概念的全面解析</h1><p>​在如今的人工智能领域，大模型可谓是备受关注的焦点。DeepSeek作为其中一员，有着独特的技术路径和理念。今天，就来跟大家聊聊我对DeepSeek的一些理解，一下仅仅是我个人的理解，不一定保证正确。</p><h2 id="一、大模型训练步骤">一、大模型训练步骤</h2><h3 id="预训练：对Transformer结构的改进">预训练：对Transformer结构的改进</h3><p>DeepSeek在预训练阶段，对Transformer结构进行了一系列改进。Transformer结构在当下的大模型中广泛应用，而DeepSeek的改进独具匠心。</p><ul><li><p><strong>DeepSeekMoE</strong>：这一改进针对的是前馈神经网络（FNN）。FNN在处理信息时起着关键作用，DeepSeekMoE对其进行优化，能够更高效地处理和传递信息，让模型在面对大量数据时，能够更准确地捕捉其中的特征和规律。deepseek取代了传统transformer的FNN（前馈神经网络），改用了DeepSeekMoE（稀疏专家网络层，每一个专家都是一个独立的神经网络，这些专家可以是FNN，也可以是MoE层本身），当我们input时，它会通过门控网络，采取路由的方式，找到合适的专家，与传统的MoE对比，DeepSeek使用更细粒度的专家，并将一些专家隔离为共享专家，能够减少专家之间的知识冗余。<strong>与单纯的FNN相比</strong>，采用这种方式进行训练，不需要使用所有的参数，只需要通过路由找到合适的专家就行，能够减少计算量。</p></li><li><p><strong>MLA（改进MHA）</strong>：多头注意力机制（MHA）是Transformer的核心部分之一。deepseek采用MLA机制，<strong>代替了传统的MHA</strong>,标准的Transformer 架构里面的MHA架构会产出非常多的KV Cache。相比MQA的KV共用和GQA的KV分组，MLA的核心是注意力键和值的低秩联合压缩，以减少推理过程中的键值(KV)缓存。相比MHA具有更好的性能，但需要的 KV 缓存量要少得多。KV Cache的缓存量少保证了DeepSeek的训练成本较低。</p></li><li><p><strong>MTP</strong>：MTP在训练阶段和推理阶段都有着重要作用。<strong>MTP 的全称是 Multi - Token Prediction</strong>（多令牌预测），与之对应的是 DeepSeek-V3 发布之前业界普遍使用的单令牌预测（Single - Token Prediction，STP），STP 一次仅预测一个Token，而 MTP 可同时预测多个 Token，<strong>这一方案在训练阶段可以提升数据训练效率，在推理阶段可以实现显著加速</strong>。</p></li><li><p><strong>并行训练策略：</strong>deepseek还采取了并行训练策略，通过HAI-LLM 框架进行训练，但是这块我不太了解。</p></li></ul><h3 id="后训练：强化学习（GRPO-改进PPO）">后训练：强化学习（GRPO - 改进PPO）</h3><p>在预训练之后，DeepSeek进入后训练阶段，采用强化学习的方式，具体是通过GRPO（改进的近端策略优化算法PPO）来实现。PPO本身是一种在强化学习中常用的算法，而GRPO对其进行改进，使得模型在与环境交互的过程中，能够更有效地调整自身策略。通过不断地尝试和反馈，模型可以学习到如何做出更优的决策，进一步提升其性能和表现。DeepSeek采用强化学习GRPO算法，对比原始的PPO方案(一次输出一个结果)，GRPO（一次输出多个结果然后选最优的）只需要训练一个模型，不用训练Critic Model，GRPO通过优化PPO算法，移除了价值模型，降低了计算开销，同时利用群体相对优势函数和KL散度惩罚，确保策略更新既高效又稳定。</p><h2 id="二、其他相关概念">二、其他相关概念</h2><h3 id="大模型概念">大模型概念</h3><p>大模型如今已经成为人工智能发展的重要方向。它具有强大的学习能力和泛化能力，能够处理各种复杂的任务。通过大规模的数据训练，大模型可以学习到丰富的知识和模式，从而在自然语言处理、图像识别等多个领域发挥重要作用。</p><h3 id="知识蒸馏概念">知识蒸馏概念</h3><p>知识蒸馏是一种将大型模型学到的知识迁移到小型模型中的技术。通过让小型模型模仿大型模型的输出，能够在不损失太多性能的前提下，降低模型的复杂度和计算成本。这对于实际应用中资源受限的场景非常有帮助，比如在一些移动设备或者边缘设备上，通过知识蒸馏得到的小型模型可以更快地运行，同时也能保持较好的效果。</p><h3 id="AI-Agent概念">AI Agent概念</h3><p>AI Agent是一种能够感知环境，并根据感知结果采取行动以实现目标的智能体。在DeepSeek相关的情境中，AI Agent可以利用DeepSeek模型的能力，与外部环境进行交互。它可以根据环境中的信息做出决策，执行相应的操作，并通过不断地学习和调整，更好地适应环境，完成各种任务。</p><h2 id="参考博客：">参考博客：</h2><p><a href="https://arxiv.org/abs/2501.12948">DeepSeek-R1: Incentivizing Reasoning Capability in LLMs via Reinforcement Learning</a></p><p><a href="https://www.zhihu.com/question/11797471137/answer/122885941335">DeepSeek v3与v1的区别</a></p><p><a href="https://mp.weixin.qq.com/s/fUumK29XohD7Wm5bTlyokg">DeepSeek-V3 高效训练关键技术分析</a></p><p><a href="https://mp.weixin.qq.com/s/W4LzpMb3cIn0zVlW2oVung">漫谈DeepSeek及其背后的核心技术</a></p><p><a href="https://zhuanlan.zhihu.com/p/29123783155">AI agent是什么</a></p><p><a href="https://zhuanlan.zhihu.com/p/81467832">知识蒸馏是什么？</a></p><p><a href="https://www.zhihu.com/question/10766825126/answer/88583863333">DeepSeek的GRPO算法是什么？</a></p><p><a href="https://zhuanlan.zhihu.com/p/25600081364">聊一聊DeepSeek中用到的GRPO算法</a></p>]]></content>
    
    
    <summary type="html">🥧个人对DeepSeek原理的理解</summary>
    
    
    
    <category term="学习" scheme="https://outoflovenicoo.github.io/categories/%E5%AD%A6%E4%B9%A0/"/>
    
    
    <category term="前沿" scheme="https://outoflovenicoo.github.io/tags/%E5%89%8D%E6%B2%BF/"/>
    
  </entry>
  
  <entry>
    <title>ACM模式输入输出模板总结</title>
    <link href="https://outoflovenicoo.github.io/posts/2025-02-12-ACM%E6%A8%A1%E5%BC%8F%E8%BE%93%E5%85%A5%E8%BE%93%E5%87%BA%E6%A8%A1%E6%9D%BF%E6%80%BB%E7%BB%93.html"/>
    <id>https://outoflovenicoo.github.io/posts/2025-02-12-ACM%E6%A8%A1%E5%BC%8F%E8%BE%93%E5%85%A5%E8%BE%93%E5%87%BA%E6%A8%A1%E6%9D%BF%E6%80%BB%E7%BB%93.html</id>
    <published>2025-02-12T10:19:03.000Z</published>
    <updated>2025-03-13T14:00:00.000Z</updated>
    
    <content type="html"><![CDATA[<h1>1.主类</h1><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> java.util.*;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Main</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h1>2.常用数据结构</h1><h2 id="（1）二叉树">（1）二叉树</h2><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">TreeNode</span> &#123;</span><br><span class="line">    <span class="type">int</span> val;</span><br><span class="line">    TreeNode left;</span><br><span class="line">    TreeNode right;</span><br><span class="line">    TreeNode() &#123;&#125;</span><br><span class="line">    TreeNode(<span class="type">int</span> val) &#123; <span class="built_in">this</span>.val = val; &#125;</span><br><span class="line">    TreeNode(<span class="type">int</span> val, TreeNode left, TreeNode right) &#123;</span><br><span class="line">        <span class="built_in">this</span>.val = val;</span><br><span class="line">        <span class="built_in">this</span>.left = left;</span><br><span class="line">        <span class="built_in">this</span>.right = right;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>（2）N叉树</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Node</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="type">int</span> val;</span><br><span class="line">    <span class="keyword">public</span> List&lt;Node&gt; children;</span><br><span class="line">    <span class="keyword">public</span> <span class="title function_">Node</span><span class="params">()</span> &#123;&#125;</span><br><span class="line">    <span class="keyword">public</span> <span class="title function_">Node</span><span class="params">(<span class="type">int</span> val)</span> &#123; <span class="built_in">this</span>.val = val; &#125;</span><br><span class="line">    <span class="keyword">public</span> <span class="title function_">Node</span><span class="params">(<span class="type">int</span> val, List&lt;Node&gt; children)</span> &#123;</span><br><span class="line">        <span class="built_in">this</span>.val = val;</span><br><span class="line">        <span class="built_in">this</span>.children = children;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h1>3.类型</h1><p><a href="https://blog.csdn.net/qq_46091002/article/details/142309349?ops_request_misc=%257B%2522request%255Fid%2522%253A%2522dec14662fa379082d0e4fb502aa200d2%2522%252C%2522scm%2522%253A%252220140713.130102334..%2522%257D&amp;request_id=dec14662fa379082d0e4fb502aa200d2&amp;biz_id=0&amp;utm_medium=distribute.pc_search_result.none-task-blog-2~all~sobaiduend~default-1-142309349-null-null.142%5Ev101%5Epc_search_result_base3&amp;utm_term=java%E7%AC%94%E8%AF%95%E8%BE%93%E5%85%A5%E8%BE%93%E5%87%BA&amp;spm=1018.2226.3001.4187">Java的输入输出_java笔试输入输出-CSDN博客</a></p><h2 id="（1）输入是整数序列">（1）输入是整数序列</h2><p>输入：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="number">5</span></span><br><span class="line"><span class="number">1</span> <span class="number">2</span> <span class="number">3</span> <span class="number">4</span> <span class="number">5</span></span><br></pre></td></tr></table></figure><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">Scanner</span> <span class="variable">scanner</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Scanner</span>(System.in);</span><br><span class="line"><span class="type">int</span> <span class="variable">n</span> <span class="operator">=</span> scanner.nextInt();</span><br><span class="line"><span class="type">int</span>[] nums = <span class="keyword">new</span> <span class="title class_">int</span>[n];</span><br><span class="line"><span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">0</span>;i&lt;n; i++)</span><br><span class="line">&#123;</span><br><span class="line">    nums[i]= scanner.nextInt();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="（2）输入整数数组">（2）输入整数数组</h2><p>[1,2,3,0]这样格式的</p><ul><li><p>首先将整数数组转换成字符串</p></li><li><p>然后去除字符串的收尾[]</p></li><li><p>用,号进行分割</p></li><li><p>将字符串转为整数</p></li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">Scanner</span> <span class="variable">scanner</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Scanner</span>(System.in);</span><br><span class="line">        </span><br><span class="line"><span class="comment">// 提示用户输入数组</span></span><br><span class="line">System.out.println(<span class="string">&quot;请输入一个数组（例如 [1,2,3,4,0]）:&quot;</span>);</span><br><span class="line"><span class="type">String</span> <span class="variable">input</span> <span class="operator">=</span> scanner.nextLine();</span><br><span class="line"></span><br><span class="line"><span class="comment">// 去除输入字符串的首尾方括号</span></span><br><span class="line">input = input.substring(<span class="number">1</span>, input.length() - <span class="number">1</span>);</span><br><span class="line"></span><br><span class="line"><span class="comment">// 将输入的字符串分割成单独的数字字符串</span></span><br><span class="line">String[] numbers = input.split(<span class="string">&quot;,&quot;</span>);</span><br><span class="line"></span><br><span class="line"><span class="comment">// 创建一个数组来存储整数</span></span><br><span class="line"><span class="type">int</span>[] array = <span class="keyword">new</span> <span class="title class_">int</span>[numbers.length];</span><br><span class="line"></span><br><span class="line"><span class="comment">// 将字符串数组转换为整数数组</span></span><br><span class="line"><span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i &lt; numbers.length; i++) &#123;</span><br><span class="line">    array[i] = Integer.parseInt(numbers[i].trim());</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 关闭 Scanner 对象</span></span><br><span class="line">scanner.close();</span><br></pre></td></tr></table></figure><h2 id="（3）输入是字符串数组形式">（3）输入是字符串数组形式</h2><p>例如这样的格式[“a”,“e”,&quot; &quot;,“f”]</p><p>我们以一个题举例吧，对上面的字符串数组求反变为[“f”,&quot; &quot;, “e”,“a”]</p><p><strong>读取输入输出的整体思路</strong></p><ul><li><p>去除收尾的方括号</p></li><li><p>将字符串进行分割（使用到正则表达式）====》转为字符串数组</p></li><li><p>输出时添加方括号和逗号</p></li></ul><p><strong>整体代码如下：</strong></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 创建一个 Scanner 对象来读取控制台输入</span></span><br><span class="line"><span class="type">Scanner</span> <span class="variable">scanner</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Scanner</span>(System.in);</span><br><span class="line"></span><br><span class="line"><span class="comment">// 提示用户输入一个格式化的字符串数组</span></span><br><span class="line">System.out.println(<span class="string">&quot;请输入一个字符串数组（例如 [\&quot;a\&quot;,\&quot;b\&quot;,\&quot;\&quot; ,\&quot;d\&quot; ,\&quot;f\&quot;]）:&quot;</span>);</span><br><span class="line"><span class="type">String</span> <span class="variable">input</span> <span class="operator">=</span> scanner.nextLine();</span><br><span class="line"></span><br><span class="line"><span class="comment">// 去除输入字符串的首尾方括号</span></span><br><span class="line">input = input.substring(<span class="number">1</span>, input.length() - <span class="number">1</span>);</span><br><span class="line"></span><br><span class="line"><span class="comment">// 将输入的字符串分割成单独的字符串元素</span></span><br><span class="line">String[] elements = input.split(<span class="string">&quot;\\s*,\\s*&quot;</span>);</span><br><span class="line"></span><br><span class="line"><span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i &lt; elements.length; i++) &#123;</span><br><span class="line">    System.out.println(elements[i]);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 反转数组</span></span><br><span class="line">String[] reversedArray = reverseArray(elements);</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment">// 输出反转后的数组</span></span><br><span class="line">System.out.print(<span class="string">&quot;反转后的数组: [&quot;</span>);</span><br><span class="line"><span class="comment">// boolean isFirst = true; // 用于控制逗号的打印</span></span><br><span class="line"><span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i &lt; reversedArray.length; i++) &#123;</span><br><span class="line">    System.out.print( reversedArray[i]);</span><br><span class="line">    <span class="keyword">if</span> (i &lt; reversedArray.length - <span class="number">1</span>)&#123;</span><br><span class="line">        System.out.print(<span class="string">&quot;,&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line">System.out.println(<span class="string">&quot;]&quot;</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="（4）输入是字符形式">（4）输入是字符形式</h2><p><img src="2025-02-12-ACM%E6%A8%A1%E5%BC%8F%E8%BE%93%E5%85%A5%E8%BE%93%E5%87%BA%E6%A8%A1%E6%9D%BF%E6%80%BB%E7%BB%93/image.png" alt=""></p><p><img src="2025-02-12-ACM%E6%A8%A1%E5%BC%8F%E8%BE%93%E5%85%A5%E8%BE%93%E5%87%BA%E6%A8%A1%E6%9D%BF%E6%80%BB%E7%BB%93/image-1.png" alt=""></p><h2 id="（5）二维：固定行列">（5）二维：固定行列</h2><p><strong>输入：</strong></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="number">3</span> <span class="number">4</span></span><br><span class="line"><span class="number">1</span> <span class="number">2</span> <span class="number">3</span> <span class="number">4</span></span><br><span class="line"><span class="number">5</span> <span class="number">6</span> <span class="number">7</span> <span class="number">8</span></span><br><span class="line"><span class="number">9</span> <span class="number">10</span> <span class="number">11</span> <span class="number">12</span></span><br></pre></td></tr></table></figure><p><strong>输出：</strong></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> java.util.Scanner;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Main</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">        <span class="type">Scanner</span> <span class="variable">sc</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Scanner</span>(System.in);</span><br><span class="line">        <span class="type">int</span> <span class="variable">rows</span> <span class="operator">=</span> sc.nextInt(); <span class="comment">// 输入行数</span></span><br><span class="line">        <span class="type">int</span> <span class="variable">cols</span> <span class="operator">=</span> sc.nextInt(); <span class="comment">// 输入列数</span></span><br><span class="line">        <span class="type">int</span>[][] matrix = <span class="keyword">new</span> <span class="title class_">int</span>[rows][cols];</span><br><span class="line">        </span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i &lt; rows; i++) &#123;</span><br><span class="line">            <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">j</span> <span class="operator">=</span> <span class="number">0</span>; j &lt; cols; j++) &#123;</span><br><span class="line">                matrix[i][j] = sc.nextInt(); <span class="comment">// 逐元素输入</span></span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="（6）二维：不固定">（6）二维：不固定</h2><p><strong>输入：</strong></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="number">3</span></span><br><span class="line"><span class="number">1</span> <span class="number">2</span> <span class="number">3</span></span><br><span class="line"><span class="number">4</span> <span class="number">5</span></span><br><span class="line"><span class="number">6</span> <span class="number">7</span> <span class="number">8</span> <span class="number">9</span></span><br></pre></td></tr></table></figure><p><strong>输出：</strong></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> java.util.Scanner;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Main</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">        <span class="type">Scanner</span> <span class="variable">sc</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Scanner</span>(System.in);</span><br><span class="line">        <span class="type">int</span> <span class="variable">rows</span> <span class="operator">=</span> sc.nextInt();</span><br><span class="line">        sc.nextLine(); <span class="comment">// 清除换行符</span></span><br><span class="line">        <span class="type">int</span>[][] matrix = <span class="keyword">new</span> <span class="title class_">int</span>[rows][];</span><br><span class="line">        </span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i &lt; rows; i++) &#123;</span><br><span class="line">            String[] line = sc.nextLine().split(<span class="string">&quot; &quot;</span>);</span><br><span class="line">            matrix[i] = <span class="keyword">new</span> <span class="title class_">int</span>[line.length];</span><br><span class="line">            <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">j</span> <span class="operator">=</span> <span class="number">0</span>; j &lt; line.length; j++) &#123;</span><br><span class="line">                matrix[i][j] = Integer.parseInt(line[j]);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
    
    
    <summary type="html">🥧本人的ACM模式输入输出模板总结</summary>
    
    
    
    <category term="算法" scheme="https://outoflovenicoo.github.io/categories/%E7%AE%97%E6%B3%95/"/>
    
    
    <category term="算法" scheme="https://outoflovenicoo.github.io/tags/%E7%AE%97%E6%B3%95/"/>
    
  </entry>
  
  <entry>
    <title>工厂和策略模式优化消息处理</title>
    <link href="https://outoflovenicoo.github.io/posts/2025-01-11-%E5%B7%A5%E5%8E%82%E5%92%8C%E7%AD%96%E7%95%A5%E6%A8%A1%E5%BC%8F%E4%BC%98%E5%8C%96%E6%B6%88%E6%81%AF%E5%A4%84%E7%90%86.html"/>
    <id>https://outoflovenicoo.github.io/posts/2025-01-11-%E5%B7%A5%E5%8E%82%E5%92%8C%E7%AD%96%E7%95%A5%E6%A8%A1%E5%BC%8F%E4%BC%98%E5%8C%96%E6%B6%88%E6%81%AF%E5%A4%84%E7%90%86.html</id>
    <published>2025-01-11T10:19:03.000Z</published>
    <updated>2025-03-23T14:00:00.000Z</updated>
    
    <content type="html"><![CDATA[<h2 id="工厂和策略模式优化消息处理">工厂和策略模式优化消息处理</h2><p>有八中消息类型：</p><p><img src="2025-01-11-%E5%B7%A5%E5%8E%82%E5%92%8C%E7%AD%96%E7%95%A5%E6%A8%A1%E5%BC%8F%E4%BC%98%E5%8C%96%E6%B6%88%E6%81%AF%E5%A4%84%E7%90%86/image-1.png" alt=""></p><p>首先，为了让用户评论、点赞与消息发送解耦，可以采用观察者模式，用户评论触发一个消息通知事件</p><p><img src="2025-01-11-%E5%B7%A5%E5%8E%82%E5%92%8C%E7%AD%96%E7%95%A5%E6%A8%A1%E5%BC%8F%E4%BC%98%E5%8C%96%E6%B6%88%E6%81%AF%E5%A4%84%E7%90%86/image-3.png" alt=""></p><p>在处理消息时，不同的消息类型有不同的策略。</p><p>比如点赞消息时先聚合到redis，再迁移到数据库</p><p><img src="2025-01-11-%E5%B7%A5%E5%8E%82%E5%92%8C%E7%AD%96%E7%95%A5%E6%A8%A1%E5%BC%8F%E4%BC%98%E5%8C%96%E6%B6%88%E6%81%AF%E5%A4%84%E7%90%86/image-5.png" alt=""></p><p>官方消息是直接存消息表，在用户登录的时候将官方消息迁移到用户消息接收表（这样可以避免数据库压力太大）</p><p><img src="2025-01-11-%E5%B7%A5%E5%8E%82%E5%92%8C%E7%AD%96%E7%95%A5%E6%A8%A1%E5%BC%8F%E4%BC%98%E5%8C%96%E6%B6%88%E6%81%AF%E5%A4%84%E7%90%86/image-24.png" alt=""></p><p>用户的回复消息，是要先存入到消息表，生成一个消息id，再存入消息接受表。给消息id和用户id加唯一索引，这样可以避免用户收到重复的消息。</p><p><img src="2025-01-11-%E5%B7%A5%E5%8E%82%E5%92%8C%E7%AD%96%E7%95%A5%E6%A8%A1%E5%BC%8F%E4%BC%98%E5%8C%96%E6%B6%88%E6%81%AF%E5%A4%84%E7%90%86/image-26.png" alt=""></p><p>因为有三种不同的应对策略，所以可以写一个工厂来统一处理。首先先定义一个工厂，写一个消息处理的接口</p><p><img src="2025-01-11-%E5%B7%A5%E5%8E%82%E5%92%8C%E7%AD%96%E7%95%A5%E6%A8%A1%E5%BC%8F%E4%BC%98%E5%8C%96%E6%B6%88%E6%81%AF%E5%A4%84%E7%90%86/image-25.png" alt=""></p><p>接口：<br>注意，精髓是@PostConstruct，这个注解会让bean在初始化的时候，将hander注册到工厂里面。</p><p><img src="2025-01-11-%E5%B7%A5%E5%8E%82%E5%92%8C%E7%AD%96%E7%95%A5%E6%A8%A1%E5%BC%8F%E4%BC%98%E5%8C%96%E6%B6%88%E6%81%AF%E5%A4%84%E7%90%86/image-22.png" alt=""></p><p>针对接口定义三个实现类，处理不同的消息类型</p><p>点赞消息处理</p><p><img src="2025-01-11-%E5%B7%A5%E5%8E%82%E5%92%8C%E7%AD%96%E7%95%A5%E6%A8%A1%E5%BC%8F%E4%BC%98%E5%8C%96%E6%B6%88%E6%81%AF%E5%A4%84%E7%90%86/image-21.png" alt=""></p><p>官方消息处理</p><p><img src="2025-01-11-%E5%B7%A5%E5%8E%82%E5%92%8C%E7%AD%96%E7%95%A5%E6%A8%A1%E5%BC%8F%E4%BC%98%E5%8C%96%E6%B6%88%E6%81%AF%E5%A4%84%E7%90%86/image-23.png" alt=""></p><p>回复消息处理</p><p><img src="2025-01-11-%E5%B7%A5%E5%8E%82%E5%92%8C%E7%AD%96%E7%95%A5%E6%A8%A1%E5%BC%8F%E4%BC%98%E5%8C%96%E6%B6%88%E6%81%AF%E5%A4%84%E7%90%86/image-20250420152609880.png" alt="image-20250420152609880"></p>]]></content>
    
    
    <summary type="html">🥧工厂和策略模式优化消息处理</summary>
    
    
    
    <category term="学习" scheme="https://outoflovenicoo.github.io/categories/%E5%AD%A6%E4%B9%A0/"/>
    
    
    <category term="实习经验" scheme="https://outoflovenicoo.github.io/tags/%E5%AE%9E%E4%B9%A0%E7%BB%8F%E9%AA%8C/"/>
    
  </entry>
  
</feed>
