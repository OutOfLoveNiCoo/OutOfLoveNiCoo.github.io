<?xml version="1.0" encoding="utf-8"?>
<search> 
  
  
    
    <entry>
      <title>联合索引学习笔记</title>
      <link href="/posts/2025-03-09-%E8%81%94%E5%90%88%E7%B4%A2%E5%BC%95%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0.html"/>
      <url>/posts/2025-03-09-%E8%81%94%E5%90%88%E7%B4%A2%E5%BC%95%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0.html</url>
      
        <content type="html"><![CDATA[<h1>联合索引底层以及内幕</h1><p><a href="https://mp.weixin.qq.com/s/8qemhRg5MgXs1So5YCv0fQ">联合索引底层</a></p><p><a href="https://blog.csdn.net/wangye135/article/details/140389620">MySQL覆盖索引和索引跳跃扫描-CSDN博客</a></p><p><img src="2025-03-09-%E8%81%94%E5%90%88%E7%B4%A2%E5%BC%95%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/image-20250407160156273-4012927.png" alt="image-20250407160156273"></p><h3 id="被问到过一个面试题：">被问到过一个面试题：</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">select a,c from t <span class="type">where</span> <span class="variable">a</span> <span class="operator">=</span> <span class="number">1</span> and b= <span class="number">2</span> order by c desc</span><br></pre></td></tr></table></figure><p>应该设置什么索引，c的升序和降序会有什么影响，哪个更快一点。</p><h3 id="升序索引与降序索引对查询性能的影响">升序索引与降序索引对查询性能的影响</h3><h4 id="1-查询排序方向与索引排序方向一致">1. 查询排序方向与索引排序方向一致</h4><ul><li><strong>升序索引用于升序查询</strong>：当创建的索引是 <code>(a, b, c ASC)</code>（<code>ASC</code> 表示升序，可省略），并且查询语句是 <code>ORDER BY c ASC</code> 时，数据库可以直接按照索引中 <code>c</code> 列的顺序来返回结果，无需额外的排序操作，这样能显著提升查询效率。因为索引已经按照升序排列好了，数据库可以直接从索引中获取有序的数据。</li><li><strong>降序索引用于降序查询</strong>：如果创建的索引是 <code>(a, b, c DESC)</code>，而查询语句是 <code>ORDER BY c DESC</code>，数据库同样可以直接利用索引中 <code>c</code> 列的降序排列来返回结果，避免了额外的排序开销。</li></ul><h4 id="2-查询排序方向与索引排序方向不一致">2. 查询排序方向与索引排序方向不一致</h4><ul><li><strong>升序索引用于降序查询</strong>：当使用 <code>(a, b, c ASC)</code> 索引，而查询语句是 <code>ORDER BY c DESC</code> 时，数据库可能无法直接利用索引的顺序，需要对从索引中获取的数据进行额外的降序排序操作。这会增加查询的时间和资源消耗，尤其是在处理大量数据时，性能下降会更明显。</li><li><strong>降序索引用于升序查询</strong>：类似地，若使用 <code>(a, b, c DESC)</code> 索引，而查询是 <code>ORDER BY c ASC</code>，数据库也需要对数据进行额外的升序排序，导致性能降低。</li></ul><h3 id="哪个更快取决于具体场景">哪个更快取决于具体场景</h3><ul><li><strong>如果查询中</strong> **<code>ORDER BY c</code>**的方向固定：<ul><li>若查询总是 <code>ORDER BY c ASC</code>，那么创建升序索引 <code>(a, b, c)</code> 会更快，因为可以直接利用索引的顺序。</li><li>若查询总是 <code>ORDER BY c DESC</code>，则创建降序索引 <code>(a, b, c DESC)</code> 更合适，能避免额外的排序操作。</li></ul></li><li><strong>如果查询中</strong> **<code>ORDER BY c</code>**的方向不固定：<ul><li>在某些数据库（如 MySQL 8.0 及以上版本）中，可以同时创建升序和降序索引，但这会增加索引维护的开销，因为每次插入、更新或删除数据时，都需要同时更新多个索引。</li><li>也可以考虑只创建一个升序索引，让数据库在需要降序排序时进行额外的排序操作。在数据量较小的情况下，这种额外排序的开销可能并不明显。</li></ul></li></ul><p><strong>示例代码</strong></p><p><strong>升序索引</strong></p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">-- 创建升序索引</span></span><br><span class="line"><span class="keyword">CREATE</span> INDEX idx_a_b_c_asc <span class="keyword">ON</span> t (a, b, c);</span><br><span class="line"></span><br><span class="line"><span class="comment">-- 升序查询</span></span><br><span class="line"><span class="keyword">SELECT</span> a, c <span class="keyword">FROM</span> t <span class="keyword">WHERE</span> a <span class="operator">=</span> <span class="number">1</span> <span class="keyword">AND</span> b <span class="operator">=</span> <span class="number">2</span> <span class="keyword">ORDER</span> <span class="keyword">BY</span> c <span class="keyword">ASC</span>;</span><br></pre></td></tr></table></figure><p><strong>降序索引</strong></p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">-- 创建降序索引</span></span><br><span class="line"><span class="keyword">CREATE</span> INDEX idx_a_b_c_desc <span class="keyword">ON</span> t (a, b, c <span class="keyword">DESC</span>);</span><br><span class="line"></span><br><span class="line"><span class="comment">-- 降序查询</span></span><br><span class="line"><span class="keyword">SELECT</span> a, c <span class="keyword">FROM</span> t <span class="keyword">WHERE</span> a <span class="operator">=</span> <span class="number">1</span> <span class="keyword">AND</span> b <span class="operator">=</span> <span class="number">2</span> <span class="keyword">ORDER</span> <span class="keyword">BY</span> c <span class="keyword">DESC</span>;</span><br></pre></td></tr></table></figure><p>综上所述，选择升序索引还是降序索引取决于查询中 <code>ORDER BY</code> 子句的排序方向。</p>]]></content>
      
      
      <categories>
          
          <category> 学习 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> MySQL </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>MySQL如何存储数据</title>
      <link href="/posts/2025-03-09-MySQL%E5%A6%82%E4%BD%95%E5%AD%98%E5%82%A8%E6%95%B0%E6%8D%AE.html"/>
      <url>/posts/2025-03-09-MySQL%E5%A6%82%E4%BD%95%E5%AD%98%E5%82%A8%E6%95%B0%E6%8D%AE.html</url>
      
        <content type="html"><![CDATA[<h1 id="InnoDB存储引擎如何存储数据"><a href="#InnoDB存储引擎如何存储数据" class="headerlink" title="InnoDB存储引擎如何存储数据"></a>InnoDB存储引擎如何存储数据</h1><h2 id="思维导图："><a href="#思维导图：" class="headerlink" title="思维导图："></a><strong>思维导图：</strong></h2><p><img src="2025-03-09-MySQL如何存储数据/1.png" alt="img"></p><p>在MySQL数据库的世界里，InnoDB存储引擎堪称是数据存储的”心脏”。今天，我们就以一位数据库工程师的视角，揭开这个”心脏”的运作奥秘。准备好了吗？让我们沿着数据存储的脉络，开启一场技术探秘之旅！</p><h2 id="一、MySQL数据存储基石：InnoDB的精密设计"><a href="#一、MySQL数据存储基石：InnoDB的精密设计" class="headerlink" title="一、MySQL数据存储基石：InnoDB的精密设计"></a>一、MySQL数据存储基石：InnoDB的精密设计</h2><p>如果把数据库比作图书馆，InnoDB就是那个既懂分类又善管理的图书管理员。它通过精心设计的文件系统，将数据有序地存放在磁盘上。</p><h3 id="（一）磁盘文件里的”身份证”与”藏书阁”"><a href="#（一）磁盘文件里的”身份证”与”藏书阁”" class="headerlink" title="（一）磁盘文件里的”身份证”与”藏书阁”"></a>（一）磁盘文件里的”身份证”与”藏书阁”</h3><p><img src="2025-03-09-MySQL如何存储数据/2.png" alt="img"></p><p>当我们新建一个订单表<code>order</code>时，系统会悄悄生成几个关键文件：<br>• <strong>opt文件</strong>：就像是数据库的”身份证”，记录着默认的字符集（比如UTF-8）和校验规则。它确保中文不会变成乱码，数字比较时不会出错。<br>• <strong>frm文件</strong>：可以理解为”书架标签”，存储着表结构的定义。每次你DESC查看表结构时，系统其实就是在读取这个文件。<br>• <strong>idb文件</strong>：这才是真正的”藏书阁”。以<code>order.idb</code>为例，它存储着订单表的所有数据。就像现代图书馆的智能书架，MySQL 5.6.6之后默认每个表都有独立的.idb文件，这样要维护某个书架（表）时，再也不用搬动整个图书馆的藏书了。</p><p>举个真实案例：某电商平台发现订单表查询变慢，DBA通过<code>ALTER TABLE order ENGINE=InnoDB</code>重建表空间后，发现.idb文件体积缩小了30%，这正是独立表空间的优势体现。</p><h3 id="（二）表空间的俄罗斯套娃结构"><a href="#（二）表空间的俄罗斯套娃结构" class="headerlink" title="（二）表空间的俄罗斯套娃结构"></a>（二）表空间的俄罗斯套娃结构</h3><p>打开这个”藏书阁”，你会发现一个精妙的存储体系：</p><p><img src="2025-03-09-MySQL如何存储数据/3.png" alt="img"></p><figure class="highlight"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">表空间 → 段 → 区 → 页 → 行</span><br></pre></td></tr></table></figure><p>就像图书馆的分区管理：<br>• <strong>段（Segment）</strong>：类似图书馆的楼层分区（索引区、数据区）<br>• <strong>区（Extent）</strong>：每个楼层里的藏书区，由连续64个页组成（1MB）<br>• <strong>页（Page）</strong>：最基本的存储单元，相当于书架隔层（16KB）<br>• <strong>行（Row）</strong>：每本书就是一行数据</p><p>这种结构设计有个精妙之处：当需要新增数据时，InnoDB不是随意找个空位，而是整区整区地分配空间。就像图书馆扩建时直接增加整个书架区，而不是这里加一本那里塞一册。</p><h2 id="二、行格式"><a href="#二、行格式" class="headerlink" title="二、行格式"></a>二、行格式</h2><p>如果说表空间是图书馆，那么行格式就是书籍的排版规范。InnoDB支持多种行格式，我们以最常用的Compact格式为例，看看它是如何将数据”装订成册”的。</p><h3 id="（一）变长字段的"><a href="#（一）变长字段的" class="headerlink" title="（一）变长字段的"></a>（一）变长字段的</h3><p>假设我们有一张用户表：<br><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">CREATE TABLE</span> users (</span><br><span class="line">    id <span class="type">INT</span> <span class="keyword">NOT NULL</span>,</span><br><span class="line">    name <span class="type">VARCHAR</span>(<span class="number">20</span>),</span><br><span class="line">    email <span class="type">VARCHAR</span>(<span class="number">50</span>)</span><br><span class="line">);</span><br></pre></td></tr></table></figure><br>当插入一条记录：<br><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">INSERT INTO</span> users <span class="keyword">VALUES</span>(<span class="number">1</span>, <span class="string">&#x27;张三&#x27;</span>, <span class="string">&#x27;zhangsan@example.com&#x27;</span>);</span><br></pre></td></tr></table></figure><br>Compact行格式会先在数据行头部放置两把”尺子”：</p><ol><li><p><strong>变长字段长度列表</strong>：逆序记录每个变长字段的实际长度<br>• email长度23字节（ASCII每个字符1字节）<br>• name长度4字节（每个中文字符3字节？不！这里有个常见误区，实际存储长度取决于字符集）<br>• 存储方式：<code>[23,4]</code>的逆序十六进制<code>0x17 0x04</code></p></li><li><p><strong>NULL值标记位图</strong>：<br>• 三个字段都不允许NULL，所以这个列表不存在<br>• 如果允许NULL，会用位图标记哪些字段是NULL（1表示NULL）</p></li></ol><p>这里有个有趣的测试：将name字段改为CHAR(20)，实际存储长度会变成60字节（假设UTF8MB4字符集），而VARCHAR(20)实际存储长度根据内容变化。这就是CHAR类型在存储空间上的”以空间换时间”策略。</p><h3 id="（二）NULL值的存储"><a href="#（二）NULL值的存储" class="headerlink" title="（二）NULL值的存储"></a>（二）NULL值的存储</h3><p>当表中存在允许NULL的字段时，Compact行格式会施展它的”隐身术”：<br><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">CREATE TABLE</span> orders (</span><br><span class="line">    id <span class="type">INT</span> <span class="keyword">PRIMARY KEY</span>,</span><br><span class="line">    product <span class="type">VARCHAR</span>(<span class="number">100</span>),</span><br><span class="line">    buyer <span class="type">VARCHAR</span>(<span class="number">50</span>) <span class="keyword">NULL</span></span><br><span class="line">);</span><br></pre></td></tr></table></figure><br>假设插入：<br><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">INSERT INTO</span> orders <span class="keyword">VALUES</span>(<span class="number">1001</span>, <span class="string">&#x27;智能手机&#x27;</span>, <span class="keyword">NULL</span>);</span><br></pre></td></tr></table></figure><br>此时：</p><ol><li>NULL值列表用1字节表示：二进制<code>00000010</code>（逆序排列，第二位表示buyer为NULL）</li><li>实际数据区不存储NULL字段的值</li><li>省去了存储”NULL”字符串的空间</li></ol><p>根据统计，当表中存在多个可为NULL的字段时，这种设计可节省约5%的存储空间。某社交平台用户表优化后，仅NULL优化就减少了20GB的存储空间！</p><h2 id="三、当数据膨胀时的”分页存储术”"><a href="#三、当数据膨胀时的”分页存储术”" class="headerlink" title="三、当数据膨胀时的”分页存储术”"></a>三、当数据膨胀时的”分页存储术”</h2><p>想象一本百科全书太厚无法放入书架隔层，这时候就需要分册存放。InnoDB的行溢出机制就是这种智慧的数字版。</p><h3 id="（一）行溢出的临界点计算"><a href="#（一）行溢出的临界点计算" class="headerlink" title="（一）行溢出的临界点计算"></a>（一）行溢出的临界点计算</h3><p>每个页（16KB）能存储多少数据？我们通过公式计算：<br><figure class="highlight abnf"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">最大行长度 <span class="operator">=</span> 页大小(<span class="number">16384</span>) - 行头信息(约<span class="number">56</span>字节) ≈ <span class="number">16328</span>字节</span><br></pre></td></tr></table></figure><br>当某行数据超过这个阈值时，就会触发行溢出。比如一个包含10个TEXT字段的表，每条记录都可能需要溢出存储。</p><h3 id="（二）溢出页的”目录索引”"><a href="#（二）溢出页的”目录索引”" class="headerlink" title="（二）溢出页的”目录索引”"></a>（二）溢出页的”目录索引”</h3><p>当发生行溢出时，Compact行格式会：</p><ol><li>在原始页保留768字节的”书签”</li><li>剩余数据存入溢出页</li><li>用20字节的指针记录溢出页地址</li><li>多个溢出页通过链表连接</li></ol><p>这就像图书馆的书籍目录：<br>• 主书架存放目录页（包含各分册位置）<br>• 实际内容存放在多个分册书架</p><p>某论坛系统曾因大文本字段导致频繁行溢出，通过将大字段拆分到扩展表，查询性能提升了3倍。</p><h2 id="四、行格式设计"><a href="#四、行格式设计" class="headerlink" title="四、行格式设计"></a>四、行格式设计</h2><h3 id="（一）Compact-vs-Dynamic：选择的智慧"><a href="#（一）Compact-vs-Dynamic：选择的智慧" class="headerlink" title="（一）Compact vs Dynamic：选择的智慧"></a>（一）Compact vs Dynamic：选择的智慧</h3><p>MySQL 8.0默认使用Dynamic行格式，它在处理溢出时更激进：<br>• 仅保留20字节指针<br>• 所有变长字段数据优先存溢出页<br>• 更适合现代应用的大数据字段场景</p><p>选择建议：<br>• 频繁更新的大字段表 → Dynamic<br>• 需要兼容旧版本 → Compact<br>• 压缩需求 → Compressed</p><h3 id="（二）字符集的隐藏陷阱"><a href="#（二）字符集的隐藏陷阱" class="headerlink" title="（二）字符集的隐藏陷阱"></a>（二）字符集的隐藏陷阱</h3><p>当计算varchar(n)最大长度时，字符集的影响常被忽视：<br>• UTF8MB4字符集：每个字符最多4字节<br>• 实际最大n值 = (65535 - 长度列表 - NULL列表) / 4</p><p>例如允许NULL的单字段表：<br><figure class="highlight tap"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">(65535 -<span class="number"> 2 </span>- 1) /<span class="number"> 4 </span>≈ 16383字符</span><br></pre></td></tr></table></figure><br>某国际化电商就曾因未考虑字符集，导致地址字段被截断，损失百万订单。</p><h2 id="五、性能优化"><a href="#五、性能优化" class="headerlink" title="五、性能优化"></a>五、性能优化</h2><ol><li><strong>NULL值优化</strong>：将允许NULL的字段改为NOT NULL DEFAULT ‘’，可节省NULL列表空间</li><li><strong>大字段分离</strong>：将BLOB/TEXT字段拆分到扩展表</li><li><strong>行格式转换</strong>：<code>ALTER TABLE ... ROW_FORMAT=DYNAMIC</code></li><li><strong>页压缩</strong>：对历史数据表启用页压缩</li><li><strong>字符集选择</strong>：中文环境优先考虑UTF8MB4而非UTF8</li></ol><p>某金融系统通过上述优化组合拳，使核心交易表的TPS从1500提升到5200，效果显著。</p><h2 id="结语：存储之道的三重境界"><a href="#结语：存储之道的三重境界" class="headerlink" title="结语：存储之道的三重境界"></a>结语：存储之道的三重境界</h2><p>理解InnoDB的存储机制，就像修炼数据库的内功心法：</p><ol><li><strong>见山是山</strong>：看懂文件结构和行格式</li><li><strong>见山不是山</strong>：理解设计哲学与取舍权衡</li><li><strong>见山还是山</strong>：能根据业务特征定制存储方案</li></ol><p>当我们翻开InnoDB的存储宝典，看到的不仅是冷冰冰的数据结构，更是一群工程师对效率与可靠性的极致追求。下次当你执行一条SELECT语句时，不妨想象一下，这简单的查询背后，正有一支精密的”存储交响乐团”在为你演奏。</p><h1 id="参考博客："><a href="#参考博客：" class="headerlink" title="参考博客："></a>参考博客：</h1><p><a href="https://xiaolincoding.com/mysql/base/row_format.html#总结">MySQL 一行记录是怎么存储的？</a></p>]]></content>
      
      
      <categories>
          
          <category> 学习 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> MySQL </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Java基础面试题</title>
      <link href="/posts/2025-01-01-Java%E5%9F%BA%E7%A1%80.html"/>
      <url>/posts/2025-01-01-Java%E5%9F%BA%E7%A1%80.html</url>
      
        <content type="html"><![CDATA[<h1>2.Java</h1><p><img src="2025-01-01-Java%E5%9F%BA%E7%A1%80/clip_image001.jpg" alt="img"></p><p>1.Java基础</p><p>1.1 BIO、NIO、AIO有什么区别</p><p><img src="2025-01-01-Java%E5%9F%BA%E7%A1%80/clip_image003.jpg" alt="img"></p><p>1.2 Comparator与Comparable有什么区别</p><p><img src="2025-01-01-Java%E5%9F%BA%E7%A1%80/clip_image005.jpg" alt="img"></p><p><img src="2025-01-01-Java%E5%9F%BA%E7%A1%80/clip_image007.jpg" alt="img"></p><p><img src="2025-01-01-Java%E5%9F%BA%E7%A1%80/clip_image009.jpg" alt="img"></p><p>1.3 说说你对Integer缓存的理解</p><p><img src="2025-01-01-Java%E5%9F%BA%E7%A1%80/clip_image011.jpg" alt="img"></p><p>1.4 synchronized的实现原理</p><p>在JVM内部，每个Java对象都有头信息，其中包含了对象的一些元信息和状态标志。synchronized通过修改头信息的状态标志来实现锁的获取和释放。</p><p>当synchronized作用于某个对象时，它就会尝试获取这个对象的锁，如果锁没有被其他线程占用，则当前线程获取到锁，并可以执行同步代码块；如果锁已经被其他线程占用，那么当前线程就会阻塞在同步块之外，直到获取到锁才能进入同步块。</p><p>当 synchronized 作用于实例方法时，锁住的是当前实例对象（即 this）。当synchronized 作用于静态方法时，锁住的是当前类的 Class 对象。当 synchronized 作用于某个类时，此时它锁住的是整个类，而不是类的某个实例。在这种情况下，由于只有一个锁存在，所以所有使用该类的线程都需要等待锁的释放。</p><p>synchronized还支持可重入性，即在同一个线程中可以多次获取同一个锁，这样可以避免死锁问题。Java虚拟机会通过锁升级的方式来提升synchronized的效率，比如偏向锁、轻量级锁和重量级锁等机制，使得在竞争不激烈的情况下，synchronized的性能可以达到与非同步代码相当的水平。</p><p>1.5⭐️ synchronized锁优化</p><p>轻量级锁和重量级锁的区别是轻量级锁会一直尝试获取锁，而重量级锁不会并且会阻塞</p><p>•     偏向锁：线程获取锁后在对象头记录线程标识，再次进入同步块无需额外加锁操作，提高性能。适用于锁基本无竞争场景，减少无竞争时加解锁开销。</p><p>•     轻量级锁：多个线程竞争同一锁时，JVM采用轻量级锁，以自旋方式尝试快速获取锁，不放弃CPU执行时间，避免线程阻塞和上下文切换开销。适用于短时间内锁竞争不激烈场景，自旋一段时间若未获取到锁，会升级为重量级锁。</p><p>•     重量级锁：线程对同一锁强烈竞争时，JVM将锁升级为重量级锁，此时线程进入阻塞状态等待锁释放。适用于竞争激烈场景，但因线程阻塞和上下文切换等操作，会带来较大性能开销。</p><p>1.6 ⭐️讲讲你对ThreadLocal的理解</p><p><img src="2025-01-01-Java%E5%9F%BA%E7%A1%80/clip_image013.jpg" alt="img"></p><p><img src="2025-01-01-Java%E5%9F%BA%E7%A1%80/clip_image015.jpg" alt="img"></p><p>1.7 ✅JDK和JRE和JVM</p><p><img src="2025-01-01-Java%E5%9F%BA%E7%A1%80/clip_image017.jpg" alt="img"></p><p>1.8 ✅什么是字节码？采用字节码的好处是什么？</p><p><img src="2025-01-01-Java%E5%9F%BA%E7%A1%80/clip_image019.jpg" alt="img"></p><p>1.9 为什么不全部使用 AOT 呢？</p><p>使用AOT就是直接在运行前把字节码编译成机器码然后执行，但是这样就不能支持java的运行时动态特性了。</p><p><img src="2025-01-01-Java%E5%9F%BA%E7%A1%80/clip_image021.jpg" alt="img"></p><p>1.10 ⭐️为什么说 Java 语言“编译与解释并存”？</p><p>答：java是编译型是指java代码要先编译成.Class字节码，jvm才能运行。此外，在jvm里面，热点代码通过JIT会直接编译成机器码然后执行。</p><p>Java是解释型语言是指，字节码在Jvm中的执行是通过解释器一句一句解释成机器码然后才能执行的。</p><p><img src="2025-01-01-Java%E5%9F%BA%E7%A1%80/clip_image023.jpg" alt="img"></p><p><img src="2025-01-01-Java%E5%9F%BA%E7%A1%80/clip_image025.jpg" alt="img"></p><p>1.11 基本类型和包装类型的区别？</p><p><img src="2025-01-01-Java%E5%9F%BA%E7%A1%80/clip_image027.jpg" alt="img"></p><p>1.12 为什么浮点数运算的时候会有精度丢失的风险？</p><p><img src="2025-01-01-Java%E5%9F%BA%E7%A1%80/clip_image029.jpg" alt="img"></p><p>1.13 面向对象三特征：封装、继承、多态</p><p><img src="2025-01-01-Java%E5%9F%BA%E7%A1%80/clip_image031.jpg" alt="img"></p><p><img src="2025-01-01-Java%E5%9F%BA%E7%A1%80/clip_image033.jpg" alt="img"></p><p>1.14 ⭐️向上转型，向下转型</p><p><img src="2025-01-01-Java%E5%9F%BA%E7%A1%80/clip_image035.jpg" alt="img"></p><p>1.15 ✅为什么要有 hashCode？</p><p><img src="2025-01-01-Java%E5%9F%BA%E7%A1%80/clip_image037.jpg" alt="img"></p><p>1.16 intern 方法有什么作用？</p><p>字符串常量池在堆里面。</p><p>运行时常量池在元空间（方法区）里面</p><p><img src="2025-01-01-Java%E5%9F%BA%E7%A1%80/clip_image039.jpg" alt="img"></p><p>1.17 ✅Java异常体系</p><p><img src="2025-01-01-Java%E5%9F%BA%E7%A1%80/clip_image041.jpg" alt="img"></p><p><img src="2025-01-01-Java%E5%9F%BA%E7%A1%80/clip_image043.jpg" alt="img"></p><p>1.18 ⭐️注解的解析方法有哪几种？</p><p>Java中注解需被解析才生效，常见解析方法有：</p><p>•     编译期直接扫描：编译器编译Java代码时扫描并处理对应注解。如@Override注解，编译器会检测方法是否重写父类对应方法，用于在编译阶段进行语法和逻辑的检查，确保代码符合重写规范。</p><p>•     运行期通过反射处理：像Spring框架的@Value、@Component等框架自带注解，利用反射机制在运行时获取类、方法、字段等信息，并根据注解定义的规则进行相应处理，如依赖注入、组件注册等操作，增强了框架的灵活性和扩展性。</p><p>2.Java集合</p><p>2.1 ArrayList怎么做的数组扩容</p><p><img src="2025-01-01-Java%E5%9F%BA%E7%A1%80/clip_image045.jpg" alt="img"></p><p>2.2 什么是 fail-fast， 什么是 fail-safe</p><p><img src="2025-01-01-Java%E5%9F%BA%E7%A1%80/clip_image047.jpg" alt="img"></p><p>2.3 如何实现数组和 List 之间的转换？</p><p><img src="2025-01-01-Java%E5%9F%BA%E7%A1%80/clip_image049.jpg" alt="img"></p><p>2.4 ⭐️HashSet实现原理</p><p><img src="2025-01-01-Java%E5%9F%BA%E7%A1%80/clip_image051.jpg" alt="img"></p><p>2.5 HashMap工作原理</p><p>HashMap基于哈希表工作，哈希表利用哈希函数将键映射到存储位置：</p><p>•     哈希映射：计算键的哈希值并转化为数组索引，以此快速定位键值对存储位置。理想状态下，哈希函数让键均匀分布，减少哈希冲突。</p><p>•     解决哈希冲突：</p><p>￮    Java 1.7：主要用链表解决，相同哈希值的键值对链接在一起。</p><p>￮    Java 1.8：当链表长度和数组长度超一定阈值，链表转换为红黑树。红黑树是自平衡二叉搜索树，在哈希冲突较多时，查找、插入和删除操作更快。</p><p>HashMap综合哈希表、链表和红黑树原理，实现高效的键值对存储与查找功能。</p><p>2.6 ⭐️HashMap 的PUT工作流程？</p><p><img src="2025-01-01-Java%E5%9F%BA%E7%A1%80/clip_image053.jpg" alt="img"></p><p>2.7 比较 HashSet、 LinkedHashSet 和 TreeSet 三者的异同</p><p><img src="2025-01-01-Java%E5%9F%BA%E7%A1%80/clip_image055.jpg" alt="img"></p><p>2.8 ⭐️Queue 与 Deque 的区别</p><p><img src="2025-01-01-Java%E5%9F%BA%E7%A1%80/clip_image057.jpg" alt="img"></p><p>2.9 在 Queue 中 poll()和 remove（）有什么区别？</p><p><img src="2025-01-01-Java%E5%9F%BA%E7%A1%80/clip_image059.jpg" alt="img"></p><p>2.10 ⭐️ArrayDeque 与 LinkedList 的区别</p><p><img src="2025-01-01-Java%E5%9F%BA%E7%A1%80/clip_image061.jpg" alt="img"></p><p>ArrayDeque： ArrayDeque 内部维护了一 个循环数组，通过两个指针 （front 和 rear）来标记队列的头部 和尾部。当向队列中添加元素 时，rear 指针向后移动；当从队 列中删除元素时，front 指针向 后移动。如果数组满了， ArrayDeque 会自动扩容。 ArrayDeque 的底层数组长度是2的幂次方，这样可以通 位运算来实现循环队列的操作， 提高性能。</p><p>LinkedList： LinkedList 内部使用双向链 表来存储元素。每个节点都包含 一个前驱节点和一个后继节点的 引用。通过这种方式， LinkedList 可以在任意位置高效 地插入和删除元素。 LinkedList 还有一个头结点 和尾节点的引用，分别表示链表 的头部和尾部。通过这两个引用，可以快速访问到链表的第一个和最后一个元素。</p><p>2.11 ⭐️HashMap 的长度为什么是2的幂次方</p><p><img src="2025-01-01-Java%E5%9F%BA%E7%A1%80/clip_image063.jpg" alt="img"></p><p>2.12 ⭐️HashMap 多线程操作导致死循环问题</p><p><img src="2025-01-01-Java%E5%9F%BA%E7%A1%80/clip_image065.jpg" alt="img"></p><p>2.13 ⭐️LinkedHashMap是什么？怎么买现的？</p><p><img src="2025-01-01-Java%E5%9F%BA%E7%A1%80/clip_image067.jpg" alt="img"></p><p>2.14 ⭐️为什么 ConcurrentHashMap 比 HashTable 效率要高？</p><p><img src="2025-01-01-Java%E5%9F%BA%E7%A1%80/clip_image069.jpg" alt="img"></p>]]></content>
      
      
      <categories>
          
          <category> 面试题 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Java基础面试题 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>JUC基础面试题</title>
      <link href="/posts/2025-01-09-JUC%E5%9F%BA%E7%A1%80%E9%9D%A2%E8%AF%95%E9%A2%98.html"/>
      <url>/posts/2025-01-09-JUC%E5%9F%BA%E7%A1%80%E9%9D%A2%E8%AF%95%E9%A2%98.html</url>
      
        <content type="html"><![CDATA[<h1>学习</h1><h2 id="1-Future">1.Future</h2><blockquote><p><a href="https://javaguide.cn/java/concurrent/java-concurrent-questions-03.html#future-%E7%B1%BB%E6%9C%89%E4%BB%80%E4%B9%88%E7%94%A8">Future 类有什么用？</a></p><p><a href="https://juejin.cn/post/6844904199625375757">Java是如何实现Future模式的?万字详解!</a></p></blockquote><p><img src="2025-01-09-JUC%E5%9F%BA%E7%A1%80%E9%9D%A2%E8%AF%95%E9%A2%98/diagram.png" alt=""></p><h2 id="（1）Future的用法">（1）Future的用法</h2><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// DaHuoGuo.java</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">DaHuoGuo</span> &#123;</span><br><span class="line">        <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> Exception &#123;</span><br><span class="line">                FutureTask&lt;String&gt; futureTask = <span class="keyword">new</span> <span class="title class_">FutureTask</span>&lt;&gt;(<span class="keyword">new</span> <span class="title class_">Callable</span>&lt;String&gt;() &#123;</span><br><span class="line">                        <span class="meta">@Override</span></span><br><span class="line">                        <span class="keyword">public</span> String <span class="title function_">call</span><span class="params">()</span> <span class="keyword">throws</span> Exception &#123;</span><br><span class="line">                                System.out.println(Thread.currentThread().getName() + <span class="string">&quot;:&quot;</span> + <span class="string">&quot;开始烧开水...&quot;</span>);</span><br><span class="line">                                <span class="comment">// 模拟烧开水耗时</span></span><br><span class="line">                                Thread.sleep(<span class="number">2000</span>);</span><br><span class="line">                                System.out.println(Thread.currentThread().getName() + <span class="string">&quot;:&quot;</span>  + <span class="string">&quot;开水已经烧好了...&quot;</span>);</span><br><span class="line">                                <span class="keyword">return</span> <span class="string">&quot;开水&quot;</span>;</span><br><span class="line">                        &#125;</span><br><span class="line">                &#125;);</span><br><span class="line"></span><br><span class="line">                <span class="type">Thread</span> <span class="variable">thread</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Thread</span>(futureTask);</span><br><span class="line">                thread.start();</span><br><span class="line"></span><br><span class="line">                <span class="comment">// do other thing</span></span><br><span class="line">                System.out.println(Thread.currentThread().getName() + <span class="string">&quot;:&quot;</span>  + <span class="string">&quot; 此时开启了一个线程执行future的逻辑（烧开水），此时我们可以干点别的事情（比如准备火锅食材）...&quot;</span>);</span><br><span class="line">                <span class="comment">// 模拟准备火锅食材耗时</span></span><br><span class="line">                Thread.sleep(<span class="number">3000</span>);</span><br><span class="line">                System.out.println(Thread.currentThread().getName() + <span class="string">&quot;:&quot;</span>  + <span class="string">&quot;火锅食材准备好了&quot;</span>);</span><br><span class="line">                <span class="type">String</span> <span class="variable">shicai</span> <span class="operator">=</span> <span class="string">&quot;火锅食材&quot;</span>;</span><br><span class="line"></span><br><span class="line">                <span class="comment">// 开水已经稍好，我们取得烧好的开水</span></span><br><span class="line">                <span class="type">String</span> <span class="variable">boilWater</span> <span class="operator">=</span> futureTask.get();</span><br><span class="line"></span><br><span class="line">                System.out.println(Thread.currentThread().getName() + <span class="string">&quot;:&quot;</span>  + boilWater + <span class="string">&quot;和&quot;</span> + shicai + <span class="string">&quot;已经准备好，我们可以开始打火锅啦&quot;</span>);</span><br><span class="line">        &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure><h2 id="（2）CompletableFuture的用法">（2）CompletableFuture的用法</h2><p>见代码CFUser</p><p>原理：</p><p><a href="https://mcnfxurl5vzo.feishu.cn/wiki/Lp6uws3rFiEDjXkkyGGchQWQnVH#share-YTvbd2a9qoU8qRx7RU4cl8kencd"> 博客</a></p><hr><h1>面试题目</h1><h2 id="并发基础">并发基础</h2><h3 id="1-线程状态如何流转">1.线程状态如何流转</h3><p><img src="2025-01-09-JUC%E5%9F%BA%E7%A1%80%E9%9D%A2%E8%AF%95%E9%A2%98/image-6.png" alt=""></p><h3 id="2-Java创建线程的方式">2.Java创建线程的方式</h3><p><img src="2025-01-09-JUC%E5%9F%BA%E7%A1%80%E9%9D%A2%E8%AF%95%E9%A2%98/image.png" alt=""></p><p><a href="https://blog.csdn.net/longshengguoji/article/details/41126119">java创建线程的三种方式及其对比_创建线程有哪几种方式-CSDN博客</a></p><h3 id="3-⭐️启动线程为何调用start而不是run方法">3. ⭐️启动线程为何调用start而不是run方法</h3><p><strong>调用start()方法会告诉jvm创建一个新的线程</strong>，并在这个新线程中执行与run()方法相关联的代码块。这个过程允许多个线程同时运行，每个线程都拥有独立的执行上下文，这意味着它们可以在互不相干的情况下执行任务。</p><p>与此不同，<strong>如果直接调用run()方法</strong>，它仅仅是一个普通的方法调用，不会创建新的线程。相反，它会在当前线程的上下文中执行run()方法中的代码。这将导致代码的顺序执行，没有并行性可言，因为它们都在同一个线程内执行。</p><p>这种区别非常重要，因为多线程编程的一个主要目标是实现并行性，从而提高程序的性能和响应能力。通过调用start()方法，可以利用多核处理器的优势，同时执行多个线程，以更有效地完成任务。而直接调用run()方法只是按照一般的方法顺序执行代码，无法发挥多线程的潜力。因此，使用start()方法来启动线程是实现并行性的关键。 </p><h3 id="4-wait-、notify-和-notifyAll-、sleep-、yield">4. wait()、notify()和 notifyAll()、sleep()、yield()</h3><ul><li><p>sleep是让线程自己拿着锁休眠，但是不释放锁，暂停线程的执行</p></li><li><p>wait是A线程通过对象的方法来释放自己持有的该对象的锁,并处于等待状态。Java中每一个对象都包含一个监视器锁，wait方法是当前持有锁的线程 【主动】 放弃锁并等待；wait 不是等锁，而是等一个条件，这个条件要嘛是定时时间到了，要嘛是别人notify。等到条件满足之后，才有资格去竞争锁，后续就走正常锁竞争流程了。  例如B没有释放，那确实得等B用完释放了才能获取到锁。</p></li><li><p><code>notifyAll()</code>：会唤醒所有在该对象的等待队列中等待的线程。</p></li><li><p><code>notify()</code>：只会随机唤醒一个在该对象的等待队列中等待的线程。</p></li><li><p>yield()方法只会给相同优先级或更高优先级的线程以运行的机会；sleep()方法给其他线程运行机会时不考虑线程的优先级，因此会给低优先级的线程以运行的机会； 线程执行 sleep()方法后转入阻塞（超时等待状态），而执行 yield()方法后转入就绪（ready）状态；扩展：</p></li></ul><p>为什么wait()、notify()和 notifyAll()要定义在类里</p><p>对象才是共享资源的单位，每一个对象都可能成为共享资源，wait方法定义在Object中是为了让每一个对象都可以方便的共享。</p><p>为什么 wait(), notify()和 notifyAll()必须在同步方法或者同步块中被调用？</p><p>共享资源时不需要关注线程，对象才是需要互斥访问的资源，因此对象的wait()方法必须在持有锁之后调用；</p><p>同理，notify()方法也必须在持有锁之后调用，类似于告诉别人我马上用完了，你可以过来排队等着</p><p>很少需要直接控制一个线程的等待状态，主要还是等待共享资源的访问权，相比控制线程本身，控制资源访问权限更符合直觉。</p><h3 id="5-Java-中-interrupted-和-isInterrupted-方法的区别？">5.Java 中 interrupted 和 isInterrupted 方法的区别？</h3><blockquote><p>interrupt：用于中断线程。调用该方法的线程的状态为将被置为”中断”状态。</p><p> 注意：线程中断仅仅是置线程的中断状态位，不会停止线程。需要用户自己去监视线程的状态为并做处理。支持线程中断的方法（也就是线程中断后会抛出interruptedException 的方法）就是在监视线程的中断状态，一旦线程的中断状态被置为“中断状态”，就会抛出中断异常。</p><p> interrupted：是静态方法，查看当前中断信号是true还是false并且清除中断信号。如果一个线程被中断了，第一次调用 interrupted 则返回 true，第二次和后面的就返回 false 了。</p><p>isInterrupted：是可以返回当前中断信号是true还是false，与interrupted最大的差别是，isInterruputed不会清除中断信号，而interrupted会清除中断信号“。</p></blockquote><h3 id="6-同步方法和同步块，哪个是更好的选择">6. 同步方法和同步块，哪个是更好的选择?</h3><p><strong>参考回答</strong>：</p><ul><li><p>同步块是更好的选择，因为它不会锁住整个对象（当然你也可以让它锁住整个对象）。同步方法会锁住整个对象，哪怕这个类中有多个不相关联的同步块，通常会导致它们停止执行并需要等待获得这个对象上的锁。</p></li><li><p>同步块更符合开放调用的原则，只在需要锁住的代码块锁住相应的对象，这样从侧面来说也可以避免死锁。</p></li></ul><p>请知道一条原则：同步的范围越小越好。 </p><h3 id="7-什么是线程同步和线程互斥，有哪几种实现方式？">7.什么是线程同步和线程互斥，有哪几种实现方式？</h3><p><strong>实现线程同步的方法</strong></p><ul><li><p>同步代码方法：synchronized关键字修饰的方法</p></li><li><p>同步代码块：synchronized关键字修饰的代码块</p></li><li><p>使用特殊变量域volatile实现线程同步：volatile关键字为域变量的访问提供了一种免锁机制</p></li><li><p>使用重入锁实现线程同步：reentrantlock类是可重入、互斥、实现了lock接口的锁，它与synchronized方法具有相同的基本行为和语义 </p></li></ul><h3 id="8-在监视器-Monitor-内部，是如何做线程同步的？程序应该做哪种级别的同步？">8.在监视器(Monitor)内部，是如何做线程同步的？程序应该做哪种级别的同步？</h3><blockquote><p>在 java 虚拟机中，监视器和锁在Java虚拟机中是一块使用的。监视器监视一块同步代码块，确保一次只有一个线程执行同步代码块。每一个监视器都和一个对象引用相关联。线程在获取锁之前不允许执行同步代码。 </p><p>一旦方法或者代码块被 synchronized 修饰，那么这个部分就放入了监视器的监视区域，确保一次只能有一个线程执行该部分的代码，线程在获取锁之前不允许执行该部分的代码</p><p>另外 java 还提供了显式监视器( Lock )和隐式监视器( synchronized )两种锁方案</p></blockquote><h3 id="9-如果你提交任务时，核心线程数已达到配置的数量，这时会发生什么">9.如果你提交任务时，核心线程数已达到配置的数量，这时会发生什么</h3><blockquote><p>有俩种可能：</p><ul><li>(1) 如果使用的是无界队列</li></ul><p>LinkedBlockingQueue，也就是无界队列的话，没关系，继续添加任务到阻塞队列中等待执行，因为LinkedBlockingQueue可以近乎认为是一个无穷大的队列，可以无限存放任务。</p><ul><li>(2) 如果使用的是有界队列比如</li></ul><p>ArrayBlockingQueue，任务首先会被添加到ArrayBlockingQueue中，ArrayBlockingQueue满了，会根据maximumPoolSize的值增加线程数量，如果增加了线程数量还是处理不过来，ArrayBlockingQueue继续满，那么则会使用拒绝策略RejectedExecutionHandler处理满了的任务，默认是AbortPolicy </p></blockquote><h3 id="10-在-Java-程序中怎么保证多线程的运行安全？">10.在 Java 程序中怎么保证多线程的运行安全？</h3><blockquote><p><strong>方法一</strong>：使用安全类，比如java.util.concurrent下的类，使用原子类AtomicInteger</p><p><strong>方法二</strong>：使用自动锁synchronized。</p><p><strong>方法三</strong>：使用手动锁Lock。手动锁Java示例代码如下：</p></blockquote><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">  Lock lock = new ReentrantLock();</span><br><span class="line">  lock.lock();</span><br><span class="line">  try &#123;</span><br><span class="line">      System.out.println(&quot;获得锁&quot;);</span><br><span class="line">  &#125; catch (Exception e) &#123;</span><br><span class="line">      // TODO: handle exception</span><br><span class="line">    &#125; finally &#123;</span><br><span class="line">     System.out.println(&quot;释放锁&quot;);</span><br><span class="line">      lock.unlock();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="11-线程类的构造方法、静态块是被哪个线程调用的">11.线程类的构造方法、静态块是被哪个线程调用的</h3><blockquote><p>这是一个非常刁钻和狡猾的问题。请记住：线程类的构造方法、静态块是被new这个线程类所在的线程所调用的，而run方法里面的代码才是被线程自身所调用的。</p><p>如果说上面的说法让你感到困惑，那么我举个例子，假设Thread2中new了Thread1，main函数中new了Thread2，那么：</p><ul><li><p>(1) Thread2的构造方法、静态块是main线程调用的，Thread2的run()方法是Thread2自己调用的</p></li><li><p>(2) Thread1的构造方法、静态块是Thread2调用的，Thread1的run()方法是Thread1自己调用的 </p></li></ul></blockquote><h3 id="12-Java中怎么获取一份线程dump文件？你如何在Java中获取线程堆栈？">12. Java中怎么获取一份线程dump文件？你如何在Java中获取线程堆栈？</h3><p><strong>参考回答</strong>：</p><blockquote><p>Dump文件是进程的内存镜像。可以把程序的执行状态通过调试器保存到dump文件中。</p><p>在Linux下，你可以通过命令jstack -l PID（Java进程的进程ID）来获取Java应用的dump文件。</p><p>在Windows下，你可以按下Ctrl + Break来获取，这样JVM就会将线程的dump文件打印到标准输出或错误文件中，它可能打印在控制台或者日志文件中，具体位置依赖应用的配置。</p></blockquote><h3 id="13-一个线程运行时发生异常会怎样？">13. 一个线程运行时发生异常会怎样？</h3><blockquote><p><strong>参考回答</strong>：</p><p>如果异常没有被捕获该线程将会停止执行。</p><p>Thread.UncaughtExceptionHandler是用于处理未捕获异常造成线程突然中断情况的一个内嵌接口。当一个未捕获异常将造成线程中断的时候，JVM会使用Thread.getUncaughtExceptionHandler()来查询线程的UncaughtExceptionHandler，并将线程和异常作为参数传递给handler的uncaughtException()方法进行处理。 </p></blockquote><h3 id="14-多线程的常用方法">14.多线程的常用方法</h3><table><thead><tr><th>方法名</th><th>描述</th></tr></thead><tbody><tr><td>sleep()isAlive()join()activeCount()enumerate()currentThread()isDaemon()setDaemon()setName()wait()notify()setPriority()</td><td>强迫一个线程睡眠N毫秒判断一个线程是否存活。等待线程终止。程序中活跃的线程数。枚举程序中的线程。得到当前线程。一个线程是否为守护线程。设置一个线程为守护线程。为线程设置一个名称。强迫一个线程等待。通知一个线程继续运行。设置一个线程的优先级。</td></tr></tbody></table><h3 id="15-❓介绍一下-ThreadLocal">15.❓介绍一下 ThreadLocal</h3><blockquote><p>Thread类有两个变量：threadLocals和inheritableThreadLocals。</p><p>这两个变量默认为null，只有当该线程调用了ThreadLocal类的get/set方法时才会创建他们，而调用ThreadLocal的get/set实际上是调用ThreadLocalMap的get/set。</p><p>ThreadLocalMap可理解成给ThreadLocal定制化的HashMap。</p><p>最终的变量放在了线程的ThreadLocalMap中，而不是ThreadLocal中，ThreadLocal只是对其进行封装，向其传递变量值。</p><p>用一个场景分析ThreadLocal的get/set流程：</p><p>首先在所有线程外部创建一个共享的ThreadLocal对象，记为TL1。在一个线程中调用TL1.get()时，首先获取到当前线程对象，记为t，然后判断t.threadLocals是否为null，如果为null，就在t中创建一个新的ThreadLocalMap对象赋值给t.threadLocals，并将&lt;TL1,null&gt;插入其中，最后get方法返回null；如果不为null，则尝试获取threadLocals中TL1所在的键值对，如果该键值对为null，则向threadLocals中通过set方法插入&lt;TL1,null&gt;，最后返回null，如果键值对不为null，则返回键值对中的值。</p><p>调用set方法时，流程和get基本一致，只是从读变成了写。</p><p>这样就可以实现不同线程访问同一个ThreadLocal（TL1）能拿到各自向其中存放的值。 </p></blockquote><p><img src="2025-01-09-JUC%E5%9F%BA%E7%A1%80%E9%9D%A2%E8%AF%95%E9%A2%98/image-5.png" alt=""></p><h3 id="16-ThreadLocal-内存泄露问题了解吗">16.ThreadLocal 内存泄露问题了解吗</h3><p><img src="2025-01-09-JUC%E5%9F%BA%E7%A1%80%E9%9D%A2%E8%AF%95%E9%A2%98/image-3.png" alt=""></p><p><strong>分析</strong></p><p>ThreadLocal 内存泄露也是个老生常谈的问题了，网上部分资料，包括好多面试官都把这个问题出现的主要原因归结为 ThreadLocalMaps 里 Entry Key（ThreadLocal 对象本身）使用了弱引用导致的，但是我们仔细看看引用结构，脑补一下内存泄露的场景就不难发现，真正导致内存泄露的主要原因，其实是 Thread 强引用 ThreadLocalMaps，如果 Thread 一直存在，ThreadLocalMaps Entry 中的 value 这个强引用一直存在，不被回收才是导致发生内存泄露的真正原因</p><blockquote><p>因为 ThreadLocal 本身不存储对象，是调用 Thread 中的 ThreadLocalMaps 来保存，而 Thread 强引用 ThreadLocalMaps 对象，如果 Thread 对象生命周期过长，不能及时被回收，就会导致 ThreadLocalMaps 对象里 Entry 的 value 存在内存泄露的可能。</p><p>当然 ThreadLocalMaps 在设计的时候也考虑过这个问题，所以 ThreadLocalMaps Key 采用了弱引用的方式，并且在 set、remove、rehash 的时候会主动清理 ThreadLocalMaps 中 Key 为 Null 的 value，但是如果 ThreadLocal 已经不被使用了 set、remove、rehash 方法也不会被调用，与此同时，如果这个线程又一直存活、不终止的话，那么一ThreadLocalMaps 中的 Value 强引用就会一直存在，也就避免不了 Value 的内存泄漏</p></blockquote><p><a href="https://learn.lianglianglee.com/%E4%B8%93%E6%A0%8F/Java%20%E5%B9%B6%E5%8F%91%E7%BC%96%E7%A8%8B%2078%20%E8%AE%B2-%E5%AE%8C/47%20%E5%86%85%E5%AD%98%E6%B3%84%E6%BC%8F%E2%80%94%E2%80%94%E4%B8%BA%E4%BD%95%E6%AF%8F%E6%AC%A1%E7%94%A8%E5%AE%8C%20ThreadLocal%20%E9%83%BD%E8%A6%81%E8%B0%83%E7%94%A8%20remove()%EF%BC%9F.md">47 内存泄漏——为何每次用完 ThreadLocal 都要调用 remove()?</a></p><h3 id="17-为什么用ThreadLocal不用线程成员变量">17.为什么用ThreadLocal不用线程成员变量?</h3><p><strong>参考回答</strong>：</p><blockquote><p>如果用成员变量，那么成员变量必须在Thread里，不能在Runnable里，因为一个Runnable对象可以被多个Thread执行。</p><p>而如果在Thread中添加成员变量，就要加强Thread和Runnable的耦合，将Thread作为Runnable的成员变量，并在Runnable中调用具体的Thread变量，如果执行Runnable的Thread可能有很多子类，不同子类有不同的成员变量，则要在run方法中进行复杂处理，扩展性较低，不利于维护。而ThreadLocal就是将成员变量统一为一个Map放到线程里。 </p></blockquote><h2 id="⭐️Java并发理论（Volatile-Synchronized-CAS）">⭐️Java并发理论（Volatile/Synchronized/CAS）</h2><h3 id="1-线程之间如何通信及线程之间如何同步">1. 线程之间如何通信及线程之间如何同步</h3><p><strong>参考回答</strong>：</p><blockquote><p>- 在并发编程中，我们需要处理两个关键问题：线程之间如何通信及线程之间如何同步。通信是指线程之间以如何来交换信息。一般线程之间的通信机制有两种：共享内存和消息传递。同步是指程序中用于控制不同线程间操作发生相对顺序的机制。</p><p>- Java的并发采用的是共享内存模型，Java线程之间的通信总是隐式进行，整个通信过程对程序员完全透明。如果编写多线程程序的Java程序员不理解隐式进行的线程之间通信的工作机制，很可能会遇到各种奇怪的内存可见性问题。</p><p>- 在共享内存并发模型里，同步是显式进行的。程序员必须显式指定某个方法或者某段代码需要在线程之间互斥执行。 </p></blockquote><h3 id="2-Java内存模型（JMM）">2.Java内存模型（JMM）</h3><p><img src="2025-01-09-JUC%E5%9F%BA%E7%A1%80%E9%9D%A2%E8%AF%95%E9%A2%98/image-4.png" alt=""></p><p><a href="https://blog.csdn.net/Your_heart_private/article/details/105566207">Jvm内存模型和JMM模型结构图_java jmm模型图-CSDN博客</a></p><p><a href="https://pdai.tech/md/java/jvm/java-jvm-x-introduce.html">JVM 基础 - Java 内存模型引入</a></p><p><a href="https://zhuanlan.zhihu.com/p/29881777">https://zhuanlan.zhihu.com/p/29881777</a></p><h3 id="3-Happens-Before-原则">3.Happens-Before 原则</h3><p><strong>分析</strong></p><p>理解JMM模型如何保证并发安全性，知道指令重排，理解happens-before原则</p><p><strong>回答</strong></p><blockquote><p>happens-before 字面意思就是先行发生，你可以理解为A happens before B，就是A发生在B之前。</p><p>happens-before（HB）是在JMM中的一个很重要的规则，即一个操作的结果对于另一个操作是可见的，用来指定两个操作之间的执行顺序。 </p></blockquote><p><a href="https://blog.51cto.com/u_11812862/3002287">阿里面试题:Java 并发编程之 happens-before 规则_51CTO博客_java happens-before原则</a></p><h3 id="4-Java-怎么进行并发控制？">4.Java 怎么进行并发控制？</h3><blockquote><p>并发控制中的锁一般有两种，悲观锁和乐观锁，一般来说悲观锁是基于Monitor实现的，这在Java中分别对应synchronized关键字和AQS。乐观锁是基于CAS+自旋来实现的，Java中用的比较多的是并发原子类。</p><p><strong>synchronized</strong></p><p>synchronized修饰的方法或代码块同一时间只能被一个线程执行。</p><p>一般有三种使用方法：</p><ol><li><p>修饰实例方法：调用某对象的该方法前获取该对象实例的锁。</p></li><li><p>修饰静态方法：调用某对象的该方法前获取该类的锁。</p></li><li><p>两个线程分别执行同一个对象synchronized修饰的实例方法和静态方法时不会发生互斥，因为锁的资源不同，一个锁了对象实例，一个锁了类。</p></li><li><p>锁对象，修饰代码块：synchronized(对象的引用)锁的是对象实例，synchronized(类.class)锁的是类。</p></li></ol><p>尽量不要使用synchronized(String a)因为JVM中，字符串常量池具有缓存功能！</p><p>synchronized不能修饰构造方法，也没必要修饰，构造方法本身就是线程安全的。</p><p>底层原理：尝试获取对象的monitor，monitor已被其他线程占用时，获取失败，该线程进入EntrySet。占有monitor时调用wait()进入WaitSet。调用notify()时从WaitSet里随机选一个线程唤醒，调用notifyAll时唤醒WaitSet里所有线程。</p><p><strong> AQS</strong></p><p>AQS全称是AbstractQueuedSynchronizer，它是Java中用来构建锁和同步器的基础框架，可以用于实现诸如ReentrantLock、Semaphore、CountDownLatch等多种同步工具。</p><p>AQS主要依赖于一个双向链表和一个volatile类型的整数state来实现同步控制。该整数state用来表示同步状态，一般情况下，state=0表示没有线程占用同步资源，state&gt;0表示有线程占用同步资源，比如ReentrantLock可以允许一个线程多次获得锁，每次state值加一。</p><p>AQS的主要方法有下面几个：</p><ul><li><p>acquire()：该方法用来获取同步状态，如果同步状态被占用，则线程将被加入等待队列中。</p></li><li><p>acquireInterruptibly()：与acquire()类似，但是该方法允许中断操作。</p></li><li><p>tryAcquire()：该方法用来尝试获取同步状态，如果成功则返回true，否则返回false。</p></li><li><p>release()：该方法用来释放同步状态，并唤醒等待队列中的线程。</p></li><li><p>acquireShared()：该方法用来获取共享式同步状态，如果同步状态被占用，则线程将被加入等待队列中。</p></li><li><p>releaseShared()：该方法用来释放共享式同步状态，并唤醒等待队列中的线程。</p></li></ul><p>AQS实现同步的关键在于，它提供了一个基于FIFO队列的等待队列，通过将等待线程加入等待队列中，然后在释放同步状态的时候，从等待队列中唤醒等待线程，从而实现了同步机制。 </p><p>AQS的实现主要有两种方式：独占式（Exclusive）和共享式（Shared）。独占式是指只有一个线程可以占用同步资源，比如ReentrantLock，而共享式是指多个线程可以同时占用同步资源，比如CountDownLatch。在AQS中，这两种方式的实现是基本相同的，区别在于获取和释放同步状态的方式不同。</p><p>以上是AQS的基本实现方式，它是Java中构建锁和同步器的核心框架，为各种同步工具的实现提供了强大的基础支持。 </p></blockquote><p><a href="https://ls8sck0zrg.feishu.cn/wiki/Y6jkwwaHPiJw6skxQsfctlVVnMb#share-WZDZdVZqWobjF0xwtjocNSOqnQd">https://ls8sck0zrg.feishu.cn/wiki/Y6jkwwaHPiJw6skxQsfctlVVnMb#share-WZDZdVZqWobjF0xwtjocNSOqnQd</a></p><h3 id="5-synchronized关键字">5. synchronized关键字</h3><p><strong>分析</strong></p><p>回答synchronized作用、特性、实现方式，可以适当画图或者举例。</p><p><strong>回答</strong></p><blockquote><p>synchronized关键字是Java用来解决多个线程共享资源竞争问题，synchronized同步语句块实现是先执行monitorenter指令，该指令会尝试获取对象的monitor，指令指向同步代码块的开始位置，monitorexit指令则同步代码块的结束位置，synchronized关键字可以保证被它修饰的方法或者代码块在任意时刻只有一个线程执行。</p><p>早期的synchronized依赖操作系统实现，属于重量锁，JDK 1.6以后对其进行了大量的优化。 </p></blockquote><p><a href="https://pdai.tech/md/java/thread/java-thread-x-key-synchronized.html">关键字: synchronized详解</a></p><h3 id="6-说说自己是怎么使用synchronized关键字，在项目中用到了吗">6. 说说自己是怎么使用synchronized关键字，在项目中用到了吗</h3><p><strong>参考回答</strong>：</p><blockquote><p>synchronized关键字最主要的三种使用方式：</p><ul><li><p>修饰实例方法：作用于当前对象实例加锁，进入同步代码前要获得当前对象实例的锁。</p></li><li><p>修饰静态方法：也就是给当前类加锁，会作用于类的所有对象实例，因为静态成员不属于任何一个实例对象，是类成员（static表明这是该类的一个静态资源，不管new了多少个对象，只有一份）。所以如果一个线程A调用一个实例对象的非静态synchronized方法，而线程B需要调用这个实例对象所属类的静态synchronized方法，是允许的，不会发生互斥现象，因为访问静态synchronized方法占用的锁是当前类的锁，而访问非静态synchronized方法占用的锁是当前实例对象锁。 </p></li><li><p>修饰代码块：指定加锁对象，对给定对象加锁，进入同步代码库前要获得给定对象的锁。</p></li></ul><p>总结：synchronized关键字加到static静态方法和synchronized(class)代码块上都是给Class类上锁。synchronized关键字加到实例方法上是给对象实例上锁。尽量不要使用synchronized(String a)因为JVM中，字符串常量池具有缓存功能！ </p></blockquote><h3 id="7-说一下synchronized底层实现原理">7. 说一下synchronized底层实现原理?</h3><p><strong>参考回答</strong>：</p><blockquote><p>Synchronized的语义底层是通过一个monitor（监视器锁）的对象来完成，每个对象有一个监视器锁(monitor)。每个Synchronized修饰过的代码当它的monitor被占用时就会处于锁定状态并且尝试获取monitor的所有权 ，过程：</p><p>1、如果monitor的进入数为0，则该线程进入monitor，然后将进入数设置为1，该线程即为monitor的所有者。</p><p>2、如果线程已经占有该monitor，只是重新进入，则进入monitor的进入数加1.</p><p>3、如果其他线程已经占用了monitor，则该线程进入阻塞状态，直到monitor的进入数为0，再重新尝试获取monitor的所有权。</p><p><code>synchronized是可以通过 反汇编指令javap命令，查看相应的字节码文件。 </code></p></blockquote><h3 id="8-synchronized可重入的原理">8. synchronized可重入的原理</h3><p><strong>参考回答</strong>：</p><blockquote><p>重入锁是指一线程获取到该锁之后，该线程可以继续获得该锁。底层原理维护一个计数器，当线程获取该锁时，计数器加一，再次获得该锁时继续加一，释放锁时，计数器减一，当计数器值为0时，表明该锁未被任何线程所持有，其它线程可以竞争获取锁。</p></blockquote><h3 id="9-什么是自旋">9. 什么是自旋</h3><blockquote><p><strong>参考回答</strong>：</p><ul><li><p>很多synchronized里面的代码只是一些很简单的代码，执行时间非常快，此时等待的线程都阻塞可能是一种不太值得的操作，因为线程阻塞涉及到用户态和内核态切换的问题。既然synchronized里面的代码执行得非常快，不妨让等待锁的线程不要被阻塞，而是在 线程的边界忙循环，这就是自旋。如果做了多次循环发现还没有获得锁，再阻塞，这样可能是一种更好的策略。</p></li><li><p>忙循环：就是程序员用循环让一个线程等待，不像传统方法wait(),sleep() 或yield() 它们都放弃了CPU控制，而忙循环不会放弃CPU，它就是在运行一个空循环。这么做的目的是为了保留CPU缓存，在多核系统中，一个等待线程醒来的时候可能会在另一个内核运行，这样会重建缓存。为了避免重建缓存和减少等待重建的时间就可以使用它了。 </p></li></ul><p>在Java中，自旋（Spinning）是一种线程同步技术，用于在多线程编程中实现锁机制。当一个线程试图获取一个已经被其他线程持有的锁时，该线程不会放弃CPU时间片，而是进行循环（通常是一个忙等待循环），不断检查锁是否可用。这种机制旨在减少线程上下文切换的开销，提高响应速度，但也可能浪费大量的CPU时间。</p><p>自旋锁是Java并发编程中的一个重要概念，通过允许线程在锁不可用时持续尝试获取锁，它可以避免线程上下文切换的开销。然而，如果锁持有时间过长，自旋线程会浪费大量CPU时间，导致性能下降。因此，自旋锁需要谨慎使用，依据具体的应用场景和需求进行选择和优化。</p></blockquote><h3 id="10-多线程中synchronized锁升级的原理是什么">10. 多线程中synchronized锁升级的原理是什么?</h3><p><strong>参考回答</strong>：</p><blockquote><p>synchronized锁升级原理：在锁对象的对象头里面有一个threadid字段，在第一次访问的时候threadid为空，jvm让其持有偏向锁，并将threadid设置为其线程id，再次进入的时候会先判断threadid是否与其线程id一致，如果一致则可以直接使用此对象，如果不一致，则升级偏向锁为轻量级锁，通过自旋循环一定次数来获取锁，执行一定次数之后，如果还没有正常获取到要使用的对象，此时就会把锁从轻量级升级为重量级锁，此过程就构成了synchronized锁的升级。 </p><p><code>锁的升级的目的：锁升级是为了减低了锁带来的性能消耗。在Java 6之后优化synchronized的实现方式，使用了偏向锁升级为轻量级锁再升级到重量级锁的方式，从而减低了锁带来的性能消耗。</code></p><ul><li><p>偏向锁，顾名思义，它会偏向于第一个访问锁的线程，如果在运行过程中同步锁只有一个线程访问，不存在多线程争用的情况，则线程是不需要触发同步的，减少加锁 / 解锁的一些CAS操作（比如等待队列的一些CAS操作），这种情况下，就会给线程加一个偏向锁。如果在运行过程中，遇到了其他线程抢占锁，则持有偏向锁的线程会被挂起，JVM会消除它身上的偏向锁，将锁恢复到标准的轻量级锁。</p></li><li><p>轻量级锁是由偏向所升级来的，偏向锁运行在一个线程进入同步块的情况下，当第二个线程加入锁争用的时候，偏向锁就会升级为轻量级锁； </p></li><li><p>重量级锁是synchronized，是Java虚拟机中最为基础的锁实现。在这种状态下，Java虚拟机会阻塞加锁失败的线程，并且在目标锁被释放的时候，唤醒这些线程。 </p></li></ul></blockquote><p><a href="https://learn.lianglianglee.com/%E4%B8%93%E6%A0%8F/Java%20%E6%A0%B8%E5%BF%83%E6%8A%80%E6%9C%AF%E9%9D%A2%E8%AF%95%E7%B2%BE%E8%AE%B2/16%20%20synchronized%E5%BA%95%E5%B1%82%E5%A6%82%E4%BD%95%E5%AE%9E%E7%8E%B0%EF%BC%9F%E4%BB%80%E4%B9%88%E6%98%AF%E9%94%81%E7%9A%84%E5%8D%87%E7%BA%A7%E3%80%81%E9%99%8D%E7%BA%A7%EF%BC%9F-%E6%9E%81%E5%AE%A2%E6%97%B6%E9%97%B4.md">16 synchronized底层如何实现?什么是锁的升级、降级?-极客时间</a></p><blockquote><h3 id="11-线程B怎么知道线程A修改了变量">11. 线程B怎么知道线程A修改了变量</h3><p><strong>参考回答</strong>：</p><p>(1) volatile修饰变量</p><p>(2) synchronized修饰修改变量的方法</p><p>(3) wait/notify</p></blockquote><h3 id="12-当一个线程进入一个对象的synchronized方法A之后，其它线程是否可进入此对象的synchronized方法B">12. 当一个线程进入一个对象的synchronized方法A之后，其它线程是否可进入此对象的synchronized方法B?</h3><blockquote><p><strong>参考回答</strong>：</p><p>不能。其它线程只能访问该对象的非同步方法，同步方法则不能进入。因为非静态方法上的synchronized修饰符要求执行方法时要获得对象的锁，如果已经进入A方法说明对象锁已经被取走，那么试图进入B方法的线程就只能在等锁池（注意不是等待池哦）中等待对象的锁。</p></blockquote><h3 id="13-synchronized、volatile、CAS比较">13. synchronized、volatile、CAS比较</h3><blockquote><p><strong>参考回答</strong>：</p><p>(1) synchronized是悲观锁，属于抢占式，会引起其他线程阻塞。</p><p>(2) volatile提供多线程共享变量可见性和禁止指令重排序优化。 </p><p>(3) CAS是基于冲突检测的乐观锁（非阻塞） </p></blockquote><p><a href="https://refblogs.com/article/582">并发编程中的synchronized、volatile和CAS操作详解 - 搬砖的码农</a></p><h3 id="14-synchronized和Lock有什么区别">14. synchronized和Lock有什么区别?</h3><blockquote><p><strong>参考回答</strong>：</p><ul><li><p>首先synchronized是Java内置关键字，在JVM层面，Lock是个接口；</p></li><li><p>原理区别：synchronized是内置锁，由JVM实现获取锁和释放锁的原理，还分为偏向锁、轻量级锁、重量级锁。Lock根据实现不同，有不同的原理，例如ReentrantLock内部是通过AQS来获取和释放锁的。</p></li><li><p>用法区别：synchronized可以给类、方法、代码块加锁；而lock只能给代码块加锁。synchronized不需要手动获取锁和释放锁，使用简单，发生异常会自动释放锁，不容易造成死锁；而lock需要自己加锁和释放锁，如果使用不当没有unLock()去释放锁就会造成死锁。</p></li><li><p>synchronized锁只能同时被一个线程拥有，但是Lock锁没有这个限制，例如在读写锁中的读锁，是可以同时被多个线程持有的，可是synchronized做不到。</p></li><li><p>synchronized锁不够灵活，一旦synchronized锁已经被某个线程获得了，此时其他线程如果还想获得，那它只能被阻塞，直到持有锁的线程运行完毕或者发生异常从而释放这个锁。如果持有锁的线程持有很长时间才释放，那么整个程序的运行效率就会降低，而且如果持有锁的线程永远不释放锁，那么尝试获取锁的线程只能永远等下去。相比之下，Lock类在等锁的过程中，如果使用的是lockInterruptibly方法，那么如果觉得等待的时间太长了不想再继续等待，可以中断退出，也可以用tryLock()等方法尝试获取锁，如果获取不到锁也可以做别的事，更加灵活。 </p></li><li><p>性能区别：在Java 5以及之前，synchronized的性能比较低，但是到了Java 6以后发生了变化，因为JDK对synchronized进行了很多优化，比如自适应自旋、锁消除、锁粗化、轻量级锁、偏向锁等，所以后期的Java版本里的synchronized的性能并不比Lock差。 </p></li></ul></blockquote><h3 id="15-synchronized和Lock如何选择">15. synchronized和Lock如何选择?</h3><p><strong>参考回答</strong>：</p><blockquote><ol><li><p>如果能不用最好既不使用Lock也不使用synchronized。因为在许多情况下你可以使用java.util.concurrent包中的机制，它会为你处理所有的加锁和解锁操作，也就是推荐优先使用工具类来加解锁。</p></li><li><p>如果synchronized关键字适合你的程序，那么请尽量使用它，这样可以减少编写代码的数量，减少出错的概率。因为一旦忘记在finally里unlock，代码可能会出很大的问题，而使用synchronized更安全。</p></li><li><p>如果特别需要Lock的特殊功能，比如尝试获取锁、可中断、超时功能等，才使用Lock。</p></li></ol></blockquote><p><a href="https://learn.lianglianglee.com/%E4%B8%93%E6%A0%8F/Java%20%E5%B9%B6%E5%8F%91%E7%BC%96%E7%A8%8B%2078%20%E8%AE%B2-%E5%AE%8C/22%20synchronized%20%E5%92%8C%20Lock%20%E5%AD%B0%E4%BC%98%E5%AD%B0%E5%8A%A3%EF%BC%8C%E5%A6%82%E4%BD%95%E9%80%89%E6%8B%A9%EF%BC%9F.md">22 synchronized 和 Lock 孰优孰劣，如何选择?</a></p><h3 id="16-synchronized和ReentrantLock区别是什么">16. synchronized和ReentrantLock区别是什么?</h3><p><strong>参考回答</strong>：</p><blockquote><p>synchronized和ReentrantLock都是Java中提供的可重入锁，二者的主要区别有以下5个：</p><ul><li><p>用法不同：synchronized可以用来修饰普通方法、静态方法和代码块，而ReentrantLock只能用于代码块。</p></li><li><p>获取锁和释放锁的机制不同：synchronized是自动加锁和释放锁的，而ReentrantLock需要手动加锁和释放锁。</p></li><li><p>锁类型不同：synchronized是非公平锁，而ReentrantLock默认为非公平锁，也可以手动指定为公平锁。 </p></li><li><p>响应中断不同：ReentrantLock可以响应中断，解决死锁的问题，而synchronized不能响应中断。</p></li><li><p>底层实现不同：synchronized是JVM层面通过监视器实现的，而ReentrantLock是基于AQS</p></li></ul></blockquote><p><a href="https://www.51cto.com/article/707239.html">https://www.51cto.com/article/707239.html</a></p><h3 id="17-volatile关键字的作用">17. volatile关键字的作用</h3><blockquote><p><strong>参考回答</strong>：</p><ul><li><p>对于可见性，Java提供了volatile关键字来保证可见性和禁止指令重排。volatile确保一个线程的修改能对其他线程是可见的。当一个共享变量被volatile修饰时，它会保证修改的值会立即被更新到主内存中，当有其他线程需要读取时，它会去内存中读取新值。</p></li><li><p>从实践角度而言，volatile的一个重要作用就是和CAS结合，保证了原子性，详细的可以参见java.util.concurrent.atomic包下的类，比如AtomicInteger。</p></li></ul></blockquote><h3 id="18-Java中能创建volatile数组吗">18. Java中能创建volatile数组吗?</h3><p><strong>参考回答</strong>：</p><blockquote><p>能，Java中可以创建volatile类型数组，不过只是一个指向数组的引用，而不是整个数组。意思是，如果改变引用指向的数组，将会受到volatile的保护，但是如果多个线程同时改变数组的元素，volatile标示符就不能起到之前的保护作用了。 </p></blockquote><h3 id="19-volatile能使得一个非原子操作变成原子操作吗">19. volatile能使得一个非原子操作变成原子操作吗?</h3><blockquote><p><strong>参考回答</strong>：</p><ul><li><p>关键字volatile的主要作用是使变量在多个线程间可见，但无法保证原子性，对于多个线程访问同一个实例变量需要加锁进行同步。</p></li><li><p>虽然volatile只能保证可见性不能保证原子性，但用volatile修饰long和double可以保证其操作原子性。（<a href="https://blog.csdn.net/tian2342/article/details/122665957%EF%BC%89">https://blog.csdn.net/tian2342/article/details/122665957）</a></p></li></ul></blockquote><h3 id="20-synchronized和volatile的区别是什么">20. synchronized和volatile的区别是什么?</h3><p><strong>参考回答</strong>：</p><blockquote><ul><li><p>synchronized表示只有一个线程可以获取作用对象的锁，执行代码，阻塞其他线程。</p></li><li><p>volatile表示变量在CPU的寄存器中是不确定的，必须从主存中读取。保证多线程环境下变量的可见性；禁止指令重排序。</p></li></ul><p><strong>区别</strong></p><ul><li><p>volatile是变量修饰符；synchronized可以修饰方法，代码块。</p></li><li><p>volatile仅能实现变量的修改可见性，不能保证原子性；而synchronized则可以保证变量的修改可见性和原子性。 </p></li><li><p>volatile不会造成线程的阻塞；synchronized可能会造成线程的阻塞。</p></li><li><p>volatile标记的变量不会被编译器优化；synchronized标记的变量可以被编译器优化。</p></li><li><p>volatile关键字是线程同步的轻量级实现，所以volatile性能肯定比synchronized关键字要好。但是volatile关键字只能用于变量而synchronized关键字可以修饰方法以及代码块。synchronized关键字在JavaSE1.6之后进行了主要包括为了减少获得锁和释放锁带来的性能消耗而引入的偏向锁和轻量级锁以及其它各种优化之后执行效率有了显著提升，实际开发中使用synchronized关键字的场景还是更多一些。 </p></li></ul></blockquote><h3 id="21-说下你对volatile的理解">21. 说下你对volatile的理解</h3><blockquote><p>volatile是Java虚拟机提供的轻量级的同步机制，具有以下特点：</p><ol><li><p>保证可见性：volatile保证了多个线程对共享变量的操作是可见的。当一个线程修改了共享变量的值，其他线程会立即看到这个改变。</p></li><li><p>禁止指令重排：volatile通过禁止指令重排来保证顺序性。在多线程环境下，为了提高程序执行效率，编译器和处理器可能会对指令进行重新排序。但是，如果一个变量被volatile修饰，就禁止了指令重排，确保每个线程都能看到正确的操作顺序。</p></li></ol><p>总的来说，volatile可以确保多个线程对共享变量的操作一致，避免了数据不一致的问题。<strong>但是它不能保证原子性，因此对于需要保证原子性的操作还需要使用其他同步机制，如synchronized关键字或java.util.concurrent.atomic包中的原子类。 </strong></p><p><strong>volatile关键字</strong>通过以下方式禁止指令重排：</p><ol><li><p>内存屏障（Memory Barrier）：当编译器或处理器看到volatile修饰的变量时，它会在该变量前后插入内存屏障。内存屏障可以保证在该屏障之前的所有读写操作都必须在屏障之后的读写操作之前完成。这实际上就禁止了指令重排。</p></li><li><p>强制立即刷新到主内存：当一个线程向被volatile关键字修饰的变量写入数据时，虚拟机会强制这个值被立即刷新到主内存中。这确保了其他线程可以立即看到这个修改。</p></li><li><p>强制从主内存读取：当一个线程读取被volatile关键字修饰的变量时，虚拟机会强制要求它从主内存中读取这个值，而不是从该线程的本地缓存中读取。这确保了该线程可以立即看到其他线程对这个变量的修改。 </p></li></ol></blockquote><h2 id="线程池">线程池</h2><h3 id="1-什么是线程池？为什么要用线程池">1. 什么是线程池？为什么要用线程池?</h3><p><strong>参考回答</strong>：</p><blockquote><p>答：Java中的线程池是运用场景最多的并发框架，几乎所有需要异步或并发执行任务的程序都可以使用线程池。在开发过程中，合理地使用线程池能够带来许多好处。</p><ul><li><p>降低资源消耗。通过重复利用已创建的线程，降低线程创建和销毁造成的消耗。</p></li><li><p>提高响应速度。当任务到达时，任务可以不需要等到线程创建就能立即执行。</p></li><li><p>提高线程的可管理性。线程是稀缺资源，如果无限制地创建，不仅会消耗系统资源，还会降低系统的稳定性，使用线程池可以进行统一分配、调优和监控。但是，要做到合理利用 。 </p></li></ul></blockquote><h3 id="2-核心参数有哪些">2. 核心参数有哪些?</h3><p><strong>分析</strong>：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="title function_">ThreadPoolExecutor</span><span class="params">(<span class="type">int</span> corePoolSize,</span></span><br><span class="line"><span class="params">                          <span class="type">int</span> maximumPoolSize,</span></span><br><span class="line"><span class="params">                          <span class="type">long</span> keepAliveTime,</span></span><br><span class="line"><span class="params">                          TimeUnit unit,</span></span><br><span class="line"><span class="params">                          BlockingQueue&lt;Runnable&gt; workQueue,</span></span><br><span class="line"><span class="params">                          ThreadFactory threadFactory,</span></span><br><span class="line"><span class="params">                          RejectedExecutionHandler handler)</span> &#123;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><blockquote><p><strong>参考回答</strong>：</p><p>线程池的构造函数有7个参数：</p><ul><li><p>corePoolSize：核心线程数</p></li><li><p>maximumPoolSize：线程池能创建线程的最大个数</p></li><li><p>keepAliveTime：空闲线程存活时间</p></li><li><p>unit：时间单位，为keepAliveTime指定时间单位</p></li><li><p>workQueue：阻塞队列，用于保存任务的阻塞队列</p></li><li><p>threadFactory：创建线程的工程类</p></li><li><p>handler：饱和策略（拒绝策略） </p></li></ul></blockquote><h3 id="3-线程池的种类，区别和使用场景">3. 线程池的种类，区别和使用场景</h3><p><strong>分析</strong></p><blockquote><p><strong>参考回答</strong>：</p><ol><li>newCachedThreadPool</li></ol><p>newCachedThreadPool创建一个可缓存线程池，如果当前线程池的长度超过了处理的需要时，它可以灵活的回收空闲的线程，当需要增加时，它可以灵活的添加新的线程，而不会对池的长度作任何限制。</p><p>使用场景：执行很多短期异步的小程序。</p><ul><li>newFixedThreadPool</li></ul><p>创建一个定长线程池，可控制线程最大并发数，超出的线程会在队列中等待。定长线程池的大小最好根据系统资源进行设置。</p><p>使用场景：执行长期的任务，性能好很多。</p><ul><li>newScheduledThreadPool</li></ul><p>创建一个固定长度的线程池，而且支持定时的以及周期性的任务执行。</p><p>使用场景：周期性执行任务的场景。</p><ul><li>newSingleThreadExecutor</li></ul><p>创建一个单线程化的线程池，它只会用唯一的工作线程来执行任务，如果这个唯一的线程因为异常结束，那么会有一个新的线程来替代它，必须保证前一项任务执行完毕后才能执行后一项。保证所有任务按照指定顺序执行。</p><p>使用场景：适合多个任务顺序执行的场景，不需要考虑并发问题。 </p></blockquote><p><a href="https://www.cnblogs.com/sachen/p/7401959.html">博客园</a></p><h3 id="4-线程池的拒绝策略有哪些">4. 线程池的拒绝策略有哪些</h3><p><strong>分析</strong></p><blockquote><p><strong>参考回答</strong>：</p><ul><li>AbortPolicy, 默认</li></ul><p>该策略是线程池的默认策略。使用该策略时，如果线程池队列满了丢掉这个任务并且抛出RejectedExecutionException异常。</p><ul><li>DiscardPolicy</li></ul><p>这个策略和AbortPolicy的silent版本，如果线程池队列满了，会直接丢掉这个任务并且不会有任何异常。</p><ul><li>DiscardOldestPolicy</li></ul><p>这个策略从字面上也很好理解，丢弃最老的。也就是说如果队列满了，会将最早进入队列的任务删掉腾出空间，再尝试加入队列。因为队列是队尾进，队头出，所以队头元素是最老的，因此每次都是移除队头元素后再尝试入队。</p><ul><li>CallerRunsPolicy</li></ul><p>使用此策略，如果添加到线程池失败，那么调用线程会自己去执行该任务，不会等待线程池中的线程去执行。就像是个急脾气的人，我等不到别人来做这件事就干脆自己干。 </p></blockquote><h3 id="5-在Java中Executor和Executors的区别">5. 在Java中Executor和Executors的区别?</h3><p><strong>参考回答</strong>：</p><blockquote><p>Executors工具类的不同方法按照我们的需求创建了不同的线程池，来满足业务的需求。</p><p>Executor接口对象能执行我们的线程任务。</p><p>ExecutorService接口继承了Executor接口并进行了扩展，提供了更多的方法我们能获得任务执行的状态并且可以获取任务的返回值。 </p></blockquote><h3 id="6-线程池都有哪些状态">6.线程池都有哪些状态</h3><p><img src="2025-01-09-JUC%E5%9F%BA%E7%A1%80%E9%9D%A2%E8%AF%95%E9%A2%98/image-1.png" alt=""></p><p><strong>参考回答</strong>：</p><blockquote><ul><li><p>RUNNING：这是最正常的状态，接受新的任务，处理等待队列中的任务。</p></li><li><p>SHUTDOWN：不接受新的任务提交，但是会继续处理等待队列中的任务。</p></li><li><p>STOP：不接受新的任务提交，不再处理等待队列中的任务，中断正在执行任务的线程。</p></li><li><p>TIDYING：所有的线程都销毁了，workerCount为0，线程池的状态转换为TIDYING状态时，会执行钩子方法terminated()。</p></li><li><p>TERMINATED：terminated()方法结束后，线程池的状态就会变成这个。</p></li></ul></blockquote><h3 id="7-线程池中submit-和execute-方法有什么区别">7. 线程池中submit()和execute()方法有什么区别?</h3><blockquote><p><strong>参考回答</strong>：</p><ul><li><p>相同点：</p><ul><li>相同点就是都可以开启线程执行池中的任务。</li></ul></li><li><p>不同点：</p><ul><li><p>接收参数：execute()只能执行Runnable类型的任务。submit()可以执行Runnable和Callable类型的任务。</p></li><li><p>返回值：submit()方法可以返回持有计算结果的Future对象，而execute()没有。</p></li><li><p>异常处理：submit()方便Exception处理。 </p></li></ul></li></ul></blockquote><h3 id="8-分析线程池的实现原理和线程的调度过程">8. 分析线程池的实现原理和线程的调度过程</h3><p><strong>分析</strong></p><p><strong>参考回答</strong>：</p><blockquote><p>提交一个任务到线程池中，线程池的处理流程如下：</p><ol><li><p>如果当前运行的线程数小于核心线程数，那么就会新建一个线程来执行任务。</p></li><li><p>如果当前运行的线程数等于或大于核心线程数，并且任务队列没满，那么就把该任务放入到任务队列里等待执行。</p></li><li><p>如果任务队列满了，但是当前运行的线程数小于最大线程数的，就新建一个线程来执行任务。</p></li><li><p>如果当前运行的线程数已经等同于最大线程数了，新建线程将会使当前运行的线程超出最大线程数，那么当前任务会被拒绝，调用拒绝策略方法。</p></li></ol></blockquote><h3 id="9-线程池的最大线程数目根据什么确定">9. 线程池的最大线程数目根据什么确定</h3><p><strong>分析</strong></p><p><strong>参考回答</strong>：</p><blockquote><p>线程池用来执行CPU密集型任务时，设置线程数为cpu核心数+1，这样可以使得每个线程都在执行任务。用来执行IO密集型任务时，大部分线程都阻塞，所以设置线程数为2*cpu核数。 </p></blockquote><h3 id="10-线程池如何调优">10. 线程池如何调优</h3><p><strong>分析</strong></p><blockquote><p><strong>参考回答</strong>：</p><ol><li><p>CPU密集型任务配置尽可能小的线程，cpu核数+1。</p></li><li><p>IO密集型任务则由于线程并不是一直在执行任务，则配置尽可能多的线程，如2*cpu核数。</p></li><li><p>混合型任务，如果可以拆分，则将其拆分成一个CPU密集型任务和一个IO密集型任务。只要这两个任务执行的时间相差不是太大，那么分解后并发执行的吞吐率高于串行执行的吞吐率；如果这两个任务执行时间相差太大，则没必要进行分解。</p></li><li><p>优先级不同的任务可以使用优先级队列PriorityBlockingQueue来处理，它可以让优先级高的任务先得到执行。</p></li><li><p>执行时间不同的任务可以交给不同线程池来处理，或者也可以使用优先级队列，让执行时间短的任务先执行。</p></li><li><p>依赖数据库连接池的任务，因为线程提交SQL后需要等待数据库返回结果，线程数应该设置得较大，这样才能更好的利用CPU。</p></li><li><p>建议使用有界队列，有界队列能增加系统的稳定性和预警能力。可以根据需要设大一点，比如几千。使用无界队列，线程池的队列就会越来越大，有可能会撑满内存，导致整个系统不可用。 </p></li></ol></blockquote><h3 id="11-线程池如何实现动态修改">11. 线程池如何实现动态修改?</h3><p><strong>参考回答</strong>：</p><blockquote><ol><li>首先线程池提供了部分setter方法可以设置线程池的参数；</li></ol><p> a. 修改核心线程数，最大线程数，空闲线程停留时间，拒绝策略等。</p><p> b. 可以将线程池的配置参数放入配置中心，当需要调整的时候，去配置中心修改就行。</p><ul><li>什么时候修改呢?</li></ul><p> a. 这里需要监控报警策略，获取线程池状态指标，当指标判定为异常之后进行报警。</p><p> b. 分析指标异常原因，评估处理策略，最后通过上述线程池提供的接口进行动态修改。(可以将动态配置)</p></blockquote><p><strong>推荐学习</strong>：</p><p><a href="https://tech.meituan.com/2020/04/02/java-pooling-pratice-in-meituan.html">Java线程池实现原理及其在美团业务中的实践</a></p><h3 id="12-使用无界队列的线程池会导致什么问题">12. 使用无界队列的线程池会导致什么问题?</h3><p><strong>参考回答</strong>：</p><blockquote><p>例如newFixedThreadPool使用了无界的阻塞队列LinkedBlockingQueue，如果线程获取一个任务后，任务的执行时间比较长，会导致队列的任务越积越多，导致机器内存使用不停飙升，最终导致OOM。 </p></blockquote><h3 id="13-线程池的问题，如果线程池当前处于空闲的状态，核心线程数量是不会被销毁的，那这几个核心线程处于什么状态？为什么处于这个状态">13. 线程池的问题，如果线程池当前处于空闲的状态，核心线程数量是不会被销毁的，那这几个核心线程处于什么状态？为什么处于这个状态?</h3><p><strong>分析</strong></p><p>这里面面试官其实想问你线程复用的逻辑，以及对线程状态机的理解，知不知道都要有一个分析思考的过程，不要一上来就回答答案或者说不知道，瞎猜。</p><p><strong>参考回答</strong></p><blockquote><p>首先线程本身创建和销毁都是成本比较高的，那就排除new和terminated状态，没有任务运行排除runnable状态，剩下阻塞和等待，因为线程不会销毁需要一直等待执行任务，超时等待也不太可能，最后同步锁才会进入阻塞状态，所以我猜是一直等待。 </p></blockquote><p><img src="2025-01-09-JUC%E5%9F%BA%E7%A1%80%E9%9D%A2%E8%AF%95%E9%A2%98/image-2.png" alt=""></p><h3 id="14-如果不允许线程池丢弃任务，应该选择哪个拒绝策略？">14. 如果不允许线程池丢弃任务，应该选择哪个拒绝策略？</h3><p>大家应该都知道，线程池的核心线程满了，就会放在阻塞队列，阻塞队列满了会创建临时线程，如果超过最大线程数，就会触发拒绝策略。那很多人都是用直接拒绝的策略，这样任务就直接丢了。 </p><p>但是如果任务很重要，不允许丢弃你会怎么做呢？那大家可以把工作中用到的方案发在评论区，我给你提供几种：</p><ol><li><p>用CallerRunsPolicy，它会采用主线程执行任务，但是如果任务非常耗时会阻塞主线程，在高并发场景慎用！</p></li><li><p>将任务进行持久化，可以采用mysql、redis、或者mq异步等方案持久化，后续再对任务进行补偿执行。</p></li><li><p>  也可以参考netty：它会再创建新的一个异步线程处理任务。 </p></li></ol><p><img src="2025-01-09-JUC%E5%9F%BA%E7%A1%80%E9%9D%A2%E8%AF%95%E9%A2%98/image76.png" alt=""></p><h3 id="15-Callable和Runnable接口有什么区别？">15. Callable和Runnable接口有什么区别？</h3><blockquote><p>Callable和Runnable接口都是用于在Java中实现多线程的接口，但它们之间有一些区别：</p><ol><li><p><strong>返回值</strong>：</p><ul><li><p>Runnable接口的run()方法没有返回值，它通常用于执行一些不需要返回结果的任务。</p></li><li><p>Callable接口的call()方法可以返回一个结果，它允许线程执行任务并返回结果，可以通过Future对象获取。</p></li></ul></li><li><p><strong>抛出异常</strong>：</p><ul><li><p>Runnable接口的run()方法不能抛出受检异常，只能抛出未检查异常。</p></li><li><p>Callable接口的call()方法可以抛出受检异常。</p></li></ul></li><li><p><strong>泛型</strong>：</p><ul><li><p>Callable接口使用了泛型，可以指定call()方法的返回类型。</p></li><li><p>Runnable接口没有使用泛型。</p></li></ul></li><li><p><strong>线程池支持</strong>：</p><ul><li><p>Callable接口通常与Executor框架一起使用，可以提交给ExecutorService的线程池执行。</p></li><li><p>Runnable接口同样可以与Executor框架一起使用，但是Callable接口提供了更丰富的功能，如取消任务、获取执行结果等。 </p></li></ul></li></ol></blockquote><h3 id="16-线程池中线程异常后：销毁还是复用？">16. 线程池中线程异常后：销毁还是复用？</h3><blockquote><p>第一个线程池拒绝策略是：</p><p><strong>执行策略为AbortPolicy</strong>：执行任务出现异常，向提交任务线程，即调用线程会抛出RejectedExecutionException异常，并会创建一个新的线程继续执行后续任务。</p><p><strong>执行策略为DiscardPolicy</strong>：内部会把异常信息吞掉，既不会把异常抛给这个线程池线程，也不会创建新的线程加入到线程池中。</p><p>这两种执行方式，都不会影响线程池里面其他线程的正常执行，更便于线程池的资源管理，可以防止资源被滥用，如果程序有默认处 </p></blockquote><h3 id="17-线程池阻塞队列类型">17.线程池阻塞队列类型</h3><blockquote><p>线程池常用的阻塞队列类型主要有以下几种：</p><ol><li><p><code>ArrayBlockingQueue</code>：基于数组实现的有界阻塞队列。其容量在创建时指定，一旦达到容量上限，新的入队操作会阻塞等待。</p></li><li><p><code>LinkedBlockingQueue</code>：基于链表实现的阻塞队列。默认情况下，其容量没有上限，可以看作是无界的，但也可以在创建时指定容量。</p></li><li><p><code>PriorityBlockingQueue</code>：无界的优先级阻塞队列，元素按照自定义的优先级规则进行排序。</p></li><li><p><code>SynchronousQueue</code>：不存储元素的阻塞队列，入队操作必须等待出队操作，反之亦然，常用于实现线程之间的直接传递。</p></li><li><p><code>DelayQueue</code>：无界的延迟阻塞队列，元素只有在指定的延迟时间到期后才能被取出。</p></li><li><p><code>LinkedTransferQueue</code>：无界的阻塞队列，具有高效的元素传递特性。</p></li><li><p><code>LinkedBlockingDeque</code>：基于链表实现的双向阻塞队列，可以从队列的头部和尾部进行插入和删除操作。</p></li></ol></blockquote><h2 id="Java中的锁">Java中的锁</h2><h3 id="1-Lock接口和synchronized对比同步它有什么优势">1. Lock接口和synchronized对比同步它有什么优势?</h3><p><strong>参考回答</strong>：</p><blockquote><p>Lock接口比同步方法和同步块提供了更具扩展性的锁操作。它们允许更灵活的结构，可以具有完全不同的性质，并且可以支持多个相关类的条件对象。</p><p>它的优势有：</p><ul><li><p><strong>(1) 可以使锁更公平。</strong></p></li><li><p><strong>(2) 可以使线程在等待锁的时候响应中断。</strong></p></li><li><p><strong>(3) 可以让线程尝试获取锁，并在无法获取锁的时候立即返回或者等待一段时间。</strong></p></li><li><p><strong>(4) 可以在不同的范围，以不同的顺序获取和释放锁。</strong></p></li></ul><p>整体上来说Lock是synchronized的扩展版，Lock提供了无条件的、可轮询的(tryLock方法)、定时的(tryLock带参方法)、可中断的(lockInterruptibly)、可多条件队列的(newCondition方法)锁操作。另外Lock的实现类基本都支持非公平锁(默认)和公平锁，synchronized只支持非公平锁，当然，在大部分情况下，非公平锁是高效的选择。 </p></blockquote><h3 id="2-乐观锁和悲观锁的理解及如何实现，有哪些实现方式">2. 乐观锁和悲观锁的理解及如何实现，有哪些实现方式?</h3><p><strong>参考回答</strong>：</p><blockquote><ul><li><p><strong>悲观锁：</strong>总是假设最坏的情况，每次去拿数据的时候都认为别人会修改，所以每次在拿数据的时候都会上锁，这样别人想拿这个数据就会阻塞直到它拿到锁。传统的关系型数据库里边就用到了很多这种锁机制，比如行锁，表锁等，读锁，写锁等，都是在做操作之前先上锁。再比如Java里面的同步原语synchronized关键字的实现也是悲观锁。</p></li><li><p><strong>乐观锁：</strong>顾名思义，就是很乐观，每次去拿数据的时候都认为别人不会修改，所以不会上锁，但是在更新的时候会判断一下在此期间别人有没有去更新这个数据，可以使用版本号等机制。乐观锁适用于多读的应用类型，这样可以提高吞吐量，像数据库提供的类似于write_condition机制，其实都是提供的乐观锁。在Java中java.util.concurrent.atomic包下面的原子变量类就是使用了乐观锁的一种实现方式CAS实现的。 </p></li></ul></blockquote><h3 id="3-什么是CAS">3. 什么是CAS</h3><p><strong>分析</strong></p><p>回答出CAS操作的原子性，系统硬件级别提供支持</p><p><strong>回答</strong></p><blockquote><p>CAS即CompareAndSwap，Java中可以通过CAS操作来保证原子性，原子性就是不可被中断的一系列操作或者一个操作，简单来说就是一系列操作要么全部完成，要么失败，不能被中断。</p><p>CAS主要包含三个参数（V，expect，update），V表示要更新的变量（内存值）、expect表示预期值（旧值）、update表示新值。算法流程是首先比较V和expect的值，如果相等，将update值赋值给V，如果不相等说明有其他线程对该变量做了更新。这个参数有的地方也会用（V，A，B）表示，其中A表示预期值，B表示新值。</p><p>当多个线程同时操作一个共享变量时，只有一个线程可以对变量进行成功更新，其他线程均会失败，但是失败并不会被挂起，进行再次尝试，也就是自旋。Java中的自旋锁就是利用CAS来实现的。 </p></blockquote><p><a href="https://www.cnblogs.com/huansky/p/15746624.html">Java CAS 原理详解 - huansky - 博客园</a></p><h3 id="4-CAS的会产生什么问题">4. CAS的会产生什么问题?</h3><p><strong>参考回答</strong>：</p><blockquote><p><strong>1、ABA问题：</strong></p><p>比如说一个线程one从内存位置V中取出A，这时候另一个线程two也从内存中取出A，并且two进行了一些操作变成了B，然后two又将V位置的数据变成A，这时候线程one进行CAS操作发现内存中仍然是A，然后one操作成功。尽管线程one的CAS操作成功，但可能存在潜藏的问题。从Java1.5开始JDK的atomic包里提供了一个类AtomicStampedReference来解决ABA问题。</p><p><strong>2、循环时间长开销大：</strong></p><p>对于资源竞争严重（线程冲突严重）的情况，CAS自旋的概率会比较大，从而浪费更多的CPU资源，效率低于synchronized。</p><p><strong>3、只能保证一个共享变量的原子操作：</strong></p><p>当对一个共享变量执行操作时，我们可以使用循环CAS的方式来保证原子操作，但是对多个共享变量操作时，循环CAS就无法保证操作的原子性，这个时候就可以用锁。 </p></blockquote><h3 id="5-什么是原子类">5. 什么是原子类</h3><blockquote><p><strong>参考回答</strong>：</p><ul><li><p>java.util.concurrent.atomic包：是原子类的小工具包，支持在单个变量上解解锁的线程安全编程。原子变量类相当于一种泛化的volatile变量，能够支持原子的和有条件的读-改-写操作。</p></li><li><p>比如：AtomicInteger表示一个int类型的值，并提供了get和set方法，这些Volatile类型的int变量在读取和写入上有着相同的内存语义。它还提供了一个原子的compareAndSet方法（如果该方法成功执行，那么将实现与读取/写入一个volatile变量相同的内存效果），以及原子的添加、递增和递减等方法。AtomicInteger表面上非常像一个扩展的Counter类，但在发生竞争的情况下能提供更高的可伸缩性，因为它直接利用了硬件对并发的支持。</p></li></ul><p>简单来说就是原子类来实现CAS无锁模式的算法。</p></blockquote><h3 id="6-原子类的常用类">6. 原子类的常用类</h3><p><strong>参考回答</strong>：</p><blockquote><ul><li><p>AtomicBoolean</p></li><li><p>AtomicInteger</p></li><li><p>AtomicLong</p></li><li><p>AtomicReference </p></li></ul></blockquote><h3 id="7-说一下Atomic的原理">7. 说一下Atomic的原理?</h3><p><strong>参考回答</strong>：</p><blockquote><ul><li>Atomic包中的类基本的特性就是在多线程环境下，当有多个线程同时对单个（包括基本类型及引用类型）变量进行操作时，具有排他性，即当多个线程同时对该变量的值进行更新时，仅有一个线程能成功，而未成功的线程可以自旋锁一样，继续尝试，一直等到执行成功。</li></ul></blockquote><h3 id="8-死锁与活锁的区别，死锁与饥饿的区别">8. 死锁与活锁的区别，死锁与饥饿的区别?</h3><p><strong>参考回答</strong>：</p><blockquote><p><strong>死锁：</strong>是指两个或两个以上的进程（或线程）在执行过程中，因争夺资源而造成的一种互相等待的现象，若无外力作用，它们都将无法推进下去。</p><p><strong>活锁：</strong>任务或者执行者没有被阻塞，由于某些条件没有满足，导致一直重复尝试，失败，尝试，失败。</p><p>活锁和死锁的区别在于，处于活锁的实体是在不断的改变状态，这就是所谓的“活”，而处于死锁的实体表现为等待；活锁有可能自行解开，死锁则不能。</p><p><strong>饥饿：</strong>一个或者多个线程因为种种原因无法获得所需要的资源，导致一直无法执行的状态。 </p><p>Java中导致饥饿的原因:</p><p>1、高优先级线程吞噬所有的低优先级线程的CPU时间。</p><p>2、线程被永久堵塞在一个等待进入同步块的状态，因为其他线程总是能在它之前持续地对该同步块进行访问。</p><p>3、线程在等待一个本身也处于永久等待完成的对象(比如调用这个对象的wait方法)，因为其他线程总是被持续地获得唤醒。 </p></blockquote><h3 id="9-如何避免死锁">9. 如何避免死锁</h3><blockquote><p>死锁是多线程编程中的一种常见问题，它发生在两个或多个线程相互等待对方释放资源的情况下，导致程序无法继续执行。为了避免死锁，我们可以采用以下策略：</p><ol><li><p><strong>锁顺序</strong>：定义一个固定的锁获取顺序，并要求所有线程都按照相同的顺序获取锁。这可以减少不同线程之间资源争夺的可能性。</p></li><li><p><strong>超时机制</strong>：在获取锁时，设置一个超时时间。如果超过指定时间仍然无法获取锁，线程应该释放已经持有的锁并重试，或者采取其他适当的措施。这有助于避免线程无限期地等待锁。</p></li><li><p><strong>避免嵌套锁</strong>：尽量避免在一个锁的持有期间再次尝试获取其他锁。如果确实需要获取多个锁，请确保获取的顺序是固定的，以减少死锁风险。</p></li><li><p><strong>使用锁机制</strong>：比如Java中的ReentrantLock，它支持可中断的锁获取和条件等待，有助于避免死锁。 </p></li></ol></blockquote><h3 id="10-为什么-wait-和-notify-方法要在同步块中调用">10. 为什么 wait 和 notify 方法要在同步块中调用</h3><blockquote><p>调用wait()就是释放锁，释放锁的前提是必须要先获得锁，先获得锁才能释放锁。</p><p>notify(),notifyAll()是将锁交给含有wait()方法的线程，让其继续执行下去，如果自身没有锁，怎么叫把锁交给其他线程 。</p></blockquote><h3 id="11-说下对AQS的理解">11. 说下对AQS的理解</h3><p>AQS（AbstractQueuedSynchronizer）是Java并发编程中的一个重要组件，它是一个抽象类，提供了线程同步的底层实现机制。AQS的作用是实现线程的同步和互斥操作，它提供了两种主要的锁机制，分别是排他锁和共享锁。</p><p><strong>排他锁也称为独占锁</strong>，在多个线程竞争同一共享资源时，同一时刻只允许一个线程访问该共享资源，即多个线程中只有一个线程获得锁资源。在AQS中，排他锁是通过内置的同步状态来实现的。当同步状态为0时，表示锁是未被获取的；当同步状态大于0时，表示锁已经被获取且被占用；当同步状态小于0时，表示锁已经被获取但是处于等待状态。</p><p><strong>共享锁</strong>允许多个线程同时获得锁资源，但是在同一时刻只有一个线程可以获取到锁的拥有权，其他线程需要等待该线程释放锁。在AQS中，共享锁的实现与排他锁类似，也是通过先进内置的同步状态来实现的。</p><p>AQS通过一个内置的<strong>FIFO</strong>（先进先出）等待队列来实现线程的排队和调度。当线程需要获取锁资源时，如果锁已经被其他线程获取，则该线程会被加入到等待队列中等待。当锁被释放时，等待队列中的第一个线程会获得锁资源并继续执行。</p><p>在实现AQS时，需要继承自AQS类并实现其抽象方法。其中比较重要的方法包括：tryAcquire()和tryRelease()方法，用于实现锁的获取和释放；acquire()和release()方法，用于实现阻塞和唤醒操作；isHeldExclusively()方法，用于判断是否是排他锁。 </p><p>答案：</p><blockquote><p>AQS是多线程同步器，它是J.U.C包中多个组件的底层实现，如Lock、CountDownLatch、Semaphore等都用到了AQS。<strong>从本质上来说，AQS提供了两种锁机制，分别是排他锁，和共享锁。</strong>排他锁，就是存在多线程竞争同一共享资源时，同一时刻只允许一个线程访问该共享资源，也就是多个线程中只能有一个线程获得锁资源，比如Lock中的ReentrantLock重入锁实现就是用到了AQS中的排他锁功能。<strong>共享锁也称为读锁</strong>，就是在同一时刻允许多个线程同时获得锁资源，比如CountDownLatch和Semaphore都是用到了AQS中的共享锁功能。</p><p>AQS有三个核心的问题：</p><p>AQS维持着一个int类型的互斥变量state来记录锁竞争的一个状态，0表示当前没有任何线程竞争锁资源，而大于等于1表示已经有线程正在持有锁资源。一个线程来获取锁资源的时候，首先判断state是否等于0，如果是(无锁状态)，则把这个state更新成1，表示占用到锁。此时如果多个线程进行同样的操作，会造成线程安全问题。AQS采用了CAS机制来保证互斥变量state的原子性。</p><p>未获取到锁资源的线程通过Unsafe类中的park方法对线程进行阻塞，把阻塞的线程按照先进先出的原则加入到一个双向链表的结构<strong>CLH</strong>中，当获得锁资源的线程释放锁之后，会从双向链表的头部去唤醒下一个等待的线程再去竞争锁。</p><p><strong>CLH 队列</strong>是一个虚拟的双向队列,用于存储等待锁的线程。当线程尝试获取同步状态失败时，会将其封装成一个节点加入到队列的尾部，并处于等待状态。线程通过自旋的方式不断检查其前驱节点的状态来判断自己是否能够获取到锁。当持有锁的线程释放锁时，会唤醒其后继节点的线程进行竞争获取。</p><p>另外关于公平性和非公平性问题，AQS的处理方式是，在竞争锁资源的时候，公平锁需要判断双向链表中是否有阻塞的线程，如果有，则需要去排队等待；而非公平锁的处理方式是，不管双向链表中是否存在等待锁的线程，都会直接尝试更改互斥变量state去竞争锁。 </p></blockquote><p><a href="https://pdai.tech/md/java/thread/java-thread-x-lock-AbstractQueuedSynchronizer.html">JUC锁: 锁核心类AQS详解</a></p><p><a href="https://javaguide.cn/java/concurrent/aqs.html">AQS 详解</a></p><h3 id="12-说下CAS的原理">12. 说下CAS的原理</h3><blockquote><p>CAS（Compare And Swap）是一种<strong>乐观的并发控制机制</strong>，它的核心原理是基于硬件层面的原子性保证。CAS操作包含三个操作数——内存位置（V）、预期原值（A）和新值（B）。它的工作原理是：</p><ol><li><p>在将新值写入内存之前，CAS操作会先比较内存位置的值是否与预期原值相匹配。</p></li><li><p>如果内存位置的值与预期原值相匹配，那么处理器会自动将该位置的值更新为新值。</p></li><li><p>如果内存位置的值与预期原值不匹配，则CAS操作失败，不会修改内存值。</p></li></ol><p>CAS的优势在于它没有阻塞状态，不会引起线程上下文的切换和调度问题。然而，CAS也存在一些缺点，例如ABA问题和开销问题。ABA问题是指一个值原来是A，变成了B，又变成了A，那么使用CAS进行检查时会发现它的值没有发生变化，但是实际上却变化了。开销问题则是因为CAS自旋操作需要不断轮询内存位置，直到成功为止，这会消耗大量的CPU资源。 </p></blockquote><h3 id="13-ReentrantLock中的公平锁和非公平锁的底层实现">13. ReentrantLock中的公平锁和非公平锁的底层实现</h3><blockquote><p>ReentrantLock是Java中提供的一种可重入锁，它支持两种锁的模式：公平锁和非公平锁。这两种锁模式的底层实现略有不同：</p><ol><li><p><strong>公平锁（Fair Lock）</strong>：公平锁的特点是按照请求锁的顺序来分配，即先到先得。在ReentrantLock中，通过构造函数可以选择创建一个公平锁。公平锁的底层实现使用了一个FIFO队列（First - In - First - Out），即等待队列。当一个线程请求锁时，如果锁已经被其他线程持有，请求线程会被放入等待队列的末尾，按照请求的顺序等待锁的释放。当锁被释放时，等待队列中的第一个线程会被唤醒并获得锁。</p></li><li><p><strong>非公平锁（Non - Fair Lock）</strong>：非公平锁不考虑请求锁的顺序，它允许新的请求线程插队并尝试立即获取锁，而不管其他线程是否在等待。在ReentrantLock中，默认情况下创建的是非公平锁。非公平锁的底层实现中，有一个等待队列，但它不会严格按照请求的顺序来分配锁，而是根据线程竞争的情况来判断是否立即分配给请求线程。</p></li></ol><p>底层实现中，无论是公平锁还是非公平锁，都使用了类似的同步器（Sync）来管理锁的状态和线程的竞争。不同之处在于如何处理等待队列中的线程，以及是否按照请求的顺序来分配锁。</p><p>需要注意的是，公平锁虽然遵循公平性原则，但在高并发情况下可能会引入较大的性能开销，因为每次都要维护一个有序的等待队列。而非公平锁则更加灵活，但可能导致某些线程一直获取不到锁。 </p></blockquote><h3 id="14-AQS是怎么实现同步管理的-底层数据结构">14. AQS是怎么实现同步管理的? 底层数据结构?</h3><p><strong>参考回答</strong>：</p><blockquote><p>AQS主要依赖于<strong>一个双向链表</strong>和一个<strong>volatile类型的整数state</strong>来实现同步控制。该整数state用来表示同步状态，一般情况下，state=0表示没有线程占用同步资源，state&gt;0表示有线程占用同步资源，state&gt;1表示同步资源已经被争用了多次，比如ReentrantLock可以允许一个线程多次获得锁，每次state值加1。</p><p>AQS实现同步的关键在于，它提供了一个基于FIFO队列的等待队列，通过将等待线程加入等待队列中，然后在释放同步状态的时候，从等待队列中唤醒等待线程，从而实现了同步机制。</p><p>AQS的实现主要有两种方式：独占式（Exclusive）和共享式（Shared）。独占式是指只有一个线程可以占用同步资源，比如ReentrantLock，而共享式是指多个线程可以同时占用同步资源，比如CountDownLatch。在AQS中，这两种方式的实现是基本相同的，区别在于获取和释放同步状态的方式不同。 </p></blockquote><h3 id="15-什么是可重入，什么是可重入锁">15. 什么是可重入，什么是可重入锁?</h3><p><strong>参考回答</strong>：</p><blockquote><p>“可重入锁”概念是：自己可以再次获取自己的内部锁。比如一个线程获得了某个对象的锁，此时这个对象锁还没有释放，当其再次想要获取这个对象的锁的时候还是可以获取的，如果不可锁重入的话，就会造成死锁。同一个线程每次获取锁，锁的计数器都自增1，所以要等到锁的计数器下降为0时才能释放锁。</p></blockquote><h3 id="16-公平锁和非公平锁有什么区别">16. 公平锁和非公平锁有什么区别?</h3><p><strong>参考回答</strong>：</p><blockquote><ul><li><p>公平锁：锁被释放之后，先申请的线程先得到锁。性能较差一些，因为公平锁为了保证时间上的绝对顺序，上下文切换更频繁。</p></li><li><p>非公平锁：锁被释放之后，后申请的线程可能会先获取到锁，是随机或者按照其他优先级排序的。性能更好，但可能会导致某些线程永远无法获取到锁。 </p></li></ul></blockquote><h3 id="17-为什么非公平锁比公平锁性能更好">17. 为什么非公平锁比公平锁性能更好?</h3><blockquote><p><strong>参考回答</strong>：</p><ul><li><p>公平锁执行流程：获取锁时，先将线程自己添加到同步队列的队尾并休眠，当某线程用完锁之后，会去唤醒同步队列队首的线程尝试去获取锁，锁的使用同步也就是队列中的先后顺序，在整个过程中，线程会从运行状态切换到休眠状态，再从休眠状态恢复成运行状态，但线程每次休眠和恢复都需要从用户态转换成内核态，而这个状态的转换是比较慢的，所以公平锁的执行速度会比较慢。</p></li><li><p>非公平锁执行流程：当线程获取锁时，会先通过CAS尝试获取锁，如果获取成功就直接拥有锁，如果获取锁失败才会进入同步队列，等待下次尝试获取锁。这样做的好处是，获取锁不遵循先到先得的规则，从而避免了一次线程休眠和恢复的操作，这样就加速了程序的执行效率。 </p></li></ul></blockquote><h3 id="18-ReentrantLock是如何实现公平锁的-非公平锁的">18. ReentrantLock是如何实现公平锁的? 非公平锁的?</h3><p><strong>参考回答</strong>：</p><blockquote><p>ReentrantLock类内部总共存在Sync、NonfairSync、FairSync三个类，NonfairSync与FairSync类继承自Sync类，Sync类继承自AbstractQueueuedSynchronizer抽象类。</p><p>非公平锁是ReentrantLock的默认实现。公平锁对比非公平锁的实现差异主要体现在tryAcquire方法（获取锁）这里。非公平锁（NonfairSync）的tryAcquire实现直接调用了父类Sync中的nonfairTryAcquire。</p><p>而公平锁tryAcquire的唯一不同的点为判断条件多了hasQueuedPredecessors()方法，即加入了同步队列中当前节点是否有前驱节点的判断，如果该方法返回true，则表示有线程比当前线程更早地请求获取锁，因此需要等待前驱线程获取并释放锁之后才能继续获取锁（这就叫公平）。</p></blockquote><h3 id="19-ReentrantReadWriteLock是什么">19. ReentrantReadWriteLock是什么?</h3><p><strong>参考回答</strong>：</p><blockquote><p>答：<code>ReentrantReadWriteLock</code>实现了<code>ReadWriteLock</code>，是一个可重入的读写锁，既可以保证多个线程同时读的效率，同时又可以保证有写入操作时的线程安全。</p><p><code>ReentrantReadWriteLock</code>其实是两把锁，一把是WriteLock（写锁），一把是ReadLock（读锁）。读锁是共享锁，写锁是独占锁。读锁可以被同时读，可以同时被多个线程持有，而写锁最多只能同时被一个线程持有。 </p></blockquote><h3 id="20-共享锁和独占锁有什么区别">20. 共享锁和独占锁有什么区别?</h3><blockquote><p><strong>参考回答</strong>：</p><ul><li><p>共享锁：一把锁可以被多个线程同时获得。</p></li><li><p>独占锁：一把锁只能被一个线程获得。</p></li></ul></blockquote><h3 id="21-线程持有读锁还能获取写锁吗">21. 线程持有读锁还能获取写锁吗?</h3><p><strong>参考回答</strong>：</p><blockquote><p>在线程持有读锁的情况下：该线程不能取得写锁(因为获取写锁的时候，如果发现当前的读锁被占用，就马上获取失败，不管读锁是不是被当前线程持有)。</p><p>在线程持有写锁的情况下：该线程可以继续获取读锁（获取读锁时如果发现写锁被占用，只有写锁没有被当前线程占用的情况才会获取失败）。</p></blockquote><h3 id="22-什么是锁的升降级-RentrantReadWriteLock为什么不支持锁升级">22. 什么是锁的升降级? RentrantReadWriteLock为什么不支持锁升级?</h3><p><strong>参考回答</strong>：</p><blockquote><p>写锁可以降级为读锁，但是读锁却不能升级为写锁。这是因为读锁升级为写锁会引起线程的争夺，毕竟写锁属于是独占锁，这样的话，会影响性能。另外，还可能会有死锁问题发生。举个例子：假设两个线程的读锁都想升级写锁，则需要对方都释放自己锁，而双方都不释放，就会产生死锁。 </p></blockquote><h3 id="23-ReentrantReadWriteLock底层读写状态如何设计的">23. ReentrantReadWriteLock底层读写状态如何设计的?</h3><p><strong>参考回答</strong>：</p><blockquote><p>答：高16位为读锁，低16位为写锁。 </p></blockquote><h2 id="并发安全容器-并发工具类">并发安全容器/并发工具类</h2><h3 id="1-JDK7与JDK8之间HashMap的区别？">1. JDK7与JDK8之间HashMap的区别？</h3><blockquote><ol><li><p>JDK8中新增了红黑树，JDK8是通过数组+链表+红黑树来实现的；</p></li><li><p>JDK7中链表的插入是用的头插法，而JDK8中则改为了尾插法；</p></li><li><p>JDK8中因为使用了红黑树保证了插入和查询的效率，所以实际上JDK8中的Hash算法实现的复杂度降低了；</p></li><li><p>JDK8中数组扩容的条件也发生了变化，只会判断是否当前元素个数是否超过了阈值，而不再判断当前put进来的元素对应的数组下标位置是否有值；</p></li><li><p>JDK7中是先扩容再添加新元素，JDK8中是先添加新元素然后再扩容。 </p></li></ol></blockquote><h3 id="2-ConcurrentHashMap和Hashtable的区别">2. ConcurrentHashMap和Hashtable的区别?</h3><p><strong>参考回答</strong>：</p><blockquote><p>ConcurrentHashMap和Hashtable的区别主要体现在实现线程安全的方式上不同。</p><p><strong>底层数据结构</strong>：JDK1.7的ConcurrentHashMap底层采用分段的数组+链表实现，JDK1.8采用的数据结构跟HashMap1.8的结构一样，数组+链表/红黑二叉树。Hashtable和JDK1.8之前的HashMap的底层数据结构类似都是采用数组+链表的形式，数组是HashMap的主体，链表则是主要为了解决哈希冲突而存在的；</p><p><strong>实现线程安全的方式（重要）</strong>：</p><p>在JDK1.7的时候，ConcurrentHashMap对整个桶数组进行了分割分段(Segment，分段锁)，每一把锁只锁容器其中一部分数据，多线程访问容器里不同数据段的数据，就不会存在锁竞争，提高并发访问率。</p><p>到了JDK1.8的时候，ConcurrentHashMap已经摒弃了Segment的概念，而是直接用Node数组+链表+红黑树的数据结构来实现，并发控制使用synchronized和CAS来操作。(JDK1.6以后synchronized锁做了很多优化) 整个看起来就像是优化过且线程安全的HashMap，虽然在JDK1.8中还能看到Segment的数据结构，但是已经简化了属性，只是为了兼容旧版本；</p><p>Hashtable(同一把锁)：使用synchronized来保证线程安全，效率非常低下。当一个线程访问同步方法时，其他线程也访问同步方法，可能会进入阻塞或轮询状态，如使用put添加元素，另一个线程不能使用put添加元素，也不能使用get，竞争会越来越激烈效率越低。 </p></blockquote><h3 id="3-ConcurrentHashMap-JDK1-7实现的原理是什么">3. ConcurrentHashMap JDK1.7实现的原理是什么?</h3><blockquote><p><strong>参考回答</strong>：</p><ul><li><p>首先将数据分为一段一段（这个“段”就是Segment）的存储，然后给每一段数据配一把锁，当一个线程占用锁访问其中一个段数据时，其他段的数据也能被其他线程访问。</p></li><li><p>ConcurrentHashMap是由Segment数组结构和HashEntry数组结构组成。</p></li><li><p>Segment继承了ReentrantLock，所以Segment是一种可重入锁，扮演锁的角色。HashEntry用于存储键值对数据。</p></li><li><p>一个ConcurrentHashMap里包含一个Segment数组，Segment的个数一旦初始化就不能改变。Segment数组的大小默认是16，也就是说默认可以同时支持16个线程并发写。</p></li><li><p>Segment的结构和HashMap类似，是一种数组和链表结构，一个Segment包含一个HashEntry数组，每个HashEntry是一个链表结构的元素，每个Segment守护着一个HashEntry数组里的元素，当对HashEntry数组的数据进行修改时，必须首先获得对应的Segment的锁。也就是说，对同一Segment的并发写入会被阻塞，不同Segment的写入是可以并发执行的。 </p></li></ul></blockquote><h3 id="4-ConcurrentHashMap-JDK1-8实现的原理是什么">4. ConcurrentHashMap JDK1.8实现的原理是什么?</h3><p><strong>参考回答</strong>：</p><blockquote><p>JDK1.8 ConcurrentHashMap取消了Segment分段锁，采用Node + CAS + synchronized来保证并发安全。数据结构跟HashMap 1.8的结构类似，数组+链表/红黑二叉树。Java 8在链表长度超过一定阈值8（同时满足容量&gt;=64）时将链表（寻址时间复杂度为O(N)）转换为红黑树（寻址时间复杂度为O(log(N))）。</p><p>Java 8中，锁粒度更细，synchronized只锁定当前链表或红黑二叉树的首节点，这样只要hash不冲突，就不会产生并发，就不会影响其他Node的读写，效率大幅提升。</p></blockquote><h3 id="5-ConcurrentHashMap-JDK1-7的实现和1-8的实现有什么区别">5. ConcurrentHashMap JDK1.7的实现和1.8的实现有什么区别?</h3><blockquote><p><strong>参考回答</strong>：</p><ul><li><p><strong>线程安全实现方式</strong>：JDK 1.7采用Segment分段锁来保证安全，Segment是继承自ReentrantLock。JDK1.8放弃了Segment分段锁的设计，采用Node + CAS + synchronized保证线程安全，锁粒度更细，synchronized只锁定当前链表或红黑二叉树的首节点。</p></li><li><p><strong>Hash碰撞解决方法</strong>：JDK 1.7采用拉链法，JDK1.8采用拉链法结合红黑树（链表长度超过一定阈值时，将链表转换为红黑树）。</p></li><li><p><strong>并发度</strong>：JDK 1.7最大并发度是Segment的个数，默认是16。JDK 1.8最大并发度是Node数组的大小，并发度更大。 </p></li></ul></blockquote><h3 id="6-JDK1-8中，ConCurrentHashmap什么情况下链表才会转换成红黑树进行存储">6. JDK1.8中，ConCurrentHashmap什么情况下链表才会转换成红黑树进行存储?</h3><p><strong>参考回答</strong>：</p><blockquote><p>答：链表长度大于等于8，且数组长度大于等于64。</p><p>并非一开始就创建红黑树结构，如果当前Node数组长度小于阈值MIN_TREEIFY_CAPACITY，默认为64，先通过扩大数组容量为原来的两倍以缓解单个链表元素过大的性能问题。</p></blockquote><h3 id="7-JDK1-8中，ConcurrentHashmap的put过程是怎样的">7. JDK1.8中，ConcurrentHashmap的put过程是怎样的?</h3><p><strong>参考回答</strong>：</p><blockquote><p>整体流程跟HashMap比较类似，大致是以下几步：</p><ul><li><p>如果桶数组未初始化，则初始化；</p></li><li><p>如果待插入的元素所在的桶为空，则尝试把此元素直接插入到桶的第一个位置；</p></li><li><p>如果正在扩容，则当前线程一起加入到扩容的过程中；</p></li><li><p>如果待插入的元素所在的桶不为空且没在迁移元素，则锁住这个桶；</p></li><li><p>如果当前桶中元素以链表方式存储，则在链表中寻找该元素或者插入元素；</p></li><li><p>如果当前桶中元素以红黑树方式存储，则在红黑树中寻找该元素或者插入元素；</p></li><li><p>如果元素存在，则覆盖旧值；</p></li><li><p>如果元素不存在，整个Map的元素个数加1，并检查是否需要扩容； </p></li></ul></blockquote><h3 id="8-ConcurrentHashMap的get方法是否要加锁，为什么">8. ConcurrentHashMap的get方法是否要加锁，为什么?</h3><p><strong>参考回答</strong>：</p><blockquote><p>答：不需要。get方法不涉及对变量的修改，所以会导致并发下可能处问题的原因就是读共享变量的可见性问题。而ConcurrentHashMap中，对get方法中用到的共享变量都使用volatile关键字修饰，所以整个get方法不加锁也不会有问题。</p></blockquote><h3 id="9-ConcurrentHashMap默认初始容量是多少">9. ConcurrentHashMap默认初始容量是多少?</h3><p><strong>参考回答</strong>：</p><blockquote><p>答：初始容量为16</p></blockquote><h3 id="10-ConcurrentHashMap的key，value是否可以为null">10. ConcurrentHashMap的key，value是否可以为null?</h3><p><strong>参考回答</strong>：</p><blockquote><p>答：不行。如果key或者value为null会抛出空指针异常。(原因是因为没办法解决get返回值为null时的二义性问题，即没办法确定是存储的值本身为null，还是说值不存在)；</p><p>注意：HashMap允许使用null作为值和键。(因为HashMap只能单线程下使用，所以hashmap可以用containsKey来二次判断，排除二义性问题) </p></blockquote><h3 id="11-存储在ConcurrentHashMap中每个节点是什么样的，有哪些变量">11.存储在ConcurrentHashMap中每个节点是什么样的，有哪些变量?</h3><p><strong>参考回答</strong>：</p><blockquote><p>答：它是实现Map.Entry&lt;K, V&gt;接口。里面存放了hash，key，value，以及next节点。它的value和next节点是用volatile进行修饰，可以保证多线程之间的可见性。</p></blockquote><h3 id="12-什么是BlockingQueue">12. 什么是BlockingQueue?</h3><p><strong>参考回答</strong>：</p><blockquote><p>阻塞队列(BlockingQueue)是一个支持两个附加操作的队列。这两个附加的操作支持阻塞的插入和移除方法。</p><ol><li><p>支持阻塞的插入方法：意思是当队列满时，队列会阻塞插入元素的线程，直到队列不满。</p></li><li><p>支持阻塞的移除方法：意思是在队列为空时，获取元素的线程会等待队列变为非空。 </p></li></ol></blockquote><h3 id="13-你了解哪些阻塞队列">13.你了解哪些阻塞队列</h3><blockquote><ul><li><p>ArrayBlockingQueue：一个由数组结构组成的有界阻塞队列。</p></li><li><p>LinkedBlockingQueue：一个由链表结构组成的阻塞队列。此队列创建时可以不指定容量大小，默认是Integer.MAX_VALUE，也就是无界的。但也可以指定队列大小，从而成为有界的。</p></li><li><p>PriorityBlockingQueue：一个支持优先级排序的无界阻塞队列。默认情况下元素采取自然顺序升序排列。也可以自定义类实现compareTo()方法来指定元素排序规则。</p></li><li><p>DelayQueue：一个使用优先级队列实现的无界阻塞队列。队列使用PriorityQueue来实现。队列中的元素必须实现Delayed接口，在创建元素时可以指定多久才能从队列中获取当前元素。只有在延迟期满时才能从队列中提取元素。（常用在缓存有效期，定时任务调度等场景）</p></li><li><p>SynchronousQueue：一个不存储元素的阻塞队列。每一个put操作必须等待一个take操作，否则不能继续添加元素。队列本身并不存储任何元素，非常适合传递性场景。</p></li><li><p>LinkedTransferQueue：一个由链表结构组成的单向无界阻塞队列。它设计了一种直接在生产者和消费者之间传输元素的机制，称为“transfer”。当生产者调用transfer(e)方法时，它会阻塞直到有一个消费者接收该元素。适用于需要高效地在生产者和消费者之间直接传输数据的场景，尤其是当生产者和消费者之间的速度大致匹配时。</p></li><li><p>LinkedBlockingDeque：一个由链表结构组成的双向阻塞队列。所谓双向队列指的是可以从队列的两端插入和移出元素。相比其他的阻塞队列，LinkedBlockingDeque多了addFirst、addLast、offerFirst、offerLast、peekFirst和peekLast等方法。双向阻塞队列可以运用在“工作窃取”模式中。 </p></li></ul></blockquote><h3 id="14-ArrayBlockingQueue和LinkedBlockingQueue有什么区别">14. ArrayBlockingQueue和LinkedBlockingQueue有什么区别?</h3><p><strong>参考回答</strong>：</p><blockquote><p>答：ArrayBlockingQueue和LinkedBlockingQueue是Java并发包中常用的两种阻塞队列实现，它们都是线程安全的。不过，它们之间也存在下面这些区别：</p><ul><li><p>底层实现：ArrayBlockingQueue基于数组实现，而LinkedBlockingQueue基于链表实现。</p></li><li><p>是否有界：ArrayBlockingQueue是有界队列，必须在创建时指定容量大小。LinkedBlockingQueue创建时可以不指定容量大小，默认是Integer.MAX_VALUE，也就是无界的。但也可以指定队列大小，从而成为有界的。</p></li><li><p>锁是否分离：ArrayBlockingQueue中的锁是没有分离的，即生产和消费用的是同一个锁；LinkedBlockingQueue中的锁是分离的，即生产用的是putLock，消费是takeLock，这样可以防止生产者和消费者线程之间的锁争夺。</p></li><li><p>内存占用：ArrayBlockingQueue需要提前分配数组内存，而LinkedBlockingQueue则是动态分配链表节点内存。这意味着，ArrayBlockingQueue在创建时就会占用一定的内存空间，且往往申请的内存比实际所用的内存更大，而LinkedBlockingQueue则是根据元素的增加而逐渐占用内存空间。 </p></li></ul></blockquote><h3 id="15-如果队列是空的，消费者会一直等待，当生产者添加元素时，消费者是如何知道当前队列有元素的呢">15. 如果队列是空的，消费者会一直等待，当生产者添加元素时，消费者是如何知道当前队列有元素的呢?</h3><p><strong>参考回答</strong>：</p><blockquote><p>答：使用通知模式实现。所谓通知模式，当消费者从空的队列获取元素时会阻塞住消费者，此时如果生产者放了一个元素进入队列，则需要通知阻塞住消费者当前有元素可取。同理当生产者往满的队列里添加元素时会阻塞住生产者，当消费者消费了一个队列中的元素后，会通知生产者当前队列可用。通过查看JDK源码发现部分阻塞队列使用了Condition来实现。 </p></blockquote><h3 id="16-CountDownLatch，CyclicBarrier，Semaphore，Exchanger了解吗">16. CountDownLatch，CyclicBarrier，Semaphore，Exchanger了解吗?</h3><blockquote><p><strong>参考回答</strong>：</p><ul><li><p>CountDownLatch：倒计数器。允许一个或多个线程等待其他线程完成操作。</p></li><li><p>CyclicBarrier的字面意思是可循环使用（Cyclic）的屏障（Barrier）。它要做的事情是，让一组线程到达一个屏障（也可以叫同步点）时被阻塞，直到最后一个线程到达屏障时，屏障才会开门，所有被屏障拦截的线程才会继续运行。</p></li><li><p>Semaphore（信号量）：是用来控制同时访问特定资源的线程数量，它通过协调各个线程，以保证合理的使用公共资源。</p></li><li><p>Exchanger（交换者）：是一个用于线程间协作的工具类。Exchanger用于进行线程间的数据交换。它提供一个同步点，在这个同步点，两个线程可以交换彼此的数据。 </p></li></ul></blockquote><h3 id="17-CyclicBarrier和CountDownLatch有什么区别">17. CyclicBarrier和CountDownLatch有什么区别?</h3><p><strong>参考回答</strong>：</p><blockquote><ol><li>CyclicBarrier是可重用的，其中的线程会等待所有的线程完成任务。届时，屏障将被拆除，并可以选择性地做一些特定的动作。</li></ol><p>CountDownLatch是一次性的，不同的线程在同一个计数器上工作，直到计数器为0.</p><ul><li>CyclicBarrier面向的是线程数；</li></ul><p>CountDownLatch面向的是任务数。</p><ul><li><p>在使用CyclicBarrier时，你必须在构造中指定参与协作的线程数，这些线程必须调用await()方法；使用CountDownLatch时，则必须要指定任务数，至于这些任务由哪些线程完成无关紧要。</p></li><li><p>CyclicBarrier可以在所有的线程释放后重新使用；CountDownLatch在计数器为0时不能再使用。 </p></li></ul></blockquote><h3 id="18-常见函数">18.常见函数</h3><blockquote><p>在 JUC（Java.util.concurrent）中，一些常用的函数及其作用如下：</p><ol><li><p><code>park()</code> 和 <code>unpark()</code>：</p><ul><li><p><code>park()</code>：用于阻塞当前线程。</p></li><li><p><code>unpark(Thread thread)</code>：用于唤醒指定的被 <code>park()</code> 阻塞的线程。</p></li></ul></li><li><p><code>wait()</code>、<code>notify()</code> 和 <code>notifyAll()</code>：</p><ul><li><p><code>wait()</code>：使当前线程等待，直到其他线程调用此对象的 <code>notify()</code> 方法或 <code>notifyAll()</code> 方法。</p></li><li><p><code>notify()</code>：唤醒在此对象监视器上等待的单个线程。</p></li><li><p><code>notifyAll()</code>：唤醒在此对象监视器上等待的所有线程。</p></li></ul></li><li><p><code>Thread.sleep(long millis)</code>：使当前正在执行的线程暂停指定的毫秒数。</p></li><li><p><code>CountDownLatch</code>：</p><ul><li><p><code>countDown()</code>：使计数器减 1。</p></li><li><p><code>await()</code>：等待计数器变为 0。</p></li></ul></li><li><p><code>CyclicBarrier</code>：</p><ul><li><code>await()</code>：等待所有线程都到达屏障点。</li></ul></li><li><p><code>Semaphore</code>：</p><ul><li><p><code>acquire()</code>：获取一个许可，如果没有可用许可则阻塞。</p></li><li><p><code>release()</code>：释放一个许可。</p></li></ul></li><li><p><code>Future</code> 和 <code>CompletableFuture</code>：用于处理异步任务的结果。</p></li></ol><p>这些函数和类为多线程编程提供了丰富的工具，帮助开发者更有效地管理线程的同步、协作和异步操作。 </p></blockquote>]]></content>
      
      
      <categories>
          
          <category> 面试题 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> JUC </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>MyBatis面试题</title>
      <link href="/posts/2025331p.html"/>
      <url>/posts/2025331p.html</url>
      
        <content type="html"><![CDATA[<h1>MyBatis</h1><h2 id="1-什么是MyBatis">1. 什么是MyBatis?</h2><p><img src="https://mcnfxurl5vzo.feishu.cn/space/api/box/stream/download/asynccode/?code=NWU3OGM0OWExNWVlYzY5MGJkNmNlZGU2NDZjN2YwODNfNXRjcUNzNWdDbEJBUDJINjhJejlxMEtEd1oyR3JHUmNfVG9rZW46Q1NmRGI0djBxb3BpVVd4cXROOGNuWXZ5blJiXzE3NDMzODkxNTM6MTc0MzM5Mjc1M19WNA" alt="img"></p><h2 id="2-Mybaits-的优点-缺点">2. Mybaits 的优点 &amp; 缺点</h2><p><img src="https://mcnfxurl5vzo.feishu.cn/space/api/box/stream/download/asynccode/?code=MzFlM2EzNDkzOWZiZjUxYmE4NWFkOTA2MzRjMjY3NDFfdEJMZm01TmFpZFY1b2xYUERoZmhsbWtKeW1uWWkweWFfVG9rZW46Q01wY2JnZnVab205b1N4THNvWGMyanB1bmZlXzE3NDMzODkxNTM6MTc0MzM5Mjc1M19WNA" alt="img"></p><h2 id="3-MyBatis的核心组件有哪些？">3. MyBatis的核心组件有哪些？</h2><p><img src="https://mcnfxurl5vzo.feishu.cn/space/api/box/stream/download/asynccode/?code=ODAyNjFhYTJiYjllODY2YjYxNWE4Yjk0ODZiNGU1N2FfbUVvUXkzNnlhbnc2VXlkMWloWVJ6ZHBvVlFvYWRXRWRfVG9rZW46QVRpTWJncGdUbzVKN2J4OThCSWNlMlM3bjJlXzE3NDMzODkxNTM6MTc0MzM5Mjc1M19WNA" alt="img"></p><h2 id="4-⭐️MyBatis的工作流程是怎样的？">4. ⭐️MyBatis的工作流程是怎样的？</h2><p><img src="https://mcnfxurl5vzo.feishu.cn/space/api/box/stream/download/asynccode/?code=NjM5ODc0MjhiYmQ1YTc4OTU1YWE4YzkzNGVkMzBmYjJfbW4zYlJ3S1N5WnFqdGFja3dHa3F3dHNMem96Q2U0U0dfVG9rZW46SDBWWmI5TDRGbzVTOTB4VlVPZmNweWxkbjZkXzE3NDMzODkxNTM6MTc0MzM5Mjc1M19WNA" alt="img"></p><h2 id="5-⭐️MyBatis一二级缓存的区别？">5. ⭐️MyBatis一二级缓存的区别？</h2><p><img src="https://mcnfxurl5vzo.feishu.cn/space/api/box/stream/download/asynccode/?code=OTEyZjBjN2MyYjE2OGRhNGQ2ZDY5NDg2ZTZmNTRhYWFfazJieW5sazBkN1I5T2IwbGZ1V2xLeHR3dHN3VHF3NTRfVG9rZW46TkZTb2JaeWNOb1JuN1p4NFBUQWNWalRQbjFkXzE3NDMzODkxNTM6MTc0MzM5Mjc1M19WNA" alt="img"></p><h2 id="6-MyBatis如何处理延迟加载？">6.MyBatis如何处理延迟加载？</h2><p><img src="https://mcnfxurl5vzo.feishu.cn/space/api/box/stream/download/asynccode/?code=NTk4ZGZkYWE4YTdlYjdhZjhkNDFiZmEyN2ViNjgxMTNfdTZ3bWEzZWY2N2ZtZEI2RG8yWWdzdk5Jekl1OXRVWHZfVG9rZW46RzQ2QmJJWFUwb1Q4emx4WHJmSmM2N2hTbmllXzE3NDMzODkxNTM6MTc0MzM5Mjc1M19WNA" alt="img"></p><h2 id="7-⭐️MyBatis中的动态SQL是什么？">7. ⭐️MyBatis中的动态SQL是什么？</h2><p><img src="https://mcnfxurl5vzo.feishu.cn/space/api/box/stream/download/asynccode/?code=N2Y1NGUzY2I5ZTYxZDMwNTEzMTdkOTQ3MmY1MjJhMzJfc2E1QmlhY004SkNpRjZrdHE3MU5QcFFGSkZvZkpKcnhfVG9rZW46QVdDUGIxamR4b0xkNjN4NEJiRmNDaUZTblliXzE3NDMzODkxNTM6MTc0MzM5Mjc1M19WNA" alt="img"></p><p><img src="https://mcnfxurl5vzo.feishu.cn/space/api/box/stream/download/asynccode/?code=NjUwODViOWZjYWEzNjRlZmUzMTY1YzVhMmE5MDhiNjdfanpSM3N0VWZqaGpzQWZMU1hnSmZQdTNFUnYzVGFQTXhfVG9rZW46S2dzN2JZQ3ZIb0hCQUV4VDdiUGNBdUpKblRkXzE3NDMzODkxNTM6MTc0MzM5Mjc1M19WNA" alt="img"></p><h2 id="8-⭐️MyBatis中XML映射有哪些标签？">8. ⭐️MyBatis中XML映射有哪些标签？</h2><p><img src="https://mcnfxurl5vzo.feishu.cn/space/api/box/stream/download/asynccode/?code=Njk0ZTQzYWVlZDk4MTM5MGQwMWY2MmZmMmRiMjdiNTdfOUdQTFZQYTV1ZWliMHRpVVJ6emJwRlRnWndDOE5YZXZfVG9rZW46QlZWV2JTWFNLbzY0elB4OTlUbmNJZkF0bkdoXzE3NDMzODkxNTM6MTc0MzM5Mjc1M19WNA" alt="img"></p><h2 id="9-模糊查询-like-语句该怎么写？">9. 模糊查询 like 语句该怎么写？</h2><p><img src="https://mcnfxurl5vzo.feishu.cn/space/api/box/stream/download/asynccode/?code=YjM1ODcxZGY3YjEyMmYyMWQyZjNjOGM2ODgxM2Y2ZjdfVzA0SWQxeXpIbVBvMXZWbHFtdHp4NlVFaG5oM01pYkpfVG9rZW46SElUb2J3NkV4bzVFSFJ4NkFFTGNRdWlXbk9iXzE3NDMzODkxNTM6MTc0MzM5Mjc1M19WNA" alt="img"></p><h2 id="10-⭐️-和-的区别是什么？">10. ⭐️#{}和${}的区别是什么？</h2><p><img src="https://mcnfxurl5vzo.feishu.cn/space/api/box/stream/download/asynccode/?code=M2I2MmNlZmJmZTdjMmVkMTlmZmI2ZGU1N2NkNjc5ZGZfdWY5WnI3UmI0dXlrdmZtVkJXdzFRWmE2N1BIS05jakJfVG9rZW46UThwbGJMUXBwb3c3UWd4SlZubGNwak1ablNnXzE3NDMzODkxNTM6MTc0MzM5Mjc1M19WNA" alt="img"></p><p><img src="https://mcnfxurl5vzo.feishu.cn/space/api/box/stream/download/asynccode/?code=ODU3ZDNjNzAxZmUyYzBmM2U1MzcxMjdiMTE0YmZkNjhfcTFUcnlDQWdybWgyNXpoYVN1VXA1TmdHWEhwSlhSN2JfVG9rZW46THZVcmI4c3ppb2RyZVV4aXNYNGNwdkdlbmlnXzE3NDMzODkxNTM6MTc0MzM5Mjc1M19WNA" alt="img"></p><h2 id="11-讲讲MyBatis中二级缓存的缺点？">11. 讲讲MyBatis中二级缓存的缺点？</h2><p><img src="https://mcnfxurl5vzo.feishu.cn/space/api/box/stream/download/asynccode/?code=OGFiYjFhMTU0NzQ5MmZjYzlmZGFiYmMwZGJkMTBjZWFfbzVwWjFDaWlPYzdnNHJ4U05NWnlKc1JlMm1CN2VzRzVfVG9rZW46VEJWZmJKQ1pHbzRBTzJ4ZkNaVWN0bWw5bnRlXzE3NDMzODkxNTM6MTc0MzM5Mjc1M19WNA" alt="img"></p><h2 id="12-为什么说-Mybatis-是半ORM-映射工具？">12. 为什么说 Mybatis 是半ORM 映射工具？</h2><p><img src="https://mcnfxurl5vzo.feishu.cn/space/api/box/stream/download/asynccode/?code=Yjc0YWMzM2MzZjA3ODE0MTU3ODY2YzY1ZjQzMGRiMTBfV2I0NkJpN1g2ZTRhWXNhNnJDZjlEOHhIYXZzMGtkYTBfVG9rZW46UENyOGJlUTBvb2cwNkN4WWNCVWNLUEVKbmxiXzE3NDMzODkxNTM6MTc0MzM5Mjc1M19WNA" alt="img"></p><h2 id="13-⭐️如何在-MyBatis-中进行分页查询？">13. ⭐️如何在 MyBatis 中进行分页查询？</h2><p><img src="https://mcnfxurl5vzo.feishu.cn/space/api/box/stream/download/asynccode/?code=NjFlYzc3Zjc0MzJjODFkYWNjYjRmYTg1ZjIzZGQxZTFfakZCc0ZrNWdUR0Y0SlROMnJKZHJiZzZWdkRHMjFYUVlfVG9rZW46QWpGOGIyeGVmb3V0WlV4Nkxib2NHVTA5bmxlXzE3NDMzODkxNTM6MTc0MzM5Mjc1M19WNA" alt="img"></p><p><img src="https://mcnfxurl5vzo.feishu.cn/space/api/box/stream/download/asynccode/?code=YTJjZGQwZjc1M2U3YmYyN2ZkOWI3OTc2MjgxYWNjOTNfZXZNcm1GR0I3WllWRVJweDJjVVBJbWN0cG5LREk0YTFfVG9rZW46TGxyOGJvVmozb2F6STh4MWtIS2NhRlhYbmdoXzE3NDMzODkxNTM6MTc0MzM5Mjc1M19WNA" alt="img"></p><h2 id="14-Mybatis和Hibernate的区别是什么？">14. Mybatis和Hibernate的区别是什么？</h2><p><img src="https://mcnfxurl5vzo.feishu.cn/space/api/box/stream/download/asynccode/?code=ZmM0N2E5YjUxZGQ0YzI3MTM4YzFiNWY0MmVmYzgzYjJfcVBXSlhhSmFCMXhKTjRQUlV6UzNmb3FnbDVIMWpNNXZfVG9rZW46RjVRNGJJY0xyb0Z6cEN4aEpGR2NNeW85bkJjXzE3NDMzODkxNTM6MTc0MzM5Mjc1M19WNA" alt="img"></p><h2 id="15-JDBC编程有哪些不足之处，MyBatis是如何解决这些问题的？">15. JDBC编程有哪些不足之处，MyBatis是如何解决这些问题的？</h2><p><img src="https://mcnfxurl5vzo.feishu.cn/space/api/box/stream/download/asynccode/?code=ZjE1MTExMzkzODVjYzdhMTk5MGI0Mjc2MWNlMDMyZGNfNzlJV2NCd1dZUURwYW9ZU0ZobWxBcGlYb3BjeThieDFfVG9rZW46VzNrMmJXMlB2b3NrMzl4ZUk0OWNkUW1hbkFkXzE3NDMzODkxNTM6MTc0MzM5Mjc1M19WNA" alt="img"></p><h2 id="16-MyBatis编程步骤是什么样的？">16. MyBatis编程步骤是什么样的？</h2><p><img src="https://mcnfxurl5vzo.feishu.cn/space/api/box/stream/download/asynccode/?code=ZTNjNTVkMTdiMTljZTg4MGNiZTc4M2ZjMTIxZWZlYzVfOHVubEdxQnVMczYwbnVhNk9weEU4YXdoaWtEZVRKV2FfVG9rZW46TXA1bmJSbDZ3b0pCN3p4RTNoQ2M5b2JXbnFmXzE3NDMzODkxNTM6MTc0MzM5Mjc1M19WNA" alt="img"></p><h2 id="17-Mybatis如何防止SQL注入？">17. Mybatis如何防止SQL注入？</h2><p><img src="https://mcnfxurl5vzo.feishu.cn/space/api/box/stream/download/asynccode/?code=N2M0YjlkODM0MWNhYTNiZDMzNzg4ZmUwMTE0NzI3ZWZfbUJXMWtUZkh0elRTNmdNenVNbEU2OURObVNXbjM1OE9fVG9rZW46SlcyOWJSNjVlb0hDZHR4dW14VGM3UGhObk5nXzE3NDMzODkxNTM6MTc0MzM5Mjc1M19WNA" alt="img"></p><h2 id="⭐️18-Xml-映射文件中，除了常见的-select，insert，upcaeldelete-标签之外，还有哪些标签？">⭐️18.Xml 映射文件中，除了常见的 select，insert，upcaeldelete 标签之外，还有哪些标签？</h2><p><img src="https://mcnfxurl5vzo.feishu.cn/space/api/box/stream/download/asynccode/?code=MDk5MTM5NzUwYzUyMDYwNTk0ODVjOWRmOWZmM2RlMDhfZ0gxRUJocG9EUjhtbkx0N0g2OGg5RmFSQ2dOU2E1dUxfVG9rZW46RFEwa2JZTmpBbzRjRzJ4bUx1UmN4Z2xFblBnXzE3NDMzODkxNTM6MTc0MzM5Mjc1M19WNA" alt="img"></p><p><img src="https://mcnfxurl5vzo.feishu.cn/space/api/box/stream/download/asynccode/?code=Yjk0ZGRiMjQxNzc4MDVmMDQ4NmQ2YThiNTZhMWZjMzRfaUxMaUlmUHFxSjE0RXdJb1VCYzRNaWFON2NEVURQNm9fVG9rZW46VW8ybWJkWDJ2b2JnblZ4MEw5c2NxN0lJblBlXzE3NDMzODkxNTM6MTc0MzM5Mjc1M19WNA" alt="img"></p><p><img src="https://mcnfxurl5vzo.feishu.cn/space/api/box/stream/download/asynccode/?code=ZDg5YTUwZmI1ZmZiZjliN2RhMmQ5MGE0MzcyNjNjOWVfYndDWlJaa2JmNG1Kb3pWQU8yWVA5RXlUZ3N5Q2dCeWlfVG9rZW46Vm4zZGJpeHE1b20wd214TVpBY2NPcFU3bkhmXzE3NDMzODkxNTM6MTc0MzM5Mjc1M19WNA" alt="img"></p><p><img src="https://mcnfxurl5vzo.feishu.cn/space/api/box/stream/download/asynccode/?code=OWQzMmQyNzczNzgwNTA3YmFmODlhYWY4MjQ4NzM0NDRfc2lBaWg5OFUwTE0zdnUyaXFDbmFxdHJSZHdlTVBYTnBfVG9rZW46RVVEeGI3QU93bzZ1ZG94N29PS2NzZVZRbjlnXzE3NDMzODkxNTM6MTc0MzM5Mjc1M19WNA" alt="img"></p><h2 id="19-Mybatis都有哪些Executor执行器？它们之间的区别是什么？">19. Mybatis都有哪些Executor执行器？它们之间的区别是什么？</h2><p><img src="https://mcnfxurl5vzo.feishu.cn/space/api/box/stream/download/asynccode/?code=MWRhODk3MTMzZjZlNjEyN2I4OGI1MWMxM2ExN2QzNGZfMVdGOXZQdFJUVnVFVnJlaUpxVGR5aTN5MU1lNGx5d1VfVG9rZW46QU96MWJYd3Rvb0xGelJ4MndMdmNFQzEwbnVnXzE3NDMzODkxNTM6MTc0MzM5Mjc1M19WNA" alt="img"></p><p><img src="https://mcnfxurl5vzo.feishu.cn/space/api/box/stream/download/asynccode/?code=YWFjZjQzYzZiY2MwZWY0Mjk3YjQxMDJmMDUwZGVhMmJfRDBFdHFNVElkbTNGQUZXUHAwUDdjNlloOWxjeTVQUTFfVG9rZW46STdoWGJ1NzRqb2ZCa0F4WlJ0ZGNFRDFibkhTXzE3NDMzODkxNTM6MTc0MzM5Mjc1M19WNA" alt="img"></p><h2 id="20-⭐️MyBatis-工作原理是什么？">20. ⭐️MyBatis 工作原理是什么？</h2><p><img src="https://mcnfxurl5vzo.feishu.cn/space/api/box/stream/download/asynccode/?code=OTc4MzE0ZjAyZGU0ZTUwODg0OWVlOTc2N2Q1YTQxNGNfdDRnY1RZdkZ0MldsMUgzQThWVTBmMFpkNGZQZGQxYWZfVG9rZW46UUtTRmJEbHEzb1BBSkp4ZGNGSGNrbndybktnXzE3NDMzODkxNTM6MTc0MzM5Mjc1M19WNA" alt="img"></p><p><img src="https://mcnfxurl5vzo.feishu.cn/space/api/box/stream/download/asynccode/?code=MTZhOWY1YzJlMzBhYjJlZjg1OWI2MjVkMjNkMDBkM2ZfbXpoMmYwdXZTV3BSWXd6ZTBWV1pDUGNSMmVaczBPQVhfVG9rZW46Q2tKd2JwVmg2b1Y1MUV4R0lPM2NGQTdXblAyXzE3NDMzODkxNTM6MTc0MzM5Mjc1M19WNA" alt="img"></p><h2 id="21-⭐️Mybatis-能执行一对一、一对多的关联查询吗？">21. ⭐️Mybatis 能执行一对一、一对多的关联查询吗？</h2><p><img src="https://mcnfxurl5vzo.feishu.cn/space/api/box/stream/download/asynccode/?code=NmQ1NjI3ZDgzMDgwMzRjZDY2YmM4NjcwZWM5ZjQ3MDFfQkFQQlQ5bTEwdk95VVFPb053cDNhbXBqcmJyZENFRjVfVG9rZW46Q3J2cmI4cU9Ub2ZMa0x4cFZZdWNzWVBBbjVjXzE3NDMzODkxNTM6MTc0MzM5Mjc1M19WNA" alt="img"></p><p><img src="https://mcnfxurl5vzo.feishu.cn/space/api/box/stream/download/asynccode/?code=NWQ0NzU3YWQwODVhNjc5MDhiOTNjOGQxZjg3OGM3MmRfd04zUE5HVXJ4Q01ZOGlSektjUEdkZUZpWXRXSnl1VE5fVG9rZW46TEM1YmJqRnJJb01YVVZ4Y0ZyQ2Naajh0bkRkXzE3NDMzODkxNTM6MTc0MzM5Mjc1M19WNA" alt="img"></p><h2 id="22-⭐️-Mybatis-是否支持延迟加载？原理？">22.⭐️ Mybatis 是否支持延迟加载？原理？</h2><p><img src="https://mcnfxurl5vzo.feishu.cn/space/api/box/stream/download/asynccode/?code=OTdmNTRiMDY0M2Q3Mjc2NjM2ZjI1OTI0Y2E3OGFiYzlfN2Q2NGw5R3l0Rk9VRWRjRVU1c0c5bnR4TjBxY3pRTWpfVG9rZW46VG1INWJrVFU1b3BJRUJ4OU1lYmNNQmFwbkJhXzE3NDMzODkxNTM6MTc0MzM5Mjc1M19WNA" alt="img"></p><h2 id="23-⭐️什么是MyBatis的接口绑定？有哪些实现方式？">23. ⭐️什么是MyBatis的接口绑定？有哪些实现方式？</h2><p><img src="https://mcnfxurl5vzo.feishu.cn/space/api/box/stream/download/asynccode/?code=OWZmNzdkZjU4NjIzYzQ4MGJiNGJhZjRjYjdhYjNiMDNfOExrZm5ueWZMVVJvYnlNSTh4eG5xbng2S0RKODZuT0RfVG9rZW46TENjUGJWeWM2b3g1VVh4U1ZYYmNVelJxbkdjXzE3NDMzODkxNTM6MTc0MzM5Mjc1M19WNA" alt="img"></p><h2 id="24-⭐️Mybatis是如何将sql执行结果封装为目标对象并返回的？都有哪些映射形式？">24. ⭐️Mybatis是如何将sql执行结果封装为目标对象并返回的？都有哪些映射形式？</h2><p><img src="https://mcnfxurl5vzo.feishu.cn/space/api/box/stream/download/asynccode/?code=OTY5ZjA2MmUxMGM2MjYwYjg1ODRhMjEyOTVlMzA4Y2NfU2N0ZW1VdURUMjlNTXBrZ3Q0ajRnZEpKdkM2MXFWMlZfVG9rZW46RDVxcGJuNXZGb1huYU94TEtuTWNJYnlUbmhoXzE3NDMzODkxNTM6MTc0MzM5Mjc1M19WNA" alt="img"></p><h2 id="25-⭐️-Mybatis的Xml映射文件中，不同的Xml映射文件，id是否可以重复？">25.⭐️ Mybatis的Xml映射文件中，不同的Xml映射文件，id是否可以重复？</h2><p><img src="https://mcnfxurl5vzo.feishu.cn/space/api/box/stream/download/asynccode/?code=YzkwNjllNWE2ODE5MzIyMzU5NGMxNDgzOGU1NGI3YjRfR2dIdnoyUlZJTE9OVHJzc2IzeXlqOWdBT29SRkVPR05fVG9rZW46TTJoc2JJeEYxbzdDd0J4TEF2OWM0RTUzbkFiXzE3NDMzODkxNTM6MTc0MzM5Mjc1M19WNA" alt="img"></p><h2 id="26-⭐️MyBatis-如何执行批量操作？">26. ⭐️MyBatis 如何执行批量操作？</h2><p><img src="https://mcnfxurl5vzo.feishu.cn/space/api/box/stream/download/asynccode/?code=NTE0MTEyMGRmNmU3M2JiMDM1NTk2MmEwYzFhN2YzMGZfYlBMdVlyZkg4VnczMUpOVTNrbFlWdXlXYTk5TWVTcnpfVG9rZW46QjlMZGJWeDNZb2doMFl4Tk9RS2NLMDB5bklkXzE3NDMzODkxNTM6MTc0MzM5Mjc1M19WNA" alt="img"></p><p><img src="https://mcnfxurl5vzo.feishu.cn/space/api/box/stream/download/asynccode/?code=MzY2YWM1NjM0ODQ3YTkyYTgxYmM0MmY2ZmY4ZjdiNGJfd291dU9GN1RySjBpc2lwcGVkVnlCUzkwN0gzbno5ZURfVG9rZW46WHNtaGJDTjRCb1RkeU14QUpDeGNJTDRsbk5jXzE3NDMzODkxNTM6MTc0MzM5Mjc1M19WNA" alt="img"></p><p><img src="https://mcnfxurl5vzo.feishu.cn/space/api/box/stream/download/asynccode/?code=ZmYyMzIzMzU4M2ZkMzc0MTIzMTY2Yjk5Njg0ZWM2MTlfTlFocTM3amNkU2x2bVR0d0dBU0U5YTdwZjVvWW9nRG5fVG9rZW46SHhNcGIxUlhMb2dEa094aGszVWNnaDh3bmFmXzE3NDMzODkxNTM6MTc0MzM5Mjc1M19WNA" alt="img"></p><p><img src="https://mcnfxurl5vzo.feishu.cn/space/api/box/stream/download/asynccode/?code=MGQ5YWZlODVmNTgzZWQyNWVjMzliZDVkMmQwYzFhMTdfR2xGVWZXM1pMUnpMSXBxS1VXaDZHRDdKaGR1b3JiY29fVG9rZW46QW5TTGJKa1JOb2I4T0N4amZ0NGNoeWR5bkdlXzE3NDMzODkxNTM6MTc0MzM5Mjc1M19WNA" alt="img"></p><h2 id="27-⭐️在mapper-中如何传递多个参数？">27. ⭐️在mapper 中如何传递多个参数？</h2><p><img src="https://mcnfxurl5vzo.feishu.cn/space/api/box/stream/download/asynccode/?code=YTFkOTA0ZTc5ZTNiOTkwZTgxZjA4MjMzMzI0MzBiYjhfYUp2V0syblJjWjNiTWFSbElkUVJJTlpHbk9rNXdhOXBfVG9rZW46RVlUTmJQSlpFb2NjWWh4emNNM2NFNE5LbnBoXzE3NDMzODkxNTM6MTc0MzM5Mjc1M19WNA" alt="img"></p><p><img src="https://mcnfxurl5vzo.feishu.cn/space/api/box/stream/download/asynccode/?code=M2M4MDcwNjY4ZGMxYTA5ZGQyMTgxMTllMzZiY2ZjNjhfQ3NUcG5OYXZ5V1RyMXpEVnRPdVNJZzhWR1kzN0V1MUlfVG9rZW46VDlRc2JrRGF2b1NxQTF4UWdtOGNuSWZvbm5tXzE3NDMzODkxNTM6MTc0MzM5Mjc1M19WNA" alt="img"></p><p><img src="https://mcnfxurl5vzo.feishu.cn/space/api/box/stream/download/asynccode/?code=MzcwYzJjODg2ZTZiZjljY2YxNWUxMDkyOThhNDlmZWRfNEQ2eVpqSnBHYkZHdXZsMWJwZ3lQWU5kSURzd3BZaGdfVG9rZW46Skk4NmI4Z2tab2xQZXR4NlFSZmM0MzYzbnhoXzE3NDMzODkxNTM6MTc0MzM5Mjc1M19WNA" alt="img"></p><h2 id="28-⭐️简述Mybatis的插件运行原理，以及如何编写一个插件？">28. ⭐️简述Mybatis的插件运行原理，以及如何编写一个插件？</h2><p><img src="https://mcnfxurl5vzo.feishu.cn/space/api/box/stream/download/asynccode/?code=MDJjYmFlNjE1NzdiNTg2ZWYxZWY4NzBkZWIxY2I0NzdfQ3lJVFdzZXdmdjFRRjhaalo1UDFKZ1ViR085dmxKbXRfVG9rZW46RVN2UWJrTVdyb2xCdGt4Rnl0OWNhZTRrbkplXzE3NDMzODkxNTM6MTc0MzM5Mjc1M19WNA" alt="img"></p><h2 id="29-⭐️分页插件的原理是什么？">29. ⭐️分页插件的原理是什么？</h2><p><img src="https://mcnfxurl5vzo.feishu.cn/space/api/box/stream/download/asynccode/?code=ZWQxMjJlZDAzZjA3OWY1NGU0NGE1NWQ4M2E4MzMwMGVfeE94Z2NSbmY0MzNFTjZZUFlUQmk1ZTJnV0xBQXhIcURfVG9rZW46UGYwZ2JCOEFFb2NJeTR4M3I1RmM4WW9IbmdMXzE3NDMzODkxNTM6MTc0MzM5Mjc1M19WNA" alt="img"></p>]]></content>
      
      
      <categories>
          
          <category> 面试题 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> MyBatis </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Rabbitmq面试题</title>
      <link href="/posts/2025331m.html"/>
      <url>/posts/2025331m.html</url>
      
        <content type="html"><![CDATA[<h1>PS:</h1><p><strong>面试题总结自小林Coding，仅供个人学习使用，如有侵权可联系删除</strong></p><h1>概念：</h1><h2 id="1-AMQP协议？">1. AMQP协议？</h2><p>AMQP，即Advanced Message Queuing Protocol，高级消息队列协议，是应用层协议的开放标准，为面向消息的中间件设计。消息中间件用于组件解耦，发送者和使用者相互无感知。其主要特征包括面向消息、队列、路由、可靠性、安全性。RabbitMQ是开源的AMQP实现，服务器端用Erlang编写，支持多种客户端，用于分布式系统存储转发消息，在易用性等方面表现好。</p><p><strong>AMQP****三层协议</strong></p><ul><li><strong>Module Layer</strong>：最高层，定义客户端调用命令，用于实现业务逻辑。</li><li><strong>Session Layer</strong>：中间层，负责客户端命令与服务器应答传输，提供可靠性同步和错误处理。</li><li><strong>Transport Layer</strong>：最底层，传输二进制数据流，提供帧处理等功能。</li></ul><p><strong>AMQP****组件</strong></p><ul><li><strong>交换器</strong>**(Exchange)**：将消息路由到队列的组件。</li><li><strong>队列 (queue)</strong>：存储消息的数据结构，位于硬盘或内存。</li><li><strong>绑定 (Binding)</strong>：告知交换器消息投递队列的规则。</li></ul><h2 id="2-RabbitMQ包含哪些要素？">2. RabbitMQ包含哪些要素？</h2><ul><li>生产者：消息队列创建者，发送消息到 MQ。</li><li>消费者：连接到 RabbitMQ，订阅到队列上，消费消息，支持持续订阅和单条订阅。</li><li>消息：包含有效载荷和标签，有效载荷指要传输的数据，标签描述有效载荷，RabbitMQ 用它决定谁获得消息，消费者只能拿到有效载荷，不知道生产者是谁。</li></ul><h2 id="3-RabbitMQ中消息可能有的几种状态？">3. RabbitMQ中消息可能有的几种状态？</h2><ul><li>alpha：消息内容（包括消息体、属性和 headers）和消息索引都存储在内存。</li><li>beta：消息内容保存在磁盘中，消息索引保存在内存中。</li><li>gamma：消息内容保存在磁盘中，消息索引在磁盘和内存中都有。</li><li>delta：消息内容和索引都在磁盘中。</li></ul><h2 id="4-发送消息的过程？">4. 发送消息的过程？</h2><ul><li>生产者将消息发布到一个或多个交换器（Exchange）中。交换器根据路由键（Routing Key）将消息分配给特定的队列（Queue）。</li><li>交换器通过路由键将消息路由到一个或多个队列。若路由键为空，消息会被分配给所有绑定到该交换器的队列。</li><li>消息进入队列，等待被消费者接收。在队列中，消息会被存储在持久化存储中，以防服务器崩溃或重启时数据丢失。</li><li>消费者从队列中获取消息并处理。消费者可通过订阅一个或多个队列来接收消息。一旦消息被消费者接收，它将从队列中移除。</li></ul><h2 id="5-为什么要使用RabbitMQ？">5. 为什么要使用RabbitMQ？</h2><ul><li>在分布式系统下具备异步、削峰、负载均衡等一系列高级功能。</li><li>拥有持久化的机制，进程消息、队列中的信息也可以保存下来。</li><li>实现消费者和生产者之间的解耦。</li><li>对于高并发场景下，利用消息队列可以使得同步访问变为串行访问达到一定量的限流，利于数据库的操作。</li><li>可以使用消息队列达到异步下单的效果，排队中，后台进行逻辑下单。</li></ul><h2 id="6-Kafka、-ActiveMQ、-RabbitMQ、-RocketMQ有什么优缺点？">6. Kafka、 ActiveMQ、 RabbitMQ、 RocketMQ有什么优缺点？</h2><p>一般的业务系统要引入 MQ，最早大家都用 ActiveMQ，但是现在确实大家用的不多了，没经过大规模吞吐量场景的验证，社区也不是很活跃，所以大家还是算了吧，我个人不推荐用这个了；</p><p>后来大家开始用 RabbitMQ，但是确实 erlang 语言阻止了大量的 Java 工程师去深入研究和掌控它，对公司而言，几乎处于不可控的状态，但是确实人家是开源的，比较稳定的支持，活跃度也高；</p><p>不过现在确实越来越多的公司会去用 RocketMQ，确实很不错，毕竟是阿里出品，但社区可能有突然黄掉的风险（目前 RocketMQ 已捐给，但 GitHub 上的活跃度其实不算高）对自己公司技术实力有绝对自信的，推荐用 RocketMQ，否则回去老老实实使用 RabbitMQ 吧，人家有活跃的开源社区，绝对不会黄；</p><p>所以中小型公司，技术实力较为一般，技术挑战不是特别高，用 RabbitMQ 是不错的选择；大型公司，基础架构研发实力较强，用 RocketMQ 是很好的选择；大数据领域的实时计算、日志采集等场景，使用 Kafka。</p><h1>应用：</h1><h2 id="1-如何确保消息正确地发送至RabbitMQ？如何确保消息接收方消费了消息？">1. 如何确保消息正确地发送至RabbitMQ？如何确保消息接收方消费了消息？</h2><ul><li><strong>消息确认机制(<strong><strong>生产者确认</strong></strong>)</strong>：生产者在发送消息后，可通过消息确认机制（Confirm）确保消息正确发送至RabbitMQ。消息确认机制分为批量确认和单个确认两种方式，生产者可根据自身业务场景选择合适的方式。</li><li><strong>消息持久化</strong>：通过将消息设置为持久化的方式，可确保消息不会丢失。在RabbitMQ中，可将Exchange、Queue和Message都标记为持久化。在发送消息时，可以将消息的delivery - mode设置为2，表示消息需要持久化。</li><li><strong>连接超时设置（<strong><strong>生产者重连</strong></strong>）</strong>：在发送消息时，可通过设置连接超时时间，当超过指定时间后仍未收到发送消息响应，可以通过重发等方式确保消息正确地发送至RabbitMQ。</li><li><strong>消息<strong><strong>序列化</strong></strong>和反序列化</strong>：在发送和接收消息时，需要将消息对象序列化为二进制数据，再在接收方反序列化为对象类型。因此，需要确保消息的序列化和反序列化过程正确无误，可以采用JSON、Protobuf等常用的序列化框架。</li></ul><h2 id="2-如何回答消息队列的丢失、重复与积压问题">2. <strong>如何回答<strong><strong>消息队列</strong></strong>的丢失、重复与积压问题</strong></h2><p>[08 MQ:如何回答消息队列的丢失、重复与积压问题](<a href="https://learn.lianglianglee.com/%E4%B8%93%E6%A0%8F/%E6%9E%B6%E6%9E%84%E8%AE%BE%E8%AE%A1%E9%9D%A2%E8%AF%95%E7%B2%BE%E8%AE%B2/08">https://learn.lianglianglee.com/专栏/架构设计面试精讲/08</a>  MQ：如何回答消息队列的丢失、<a href="http://xn--jhqr7k26ed03b16ylgfo6e.md">重复与积压问题.md</a>)</p><ul><li><strong>消息确认机制</strong>：消费者处理消息后，向RabbitMQ发送消息确认（ACK），告知消息已正确处理。若未发送，RabbitMQ会将消息重新投到队列，造成重复消费。</li><li><strong>消息去重机制</strong>：可在应用程序中实现，比如用分布式缓存、数据库等存储系统记录已处理消息标识，下次处理时判断，若已处理则忽略，避免重复处理。</li><li><strong>消息幂等性处理（业务处理）</strong>：将消费者处理逻辑设计为幂等操作，即重复执行多次效果相同，防止因消息重复消费致业务数据错误。</li><li><strong>设置消息过期时间</strong>：发送消息时设置过期时间，过期后不再投递给消费者，避免重复消费。</li><li><strong>使用消息唯一标识符</strong>：在消息中添加如UUID这样的唯一标识符，保证每条消息有独一无二标识，避免重复消费和重复投递。</li></ul><h2 id="3-如何保证消息持久化？">3. 如何保证消息持久化？</h2><ul><li><strong>消息的<strong><strong>delivery - mode</strong></strong>设置为2</strong>：在发送消息时，可以将消息的delivery - mode属性设置为2，表示消息需要被持久化。持久化的消息将会被写入磁盘，即使RabbitMQ重启或者崩溃，消息也仍然可以保留。</li><li><strong>队列的durable属性设置为true</strong>：在创建队列时，可以将队列的durable属性设置为true，表示队列是持久性的。持久化的队列将会在RabbitMQ重启或者崩溃后得到保留。</li><li><strong>将<strong><strong>交换器</strong></strong>的durable属性设置为true</strong>：在创建交换器时，可以将交换器的durable属性设置为true，表示交换器是持久性的。持久化的交换器将会在RabbitMQ重启或者崩溃后得到保留。</li><li><strong>使用事务机制</strong>：在发送消息时，可以使用事务机制来确保消息的持久性。通过开启事务，发送者可以将消息发送到RabbitMQ，然后等待RabbitMQ的确认，确认后再提交事务。使用事务机制可以确保消息的可靠性，但是会影响系统的性能。</li></ul><h2 id="4-消息如何路由？">4. 消息如何路由？</h2><p>消息的路由过程通过交换器（Exchange）实现。当消息被发送到 RabbitMQ 时，生产者将消息发布到交换器中，然后依据交换器的类型和绑定规则将消息路由到一个或多个队列中。</p><p>消息路由的基本流程如下：</p><ul><li>生产者将消息发送到指定的交换器中。</li><li>交换器根据路由键（Routing Key）和绑定键（Binding Key）将消息发送到一个或多个队列中。路由键和绑定键可以是任意字符串，根据交换器的类型和绑定规则进行匹配。</li><li>若交换器类型为 direct，会根据路由键进行精确匹配，将消息发送到所有匹配的队列中。</li><li>若交换器类型为 fanout，会将消息发送到所有绑定到该交换器的队列中。</li><li>若交换器类型为 topic，会根据通配符匹配规则将消息发送到匹配的队列中。例如，路由键为 “foo.bar” 的消息可以匹配绑定键为 “*.bar” 或 “foo.#” 的队列。</li><li>若交换器类型为 headers，会根据消息的属性（headers）进行匹配，将消息发送到匹配的队列中。</li><li>如果没有匹配的队列，消息将被丢弃或返回给生产者，根据生产者的配置。</li></ul><p>需注意，交换器和队列都需要进行绑定，否则消息将无法路由到队列中。另外，可根据需要在交换器和队列中配置各种属性，例如持久化、自动删除等，以满足不同的业务需求。</p><h2 id="5．⭐️RabbitMQ的消息确认过程？">5．⭐️RabbitMQ的消息确认过程？</h2><p><strong>消费者确认机制：</strong></p><p>为确认消费者是否成功处理消息，RabbitMQ 提供了消费者确认机制（Consumer Acknowledgement）。当消费者处理消息结束后，应向 RabbitMQ 发送一个回执，告知 RabbitMQ 自己的处理状态。回执有三种可选值：</p><ul><li>ack：成功处理消息，RabbitMQ 从队列中删除该消息。</li><li>nack：消息处理失败，RabbitMQ 需要再次投递消息。</li><li>reject：消息处理失败并拒绝该消息，RabbitMQ 从队列中删除该消息。</li></ul><p><img src="https://mcnfxurl5vzo.feishu.cn/space/api/box/stream/download/asynccode/?code=NzU2YmM3YmFkYTU4MGY3OThiZjVkNDkxMDkzNjNkYjlfZEtDMkh2N0FYbENvR2xEVm4wMnZJTjRWVWFKRElrYzlfVG9rZW46SUZQVWJLOUV4b3RmRVF4MWhPRWNHOEs3bmRkXzE3NDMzODg3ODE6MTc0MzM5MjM4MV9WNA" alt="img"></p><p>RabbitMQ的消息确认机制是指消费者在消费一条消息后，向RabbitMQ发送确认消息（ACK）的过程，以此告知RabbitMQ消息已被正确处理。<strong>该机制的作用是确保RabbitMQ能正确地将消息从队列中删除，避免重复投递和重复消费。</strong></p><p>消息确认机制的过程如下：</p><ul><li>消费者从RabbitMQ中获取消息并处理。</li><li>处理完成后，向RabbitMQ发送确认消息（ACK）。确认消息通常是一个简单的AMQP基本确认帧，带有消息的标识符（delivery tag）和是否批量确认的标记。</li><li>RabbitMQ收到确认消息后，将该消息从队列中删除。</li><li>如果消费者在一定时间内没有发送确认消息，RabbitMQ会认为消息未被正确处理，将会重新将消息投递到队列中，等待下一次消费。</li></ul><p>需要注意的是，在某些情况下，消费者可能无法正确处理消息，比如消费者崩溃或出现异常等。为避免这种情况导致消息丢失，<strong>RabbitMQ还提供了Nack</strong>（Negative Acknowledge）和Reject机制，可将消息标记为无法处理或无法路由的状态，使其重新回到队列中等待下一次投递。此外，可通过设置重试次数和重试时间间隔等参数，进行消息重试和延迟投递的配置，以满足不同的业务需求。</p><h2 id="6-❓消息基于什么传输？">6. ❓消息基于什么传输？</h2><p><img src="https://mcnfxurl5vzo.feishu.cn/space/api/box/stream/download/asynccode/?code=NzJmYWVhZWU4ZmI4YWY2NDg4N2FjNmExZGYyOWNlY2RfZFhvUUFRZ1d0b1A5QkgzUjhDYWw4ZlZONU85c3k5OWhfVG9rZW46RWhMdmJ5YUJRb2hxSkd4MUQwT2NGYUtIbkdkXzE3NDMzODg3ODE6MTc0MzM5MjM4MV9WNA" alt="img"></p><h2 id="7-为什么不应该对所有的-message-都使用持久化机制？">7. 为什么不应该对所有的 message 都使用持久化机制？</h2><p>使用持久化机制会增加磁盘负担，尤其在高并发场景下，成本更高。若所有消息都用，会使RabbitMQ性能下降，影响系统性能。所以要依业务需求和消息重要性选择是否用。重要消息用它保可靠，临时消息可不用，减轻服务器负担。</p><p>若message设了persistent属性，但queue未设durable属性，queue的owner node异常时，在queue重建前，发往它的message将被阻塞；若message和queue都分别设了persistent和durable属性，queue的owner node异常且无法重启，queue无法在其他node重建，只能等其owner node重启后才能恢复使用，期间发送给该queue的消息也会被阻塞。</p><p>因此，是否对message持久化，需综合考量性能需求及可能问题。若想单RabbitMQ服务器达100000条/秒以上消息吞吐量，要么不用持久化保速度，用其他方式确保消息可靠；要么用持久化，且保证关键消息量不致性能瓶颈。</p><h2 id="8-如何保证高可用的？RabbitMQ-的集群？">8. 如何保证高可用的？RabbitMQ 的集群？</h2><p><strong>普通集群模式</strong></p><p>普通集群模式是RabbitMQ最常见且最简单的集群模式。多台RabbitMQ服务器经网络连接成集群，共同管理消息队列，借节点间通信实现消息传递与路由。适用于多数应用场景，提供高可用性和可靠性。</p><p><strong>镜像集群模式</strong></p><p>一种高可用性集群模式，可提升RabbitMQ集群的可靠性与容错能力。每个节点有多个镜像节点，镜像节点自动复制主节点消息队列，主节点故障时接管消息队列处理。适用于对消息可靠性要求高的场景，但会增加网络带宽和存储成本</p><p><strong>Federated集群模式</strong></p><p>RabbitMQ的特殊集群模式，能将多个RabbitMQ集群组成逻辑整体，通过Federation插件实现集群间消息传递与路由。适用于需跨多数据中心或地理分布的场景，但会增加网络延迟和复杂度。</p><h2 id="9-RabbitMQ上的一个queue中存放的message是否有数量限制？">9. RabbitMQ上的一个queue中存放的message是否有数量限制？</h2><ul><li><strong>队列的大小限制</strong>：队列可通过配置参数限制大小，当队列大小达到限制，新消息无法入队。该限制能通过RabbitMQ的管理界面或者AMQP协议设置。</li><li><strong>内存****限制</strong>：RabbitMQ中的消息队列保存在内存中，若队列中消息数量过多，会占用大量内存空间，可能致使系统性能下降甚至崩溃。所以，系统内存大小是队列存放消息数量的限制因素之一。</li><li><strong>磁盘限制</strong>：当RabbitMQ的磁盘空间不足时，也会对队列中存放消息的数量形成限制。</li></ul><h2 id="10-⭐️在单node系统和多node构成的cluster系统中声明queue，exchange，以及进行binding会有什么不同？">10. ⭐️在单node系统和多node构成的cluster系统中声明queue，exchange，以及进行binding会有什么不同？</h2><p>当你在单node上声明queue时，只要该node上相关元数据进行了变更，你就会得到Queue.Declare - ok回应；而在cluster上声明queue，则要求cluster上的全部node都要进行元数据成功更新，才会得到Queue.Declare - ok回应。另外，若node类型为RAM node则变更的数据仅保存在内存中，若类型为disk node则还要变更保存在磁盘上的数据。</p><p><strong>客户端连接到cluster中的任意node上是否都能正常工作？</strong></p><p>是的，客户端感觉不到不同。</p><p><strong>若cluster中拥有某个queue的owner node失效了，且该queue被声明具有durable属性，是否能够成功从其他node上重新声明该queue？</strong></p><p>不能，在这种情况下，将得到404 NOT FOUND错误。只能等queue所属的node恢复后才能使用该queue。但若该queue本身不具有durable属性，则可在其他node上重新声明。</p><h2 id="11-向不存在的exchange发publish消息会发生什么？向不存在的queue执行consume动作会发生什么？">11. 向不存在的exchange发publish消息会发生什么？向不存在的queue执行consume动作会发生什么？</h2><p>都会收到 Channel.Close 信令告之不存在（内含原因 404 NOT FOUND）</p><h2 id="12-为什么说保证message被可靠持久化的条件是queue和exchange具有durable属性，同时message具有-persistent属性才行？">12. 为什么说保证message被可靠持久化的条件是queue和exchange具有durable属性，同时message具有 persistent属性才行？</h2><p>binding 关系可以表示为 exchange - binding - queue。从文档中我们知道，若要求投递的 message 能够不丢失，要求 message 本身设置 persistent 属性，要求 exchange 和 queue 都设置 durable 属性。其实这问题可以这么想，若 exchange 或 queue 未设置 durable 属性，则在其 crash 之后就会无法恢复，那么即使 message 设置了 persistent 属性，仍然存在 message 虽然能恢复但却无处容身的问题；同理，若 message 本身未设置 persistent 属性，则 message 的持久化更无从谈起。</p><h2 id="13-死信队列和延迟队列的使用？">13. 死信队列和延迟队列的使用？</h2><p><strong>死信队列</strong></p><p>当消息无法被正确处理时，可将其转发到死信队列，以便进一步处理。通过使用死信队列，能统一存储和管理无法处理的消息，并借助设置合适的TTL（存活时间）和DLX（死信交换器）等参数，灵活控制消息的转发和重新处理。</p><p>使用死信队列的主要步骤：</p><ul><li>创建一个普通队列和一个死信交换器；</li><li>将普通队列绑定到死信交换器，并指定死信队列的路由键；</li><li>发送消息时，可将消息的TTL设为较小值，当消息未被消费者处理时，会转发到死信队列。</li></ul><p>当需在一段时间后才能处理某个消息时，可使用延迟队列。通过设置消息的TTL和DLX等参数，能将消息转发到指定队列，以便在一定时间后再进行处理。适用于订单超时处理、提醒任务等场景。</p><p>使用延迟队列的主要步骤：</p><ul><li>创建一个普通队列和一个交换器；</li><li>在交换器中设置消息的TTL和DLX等参数，将消息转发到指定队列；</li><li>在指定队列中处理消息。</li></ul><h2 id="14-什么情况下producer不主动创建queue是安全的？">14. 什么情况下producer不主动创建queue是安全的？</h2><p>message是允许丢失的；实现了针对未处理消息的republish功能。</p><h2 id="15-如何保证消息的顺序性？">15. 如何保证消息的顺序性？</h2><p>只有一个队列仅有一个消费者的情况下才能保证顺序，否则只能通过全局 ID 实现（每条消息都有一个 msgId，关联的消息拥有一个 parentMsgId。可以在消费端实现前一条消息未消费，不处理下一条消息；也可以在生产端实现前一条消息未处理完不发下一条消息。</p><h2 id="16-消息什么时候会变成死信？">16. 消息什么时候会变成死信？</h2><p>消息拒绝并且没有设置重新入队；消息过期；消息堆积，并且队列达到最大长度，先入队的消息会变成 DL（死信）。</p><h2 id="17-⭐️-RabbitMQ事务机制：">17.⭐️ RabbitMQ事务机制：</h2><p>RabbitMQ 支持事务机制，用于在发送消息时保证事务的原子性。事务机制允许在多个 RabbitMQ 操作中声明事务，并在最终确认消息被完全处理之前，将多个操作打包为一个原子操作。</p><p>在 RabbitMQ 中，事务机制的使用流程如下：</p><ul><li>开启事务：在发送消息之前，使用 txSelect 方法开启事务；</li><li>发送消息：使用 basicPublish 方法发送消息；</li><li>提交事务：使用 txCommit 方法提交事务，如果提交成功，则消息会被 RabbitMQ 确认，否则消息会被回滚；</li><li>回滚事务：使用 txRollback 方法回滚事务，如果回滚成功，则之前发送的消息会被撤销，否则消息会被继续处理。</li></ul><p>需要注意的是，使用事务机制会对 RabbitMQ 的性能产生一定的影响，因此建议在必要的情况下使用，例如在消息的可靠性要求非常高的场景下。在消息量较大的场景下，可以使用事务机制的替代方案，如消息确认机制（ACK 机制）等，以保证系统的高性能和可靠性。</p>]]></content>
      
      
      <categories>
          
          <category> 面试题 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> MQ </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Spring基础面试题</title>
      <link href="/posts/2025-01-09-Spring%E5%9F%BA%E7%A1%80%E9%9D%A2%E8%AF%95%E9%A2%98.html"/>
      <url>/posts/2025-01-09-Spring%E5%9F%BA%E7%A1%80%E9%9D%A2%E8%AF%95%E9%A2%98.html</url>
      
        <content type="html"><![CDATA[<h1>1.Spring面试题</h1><h2 id="一、Spring概述">一、Spring概述</h2><h3 id="1-Spring中的设计模式有哪些？">1. Spring中的设计模式有哪些？</h3><ul><li><p><strong>工厂模式</strong>：Spring容器本质是工厂，通过BeanFactory、ApplicationContext等利用该模式创建bean对象，将对象创建和使用分离，便于管理和维护bean实例。</p></li><li><p><strong>代理模式</strong>：Spring AOP功能借助此模式实现，分动态代理和静态代理，用于在不修改目标对象代码的情况下，为其添加额外功能，如日志记录、事务管理等。</p></li><li><p><strong>单例模式</strong>：Spring中Bean默认是单例的，即整个应用中只有一个实例，利于容器对Bean统一管理，减少资源消耗。</p></li><li><p><strong>模板模式</strong>：像JdbcTemplate、RestTemplate等以Template结尾的类，定义了操作数据库、网络等的通用骨架，具体实现步骤由子类完成，提高了代码复用性。</p></li><li><p><strong>观察者模式</strong>：Spring事件驱动模型是其经典应用，存在事件发布者、事件和事件监听器，发布者发布事件，监听器监听并做出响应，实现组件间解耦。</p></li><li><p><strong>适配器模式</strong>：Spring AOP的增强或通知（Advice）使用该模式，在Spring MVC中也用于适配Controller，让不兼容的接口协同工作。</p></li><li><p><strong>策略模式</strong>：Spring的Resource接口有不同实现类，根据不同策略访问资源，便于在运行时动态选择算法或行为。 </p></li></ul><h3 id="2-IOC的实现原理">2.IOC的实现原理</h3><ol><li><p>扫描和解析配置文件或注解信息，将其转换为内部的对象定义和依赖关系；</p></li><li><p>根据对象定义和依赖关系，使用反射机制动态创建和初始化对象，并将对象注入到需要使用它们的地方。</p></li></ol><p>具体来说，Spring IOC的实现过程如下：</p><ul><li><p>读取配置文件或解析注解信息，将其转换为内部的对象定义和依赖关系。在Spring中，可以使用XML文件或注解来配置对象和依赖关系。Spring通过解析配置文件或注解信息，将其转换为内部的对象定义和依赖关系（BeanDefinition）放到容器（BeanFactory）中。对象定义包括对象的类型、属性、构造函数等信息，依赖关系包括对象之间的依赖关系、依赖注入方式等信息。</p></li><li><p>实例化bean对象：Spring会根据对象定义的类型和构造函数信息，使用反射机制来创建对象。</p></li><li><p>设置属性：实例化后的仍然是一个原生的状态，并没有进行依赖注入。这一步Spring根据BeanDefinition中的信息进行属性填充，依赖注入。</p></li><li><p>调用Aware接口：Spring会检测该对象是否实现了xxxAware接口，如果有会在这里执行完成。Aware主要是能获取到Spring容器中的一些资源，然后可以供后续步骤，例如初始化阶段使用。</p></li><li><p>BeanPostProcessor前置处理：postProcessBeforeInitialization方法。上述几个步骤后，bean对象已经被正确构造，但如果想要对象被初始化前再进行一些自定义的处理，就可以通过BeanPostProcessor接口的该方法来实现。</p></li><li><p>初始化阶段：该阶段Spring首先会看是否实现了InitializingBean接口的afterPropertiesSet方法以及是否有自定义的init - method等，如果有会进行调用执行。</p></li><li><p>BeanPostProcessor后置处理：postProcessAfterInitialization方法。当前正在初始化的bean对象会被传递进来，我们就可以对这个bean作任何处理，与前面前置处理相对的，这个函数会在InitializationBean完成后执行，因此为后置处理。</p></li><li><p>bean初始化完成可以被使用了。</p></li></ul><p>总的来说，Spring IOC的实现原理是通过反射机制动态创建对象，依赖注入，对象初始化。通过解耦对象之间的依赖关系，使得应用程序更加灵活、可维护、可扩展。 </p><h3 id="3-IOC和DI有什么关系">3.IOC和DI有什么关系</h3><p><img src="2025-01-09-Spring%E5%9F%BA%E7%A1%80%E9%9D%A2%E8%AF%95%E9%A2%98/image3.png" alt=""></p><h3 id="4-谈谈你对Spring的理解">4. 谈谈你对Spring的理解</h3><p><img src="2025-01-09-Spring%E5%9F%BA%E7%A1%80%E9%9D%A2%E8%AF%95%E9%A2%98/image4.png" alt=""></p><h3 id="5-Spring有哪些缺点">5. Spring有哪些缺点</h3><p><img src="2025-01-09-Spring%E5%9F%BA%E7%A1%80%E9%9D%A2%E8%AF%95%E9%A2%98/image5.png" alt=""></p><p><img src="2025-01-09-Spring%E5%9F%BA%E7%A1%80%E9%9D%A2%E8%AF%95%E9%A2%98/image6.png" alt=""></p><h3 id="6-⭐️Spring-Ioc容器的加载过程">6. ⭐️Spring-Ioc容器的加载过程</h3><p>Spring的IOC容器工作的过程，其实可以划分为两个阶段：配置解析阶段和Bean的创建段。其中：</p><ul><li><p>配置解析阶段主要做的工作是加载和<strong>解析配置文件</strong>，将配置的bean解析成BeanDefinition。</p><ul><li><p>整个过程是：</p><ol><li><p>读取配置：通过BeanDefinitionReader读取配置文件或配置类。</p></li><li><p>解析配置信息：如ComponentScan、Bean配置等。</p></li><li><p>扫描类注解：根据ComponentScan扫描@Component、@Bean、@Configuration、@Import等注解…</p></li><li><p>将符合的bean注册为BeanDefinition。</p></li></ol></li></ul></li><li><p>Bean的创建过程主要做的工作是根据BeanDefinition创建Bean。</p><ul><li><p><strong>大概过程：</strong></p><ol><li><p>实例化Bean：容器根据配置文件中的Bean定义，实例化Bean对象。可以通过构造函数实例化、工厂方法实例化、静态工厂方法实例化等方式来创建Bean对象。</p></li><li><p>注入Bean属性：容器会为实例化的Bean对象设置属性，可以通过setter方法注入属性值，也可以通过构造函数注入属性值。</p></li><li><p>处理依赖关系：容器会处理Bean之间的依赖关系，将依赖的Bean注入到需要的地方。</p></li><li><p>执行初始化方法：容器会调用Bean的初始化方法，可以通过实现InitializingBean接口或在配置文件中指定初始化方法来定义Bean的初始化逻辑。</p></li><li><p>注册Bean：容器会将实例化、属性设置和初始化完成的Bean对象注册到容器中，以便后续的使用和管理。</p></li><li><p>完成加载：容器完成所有Bean的加载和初始化后，即完成了IOC容器的加载过程。此时，可以通过容器调用getBean获取Bean对象。 </p></li></ol></li></ul></li></ul><h2 id="二、Spring-Bean">二、Spring Bean</h2><h3 id="1-什么是Bean">1.什么是Bean</h3><p><img src="2025-01-09-Spring%E5%9F%BA%E7%A1%80%E9%9D%A2%E8%AF%95%E9%A2%98/image8.png" alt=""></p><h3 id="2-⭐️Bean生命周期">2.⭐️Bean生命周期</h3><p><img src="2025-01-09-Spring%E5%9F%BA%E7%A1%80%E9%9D%A2%E8%AF%95%E9%A2%98/image9.png" alt=""></p><p><img src="2025-01-09-Spring%E5%9F%BA%E7%A1%80%E9%9D%A2%E8%AF%95%E9%A2%98/image10.png" alt=""></p><p><img src="2025-01-09-Spring%E5%9F%BA%E7%A1%80%E9%9D%A2%E8%AF%95%E9%A2%98/image11.png" alt=""></p><h3 id="3-什么是FactoryBean？">3. 什么是FactoryBean？</h3><p><img src="2025-01-09-Spring%E5%9F%BA%E7%A1%80%E9%9D%A2%E8%AF%95%E9%A2%98/image12.png" alt=""></p><h3 id="4-⭐️BeanFactory-和-FactoryBean区别是什么？">4. ⭐️BeanFactory 和 FactoryBean区别是什么？</h3><p><img src="2025-01-09-Spring%E5%9F%BA%E7%A1%80%E9%9D%A2%E8%AF%95%E9%A2%98/image13.png" alt=""></p><h3 id="5-⭐️BeanFactory-和-ApplicationContext有什么区别？">5.⭐️BeanFactory 和 ApplicationContext有什么区别？</h3><p><img src="2025-01-09-Spring%E5%9F%BA%E7%A1%80%E9%9D%A2%E8%AF%95%E9%A2%98/image14.png" alt=""></p><h3 id="6-Bean的作用域有哪些？">6. Bean的作用域有哪些？</h3><p><img src="2025-01-09-Spring%E5%9F%BA%E7%A1%80%E9%9D%A2%E8%AF%95%E9%A2%98/image15.png" alt=""></p><hr><h3 id="7-⭐️Bean-是线程安全的吗？">7. ⭐️Bean 是线程安全的吗？</h3><p><img src="2025-01-09-Spring%E5%9F%BA%E7%A1%80%E9%9D%A2%E8%AF%95%E9%A2%98/image16.png" alt=""></p><h3 id="8-将一个类声明为-Spring-的-Bean-的注解有哪些？">8. 将一个类声明为 Spring 的 Bean 的注解有哪些？</h3><p><img src="2025-01-09-Spring%E5%9F%BA%E7%A1%80%E9%9D%A2%E8%AF%95%E9%A2%98/image17.png" alt=""></p><h3 id="9-注入Bean-的注解有哪些？">9. 注入Bean 的注解有哪些？</h3><p><img src="2025-01-09-Spring%E5%9F%BA%E7%A1%80%E9%9D%A2%E8%AF%95%E9%A2%98/image18.png" alt=""></p><hr><h3 id="10-Autowired底层的实现原理是什么？">10. @Autowired底层的实现原理是什么？</h3><p><img src="2025-01-09-Spring%E5%9F%BA%E7%A1%80%E9%9D%A2%E8%AF%95%E9%A2%98/image19.png" alt=""></p><h3 id="11-⭐️AutoWired-与-Resource-区别">11.⭐️AutoWired 与 Resource 区别</h3><p><img src="2025-01-09-Spring%E5%9F%BA%E7%A1%80%E9%9D%A2%E8%AF%95%E9%A2%98/image20.png" alt=""></p><h3 id="12-❓什么是三级缓存？">12. ❓什么是三级缓存？</h3><p><img src="2025-01-09-Spring%E5%9F%BA%E7%A1%80%E9%9D%A2%E8%AF%95%E9%A2%98/image21.png" alt=""></p><hr><h3 id="13-⭐️-为什么需要三级缓存？">13.⭐️ 为什么需要三级缓存？</h3><p><img src="2025-01-09-Spring%E5%9F%BA%E7%A1%80%E9%9D%A2%E8%AF%95%E9%A2%98/image22.png" alt=""></p><h3 id="14-❓Spring如何解决循环依赖问题？">14. ❓Spring如何解决循环依赖问题？</h3><p><img src="2025-01-09-Spring%E5%9F%BA%E7%A1%80%E9%9D%A2%E8%AF%95%E9%A2%98/image23.png" alt=""></p><h3 id="15-⭐️Bean有哪几种配置方式？">15.⭐️Bean有哪几种配置方式？</h3><p><img src="2025-01-09-Spring%E5%9F%BA%E7%A1%80%E9%9D%A2%E8%AF%95%E9%A2%98/image24.png" alt=""></p><hr><h2 id="三、Spring-AOP">三、Spring AOP</h2><h3 id="1-⭐️什么是AOP">1.⭐️什么是AOP?</h3><p><img src="2025-01-09-Spring%E5%9F%BA%E7%A1%80%E9%9D%A2%E8%AF%95%E9%A2%98/image25.png" alt=""></p><p><img src="2025-01-09-Spring%E5%9F%BA%E7%A1%80%E9%9D%A2%E8%AF%95%E9%A2%98/image26.png" alt=""></p><hr><h3 id="2-谈谈你对AOP的理解">2.谈谈你对AOP的理解</h3><p><img src="2025-01-09-Spring%E5%9F%BA%E7%A1%80%E9%9D%A2%E8%AF%95%E9%A2%98/image27.png" alt=""></p><p><img src="2025-01-09-Spring%E5%9F%BA%E7%A1%80%E9%9D%A2%E8%AF%95%E9%A2%98/image28.png" alt=""></p><h3 id="3-AOP有哪些实现方式">3.AOP有哪些实现方式</h3><p><img src="2025-01-09-Spring%E5%9F%BA%E7%A1%80%E9%9D%A2%E8%AF%95%E9%A2%98/image29.png" alt=""></p><h3 id="4-⭐️Spring-AOP-and-AspectJ-AOP-有什么区别？">4. ⭐️Spring AOP and AspectJ AOP 有什么区别？</h3><p><img src="2025-01-09-Spring%E5%9F%BA%E7%A1%80%E9%9D%A2%E8%AF%95%E9%A2%98/image30.png" alt=""></p><p><img src="2025-01-09-Spring%E5%9F%BA%E7%A1%80%E9%9D%A2%E8%AF%95%E9%A2%98/image31.png" alt=""></p><h3 id="5-Spring-AOP通知和执行顺序？">5. Spring-AOP通知和执行顺序？</h3><p><img src="2025-01-09-Spring%E5%9F%BA%E7%A1%80%E9%9D%A2%E8%AF%95%E9%A2%98/image32.png" alt=""></p><hr><h3 id="6-⭐️⭐️⭐️JDK动态代理和CGLIB动态代理的区别">6.⭐️⭐️⭐️JDK动态代理和CGLIB动态代理的区别</h3><p><img src="2025-01-09-Spring%E5%9F%BA%E7%A1%80%E9%9D%A2%E8%AF%95%E9%A2%98/image33.png" alt=""></p><p><img src="2025-01-09-Spring%E5%9F%BA%E7%A1%80%E9%9D%A2%E8%AF%95%E9%A2%98/image34.png" alt=""></p><h3 id="7-⭐️什么情况下AOP会失效，怎么解决？">7. ⭐️什么情况下AOP会失效，怎么解决？</h3><p><img src="2025-01-09-Spring%E5%9F%BA%E7%A1%80%E9%9D%A2%E8%AF%95%E9%A2%98/image35.png" alt=""></p><hr><h2 id="四、Spring注解">四、Spring注解</h2><h3 id="1-Configuration和-Component有什么区别？">1. @Configuration和@Component有什么区别？</h3><p><img src="2025-01-09-Spring%E5%9F%BA%E7%A1%80%E9%9D%A2%E8%AF%95%E9%A2%98/image36.png" alt=""></p><h3 id="2-⭐️-Component，-Controller，-Repository，-Service-有何区别？">2. ⭐️@Component， @Controller， @Repository， @Service 有何区别？</h3><p><img src="2025-01-09-Spring%E5%9F%BA%E7%A1%80%E9%9D%A2%E8%AF%95%E9%A2%98/image37.png" alt=""></p><h3 id="3-⭐️-Component-和-Bean-有什么区别？">3. ⭐️@Component 和 @Bean 有什么区别？</h3><p><img src="2025-01-09-Spring%E5%9F%BA%E7%A1%80%E9%9D%A2%E8%AF%95%E9%A2%98/image38.png" alt=""></p><hr><h3 id="4-Required-注解有什么用？">4. @Required 注解有什么用？</h3><p><img src="2025-01-09-Spring%E5%9F%BA%E7%A1%80%E9%9D%A2%E8%AF%95%E9%A2%98/image39.png" alt=""></p><h3 id="5-⭐️⭐️⭐️-Qualifier-注解有什么用？">5. ⭐️⭐️⭐️@Qualifier 注解有什么用？</h3><p><img src="2025-01-09-Spring%E5%9F%BA%E7%A1%80%E9%9D%A2%E8%AF%95%E9%A2%98/image40.png" alt=""></p><hr><h3 id="6-RequestMapping-注解有什么用？">6. @RequestMapping 注解有什么用？</h3><p><img src="2025-01-09-Spring%E5%9F%BA%E7%A1%80%E9%9D%A2%E8%AF%95%E9%A2%98/image41.png" alt=""></p><h3 id="7-RequestMapping-和-GetMapping-注解的不同之处在哪里？">7. @RequestMapping 和 @GetMapping 注解的不同之处在哪里？</h3><p><img src="2025-01-09-Spring%E5%9F%BA%E7%A1%80%E9%9D%A2%E8%AF%95%E9%A2%98/image42.png" alt=""></p><h3 id="8-Controller-注解有什么用">8. @Controller 注解有什么用</h3><p><img src="2025-01-09-Spring%E5%9F%BA%E7%A1%80%E9%9D%A2%E8%AF%95%E9%A2%98/image43.png" alt=""></p><h3 id="9-⭐️-RestController-和-Controller-有什么区别？">9. ⭐️@RestController 和 @Controller 有什么区别？</h3><p><img src="2025-01-09-Spring%E5%9F%BA%E7%A1%80%E9%9D%A2%E8%AF%95%E9%A2%98/image44.png" alt=""></p><p><img src="2025-01-09-Spring%E5%9F%BA%E7%A1%80%E9%9D%A2%E8%AF%95%E9%A2%98/image45.png" alt=""></p><p><img src="2025-01-09-Spring%E5%9F%BA%E7%A1%80%E9%9D%A2%E8%AF%95%E9%A2%98/image46.png" alt=""></p><p><img src="2025-01-09-Spring%E5%9F%BA%E7%A1%80%E9%9D%A2%E8%AF%95%E9%A2%98/image47.png" alt=""></p><h3 id="10-⭐️-RequestParam-和-PathVariable-两个注解的区别？">10. ⭐️@RequestParam 和 @PathVariable 两个注解的区别？</h3><p><img src="2025-01-09-Spring%E5%9F%BA%E7%A1%80%E9%9D%A2%E8%AF%95%E9%A2%98/image48.png" alt=""></p><hr><h2 id="五、Spring事务">五、Spring事务</h2><h3 id="1-⭐️说一下-spring-的事务隔离级别？">1. ⭐️说一下 spring 的事务隔离级别？</h3><p><img src="2025-01-09-Spring%E5%9F%BA%E7%A1%80%E9%9D%A2%E8%AF%95%E9%A2%98/image49.png" alt=""></p><p><img src="2025-01-09-Spring%E5%9F%BA%E7%A1%80%E9%9D%A2%E8%AF%95%E9%A2%98/image50.png" alt=""></p><h3 id="2-⭐️-说一下Spring的事务传播行为">2.⭐️ 说一下Spring的事务传播行为</h3><p><a href="https://mp.weixin.qq.com/s/tRFoa76ElLFIrZRTwHIUMQ">https://mp.weixin.qq.com/s/tRFoa76ElLFIrZRTwHIUMQ</a></p><p><img src="2025-01-09-Spring%E5%9F%BA%E7%A1%80%E9%9D%A2%E8%AF%95%E9%A2%98/image51.png" alt=""></p><hr><h3 id="3-⭐️Spring事件监听的核心机制是什么？">3. ⭐️Spring事件监听的核心机制是什么？</h3><p>Spring事件监听的核心机制围绕观察者模式展开：</p><p>观察者模式：它允许一个对象（称为主题或被观察者）维护一组依赖于它的对象（称为观察者），并在主题状态发生变化时通知观察者。</p><p>它包含三个核心：</p><ol><li><p><strong>事件：</strong>事件是观察者模式中的主题状态变化的具体表示，它封装了事件发生时的信息。在Spring中，事件通常是普通的Java对象，用于传递数据或上下文信息。</p></li><li><p><strong>事件发布者：</strong>在Spring中，事件发布者充当主题的角色，负责触发并发布事件。它通常实现了ApplicationEventPublisher接口或使用注解@Autowired来获得事件发布功能。</p></li><li><p><strong>事件监听器</strong>：事件监听器充当观察者的角色，负责监听并响应事件的发生。它实现了ApplicationListener接口，通过onApplicationEvent()方法来处理事件。</p></li></ol><p>总之，Spring事件监听机制的核心机制是观察者模式，通过事件、事件发布者和事件监听器的协作，实现了松耦合的组件通信，使得应用程序更加灵活和可维护。 </p><h3 id="4-⭐️Spring事务的失效原因？">4. ⭐️Spring事务的失效原因？</h3><ol><li><p><strong>自身调用问题：</strong>spring是通过aop的方式，对需要spring管理事务的bean生成了代理对象，然后通过代理对象拦截了目标方法的执行，在方法前后添加了事务的功能，所以必须通过代理对象调用目标方法的时候，事务才会起效。</p></li><li><p><strong>非public方法导致的事务时效：</strong>当事务方法被标记为非public时，Spring的事务代理通常是通过Java动态代理或CGLIB动态代理生成的，这些代理要求目标方法是公开可访问的public。</p></li><li><p><strong>方法本身自己捕捉了异常</strong>，这样即使出现异常也不会触发事务的回滚，所以要进行抛出，而不是自己捕捉。</p></li><li><p>造成事务回滚的异常一般是<strong>Error类异常或者是运行时异常</strong>，如果抛出的是检查型异常的话，那么不会造成事务回滚，所以我们可以将rollbackfor配置为Exception。</p></li><li><p>开启事务的bean<strong>没有交给spring容器管理</strong>。</p></li><li><p><strong>数据库不支持事务。 </strong></p></li></ol><h3 id="5-Spring-事务实现方式有哪些？">5. Spring 事务实现方式有哪些？</h3><p><img src="2025-01-09-Spring%E5%9F%BA%E7%A1%80%E9%9D%A2%E8%AF%95%E9%A2%98/image54.png" alt=""></p><h3 id="6-声明式事务实现原理了解吗？">6. 声明式事务实现原理了解吗？</h3><p><img src="2025-01-09-Spring%E5%9F%BA%E7%A1%80%E9%9D%A2%E8%AF%95%E9%A2%98/image55.png" alt=""></p><h3 id="7-⭐️-protected-和-private-加事务会生效吗？">7.⭐️ protected 和 private 加事务会生效吗？</h3><p><img src="2025-01-09-Spring%E5%9F%BA%E7%A1%80%E9%9D%A2%E8%AF%95%E9%A2%98/image56.png" alt=""></p><h3 id="8-Spring-声明式事务无效可能的原因有哪些？">8. Spring 声明式事务无效可能的原因有哪些？</h3><p><img src="2025-01-09-Spring%E5%9F%BA%E7%A1%80%E9%9D%A2%E8%AF%95%E9%A2%98/image57.png" alt=""></p><hr><h2 id="六、Spring-MVC">六、Spring MVC</h2><h3 id="1-MVC是什么？MVC设计模式的好处有哪些">1. MVC是什么？MVC设计模式的好处有哪些</h3><p><img src="2025-01-09-Spring%E5%9F%BA%E7%A1%80%E9%9D%A2%E8%AF%95%E9%A2%98/image58.png" alt=""></p><p><img src="2025-01-09-Spring%E5%9F%BA%E7%A1%80%E9%9D%A2%E8%AF%95%E9%A2%98/image59.png" alt=""></p><hr><h3 id="2-SpringMVC有哪些核心组件？">2. SpringMVC有哪些核心组件？</h3><p><img src="2025-01-09-Spring%E5%9F%BA%E7%A1%80%E9%9D%A2%E8%AF%95%E9%A2%98/image60.png" alt=""></p><h3 id="3-⭐️SpringMVC的执行流程了解吗？">3. ⭐️SpringMVC的执行流程了解吗？</h3><p><img src="2025-01-09-Spring%E5%9F%BA%E7%A1%80%E9%9D%A2%E8%AF%95%E9%A2%98/image61.png" alt=""></p><p><img src="2025-01-09-Spring%E5%9F%BA%E7%A1%80%E9%9D%A2%E8%AF%95%E9%A2%98/image62.png" alt=""></p><h3 id="4-Spring-MVC-拦截器是什么？">4. Spring MVC 拦截器是什么？</h3><p><img src="2025-01-09-Spring%E5%9F%BA%E7%A1%80%E9%9D%A2%E8%AF%95%E9%A2%98/image63.png" alt=""></p><h3 id="5-拦截器的使用场景有哪些？">5. 拦截器的使用场景有哪些？</h3><p><img src="2025-01-09-Spring%E5%9F%BA%E7%A1%80%E9%9D%A2%E8%AF%95%E9%A2%98/image64.png" alt=""></p><hr><h3 id="6-⭐️如何实现过滤器？">6. ⭐️如何实现过滤器？</h3><p><img src="2025-01-09-Spring%E5%9F%BA%E7%A1%80%E9%9D%A2%E8%AF%95%E9%A2%98/image65.png" alt=""></p><p><img src="2025-01-09-Spring%E5%9F%BA%E7%A1%80%E9%9D%A2%E8%AF%95%E9%A2%98/image66.png" alt=""></p><hr><h3 id="7-⭐️SpringMVC的拦截器和过滤器有什么区别？执行顺序？">7. ⭐️SpringMVC的拦截器和过滤器有什么区别？执行顺序？</h3><p>拦截器和过滤器的区别主要体现在以下5点：</p><ol><li><p>出身不同：过滤器来自于Servlet，而拦截器来自于Spring框架；</p></li><li><p>触发时机不同：请求的执行顺序是：请求进入容器 &gt; 进入过滤器 &gt; 进入Servlet &gt; 进入拦截器 &gt; 执行控制器（Controller）。所以过滤器和拦截器的执行时机，是过滤器先执行，然后才会执行拦截器，最后才会进入真正要调用的方法；</p></li><li><p>底层实现不同：过滤器是基于方法回调实现的，拦截器是基于动态代理（底层是反射）实现的；</p></li><li><p>支持的项目类型不同：过滤器是Servlet规范中定义的，所以过滤器要依赖Servlet容器，它只能用在Web项目中；而拦截器是Spring中的一个组件，因此拦截器既可以用在Web项目中，同时还可以用在Application或Swing程序中； </p></li><li><p>使用的场景不同：因为拦截器更接近业务系统，所以拦截器主要用来实现项目中的业务判断，比如：登录判断、权限判断、日志记录等业务；而过滤器通常是用来实现通用功能过滤的，比如：敏感词过滤、字符集编码设置、响应数据压缩等功能 。 </p></li></ol><h3 id="8-⭐️Spring-MVC异常处理是什么？">8. ⭐️Spring MVC异常处理是什么？</h3><p><img src="2025-01-09-Spring%E5%9F%BA%E7%A1%80%E9%9D%A2%E8%AF%95%E9%A2%98/image68.png" alt=""></p><hr><h1>2.SpringBoot面试题</h1><h3 id="1-SpringBoot可以同时处理多少请求">1. SpringBoot可以同时处理多少请求</h3><p>SpringBoot默认的内嵌容器是Tomcat，也就是我们的程序实际上是运行在Tomcat里的。所以与其说SpringBoot可以处理多少请求，到不如说Tomcat可以处理多少请求。</p><p>在SpringBoot中处理请求数量相关的参数有四个：</p><ul><li><p>server.tomcat.threads.min - spare：最少的工作线程数，默认大小是10。该参数相当于长期工，如果并发请求的数量达到不到10，就会依次使用这几个线程去处理请求。</p></li><li><p>server.tomcat.threads.max：最多的工作线程数，默认大小是200。该参数相当于临时工，如果并发请求的数量在10到200之间，就会使用这些临时工线程进行处理。</p></li><li><p>server.tomcat.max - connections：最大连接数，默认大小是8192。表示Tomcat可以处理的最大请求数量，超过8192的请求就会被放入到等待队列。</p></li><li><p>server.tomcat.accept - count：等待队列的长度，默认大小是100。</p></li></ul><p>如果把Tomcat比作一家饭店的话，那么一个请求其实就相当于一位客人。min - spare就是厨师(长期工)；max是厨师总数(长期工+临时工)；max - connections就是饭店里的座位数量；accept - count是门口小板凳的数量。来的客人优先坐到饭店里面，然后厨师开始忙活，如果长期工可以干的，就让长期工干，如果长期工干不完，就再让临时工干。图中的厨师一共15人，饭店里有30个座位，也就是说，如果现在来了20个客人，那么就会有5个人先在饭店里等着。如果现在来了35个人，饭店里坐不下，就会让5个人先到门口坐一下。如果来了50个人，那么饭店座位+门口小板凳一共40个，所以就会有10人离开。</p><p>也就是说，SpringBoot同时所能处理的最大请求数量是max - connections+accept - count，超过该数量的请求直接就会被丢掉。 </p><h3 id="2-❓SpringBoot启动原理">2.❓SpringBoot启动原理</h3><p><img src="2025-01-09-Spring%E5%9F%BA%E7%A1%80%E9%9D%A2%E8%AF%95%E9%A2%98/image70.jpeg" alt=""></p><p><img src="2025-01-09-Spring%E5%9F%BA%E7%A1%80%E9%9D%A2%E8%AF%95%E9%A2%98/image71.png" alt=""></p><hr><h3 id="3-⭐️为什么SpringBoot的jar可以直接运行？">3. ⭐️为什么SpringBoot的jar可以直接运行？</h3><p><img src="2025-01-09-Spring%E5%9F%BA%E7%A1%80%E9%9D%A2%E8%AF%95%E9%A2%98/image72.png" alt=""></p><h3 id="4-⭐️Spring-Boot为什么默认使用CGLIB">4. ⭐️Spring Boot为什么默认使用CGLIB</h3><p><img src="2025-01-09-Spring%E5%9F%BA%E7%A1%80%E9%9D%A2%E8%AF%95%E9%A2%98/image73.png" alt=""></p><h3 id="5-⭐️Spring与Spring-Boot的区别？">5. ⭐️Spring与Spring Boot的区别？</h3><p><img src="2025-01-09-Spring%E5%9F%BA%E7%A1%80%E9%9D%A2%E8%AF%95%E9%A2%98/image74.png" alt=""></p><hr><h3 id="6-⭐️Spring、-Spring-MVC和SpringBoot有什么区别？">6. ⭐️Spring、 Spring MVC和SpringBoot有什么区别？</h3><p><img src="2025-01-09-Spring%E5%9F%BA%E7%A1%80%E9%9D%A2%E8%AF%95%E9%A2%98/image75.png" alt=""></p><h3 id="7-项目怎么用SpringBoot的？">7. 项目怎么用SpringBoot的？</h3><p><img src="2025-01-09-Spring%E5%9F%BA%E7%A1%80%E9%9D%A2%E8%AF%95%E9%A2%98/image76.png" alt=""></p><h3 id="8-运行-Spring-Boot-有哪几种方式？">8. 运行 Spring Boot 有哪几种方式？</h3><p><img src="2025-01-09-Spring%E5%9F%BA%E7%A1%80%E9%9D%A2%E8%AF%95%E9%A2%98/image77.png" alt=""></p><hr><h3 id="9-⭐️-Spring-Boot-自动装配是什么？">9.⭐️ Spring Boot 自动装配是什么？</h3><p><img src="2025-01-09-Spring%E5%9F%BA%E7%A1%80%E9%9D%A2%E8%AF%95%E9%A2%98/image78.png" alt=""></p><h3 id="10-⭐️SpringBoot-自动化配置原理是什么？">10. ⭐️SpringBoot 自动化配置原理是什么？</h3><p><img src="2025-01-09-Spring%E5%9F%BA%E7%A1%80%E9%9D%A2%E8%AF%95%E9%A2%98/image79.png" alt=""></p><p><img src="2025-01-09-Spring%E5%9F%BA%E7%A1%80%E9%9D%A2%E8%AF%95%E9%A2%98/image80.png" alt=""></p><h3 id="11-⭐️Spring-Boot-有几种方式读取配置文件？">11. ⭐️Spring Boot 有几种方式读取配置文件？</h3><p><img src="2025-01-09-Spring%E5%9F%BA%E7%A1%80%E9%9D%A2%E8%AF%95%E9%A2%98/image81.png" alt=""></p><h3 id="12-Spring-Boot-配置文件的加载顺序？">12. Spring Boot 配置文件的加载顺序？</h3><p><img src="2025-01-09-Spring%E5%9F%BA%E7%A1%80%E9%9D%A2%E8%AF%95%E9%A2%98/image82.png" alt=""></p><p><img src="2025-01-09-Spring%E5%9F%BA%E7%A1%80%E9%9D%A2%E8%AF%95%E9%A2%98/image83.png" alt=""></p><hr><h3 id="13-⭐️bootstrap-properties-和-application-，properties-有何区别？">13. ⭐️bootstrap.properties 和 application.，properties 有何区别？</h3><p><img src="2025-01-09-Spring%E5%9F%BA%E7%A1%80%E9%9D%A2%E8%AF%95%E9%A2%98/image84.png" alt=""></p><p><img src="2025-01-09-Spring%E5%9F%BA%E7%A1%80%E9%9D%A2%E8%AF%95%E9%A2%98/image85.png" alt=""></p><h3 id="14-Spring-Boot-Actuator是什么？">14. Spring Boot Actuator是什么？</h3><p><strong>Spring Boot Actuator</strong>是Spring Boot提供的一个用于<strong>监控和管理应用程序</strong>的模块。包括不限于健康检查、日志监控、指标收集、审计功能、报警功能等。开发人员可以通过这些监控及时发现问题并解决。</p><p>默认情况下，Spring Boot Actuator已经集成在Spring Boot中，只需要在项目中添加依赖并配置一些参数即可使用。 </p><h3 id="15-Spring-Boot-项目如何热部署？">15. Spring Boot 项目如何热部署？</h3><p><img src="2025-01-09-Spring%E5%9F%BA%E7%A1%80%E9%9D%A2%E8%AF%95%E9%A2%98/image87.png" alt=""></p><h3 id="16-⭐️Spring-Boot-中的-starter-是什么？">16. ⭐️Spring Boot 中的 starter 是什么？</h3><p><img src="2025-01-09-Spring%E5%9F%BA%E7%A1%80%E9%9D%A2%E8%AF%95%E9%A2%98/image88.png" alt=""></p><h3 id="17-Spring-Boot-有哪些-starter-？">17. Spring Boot 有哪些 starter ？</h3><p><img src="2025-01-09-Spring%E5%9F%BA%E7%A1%80%E9%9D%A2%E8%AF%95%E9%A2%98/image89.png" alt=""></p><h3 id="18-Spring-Boot-打包成的jar-和普通的jar-有什么区别？">18. Spring Boot 打包成的jar 和普通的jar 有什么区别？</h3><p>Spring  boot打包成的jar包可执行但是不能引用。</p><p><strong>SpringBoot如何实现打包</strong></p><ul><li><p>进入项目目录在控制台输入mvn clean package，clean是清空已存在的项目包，package进行打包。</p></li><li><p>或者点击左边选项栏中的Maven，先点击clean再点击package。 </p></li></ul><p>Spring Boot项目最终打包成的jar是可执行jar，这种jar可以直接通过java -jar xxx.jar命令来运行，这种jar不可以作为普通的jar被其他项目依赖，即使依赖了也无法使用其中的类。</p><p>Spring Boot的jar无法被其他项目依赖，主要还是他和普通jar的结构不同。普通的jar包，解压后直接就是包名，包里就是我们的代码，而Spring Boot打包成的可执行jar解压后，在\BOOT - INF\classes目录下才是我们的代码，因此无法被直接引用。如果非要引用，可以在pom.xml文件中增加配置，将Spring Boot项目打包成两个jar，一个可执行，一个可引用。 </p><hr><h3 id="19-⭐️-SpringBoot-的核心注解是哪个？它主要由哪几个注解组成的？">19.⭐️ SpringBoot 的核心注解是哪个？它主要由哪几个注解组成的？</h3><p><img src="2025-01-09-Spring%E5%9F%BA%E7%A1%80%E9%9D%A2%E8%AF%95%E9%A2%98/image92.png" alt=""></p><h3 id="20-SpringBoot事务的使用">20. SpringBoot事务的使用</h3><p><img src="2025-01-09-Spring%E5%9F%BA%E7%A1%80%E9%9D%A2%E8%AF%95%E9%A2%98/image93.png" alt=""></p><h3 id="21-⭐️什么是-JavaConfig？">21. ⭐️什么是 JavaConfig？</h3><p>Spring JavaConfig 是Spring社区的产品，Spring 3.0引入了它，它提供了配置Spring IOC容器的纯Java方法，有助于避免使用XML配置。使用JavaConfig的优点在于：</p><ul><li><p>面向对象的配置。配置被定义为JavaConfig中的类，用户可利用Java面向对象功能，配置类可继承、重写@Bean方法等。</p></li><li><p>减少或消除XML配置。许多开发人员不希望在XML和Java间来回切换，JavaConfig提供纯Java配置Spring容器的方法，虽然仅用JavaConfig配置容器可行，但常将其与XML混合匹配。</p></li><li><p>类型安全和重构友好。Java 5.0对泛型的支持，使按类型检索bean，无需强制转换或基于字符串查找。</p></li></ul><p>常用的Java config：</p><ul><li><p>@Configuration：在类上标注此注解，表示该类是配置类。</p></li><li><p>@ComponentScan：在配置类上添加此注解，默认扫描该类所在包下所有配置类，相当于之前的&lt;context:component-scan&gt;。</p></li><li><p>@Bean：bean的注入，相当于以前的&lt; bean id=“objectMapper” class=“org.codehaus.jackson.map.ObjectMapper” /&gt;。 </p></li><li><p>@EnableWebMvc：相当于xml的&lt;mvc:annotation-driven&gt;。</p></li><li><p>@ImportResource：相当于xml的&lt; import resource=“applicationContext-cache.xml”&gt; 。 </p></li></ul><h3 id="22-什么是-YAML？">22. 什么是 YAML？</h3><p><img src="2025-01-09-Spring%E5%9F%BA%E7%A1%80%E9%9D%A2%E8%AF%95%E9%A2%98/image95.png" alt=""></p><h3 id="23-⭐️什么是-Spring-Profiles？">23. ⭐️什么是 Spring Profiles？</h3><p><img src="2025-01-09-Spring%E5%9F%BA%E7%A1%80%E9%9D%A2%E8%AF%95%E9%A2%98/image96.png" alt=""></p><h3 id="24-SpringBoot多数据源拆分的思路">24. SpringBoot多数据源拆分的思路</h3><p><img src="2025-01-09-Spring%E5%9F%BA%E7%A1%80%E9%9D%A2%E8%AF%95%E9%A2%98/image97.png" alt=""></p><h3 id="25-保护-Spring-Boot-应用有哪些方法？">25. 保护 Spring Boot 应用有哪些方法？</h3><p><img src="2025-01-09-Spring%E5%9F%BA%E7%A1%80%E9%9D%A2%E8%AF%95%E9%A2%98/image98.png" alt=""></p><h3 id="26-⭐️Spring-Boot-中如何解决跨域问题？">26. ⭐️Spring Boot 中如何解决跨域问题？</h3><p><img src="2025-01-09-Spring%E5%9F%BA%E7%A1%80%E9%9D%A2%E8%AF%95%E9%A2%98/image99.png" alt=""></p><h3 id="27-Spring-Boot-中的监视器是什么？">27. Spring Boot 中的监视器是什么？</h3><p><img src="2025-01-09-Spring%E5%9F%BA%E7%A1%80%E9%9D%A2%E8%AF%95%E9%A2%98/image100.png" alt=""></p><h3 id="28-✅如何使用-Spring-Boot-实现全局异常处理？">28. ✅如何使用 Spring Boot 实现全局异常处理？</h3><p><strong>@ControllerAdvice + @ExceptionHandler</strong></p><p>在这种异常处理方式下，会给所有或者指定的Controller织入异常处理的逻辑（AOP），当Controller中的方法抛出异常的时候，由被@ExceptionHandler注解修饰的方法进行处理。 </p><h3 id="29-如何重新加载-Spring-Boot-上的更改，而无需重新启动服务器？Spring-Boot项目如何热部署？">29. 如何重新加载 Spring Boot 上的更改，而无需重新启动服务器？Spring Boot项目如何热部署？</h3><p><img src="2025-01-09-Spring%E5%9F%BA%E7%A1%80%E9%9D%A2%E8%AF%95%E9%A2%98/image102.png" alt=""></p><h3 id="30您使用了哪些-starter-maven-依赖项？">30您使用了哪些 starter maven 依赖项？</h3><p><img src="2025-01-09-Spring%E5%9F%BA%E7%A1%80%E9%9D%A2%E8%AF%95%E9%A2%98/image103.png" alt=""></p><hr><h1>3.Spring Cloud面试题</h1><h2 id="一、微服务概念">一、微服务概念</h2><h3 id="1-什么是微服务？">1. 什么是微服务？</h3><p><img src="2025-01-09-Spring%E5%9F%BA%E7%A1%80%E9%9D%A2%E8%AF%95%E9%A2%98/image104.png" alt=""></p><h3 id="2-⭐️微服务相较于传统的web项目有什么优势？">2. ⭐️微服务相较于传统的web项目有什么优势？</h3><p><img src="2025-01-09-Spring%E5%9F%BA%E7%A1%80%E9%9D%A2%E8%AF%95%E9%A2%98/image105.png" alt=""></p><h3 id="3微服务的通讯方式有哪些？">3微服务的通讯方式有哪些？</h3><p><img src="2025-01-09-Spring%E5%9F%BA%E7%A1%80%E9%9D%A2%E8%AF%95%E9%A2%98/image106.png" alt=""></p><h3 id="4-⭐️分布式和微服务有什么区别？">4. ⭐️分布式和微服务有什么区别？</h3><p><img src="2025-01-09-Spring%E5%9F%BA%E7%A1%80%E9%9D%A2%E8%AF%95%E9%A2%98/image107.png" alt=""></p><hr><h3 id="5-⭐️现在有哪些流行的微服务解决方案？">5. ⭐️现在有哪些流行的微服务解决方案？</h3><p><img src="2025-01-09-Spring%E5%9F%BA%E7%A1%80%E9%9D%A2%E8%AF%95%E9%A2%98/image108.png" alt=""></p><hr><h3 id="6-说下微服务有哪些组件？">6. 说下微服务有哪些组件？</h3><p><img src="2025-01-09-Spring%E5%9F%BA%E7%A1%80%E9%9D%A2%E8%AF%95%E9%A2%98/image109.png" alt=""></p><h3 id="7-⭐️-微服务架构如何运行的？">7.⭐️ 微服务架构如何运行的？</h3><p><img src="2025-01-09-Spring%E5%9F%BA%E7%A1%80%E9%9D%A2%E8%AF%95%E9%A2%98/image110.png" alt=""></p><h2 id="二、Spring-Cloud">二、Spring Cloud</h2><h3 id="1-Spring-Cloud是什么？">1. Spring Cloud是什么？</h3><p><img src="2025-01-09-Spring%E5%9F%BA%E7%A1%80%E9%9D%A2%E8%AF%95%E9%A2%98/image111.png" alt=""></p><h3 id="2-Spring-Boot-和-Spring-Cloud-的关系是什么？">2. Spring Boot 和 Spring Cloud 的关系是什么？</h3><p><img src="2025-01-09-Spring%E5%9F%BA%E7%A1%80%E9%9D%A2%E8%AF%95%E9%A2%98/image112.png" alt=""></p><h3 id="3-Spring-Cloud-由什么组成？">3. Spring Cloud 由什么组成？</h3><p><img src="2025-01-09-Spring%E5%9F%BA%E7%A1%80%E9%9D%A2%E8%AF%95%E9%A2%98/image113.png" alt=""></p><h2 id="三、服务注册与发现">三、服务注册与发现</h2><h3 id="1-SpringCloud可以选择哪些注册中心？">1. SpringCloud可以选择哪些注册中心？</h3><p><img src="2025-01-09-Spring%E5%9F%BA%E7%A1%80%E9%9D%A2%E8%AF%95%E9%A2%98/image114.png" alt=""></p><h3 id="2-⭐️Nacos、-Eureka、-Zookeeper注册中心的区别">2. ⭐️Nacos、 Eureka、 Zookeeper注册中心的区别</h3><p><img src="2025-01-09-Spring%E5%9F%BA%E7%A1%80%E9%9D%A2%E8%AF%95%E9%A2%98/image115.png" alt=""></p><p><img src="2025-01-09-Spring%E5%9F%BA%E7%A1%80%E9%9D%A2%E8%AF%95%E9%A2%98/image116.png" alt=""></p><h3 id="3-⭐️Nacos的服务注册表结构是怎样的？">3. ⭐️Nacos的服务注册表结构是怎样的？</h3><p><img src="2025-01-09-Spring%E5%9F%BA%E7%A1%80%E9%9D%A2%E8%AF%95%E9%A2%98/image117.png" alt=""></p><h3 id="4-Nacos中的Namespace是什么？如何使用它来组织和管理微服务？">4. Nacos中的Namespace是什么？如何使用它来组织和管理微服务？</h3><p>Nacos中的<strong>Namespace</strong>是用于隔离不同环境或应用之间的配置和服务信息的概念。通过使用Namespace，可以将不同的环境（例如开发、测试和生产）或不同的应用程序（例如Web应用和移动应用）的配置和服务信息分离开来，以避免冲突和错误。</p><p>在Nacos中，每个Namespace都有自己独立的配置和服务注册表。这意味着，如果您有多个应用程序需要使用Nacos，您可以将它们分别放置在不同的Namespace中。每个Namespace都有自己的命名空间ID，用于标识该Namespace。要使用Namespace，在Nacos客户端初始化时，您需要指定要使用的Namespace ID。</p><p>通过使用Namespace，您可以对不同Namespace下的服务进行分组和管理，例如可以使用Nacos提供的<strong>Group</strong>功能对同一Namespace下的服务进行分组，方便管理和查找。同时，使用Namespace还可以对不同环境下的配置进行隔离，避免不同环境之间的配置冲突。 </p><hr><h2 id="四、负载均衡">四、负载均衡</h2><h3 id="1-在Spring-Cloud中，怎么实现服务的负载均衡？">1. 在Spring Cloud中，怎么实现服务的负载均衡？</h3><p><img src="2025-01-09-Spring%E5%9F%BA%E7%A1%80%E9%9D%A2%E8%AF%95%E9%A2%98/image119.png" alt=""></p><p><img src="2025-01-09-Spring%E5%9F%BA%E7%A1%80%E9%9D%A2%E8%AF%95%E9%A2%98/image120.png" alt=""></p><h3 id="2-负载均衡有什么策略？">2. 负载均衡有什么策略？</h3><p><img src="2025-01-09-Spring%E5%9F%BA%E7%A1%80%E9%9D%A2%E8%AF%95%E9%A2%98/image121.png" alt=""></p><hr><h2 id="五、⭐️远程调用">五、⭐️远程调用</h2><h3 id="1-能说下HTTP和RPC的区别吗？">1. 能说下HTTP和RPC的区别吗？</h3><p>严格来讲，HTTP和不是一个层面的东西：</p><ul><li><p>HTTP（Hypertext Transfer Protocol）是一种应用层协议，主要强调的是网络通信；</p></li><li><p>RPC（Remote Procedure Call，远程过程调用）是一种用于分布式系统之间通信的协议，强调的是服务之间的远程调用。</p></li></ul><p>一些RPC框架比如gRPC，底层传输协议其实也是用的HTTP2，包括Dubbo3，也兼容了gRPC，使用了HTTP2作为传输层的一层协议。 </p><p><img src="2025-01-09-Spring%E5%9F%BA%E7%A1%80%E9%9D%A2%E8%AF%95%E9%A2%98/image.png" alt=""></p><p>在微服务体系里：</p><ul><li><p>基于HTTP风格的远程调用通常使用框架如Feign来实现</p></li><li><p>基于RPC的远程调用通常使用框架如Dubbo来实现</p></li></ul><hr><h3 id="2-⭐️什么是Feign？">2. ⭐️什么是Feign？</h3><p><img src="2025-01-09-Spring%E5%9F%BA%E7%A1%80%E9%9D%A2%E8%AF%95%E9%A2%98/image125.png" alt=""></p><h3 id="3-为什么Feign第一次调用耗时很长？">3. 为什么Feign第一次调用耗时很长？</h3><p><img src="2025-01-09-Spring%E5%9F%BA%E7%A1%80%E9%9D%A2%E8%AF%95%E9%A2%98/image126.png" alt=""></p><h3 id="4-Fegin怎么做负载均衡？Ribbon？">4. Fegin怎么做负载均衡？Ribbon？</h3><p><img src="2025-01-09-Spring%E5%9F%BA%E7%A1%80%E9%9D%A2%E8%AF%95%E9%A2%98/image127.png" alt=""></p><h3 id="5-Feign和Dubbo的区别呢？">5. Feign和Dubbo的区别呢？</h3><p><img src="2025-01-09-Spring%E5%9F%BA%E7%A1%80%E9%9D%A2%E8%AF%95%E9%A2%98/image128.png" alt=""></p><h3 id="6-Feign与-OpenFeign的区别？">6. Feign与 OpenFeign的区别？</h3><p><img src="2025-01-09-Spring%E5%9F%BA%E7%A1%80%E9%9D%A2%E8%AF%95%E9%A2%98/image129.png" alt=""></p><h3 id="7-Ribbon和-Feign-调用服务的区别是什么？">7. Ribbon和 Feign 调用服务的区别是什么？</h3><p><img src="2025-01-09-Spring%E5%9F%BA%E7%A1%80%E9%9D%A2%E8%AF%95%E9%A2%98/image130.png" alt=""></p><hr><h2 id="六、服务容灾">六、服务容灾</h2><h3 id="1-⭐️什么是断路器？为什么需要断路器">1. ⭐️什么是断路器？为什么需要断路器</h3><p><img src="2025-01-09-Spring%E5%9F%BA%E7%A1%80%E9%9D%A2%E8%AF%95%E9%A2%98/image131.png" alt=""></p><h3 id="2-什么是Hystrix？">2. 什么是Hystrix？</h3><p><img src="2025-01-09-Spring%E5%9F%BA%E7%A1%80%E9%9D%A2%E8%AF%95%E9%A2%98/image132.png" alt=""></p><h3 id="3-⭐️微服务雪崩效应是什么？">3. ⭐️微服务雪崩效应是什么？</h3><p><img src="2025-01-09-Spring%E5%9F%BA%E7%A1%80%E9%9D%A2%E8%AF%95%E9%A2%98/image133.png" alt=""></p><h3 id="4-⭐️服务降级，你了解吗？">4. ⭐️服务降级，你了解吗？</h3><p><img src="2025-01-09-Spring%E5%9F%BA%E7%A1%80%E9%9D%A2%E8%AF%95%E9%A2%98/image134.png" alt=""></p><h3 id="5-服务熔断，你了解吗？">5. 服务熔断，你了解吗？</h3><p><img src="2025-01-09-Spring%E5%9F%BA%E7%A1%80%E9%9D%A2%E8%AF%95%E9%A2%98/image135.png" alt=""></p><hr><h3 id="6-服务限流，你了解吗？">6. 服务限流，你了解吗？</h3><p><img src="2025-01-09-Spring%E5%9F%BA%E7%A1%80%E9%9D%A2%E8%AF%95%E9%A2%98/image136.png" alt=""></p><h3 id="7-什么是降级熔断？为什么要进行熔断？">7. 什么是降级熔断？为什么要进行熔断？</h3><p><img src="2025-01-09-Spring%E5%9F%BA%E7%A1%80%E9%9D%A2%E8%AF%95%E9%A2%98/image137.png" alt=""></p><h3 id="8-⭐️有哪些熔断降级方案实现？">8. ⭐️有哪些熔断降级方案实现？</h3><p><img src="2025-01-09-Spring%E5%9F%BA%E7%A1%80%E9%9D%A2%E8%AF%95%E9%A2%98/image138.png" alt=""></p><h3 id="9-⭐️Sentinel-是什么？它是如何工作的？">9. ⭐️Sentinel 是什么？它是如何工作的？</h3><p><img src="2025-01-09-Spring%E5%9F%BA%E7%A1%80%E9%9D%A2%E8%AF%95%E9%A2%98/image139.png" alt=""></p><h3 id="10-Sentinel怎么实现限流的？">10. Sentinel怎么实现限流的？</h3><p><img src="2025-01-09-Spring%E5%9F%BA%E7%A1%80%E9%9D%A2%E8%AF%95%E9%A2%98/image140.png" alt=""></p><p><img src="2025-01-09-Spring%E5%9F%BA%E7%A1%80%E9%9D%A2%E8%AF%95%E9%A2%98/image142.png" alt=""></p><p><img src="2025-01-09-Spring%E5%9F%BA%E7%A1%80%E9%9D%A2%E8%AF%95%E9%A2%98/image141.png" alt=""></p><h3 id="11-Sentinel采用的什么限流算法？">11. Sentinel采用的什么限流算法？</h3><p><img src="2025-01-09-Spring%E5%9F%BA%E7%A1%80%E9%9D%A2%E8%AF%95%E9%A2%98/image143.png" alt=""></p><h3 id="12-Sentinel怎么实现集群限流？">12. Sentinel怎么实现集群限流？</h3><p><img src="2025-01-09-Spring%E5%9F%BA%E7%A1%80%E9%9D%A2%E8%AF%95%E9%A2%98/image144.png" alt=""></p><h3 id="13-Sentinel-与Hystrix的区别是什么？">13. Sentinel 与Hystrix的区别是什么？</h3><p><img src="2025-01-09-Spring%E5%9F%BA%E7%A1%80%E9%9D%A2%E8%AF%95%E9%A2%98/image145.png" alt=""></p><hr><h2 id="七、服务网关">七、服务网关</h2><h3 id="1-⭐️什么是服务网关？为什么需要服务网关？">1. ⭐️什么是服务网关？为什么需要服务网关？</h3><p><img src="2025-01-09-Spring%E5%9F%BA%E7%A1%80%E9%9D%A2%E8%AF%95%E9%A2%98/image146.png" alt=""></p><h3 id="2-SpringCloud可以选择哪些APl网关？">2. SpringCloud可以选择哪些APl网关？</h3><p><img src="2025-01-09-Spring%E5%9F%BA%E7%A1%80%E9%9D%A2%E8%AF%95%E9%A2%98/image147.png" alt=""></p><hr><h3 id="3-什么是限流算法，网关如何实现限流？">3. 什么是限流算法，网关如何实现限流？</h3><p><img src="2025-01-09-Spring%E5%9F%BA%E7%A1%80%E9%9D%A2%E8%AF%95%E9%A2%98/image148.png" alt=""></p><h3 id="4-什么是Spring-Cloud-Gateway">4.什么是Spring Cloud Gateway</h3><p><img src="2025-01-09-Spring%E5%9F%BA%E7%A1%80%E9%9D%A2%E8%AF%95%E9%A2%98/image149.png" alt=""></p><h3 id="5-Spring-Cloud-Gateway核心概念？">5. Spring Cloud Gateway核心概念？</h3><p><img src="2025-01-09-Spring%E5%9F%BA%E7%A1%80%E9%9D%A2%E8%AF%95%E9%A2%98/image150.png" alt=""></p><hr><h3 id="6-为什么我们选择GateWay？">6. 为什么我们选择GateWay？</h3><p><img src="2025-01-09-Spring%E5%9F%BA%E7%A1%80%E9%9D%A2%E8%AF%95%E9%A2%98/image151.png" alt=""></p><h3 id="7-Spring-Cloud-GateWay工作流程？">7. Spring Cloud GateWay工作流程？</h3><p><img src="2025-01-09-Spring%E5%9F%BA%E7%A1%80%E9%9D%A2%E8%AF%95%E9%A2%98/image152.png" alt=""></p><hr><h2 id="八、配置中心">八、配置中心</h2><h3 id="1-⭐️什么是配置中心？为什么需要配置中心？">1. ⭐️什么是配置中心？为什么需要配置中心？</h3><p><img src="2025-01-09-Spring%E5%9F%BA%E7%A1%80%E9%9D%A2%E8%AF%95%E9%A2%98/image153.png" alt=""></p><h3 id="2-SpringCloud可以选择哪些配置中心？">2. SpringCloud可以选择哪些配置中心？</h3><p><img src="2025-01-09-Spring%E5%9F%BA%E7%A1%80%E9%9D%A2%E8%AF%95%E9%A2%98/image154.png" alt=""></p><h3 id="3-Nacos配置中心的原理了解吗？">3. Nacos配置中心的原理了解吗？</h3><p><img src="2025-01-09-Spring%E5%9F%BA%E7%A1%80%E9%9D%A2%E8%AF%95%E9%A2%98/image155.png" alt=""></p><h3 id="4-Nacos配置中心长轮询机制？">4. Nacos配置中心长轮询机制？</h3><p><img src="2025-01-09-Spring%E5%9F%BA%E7%A1%80%E9%9D%A2%E8%AF%95%E9%A2%98/image156.png" alt=""></p><h3 id="5-链路跟踪">5. 链路跟踪</h3><p><img src="2025-01-09-Spring%E5%9F%BA%E7%A1%80%E9%9D%A2%E8%AF%95%E9%A2%98/image157.png" alt=""></p><h3 id="6-SpringCloud可以选择哪些微服务链路追踪方案？">6. SpringCloud可以选择哪些微服务链路追踪方案？</h3><p><img src="2025-01-09-Spring%E5%9F%BA%E7%A1%80%E9%9D%A2%E8%AF%95%E9%A2%98/image158.png" alt=""></p><h2 id="九、分布式事务">九、分布式事务</h2><h3 id="1-⭐️什么情况下需要用到分布式事务？有哪些方案？">1. ⭐️什么情况下需要用到分布式事务？有哪些方案？</h3><p><img src="2025-01-09-Spring%E5%9F%BA%E7%A1%80%E9%9D%A2%E8%AF%95%E9%A2%98/image159.png" alt=""></p><h3 id="2-什么是Seata？谈谈你对Seata的理解？">2. 什么是Seata？谈谈你对Seata的理解？</h3><p><img src="2025-01-09-Spring%E5%9F%BA%E7%A1%80%E9%9D%A2%E8%AF%95%E9%A2%98/image160.png" alt=""></p><h3 id="3-Seata支持哪些模式的分布式事务？">3. Seata支持哪些模式的分布式事务？</h3><p><img src="2025-01-09-Spring%E5%9F%BA%E7%A1%80%E9%9D%A2%E8%AF%95%E9%A2%98/image161.png" alt=""></p><p> </p><p><img src="2025-01-09-Spring%E5%9F%BA%E7%A1%80%E9%9D%A2%E8%AF%95%E9%A2%98/image162.png" alt=""></p><p> </p><p><img src="2025-01-09-Spring%E5%9F%BA%E7%A1%80%E9%9D%A2%E8%AF%95%E9%A2%98/image163.png" alt=""></p><p> </p><p><img src="2025-01-09-Spring%E5%9F%BA%E7%A1%80%E9%9D%A2%E8%AF%95%E9%A2%98/image164.png" alt=""></p><p> </p><p><img src="2025-01-09-Spring%E5%9F%BA%E7%A1%80%E9%9D%A2%E8%AF%95%E9%A2%98/image165.png" alt=""></p><hr><h3 id="4-了解Seata的实现原理吗？">4. 了解Seata的实现原理吗？</h3><p><img src="2025-01-09-Spring%E5%9F%BA%E7%A1%80%E9%9D%A2%E8%AF%95%E9%A2%98/image166.png" alt=""></p><p> </p><p><img src="2025-01-09-Spring%E5%9F%BA%E7%A1%80%E9%9D%A2%E8%AF%95%E9%A2%98/image167.png" alt=""></p><p> </p><p><img src="2025-01-09-Spring%E5%9F%BA%E7%A1%80%E9%9D%A2%E8%AF%95%E9%A2%98/image168.png" alt=""></p><hr><h3 id="5-Seata的事务执行流程是什么样的？">5. Seata的事务执行流程是什么样的？</h3><p><img src="2025-01-09-Spring%E5%9F%BA%E7%A1%80%E9%9D%A2%E8%AF%95%E9%A2%98/image169.png" alt=""></p><h3 id="6-Seata的事务回滚是怎么实现的？">6. Seata的事务回滚是怎么实现的？</h3><p><img src="2025-01-09-Spring%E5%9F%BA%E7%A1%80%E9%9D%A2%E8%AF%95%E9%A2%98/image170.png" alt=""></p><h2 id="十、其它">十、其它</h2><h3 id="1-你们的服务怎么做监控和告警？">1. 你们的服务怎么做监控和告警？</h3><p><img src="2025-01-09-Spring%E5%9F%BA%E7%A1%80%E9%9D%A2%E8%AF%95%E9%A2%98/image171.png" alt=""></p><h3 id="2-你们的服务怎么做日志收集？">2. 你们的服务怎么做日志收集？</h3><p><img src="2025-01-09-Spring%E5%9F%BA%E7%A1%80%E9%9D%A2%E8%AF%95%E9%A2%98/image172.png" alt=""></p><h3 id="3-说下你对DDD的理解？">3. 说下你对DDD的理解？</h3><p><img src="2025-01-09-Spring%E5%9F%BA%E7%A1%80%E9%9D%A2%E8%AF%95%E9%A2%98/image173.png" alt=""></p>]]></content>
      
      
      <categories>
          
          <category> 面试题 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Spring </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>分布式学习笔记</title>
      <link href="/posts/2025331n.html"/>
      <url>/posts/2025331n.html</url>
      
        <content type="html"><![CDATA[<h1>1.分布式理论（CAP &amp; BASE）：</h1><h2 id="1-CAP">(1) CAP:</h2><p><img src="./assets/(null)-20250331104223525.(null)" alt="img"></p><p>首先，我解释下<strong>CAP定理</strong>的含义，c是指一致性，就是指所有节点访问同一份最新的数据副本。A是指可用性，表示非故障的节点在合理的时间内返回合理的响应（不是错误或者超时的响应），A是指分区容错性分布式系统出现网络分区的时候，仍然能够对外提供服务。</p><p>如果是一个分布式系统，肯定有很多个节点，为了系统的安全性。P是一定要满足的。在此基础上，强一致性和可用性只能满足二选一。因为如果要满足强一致性，那么在读写时必须要对其加锁。这时候其它节点的读写操作就被禁用了，那么其它节点的可用性就无法保证。而如果保证可用性，那每个节点的实时数据无法保证强一致性。对于分布式系统，因此只能完成CP和AP。无法完成CA。</p><h1>2.分布式-paxos和raft的区别</h1><p>[20 共识算法:一次性说清楚 Paxos、Raft 等算法的区别](<a href="https://learn.lianglianglee.com/%E4%B8%93%E6%A0%8F/24%E8%AE%B2%E5%90%83%E9%80%8F%E5%88%86%E5%B8%83%E5%BC%8F%E6%95%B0%E6%8D%AE%E5%BA%93-%E5%AE%8C/20">https://learn.lianglianglee.com/专栏/24讲吃透分布式数据库-完/20</a>  共识算法：一次性说清楚 Paxos、Raft <a href="http://xn--mcrqzq82dl1in3fnna.md">等算法的区别.md</a>)</p><p>答：Paxos在一个节点当选为就是 leader 节点之后，其他的从节点如果不满主节点的那个投票策略的话，是可以对主节点的投票就是进行否决的。Paxos就是三阶段提交。但是 raft 的话就是只要集群中存在 leader 节点的话，从节点就是会按照主节点的策略来进行一致性的执行。</p><h1>3.分布式-为什么就是分布式的共识算法都需要要求多数派提交才能完成它的分布式一致性？</h1><p>有作恶节点，消息可能到的顺序不一样，拜占庭问题</p>]]></content>
      
      
      <categories>
          
          <category> 学习 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 分布式 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>场景题</title>
      <link href="/posts/2025-01-09-%E5%9C%BA%E6%99%AF%E9%A2%98.html"/>
      <url>/posts/2025-01-09-%E5%9C%BA%E6%99%AF%E9%A2%98.html</url>
      
        <content type="html"><![CDATA[<h1>场景题</h1><h2 id="1-如何基于-Redis-实现延时任务？">1.如何基于 Redis 实现延时任务？</h2><p>① 利用Redis的过期监听机制</p><p>在 pub/sub 模式下，生产者需要指定消息发送到哪个 channel 中，而消费者则订阅对应的 channel 以获取消息。<br>Redis 中有很多默认的 channel，这些 channel 是由 Redis 本身向它们发送消息的，而不是我们自己编写的代码。其中，<strong>keyevent@0</strong>:expired 就是一个默认的 channel，负责监听 key 的过期事件。也就是说，当一个 key 过期之后，Redis 会发布一个 key 过期的事件到__keyevent@<db>__:expired这个 channel 中。</p><p>￮    失效性差</p><p>￮    丢消息</p><p>￮    重复消费消息</p><p>②Redission延时队列</p><p>Redisson 的延迟队列 RDelayedQueue 是基于 Redis 的 SortedSet 来实现的。SortedSet 是一个有序集合，其中的每个元素都可以设置一个分数，代表该元素的权重。Redisson 利用这一特性，将需要延迟执行的任务插入到 SortedSet 中，并给它们设置相应的过期时间作为分数。<br>Redisson 在客户端（即应用程序进程）中启动一个定时任务，到时间后使用 zrangebyscore 命令扫描 SortedSet 中过期的元素（即分数小于或等于当前时间的元素），然后将这些过期元素从 SortedSet 中移除，并将它们加入到就绪消息列表（ List 结构）中。<br>当任务被移到实际的就绪消息列表中时，Redisson 通常还会通过发布/订阅机制（Redis 的 Pub/Sub 模型）来通知消费者有新任务到达。<br>就绪消息列表是一个阻塞队列，消费者可以使用阻塞操作（如 BLPOP key 0，0 表示无限等待，直到有消息进入队列）监听。由于 Redis 的 Pub/Sub 机制是事件驱动的，它避免了轮询开销，只有在有新消息时才会触发处理逻辑。</p><p>RedissonDelayQueue 中的两个核心方法：<br>● startConsumer（）：启动一个消费者线程，从阻塞队列 blockingQueue 中获取任务并处理。<br>● addTask(String task, long delay)：将一个任务添加到延迟队列中，并指定延迟时间。</p><p><img src="2025-01-09-%E5%9C%BA%E6%99%AF%E9%A2%98/clip_image002.jpg" alt="img"></p><h2 id="2-设计一个秒杀系统">2.设计一个秒杀系统</h2><p><a href="https://ls8sck0zrg.feishu.cn/wiki/KfZ1wUS3niXbM4ky37qcMSG2nPd">后端训练营</a>  <a href="https://ls8sck0zrg.feishu.cn/wiki/L1WKwK29ti7Z7dkIS2EcgSdnnoh">后端训练营 秒杀专栏</a></p><p><img src="2025-01-09-%E5%9C%BA%E6%99%AF%E9%A2%98/clip_image003.jpg" alt="img"></p><!--说点深刻一点的结论--><p>不同量级和要求下的架构也是不一样的，我这里主要还是按比较常见的场景（几十万qps）来做的分析。</p><p>在实战中，我们需要按需设计，原则上不能低估秒杀请求量，但也不要用大炮打蚊子</p><!--要点作为线索牵引--><p>在秒杀系统中，我认为最大的挑战是高并发和高精准。</p><p>解决高并发思路：</p><p>1.限流：</p><p>￮    接口限流：限流组件Hystrix、Sentinel或者redis+Lua脚本</p><p>￮    提前预约机制</p><p>￮    问题验证码机制</p><p>2.降级：核心思想就是丢车保帅，优先保证核心业务，降级的目的在于应对系统自身的故障</p><p>3.熔断：可以防止因为秒杀交易影响到其他正常服务的提供</p><p>4.流量削峰：采用MQ</p><p>解决高精准的思路：</p><p>1.采用Redis+Lua脚本判断当前库存是否够，如果够就扣减，先对 Redis 的库存进行更新，然后再异步同步到 MySQL 的库存。这里的异步实现方式建议使用 MQ，由 MQ 保证消息被消费，实现最终一致性，毕竟秒杀场景本身就要引入 MQ 进行流量削峰。</p><p>任务对比库存和名额，解决少卖；除此之外，也要考虑到了黄牛打击、限频兜底，用户体验等问题</p><!--收尾--><p>以上就是我对秒杀系统的设计，有不成熟的地方还请指教</p><h2 id="3-短链系统">3.短链系统</h2><p><img src="2025-01-09-%E5%9C%BA%E6%99%AF%E9%A2%98/clip_image004.jpg" alt="img"></p><h2 id="4-排行榜">4.排行榜</h2><p><img src="2025-01-09-%E5%9C%BA%E6%99%AF%E9%A2%98/clip_image005.jpg" alt="img"></p><h2 id="5-缓存一致保证">5.缓存一致保证</h2><p><a href="https://mp.weixin.qq.com/s/_VyHzICG_qZENjjnHGC0UA">https://mp.weixin.qq.com/s/_VyHzICG_qZENjjnHGC0UA</a></p><p><img src="2025-01-09-%E5%9C%BA%E6%99%AF%E9%A2%98/clip_image006.jpg" alt="img"></p><h2 id="6-如果要你设计一个线程池，你觉得这个线程池要提供哪些功能，以及它内部应该是怎么样的一个实现的逻辑，你能描述一下吗？">6.如果要你设计一个线程池，你觉得这个线程池要提供哪些功能，以及它内部应该是怎么样的一个实现的逻辑，你能描述一下吗？</h2><p>如果要我来实现一个线程池的话，我首先会考虑它实际的应用场景大概是什么样子的，然后提供什么功能。一般线程池的场景的话就是，加快数据的读取速度之类的，怎么创建线程这些就是最基础的功能的考虑。然后也会对一些异常场景或者是做一些完整性的考虑，比如说线程这个创建之后该怎么进行回收处理，因为不能让这个线程无限制的增加下去占用资源。  同时的话如果线程和线程之间会存在优先级之类的问题，那么就要在设计的时候考虑到抢占相关的机制设计，那抢占这样的话就会有很多不同的策略，可能是根据执行的时间或者是给固定的时间，然后进行分别的调度。可以根据不同的业务设计不同的调度的策略。设计完成之后的话，一般还要再进行功能测试和性能测试，进行优化的迭代。  如何设置一个最优的线程数？  如果我们的任务主要是进行计算，那么就意味着CPU的处理能力是稀缺的资源，我们能够通过大量增加线程数提高计算能力吗？往往是不能的，如果线程太多，反倒可能导致大量的上下文切换开销。所以，这种情况下，通常建议按照CPU核的数目N或者N+1。  如果是需要较多等待的任务，例如I/O操作比较多，可以参考Brain Goetz推荐的计算方法：线程数 = CPU核数 × 目标CPU利用率 ×（1 + 平均等待时间/平均工作时间）</p><p>以下是关于LRU cache的设计相关内容：</p><h2 id="7-设计一个-LRU-的这样的-cache，内部的关键的数据结构，数据的读写的流程">7.设计一个 LRU 的这样的 cache，内部的关键的数据结构，数据的读写的流程</h2><p>关键数据结构</p><p>通常使用哈希表和双向链表来实现LRU cache。</p><p>•     双向链表：用于维护数据的使用顺序。链表头部是最近使用的数据，尾部是最久未使用的数据。这样可以在O(1)时间复杂度内实现数据节点的插入和删除操作。</p><p>•     哈希表：用于快速访问缓存中的数据，通过键值对的形式存储，能在O(1)时间复杂度内判断数据是否存在于缓存中，并获取对应的数据节点。哈希表的键为缓存数据的键，值为双向链表中对应节点的引用。</p><p>数据读写流程</p><p>•     读操作：</p><p>￮    首先通过哈希表查找给定键对应的节点是否存在于缓存中。</p><p>￮    如果存在，将该节点从当前位置移动到双向链表的头部，表示该数据最近被使用过，并返回对应的值。</p><p>￮    如果不存在，说明缓存未命中，返回相应的未命中标识。</p><p>•     写操作：</p><p>￮    先在哈希表中查找要写入的键是否已存在。</p><p>￮    如果存在，更新对应节点的值，并将该节点移动到双向链表的头部。</p><p>￮    如果不存在，判断缓存是否已满。若缓存未满，在双向链表头部插入新节点，并在哈希表中添加对应的键值对；若缓存已满，先移除双向链表尾部的节点（即最近最少使用的数据），并从哈希表中删除对应的键值对，然后再在双向链表头部插入新节点，并在哈希表中添加新的键值对。</p><p>并发控制设计</p><p>•     读写锁：可以使用读写锁来控制并发访问。读操作时获取读锁，多个读操作可以同时进行；写操作时获取写锁，写锁与读锁、写锁与写锁之间互斥，确保在写操作时没有其他读或写操作并发执行，保证数据的一致性。</p><p>•     分段锁：将整个缓存按 key 的 hash 值划分为多个 Segment，每个 Segment 内部维护一个小型 LRU 缓存（HashMap + 双向链表），并持有自己的锁。操作各自区域的数据时只锁定当前 Segment，不同 Segment 的操作可以并发执行，降低了锁的竞争范围，提高并发性能。</p><p>•     细粒度控制：增加状态量和变动信息来进行更细粒度的判断。例如，记录每个操作涉及的数据范围，每次操作进来时，根据当前状态和要操作的数据范围判断是否存在冲突，以此来决定是否允许并发执行。</p><h2 id="8-如何设计一个扫码登录系统？">8.如何设计一个扫码登录系统？</h2><h2 id="9-时钟回拨怎么解决？">9.时钟回拨怎么解决？</h2><p>美团leaf的解决方案，并且说了可以将机器号拆出几位作为时钟序号，每次回拨就自增。个人更喜欢后者，更轻量级</p>]]></content>
      
      
      <categories>
          
          <category> 面试题 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 场景题 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Redis面试题</title>
      <link href="/posts/2025-01-09-Redis%E9%9D%A2%E8%AF%95%E9%A2%98.html"/>
      <url>/posts/2025-01-09-Redis%E9%9D%A2%E8%AF%95%E9%A2%98.html</url>
      
        <content type="html"><![CDATA[<h1>学习</h1><h2 id="1-大key热key问题">1.大key热key问题</h2><blockquote><p><a href="https://xiaolincoding.com/redis/storage/bigkey_aof_rdb.html">Redis 大 Key 对持久化有什么影响？</a></p><p><a href="https://www.cnblogs.com/rjzheng/p/10874537.html">【原创】谈谈redis的热key问题如何解决 - 孤独烟 - 博客园</a></p><p><a href="https://xiaolincoding.com/redis/cluster/cache_problem.html">什么是缓存雪崩、击穿、穿透？</a></p></blockquote><p><img src="2025-01-09-Redis%E9%9D%A2%E8%AF%95%E9%A2%98/diagram.png" alt=""></p><h1>概念</h1><h2 id="1-说说你对Redis的理解">1. 说说你对Redis的理解</h2><p>Redis是一个基于Key - Value存储结构的开源内存数据库，也是一种NoSQL数据库。</p><p>它支持多种数据类型，包括String、Map、Set、ZSet和List，以满足不同应用场景的需求。</p><p>Redis以内存存储和优化的数据结构为基础，提供了快速的读写性能和高效的数据访问。常被用作应用与数据库之间的缓存组件，提升数据IO效率。</p><p>此外，Redis支持主从复制、哨兵机制和集群方式，实现高可用性和水平扩展。 </p><p><img src="2025-01-09-Redis%E9%9D%A2%E8%AF%95%E9%A2%98/image2.png" alt=""></p><ol><li><p><strong>主从复制</strong>：主从复制是Redis最基本的高可用方案，它通过将一个Redis实例作为主节点，将多个Redis实例作为从节点，实现数据的同步复制。主节点负责写入数据，从节点负责读取数据，当主节点宕机时，从节点可以自动切换成主节点，保证系统的可用性。</p></li><li><p><strong>哨兵机制</strong>：哨兵机制是Redis提供的一种自动故障转移方案，它可以监控主节点的状态，当主节点宕机时，自动将从节点切换成主节点，保证系统的可用性。哨兵机制还可以监控从节点的状态，当从节点宕机时，自动将从其他从节点中选举一个节点切换成主节点。</p></li><li><p><strong>集群方式</strong>：集群方式是Redis提供的一种分布式方案，它将多个Redis实例组成一个集群，每个实例负责一部分数据。集群方式可以自动将数据分配到不同的节点上，保证系统的可用性和扩展性。集群方式还可以自动将数据备份到其他节点上，保证数据的可靠性。 </p></li></ol><h2 id="2-⭐️Redis的热Key问题如何解决">2. ⭐️Redis的热Key问题如何解决</h2><p>首先一般来说我们生产环境用的都是redis集群来做缓存，hotkey主要是指某个特定的key，分布到了redis集群某个节点上，但是相比于其他同类型的key，这个key的访问频率极高，导致存储这个key的redis节点负载过高，可能导致redis不可用，实际生产环境中比如有：某个商品突然成为爆品，结果大家都去买他，大量的查询达到对应商品缓存所在redis节点。</p><p><strong>解决方案：</strong>对于可预知的hot key问题，比如商品秒杀，我们在发布商品的时候就需要对这些活动商品进行<strong>缓存预热</strong>，并且利用分布式缓存本地缓存来帮助提高我们的查询性能，对于不可预知的场景，我们一般来说都会接入我们的热点探测系统，定期上报我们对应key的调用次数，有热点探测系统检测是否是热key，然后通过sdk通知各个应用节点快速构建本地缓存，来抗住这些热key带来的流量，当然我们也有兜底的方案，比如：限流熔断等。 </p><h2 id="3-一个REDIS实例最多能存放多少KEYS">3. 一个REDIS实例最多能存放多少KEYS</h2><p>Redis的每个实例最多可以存放<strong>2^32 - 1</strong>个keys，即大约42亿个keys，这是由Redis内部使用的哈希表决定的，它使用32位无符号整数作为索引。Redis使用的哈希函数和负载因子等因素也会影响实际可存放键的数量。</p><p>需要注意的是，尽管Redis允许存储数量庞大的键，但在实践中，存储过多的键可能会导致性能下降和内存消耗增加。因此，在设计应用程序时，需要根据实际需求和硬件资源来合理规划键的数量，避免过度使用Redis实例造成负担。如果需要存储更多的键值对，可以考虑使用Redis集群或分片技术，以扩展整体存储容量。 </p><h2 id="4-Redis为什么这么快">4. Redis为什么这么快</h2><ol><li><p>首先redis是基于内存的nosql数据库，基于内存的读写效率本身就非常高</p></li><li><p>redis内部对应核心命令的执行采用了单线程模型，并且给予内存模型，单条命令的执行速度远小于线程上下文的开销，所以使用单线程能够大大提升我们redis的吞吐量</p></li><li><p>内部提供了高亮查询和操作的数据结构</p></li><li><p>采用IO多路复用模型，能够同时处理大量连接，并且使用reator模型，能够并发的处理连接以及对连接进行响应，但是内部命令执行还是单线程的</p></li><li><p>5.对redis常用操作进行优化，提供了管道技术和批量操作技术，能够减少单次redis操作的网络开销</p></li></ol><h2 id="5-怎么实现Redis的高可用？">5. 怎么实现Redis的高可用？</h2><ol><li><p><strong>主从复制</strong>：通过设置主从复制，将主节点的数据同步到多个从节点上。主节点负责处理写操作，并将写操作的日志复制给从节点，从节点则负责处理读请求。如果主节点发生故障，可以将一个从节点升级为新的主节点，从而实现故障转移和高可用。</p></li><li><p><strong>哨兵机制</strong>：使用Redis哨兵来监控主节点和从节点的状态。哨兵是一组独立运行的进程，它会监控Redis实例的健康状态，并在主节点出现故障时自动进行故障转移。它还能够监控从节点，并在需要时将其提升为主节点。</p></li><li><p><strong>集群模式</strong>：Redis集群是一种分布式方案，可以将多个Redis节点组成一个逻辑集群，提供数据分片和自动故障恢复。每个节点负责存储和处理部分数据，通过节点间的数据分片和分布式算法保证数据的可用性和负载均衡。当集群中的某个节点出现故障时，集群会自动进行故障转移和恢复。 </p></li></ol><h2 id="6-Redis是单线程还是多线程">6. Redis是单线程还是多线程</h2><p>Redis 6.x版本引入了多线程的I/O处理，但这并不改变其核心数据处理的单线程特性。多线程I/O处理主要用于处理网络I/O，以提高<strong>网络吞吐量</strong>，而核心的数据操作仍然由单个主线程处理。</p><p>总的来说，Redis的单线程模型是其设计的一个核心特点，它使得Redis在保持简单性的同时，能够提供极高的性能。 </p><h2 id="7-⭐️为什么Redis-单线程模型效率也能那么高">7. ⭐️为什么Redis 单线程模型效率也能那么高</h2><p>尽管Redis采用了单线程模型，但其效率仍然非常高。以下是一些原因：</p><ol><li><p><strong>非阻塞IO</strong>：Redis使用了事件驱动的非阻塞IO机制。它通过事件循环处理来自客户端的请求，在等待数据IO时并不会阻塞主线程，而是继续处理其他请求。这种机制允许Redis以高效地方式处理大量的并发连接。</p></li><li><p><strong>内存操作</strong>：Redis主要将数据存储在内存中，并且由于单线程模型的存在，在内存操作的情况下，Redis可以通过简单的指针操作来实现快速读写，而不需要考虑复杂的数据同步和竞争条件。</p></li><li><p><strong>单线程避免的开销</strong>：与多线程模型相比，单线程模型避免了线程间的上下文切换、锁竞争和资源管理开销。这使得Redis可以更高效地使用CPU资源，并减少了大量与线程相关的开销。</p></li></ol><p>需要注意的是，Redis单线程模型适合于处理大量的短期操作和快速响应的场景，但在处理长时间运行的计算密集型任务时可能会有性能上的不足。为了提高处理能力和并发性，可以使用Redis的集群模式、多实例部署或将计算密集型任务委托给其他更适合的工具或语言来处理。</p><h2 id="8-说说你对Redis操作原子性的理解">8. 说说你对Redis操作原子性的理解</h2><p>Redis的操作是原子性的，这是因为Redis的每个命令都是以单线程的方式执行的，整个命令的执行过程是不可中断的，要么全部执行成功，要么全部执行失败。</p><p>在Redis中，每个命令都会被转换成一个或多个底层操作，这些操作会基于数据结构的特定实现来执行。比如，对于字符串类型，获取一个键值对、设置一个键值对等操作都是原子性的。在执行这些底层操作时，Redis会使用一些技术来保证原子性，主要包括以下两点：</p><ol><li><p>Redis使用单线程模型，避免了多线程之间的竞争条件和锁开销，从而保证了操作的原子性。</p></li><li><p>Redis在执行一些复杂的操作时，比如事务、Lua脚本等，会将多个底层操作打包成一个原子性操作，这些底层操作要么全部执行成功，要么全部执行失败。在事务和Lua脚本中，Redis同时支持回滚操作，即当一些命令执行成功，后面的命令出错时，Redis可以自动撤销已经执行的命令。</p></li></ol><p>因此，Redis的操作是原子性的，这得益于Redis单线程模型和底层操作的实现方式。这种原子性操作保证了Redis能够提供高效和可靠的服务。 </p><h1>数据结构 </h1><h2 id="1-说说-Redis-的数据类型">1. 说说 Redis 的数据类型</h2><p>Redis支持五种主要的数据类型：</p><ol><li><p><strong>String</strong>：String是最常用的数据类型，在Redis中以二进制安全的方式存储字符串。它可以包含任何类型的数据，比如文本、整数或二进制数据。</p></li><li><p><strong>Hash</strong>：Hash是一个键值对的集合，其中每个键都与一个值相关联。在Redis中，Hash可以用于存储和操作对象，每个键值对相当于对象的字段和值。</p></li><li><p><strong>List</strong>：List是一个按照插入顺序排序的字符串元素集合。集合中的元素可以重复，可以从列表的两端进行插入和删除操作，可用于实现队列、栈等数据结构。</p></li><li><p><strong>Set</strong>：Set是一个无序、唯一的字符串集合，不允许重复的成员。可以对集合执行添加、删除和判断成员是否存在等操作，也支持集合间的交集、并集和差集运算。</p></li><li><p><strong>Sorted Set</strong>：Sorted Set是一个有序的字符串集合，每个成员都关联着一个分数。集合中的成员根据分数的大小进行排序，可以进行范围查询和按分数排名操作。</p></li></ol><p>除了这些主要的数据类型，Redis还提供了其他一些特殊的数据结构和功能，如HyperLogLog用于基数统计、Geo用于地理位置信息存储、Pub/Sub用于发布与订阅等。 </p><h2 id="2-❓Redis底层数据结构？">2.❓Redis底层数据结构？</h2><p><a href="https://xiaolincoding.com/redis/data_struct/command.html">Redis 常见数据类型和应用场景</a></p><p><img src="2025-01-09-Redis%E9%9D%A2%E8%AF%95%E9%A2%98/diagram-1.png" alt=""></p><p><a href="https://xiaolincoding.com/redis/data_struct/data_struct.html#%E9%94%AE%E5%80%BC%E5%AF%B9%E6%95%B0%E6%8D%AE%E5%BA%93%E6%98%AF%E6%80%8E%E4%B9%88%E5%AE%9E%E7%8E%B0%E7%9A%84">Redis 数据结构</a></p><p><img src="2025-01-09-Redis%E9%9D%A2%E8%AF%95%E9%A2%98/image-1.png" alt=""></p><h2 id="3-❓为什么用跳表，不用红黑树、B-树">3.❓为什么用跳表，不用红黑树、B+树</h2><p>答：因为ZSet有一个核心功能是范围查找，采用跳表可以比较容易查找到一个范围的起点和终点（依次往后查找），而红黑树不行。且跳表比红黑树实现更简单，更容易实现，可以通过控制跳表的索引层级来控制内存的消耗。</p><h1>持久化</h1><h2 id="1-说说Redis的持久化机制">1. 说说Redis的持久化机制</h2><p>Redis有两种持久化机制：RDB和AOF。</p><ul><li><p><strong>RDB</strong>：是一种快照持久化的方式，它会将Redis在某个时间点的数据状态以二进制的方式保存到硬盘上的一个文件中。RDB持久化可以通过配置定时或手动触发，也可以设置自动触发的条件。RDB的优点是生成的文件比AOF文件更小，恢复速度也更快，适合用于备份和灾难恢复。</p></li><li><p><strong>AOF</strong>：是一种追加日志持久化方式，它会将Redis执行的写命令追加到一个文件的末尾。当Redis重启时，它会重新执行这些写命令来恢复数据状态。AOF提供了更可靠的持久化方式，因为它可以保证每个写操作都被记录下来，并且不会发生数据丢失的情况。AOF文件可以根据配置进行同步写入硬盘的频率，包括每秒同步、每写入命令同步和禁用同步三种模式。 </p></li></ul><h2 id="2-AOF的三种写回策略？​">2.AOF的三种写回策略？​</h2><p>Always、Everysec 和 No，这三种策略在可靠性上是从高到低，而在性能上从低到高。</p><p>Always是每次写操作命令执行完后，同步将 AOF 日志数据写回硬盘；Everysec每次写操作命令执行完后，先将命令写入到 AOF 文件的内核缓冲区，然后每隔一秒将缓冲区里的内容写回到硬盘；No就是不控制写回硬盘的时机。每次写操作命令执行完后，先将命令写入到 AOF 文件的内核缓冲区，再由操作系统决定何时将缓冲区内容写回硬盘。</p><h2 id="3-AOF的磁盘重写机制？​">3.AOF的磁盘重写机制？​</h2><p>随着执行的命令越多，AOF 文件的体积自然也会越来越大，为了避免日志文件过大， Redis 提供了 AOF 重写机制，它会直接扫描数据中所有的键值对数据，然后为每一个键值对生成一条写操作命令，接着将该命令写入到新的 AOF 文件，重写完成后，就替换掉现有的 AOF 日志。重写的过程是由后台子进程完成的，这样可以使得主进程可以继续正常处理命令。</p><h2 id="4-AOF的重写的具体过程？​">4.AOF的重写的具体过程？​</h2><p>触发重写机制后，主进程会创建重写 AOF 的子进程，此时父子进程共享物理内存，重写子进程只会对这个内存进行只读。重写 AOF 子进程读取数据库里的所有数据，并逐一把内存数据的键值对转换成一条命令，再将命令记录到重写日志。</p><p>在发生写操作的时候，操作系统才会去复制物理内存，这样是为了防止 fork 创建子进程时，由于物理内存数据的复制时间过长而导致父进程长时间阻塞的问题。</p><h2 id="5-为什么先执行Redis命令，再把数据写入AOF日志呢？">5.为什么先执行Redis命令，再把数据写入AOF日志呢？</h2><p>好处:</p><ul><li><p>保证正确写入：如果当前的命令语法有问题，错误的命令记录到AOF日志里后可能还会进行语法检查。先执行Redis命令，再把数据写入AOF日志可以保证写入的都是正确可执行的命令。</p></li><li><p>不阻塞当前写操作：因为当写操作命令执行成功后才会将命令记录到AOF日志，避免写入阻塞。</p></li></ul><p>缺陷：</p><ul><li><p>数据可能会丢失：执行写操作命令和记录日志是两个过程，Redis还没来得及将命令写入到硬盘时发生宕机，数据会有丢失的风险。</p></li><li><p>阻塞其他操作：不会阻塞当前命令的执行，但因为AOF日志也是在主线程中执行，所以当Redis把日志文件写入磁盘的时候，还是会阻塞后续的操作无法执行。 </p></li></ul><h2 id="6-AOF子进程的内存数据跟主进程的内存数据不一致怎么办？​">6.AOF子进程的内存数据跟主进程的内存数据不一致怎么办？​</h2><p>Redis设置了一个 AOF 重写缓冲区，这个缓冲区在创建 bgrewriteaof 子进程之后开始使用。在重写 AOF 期间，当 Redis 执行完一个写命令之后，它会同时将这个写命令写入到AOF 缓冲区和AOF 重写缓冲区。当子进程完成 AOF 重写工作后，会向主进程发送一条信号。主进程收到该信号后，会调用一个信号处理函数，将 AOF 重写缓冲区中的所有内容追加到新的 AOF 的文件中，使得新旧两个 AOF 文件所保存的数据库状态一致；新的 AOF 的文件进行改名，覆盖现有的 AOF 文件。</p><h2 id="7-RDB-在执行快照的时候，数据能修改吗？​">7.RDB 在执行快照的时候，数据能修改吗？​</h2><p>可以。执行 bgsave 过程中，Redis 依然可以继续处理操作命令的，数据是能被修改的，采用的是写时复制技术（Copy-On-Write, COW）。执行 bgsave 命令的时候，会通过 fork（）创建子进程，此时子进程和父进程是共享同一片内存数据的，因为创建子进程的时候，会复制父进程的页表，但是页表指向的物理内存还是一个，由于共享父进程的所有数据，可以直接读取主线程里的内存数据，并将数据写入到 RDB 文件。此时如果主线程执行读操作，则主线程和 bgsave 子进程互相不影响。如果主线程要修改共享数据里的某一块数据，就会发生写时复制，数据的物理内存就会被复制一份，主线程在这个数据副本进行修改操作。与此同时，子进程可以继续把原来的数据写入到 RDB 文件。</p><h2 id="11-说说Redis的过期策略">11. 说说Redis的过期策略</h2><p>对于redis的数据，如果过期了，并不会立刻自动取删除他，主要有两种方案，第一种惰性删除，只有当我们下一次再查询他的时候，发现他已经过期了，再删除，否则会常驻在内存中，优点是减少删除的开销，但是会浪费内存。</p><p>第二种是：定期删除，redis每个一段时间内，会去检查哪些key已经过期，然后释放过期key占用的空间</p><p>第三种：一般来说我们会配合二者一起使用</p><p><strong>Redis 选择惰性删除+定期删除这两种策略配和使用</strong>，以求在合理使用 CPU 时间和避免内存浪费之间取得平衡。Redis 在访问或者修改 key 之前，都会调用 expireIfNeeded 函数对其进行检查，检查 key 是否过期：​如果过期，则删除该 key，然后返回 null 客户端；​如果没有过期，不做任何处理，然后返回正常的键值对给客户端；​</p><p>每隔一段时间，从过期字典中随机抽取 20 个 key；检查这 20 个 key 是否过期，并删除已过期的 key；已过期 key 的数量占比随机抽取 key 的数量大于 25%，则继续重复步骤直到比重小于25%。</p><h2 id="12-说说Redis的内存淘汰策略">12.说说Redis的内存淘汰策略</h2><p><strong>不进行数据淘汰的策略</strong></p><p>它表示当运行内存超过最大设置内存时，不淘汰任何数据，这时如果有新的数据写入，则会触发OOM，只是单纯的查询或者删除操作的话还是可以正常工作。</p><p><strong>进行数据淘汰的策略</strong></p><p>在设置了过期时间的数据中进行淘汰：</p><p>在所有数据范围内进行淘汰：</p><h2 id="13-Redis持久化时对过期键会如何处理的？​">13.Redis持久化时对过期键会如何处理的？​</h2><p><strong>RDB</strong></p><p>RDB分文生成阶段和加载阶段，生成阶段会对key进行过期检查，过期的key不会保存到RDB文件中；加载阶段看服务器是主服务器还是从服务器，如果是主服务器，在载入 RDB 文件时，程序会对文件中保存的键进行检查，过期键不会被载入到数据库中；如果从服务器，在载入 RDB 文件时，不论键是否过期都会被载入到数据库中。但由于主从服务器在进行数据同步时，从服务器的数据会被清空。过期键对载入 RDB 文件的从服务器也不会造成影响。</p><p><strong>AOF</strong></p><p>AOF文件写入阶段和AOF重写阶段。写入阶段如果数据库某个过期键还没被删除，AOF 文件会保留此过期键，当此过期键被删除后，Redis 会向 AOF 文件追加一条 DEL 命令来显式地删除该键值。重写阶段会对 Redis 中的键值对进行检查，已过期的键不会被保存到重写后的 AOF 文件中。</p><h2 id="14-Redis主从模式中，对过期键会如何处理？">14.Redis主从模式中，对过期键会如何处理？</h2><p>从库不会进行过期扫描，从库的过期键处理依靠主服务器控制，主库在 key 到期时，会在 AOF 文件里增加一条 del 指令，同步到所有的从库，从库通过执行这条 del 指令来删除过期的 key。</p><p>如果主从同步发生意外，原本主库的 key 过期了，但是 del 指令没有同步给从库成功，导致从库内存中存在已经过期但没有删除的 key，这时候有客户端访问从库时，即使 key 还是在内存的，但是从库发现 key 是过期（根据过期时间）的，就不会返回 key 的数据给客户端了。</p><h1>应用</h1><h2 id="1-Redis有哪些常用应用场景">1. Redis有哪些常用应用场景</h2><ol><li><p><strong>缓存</strong>：Redis可以作为缓存层，加速访问频繁的数据。由于其高性能、支持持久化和数据结构丰富等特点，使其成为一个理想的缓存解决方案。在缓存方面，Redis能够存储热点数据、频繁查询结果、会话数据等，从而减轻数据库负载，提高系统整体性能。</p></li><li><p><strong>会话存储</strong>：Redis可以用于存储用户会话数据，特别是在分布式系统中，多个服务器之间共享会话数据非常方便。这在网站、应用程序中管理用户登录状态、购物车信息等方面非常有用。</p></li><li><p><strong>消息队列</strong>：Redis的发布/订阅功能以及List数据结构的弹性特性，使其可以作为轻量级消息队列使用。应用程序可以将消息发布到Redis，而其他应用程序可以订阅这些消息并处理它们，实现解耦和异步通信。</p></li><li><p><strong>计数器</strong>：Redis的原子操作和计数器数据结构使其成为实现各种计数功能的理想选择。比如，可以用来统计网站的点击量、点赞数、在线用户数等。</p></li><li><p><strong>实时排行榜</strong>：Redis的有序集合数据结构非常适合实现实时排行榜功能。通过将用户得分作为有序集合的成员，可以轻松地获取排行榜数据并支持快速的更新。</p></li><li><p><strong>分布式锁</strong>：Redis的SETNX命令可以用来实现分布式锁，保证在分布式环境下对共享资源的互斥访问。</p></li><li><p><strong>分布式状态存储</strong>：除了会话数据，Redis还可以用来存储应用程序的状态信息，比如用户的偏好设置、临时状态等。 </p></li></ol><h2 id="2-什么是缓存击穿、缓存穿透、缓存雪崩">2. 什么是缓存击穿、缓存穿透、缓存雪崩</h2><p><img src="2025-01-09-Redis%E9%9D%A2%E8%AF%95%E9%A2%98/image14.png" alt=""></p><p><a href="https://ls8sck0zrg.feishu.cn/wiki/IqzrwXjITiFZ6mkqQoHcsPq8nkg#share-N16YdrTvOo1CyVxr2ttcxJR1n0d">https://ls8sck0zrg.feishu.cn/wiki/IqzrwXjITiFZ6mkqQoHcsPq8nkg#share-N16YdrTvOo1CyVxr2ttcxJR1n0d</a></p><h2 id="3-布隆过滤器是怎么工作的？">3.布隆过滤器是怎么工作的？</h2><p>布隆过滤器由初始值都为0的位图数组和N个哈希函数两部分组成。在写入数据库数据时，在布隆过滤器里做个标记，这样下次查询数据是否在数据库时，只需要查询布隆过滤器，如果查询到数据没有被标记，说明不在数据库中。</p><ul><li><p>第一步，使用N个哈希函数分别对数据做哈希计算，得到N个哈希值</p></li><li><p>第二步，将第一步得到的N个哈希值对位图数组的长度取模，得到每个哈希值在位图数组的对应位置</p></li><li><p>第三步，将每个哈希值在位图数组的对应位置的值设置为1、</p></li></ul><p>缺陷</p><ul><li><p>布隆过滤器由于是基于哈希函数实现查找的，会存在哈希冲突的可能性，数据可能落在相同位置，存在误判的情况。查询布隆过滤器说数据存在，并不一定证明数据库中存在这个数据，但是查询到数据不存在，数据库中一定就不存在这个数据。</p></li><li><p>不支持一个关键字的删除，因为一个关键字的删除会牵连其他的关键字。改进方法就是counting Bloom filter，用一个counter数组代替位数组，就可以支持删除了。</p></li><li><p>对于输入的n个元素，要确定数组m大小和hash函数的个数，hash函数个数k = (ln2) * (m/n) 时，错误率最小。在错误率不大于E情况下，m至少要等于n*lg(1/E)才能表示n个元素的集合。 </p></li></ul><h2 id="4-如何保证数据库和缓存的一致性？">4.如何保证数据库和缓存的一致性？</h2><p><a href="https://mcnfxurl5vzo.feishu.cn/wiki/Tfj8wjNOei9by3kjWjVcL0pwn5g#share-ZIJvdlLucoi7wyxvThSc9iPFnbc"> 11.场景题</a></p><h3 id="Cache-Aside">Cache Aside</h3><ul><li><p>原理：<strong>先从缓存中读取数据，如果没有就再去数据库里面读数据，然后把数据放回缓存中，如果缓存中可以找到数据就直接返回数据；</strong>更新数据的时候先把数据持久化到数据库，然后再让缓存失效。</p></li><li><p>问题：假如有两个操作一个更新一个查询，第一个操作先更新数据库，还来不及删除缓存，查询操作可能拿到的就是旧的数据；更新操作马上让缓存失效了，所以后续的查询可以保证数据的一致性；<strong>还有的问题就是有一个是读操作没有命中缓存，然后就到数据库中取数据，此时来了一个写操作，写完数据库后，让缓存失效，然后，之前的那个读操作再把老的数据放进去，也会造成脏数据。</strong></p></li><li><p>可行性：出现上述问题的概率其实非常低，需要同时达成读缓存时缓存失效并且有并发写的操作。数据库读写要比缓存慢得多，所以读操作在写操作之前进入数据库，并且在写操作之后更新，概率比较低。</p></li></ul><h3 id="Read-Write-Through">Read/Write Through</h3><ul><li><p>原理：Read/Write Through原理是把更新数据库（Repository）的操作由缓存代理，应用认为后端是一个单一的存储，而存储自己维护自己的缓存。</p></li><li><p>Read Through：就是在查询操作中更新缓存，也就是说，当缓存失效的时候，Cache Aside策略是由调用方负责把数据加载入缓存，而Read Through则用缓存服务自己来加载，从而对调用方是透明的。</p></li><li><p>Write Through：当有数据更新的时候，如果没有命中缓存，直接更新数据库，然后返回。如果命中了缓存，则更新缓存，然后再由缓存自己更新数据库（这是一个同步操作）。 </p></li></ul><h3 id="Write-Behind">Write Behind</h3><p>原理：在更新数据的时候，只更新缓存，不更新数据库，而缓存会异步地批量更新数据库。这个设计的好处就是让数据的I/O操作非常快，带来的问题是，数据不是强一致性的，而且可能会丢。</p><h2 id="5-如何保证删除缓存操作一定能成功？​">5.如何保证删除缓存操作一定能成功？​</h2><p><strong>重试机制</strong></p><p>引入消息队列，删除缓存的操作由消费者来做，删除失败的话重新去消息队列拉取相应的操作，超过一定次数没有删除成功就像业务层报错。</p><p><strong>订阅BINLog</strong></p><p>订阅 binlog 日志，拿到具体要操作的数据，然后再执行缓存删除。可以让删除服务模拟自己伪装成一个 MySQL 的从节点，向 MySQL 主节点发送 dump 请求，主节点收到请求后，就会开始推送 BINLog ，删除服务解析 BINLog 字节流之后，转换为便于读取的结构化数据，再进行删除。</p><p>订阅bin log会跟 mq 结合一起用，通过 订阅bin log知道数据发生更新，然后投递给消息队列，然后让消息队列重试。</p><h2 id="6-业务一致性要求高怎么办？">6.业务一致性要求高怎么办？</h2><p><strong>先更新数据库再更新缓存</strong></p><p>可以先更新数据库再更新缓存，但是可能会有并发更新的缓存不一致的问题。解决办法是更新缓存前加一个分布式锁，保证同一时间只运行一个请求更新缓存，加锁后对于写入的性能就会带来影响；在更新完缓存时，给缓存加上较短的过期时间，出现缓存不一致的情况缓存的数据也会很快过期。</p><p><strong>延迟双删</strong></p><p>采用延迟双删，先删除缓存，然后更新数据库，等待一段时间再删除缓存。保证第一个操作再睡眠之后，第二个操作完成更新缓存操作。但是具体睡眠多久其实是个玄学，很难评估出来，这个方案也只是尽可能保证一致性而已，依然也会出现缓存不一致的现象。</p><p>提示：最好给锁设置过期时间防止阻塞。</p><blockquote><p><a href="https://ls8sck0zrg.feishu.cn/wiki/wikcnEJdzUmS3CgUHXUCjJY5Iad">https://ls8sck0zrg.feishu.cn/wiki/wikcnEJdzUmS3CgUHXUCjJY5Iad</a></p><p><a href="https://xiaolincoding.com/redis/architecture/mysql_redis_consistency.html#%E6%95%B0%E6%8D%AE%E5%BA%93%E5%92%8C%E7%BC%93%E5%AD%98%E5%A6%82%E4%BD%95%E4%BF%9D%E8%AF%81%E4%B8%80%E8%87%B4%E6%80%A7">数据库和缓存如何保证一致性？</a></p></blockquote><h2 id="7-⭐️说说你对缓存双写不一致的理解">7. ⭐️说说你对缓存双写不一致的理解</h2><p><strong>缓存不一致</strong>主要是指我们的业务系统里面引入了缓存提升我们查询性能，但是当我们数据库数据发生变更的时候，我们如何去保证缓存和数据库中数据的一致性问题，主要有两大种方案。</p><p>首先是异步通知，可以利用canal监听我们mysql的数据变化，然后发送变更缓存消息到mq，让业务系统去对缓存进行更新，由于我们一般监听binlog都是在从mysql上进行，而主从同步有一定的延时，监听完消息发送到mq又存在一定的延时，所以他的实时性不是很好，比较适合用在一致性要求不是很高的缓存场景，并且异步通知最大的优点就是解耦，对于更新缓存的逻辑不需要耦合在代码中<br>第二种方案也是得物使用规范的中最推荐的同步双写，之所以使用这种方案，就是非常多的业务中都涉及到钱相关，如果缓存长时间不一致容易造成大量的资损，比如：我们商品中心大量商品数据进行了缓存，此时我们管理员修改了价格，这个缓存怎么同步，其实就是缓存一致性的问题，对于这种一致性比较高的业务，我们推荐最佳方案是采用延时双删，先删缓存，然后写数据库，然后过500ms再删一次缓存，这种方案能够尽可能避免出现缓存不一致的问题，但是也是无法完全避免，因为可能出现一些极端情况，比如出现了慢SQL，查了半天还是旧数据，结果我们双删也删完了，他又走了旧数据的逻辑，但是这种都可以通过监控来进行优化，尽最大可能不出现问题。</p><p>如果想要保证强一致性，其实方案就是使用读写锁来保证了，但是一般C端业务，优先考虑用户体验性，如果不是直接操作钱一般不使用这种方案。</p><p><img src="2025-01-09-Redis%E9%9D%A2%E8%AF%95%E9%A2%98/image.png" alt=""></p><h2 id="8-如何实现延迟队列？">8.如何实现延迟队列？</h2><p>使用ZSet，ZSet有一个Score属性可以用来存储延迟执行的时间。使用zadd score1 value1命令，再利用zrangebyscore查询符合条件的所有待处理的任务，通过循环执行队列任务。</p><h2 id="9-如何设计一个缓存策略，可以动态缓存热点数据呢？">9.如何设计一个缓存策略，可以动态缓存热点数据呢？</h2><p>由于数据存储受限，系统并不是将所有数据都需要存放到缓存中的，而只是将其中一部分热点数据缓存起来，所以我们要设计一个热点数据动态缓存的策略。</p><p>热点数据动态缓存的策略总体思路：<strong>通过数据最新访问时间来做排名，并过滤掉不常访问的数据，只留下经常访问的数据。用zadd方法和zrange方法来完成排序队列和获取前面商品。</strong></p><p>例子：</p><p>以电商平台场景中的例子，现在要求只缓存用户经常访问的Top 1000的商品。具体细节如下：</p><ul><li><p>先通过缓存系统做一个排序队列（比如存放1000个商品），系统会根据商品的访问时间，更新队列信息，越是最近访问的商品排名越靠前；</p></li><li><p>同时系统会定期过滤掉队列中排名最后的200个商品，然后再从数据库中随机读取出200个商品加入队列中；</p></li><li><p>当请求每次到达的时候，会先从队列中获取商品ID，如果命中，就根据ID再从另一个缓存数据结构中读取实际的商品信息，并返回。 </p></li></ul><h2 id="10-⭐️分布式锁原理和潜在风险">10.⭐️分布式锁原理和潜在风险</h2><blockquote><p><a href="https://ls8sck0zrg.feishu.cn/wiki/Kdz7wj1g8il0SXkviJNcYDKEnHf">https://ls8sck0zrg.feishu.cn/wiki/Kdz7wj1g8il0SXkviJNcYDKEnHf</a></p></blockquote><ol><li><p><strong>Redis实现分布式锁原理</strong>：一个客户端想要加锁，就会去Redis中查找对应的key是否存在，如果不存在，就创建这个key，表示加锁成功，当另外一个客户端也想加锁时，发现这个key已经存在了，就会返回加锁失败。可以采用setnx命令将查询是否存在 - 创建key这个过程变成一个原子操作，或者使用Lua脚本，让Redis单线程执行这个脚本。</p></li><li><p><strong>潜在风险1</strong>：当一个客户端成功执行setnx进行加锁之后，结果执行del命令释放锁，却一直没有成功，导致锁没有释放，其他客户端无法获取锁，从而影响业务。</p><ul><li><strong>解决方法</strong>：给这个锁设置过期时间，当超过过期时间时，Redis会自动将其释放，可以采用setnx命令的nx参数，再使用px参数设置毫秒过期时间，或者ex参数（这是秒过期时间）。</li></ul></li><li><p><strong>潜在风险2</strong>：当客户端A成功加锁之后，但却被客户端B使用del命令进行删除，而如果马上有其他客户端来获取锁，就会和客户端A一起共享数据，造成业务逻辑错误。</p><ul><li><strong>解决方法</strong>：给这个锁对应的Value设置一个唯一标识，保证每个客户端的唯一标识不同，当删除锁的时候，需要先检查这个value是否与客户端标识一致才能进行删除。而这也导致删除锁操作变成了读取变量、判断变量、删除变量多个操作，需要保证执行的原子性，所以这里也需要整合Lua脚本，发送给Redis单线程执行。 </li></ul></li><li><p><strong>潜在风险3</strong>：当锁的过期时间已经到了，但业务还没有完成。</p><ul><li><strong>解决方法</strong>：启动一个看门狗（go启动一个goroutine），在过期之前刷新一下过期时间。 </li></ul></li></ol><h2 id="11-使用Redis实现分布式锁的优点和缺点">11.使用Redis实现分布式锁的优点和缺点?</h2><ul><li><p>优点：性能高效；实现方便；避免单点故障。</p></li><li><p>缺点：超时时 间不好设置。如果锁的超时间设置过长，会影响性能，如果设置的超时间过短会保护不到共享资源。Redis主从复制模式中的数据是异步复制的，导致分布式锁的不可靠性。如果在Redis主节点获取到锁后，在没有同步到其他节点时，Redis主节点宕机了，此时新的Redis主节点依然可以获取锁，所以多个应用服务就可以同时获取到锁。</p></li></ul><h2 id="12-如何为分布式锁设置合理的超时时间">12.如何为分布式锁设置合理的超时时间?</h2><p>可以基于续约的方式设置超时时间：先给锁设置一个超时时间，然后启动一个守护线程，让守护线程在一段时间后，重新设置这个锁的超时时间。实现方式就是：写一个守护线程，然后去判断锁的情况，当锁快失效的时候，再次进行续约加锁，当主线程执行完成后，销毁续约锁即可，不过这种方式实现起来相对复杂。 </p><h2 id="13-❓Redis解决集群情况下分布式锁的可靠性">13.❓Redis解决集群情况下分布式锁的可靠性?</h2><p>分布式锁算法Redlock（红锁）。基于多个Redis节点的分布式锁，即使有节点发生了故障，锁变量仍然是存在的，客户端还是可以完成锁操作。官方推荐是至少部署5个Redis节点，而且都是主节点，它们之间没有任何关系，都是一个个孤立的节点。</p><p><strong>基本思路：</strong>是让客户端和多个独立的Redis节点依次请求申请加锁，<strong>如果客户端能够和半数以上的节点成功地完成加锁操作，那么就认为，客户端成功地获得分布式锁</strong>，否则加锁失败。即使有某个Redis节点发生故障，锁的数据在其他节点上也有保存，客户端仍然可以正常地进行锁操作，锁的数据也不会丢。</p><p>Redlock算法加锁三个过程：</p><p>加锁成功要同时满足两个条件：有超过半数的Redis节点成功的获取到了锁，并且总耗时没有超过锁的有效时间，那么就是加锁成功。</p><p>加锁成功后，客户端需要重新计算这把锁的有效时间，计算的结果是「锁最初设置的过期时间」减去「客户端从大多数节点获取锁的总耗时（t2-t1）」。如果计算的结果已经来不及完成共享数据的操作了，可以释放锁，以免出现还没完成数据操作，锁就过期了的情况。加锁失败后，客户端向所有Redis节点发起释放锁的操作，执行释放锁的Lua脚本就可以。 </p><h2 id="14-Redis管道有什么用？">14.Redis管道有什么用？</h2><p>管道技术是客户端提供的一种批处理技术，用于一次处理多个 Redis 命令，从而提高整个交互的性能。使用管道技术可以解决多个命令执行时的网络等待，它是把多个命令整合到一起发送给服务器端处理之后统一返回给客户端，这样就免去了每条命令执行后都要等待的情况，从而有效地提高了程序的执行效率。</p><p>但使用管道技术也要注意避免发送的命令过大，或管道内的数据太多而导致的网络阻塞。管道技术本质上是客户端提供的功能，而非 Redis 服务器端的功能。</p><blockquote><p>Redis 的IO多路复用用的是管道？</p><h2 id="说说你对PIPELINE的理解">说说你对PIPELINE的理解</h2><p>redis本端网络通信使用的是Redis协议，本质上是把我们的命令通过协议包装发送给redis，需要经过编码解码和网络传输的过程。如果每次发送的数据较少，能够把时间消耗在解码和拆包的时间短，时间全浪费在这些时间上了，此时我们就可以使用<strong>pipeline，单次网络通信传输一堆指令，减少网络通信来回的次数。 </strong></p></blockquote><h2 id="15-Redis如何处理大key">15.Redis如何处理大key?</h2><p><strong>定义：String类型的值大于10 KB；Hash、List、Set、ZSet类型的元素的个数超过5000个；</strong></p><p><strong>影响：</strong></p><p><strong>处理：</strong></p><ul><li><p>把大key拆分成多个小key来存储。比如把一个大的哈希结构分割成多个小的哈希结构，减少单个key的大小以降低内存的压力。</p><ul><li><p>当value是string时，比较难拆分，则使用序列化、压缩算法将key的大小控制在合理范围内，但是序列化和反序列化都会带来更多时间上的消耗。</p></li><li><p>当value是string，压缩之后仍然是大key，则需要进行拆分，一个大key分为不同的部分，记录每个部分的key，使用multiget等操作实现事务读取。</p></li><li><p>分拆成几个key-value，存储在一个hash中，每个field代表一个具体的属性，使用hget，hmget来获取部分的value，使用hset，hmset更新部分属性</p></li><li><p>当value是list/set等集合类型时，根据预估的数据规模来进行分片，不同的元素计算后分到不同的片。 </p></li></ul></li><li><p>搭建redis集群，把key分配到不同的节点上，降低单个redis节点的存储压力。</p></li></ul><h2 id="16-Redis支持事务回滚吗？">16.Redis支持事务回滚吗？</h2><p>不支持，Redis 提供的 DISCARD 命令只能用来主动放弃事务执行，把暂存的命令队列清空，起不到回滚的效果。因为Redis 事务的执行时，错误通常都是编程错误造成的，这种错误通常只会出现在开发环境中，而很少会在实际的生产环境中出现，所以官方认为没有必要为 Redis 开发事务回滚功能。</p><h2 id="17-Redis到底支不支持事务啊？">17. Redis到底支不支持事务啊？</h2><p><img src="2025-01-09-Redis%E9%9D%A2%E8%AF%95%E9%A2%98/image22.png" alt=""></p><p><img src="2025-01-09-Redis%E9%9D%A2%E8%AF%95%E9%A2%98/image23.png" alt=""></p><p>Redis 支持事务。</p><p>Redis 事务可以让一系列命令按顺序执行，在执行过程中不会被其他客户端的命令打断。</p><p>Redis 事务使用 <code>MULTI</code> 命令开启，然后将多个命令放入事务中，最后使用 <code>EXEC</code> 命令执行事务。</p><p>需要注意的是，Redis 事务不支持回滚，即在事务执行过程中，如果某条命令执行失败，不会影响已经执行成功的命令，也不会回滚整个事务。但从 Redis 2.6 版本开始，增加了对乐观锁的支持，通过 <code>WATCH</code> 命令可以在事务执行前监视一些键，如果在事务执行过程中这些键被其他客户端修改，事务会执行失败。</p><h1>高可用</h1><p><img src="2025-01-09-Redis%E9%9D%A2%E8%AF%95%E9%A2%98/diagram-2.png" alt=""></p><h2 id="1-REDIS-集群的原理是什么">1. REDIS 集群的原理是什么</h2><p>Redis集群通过<strong>数据分片和主从复制</strong>实现了横向扩展和高可用性。它将<strong>数据划分为16384个哈希槽</strong>，并将这些槽均匀地分配到多个节点上。每个节点负责处理一部分槽的数据，实现了数据的分散存储和负载均衡。</p><p>在集群中，<strong>每个哈希槽有一个主节点和多个从节点</strong>。主节点负责处理读写请求，而从节点则通过主从复制机制复制主节点的数据，提供数据的冗余备份和故障恢复功能。</p><p>当主节点发生故障时，集群会自动进行故障转移。它会选举一个从节点升级为新的主节点，保证服务的持续可用性。同时，集群管理节点负责监控节点的状态，并协调故障转移过程。</p><p><strong>客户端在与Redis集群交互时，根据键的哈希值将请求发送到相应的节点。客户端还可以通过集群管理节点获取整个集群的拓扑信息，了解哪些键存储在哪个节点上。</strong></p><p>通过数据分片和主从复制，Redis集群实现了数据水平切分、负载均衡和高可用性。它允许数据规模和吞吐量的线性扩展，并能自动处理节点故障。集群管理节点协调集群状态，客户端通过哈希映射与集群交互，从而实现了一个稳定和可靠的Redis分布式系统。 </p><p><img src="2025-01-09-Redis%E9%9D%A2%E8%AF%95%E9%A2%98/image16.png" alt=""></p><h2 id="2-REDIS集群方案什么情况下会导致整个集群不可用">2. REDIS集群方案什么情况下会导致整个集群不可用</h2><ol><li><p>多个主节点同时故障：如果多个主节点同时发生故障，而且它们的从节点无法升级为新的主节点，那么整个集群将无法提供读写服务。</p></li><li><p>集群管理节点故障：集群管理节点负责监控集群状态和协调故障转移操作。如果集群管理节点发生故障，并且无法及时恢复或替换，那么集群将失去管理和协调能力，可能导致集群不可用。</p></li><li><p>网络分区：如果集群中的节点之间发生网络分区，即无法互相通信，那么可能会引起脑裂（split - brain）问题。在这种情况下，每个分区内的节点可能会认为自己是合法的Redis集群，导致数据冲突和不一致性，最终导致整个集群无法正常工作。</p></li><li><p>配置错误：如果Redis集群的配置出现错误或者某些节点的配置不一致，可能导致集群无法正常运行。</p></li><li><p>内存不足：如果集群中的某个节点的内存不足以容纳当前处理的数据量，可能会导致该节点性能下降甚至崩溃，从而影响整个集群的可用性。 </p></li></ol><h2 id="3-⭐️REDIS集群会有写操作丢失吗？为什么">3. ⭐️REDIS集群会有写操作丢失吗？为什么</h2><p>在Redis集群中，由于采用了主从复制模型的异步复制机制，写操作有一定的丢失风险。</p><p>当客户端向主节点发送写操作时，主节点会立即返回成功响应，而不等待所有从节点执行复制。如果主节点在执行完写操作后出现故障或网络问题，导致从节点无法及时接收到复制操作，那么这些未复制的写操作将会丢失。 </p><h2 id="4-主从模式的同步过程？">4.主从模式的同步过程？</h2><h3 id="第一次同步">第一次同步</h3><p>主要分为建立连接协商、主从数据同步、发送新操作三个步骤：</p><ul><li><p>连接协商：从服务器先发送命令给主服务器表示要进行数据同步，命令内容包括主服务器的runID和复制进度两个参数，主服务器收到命令之后会给从服务响应命令，响应包括主服务器的runID和复制进度。从服务器收到响应之后会记录这两个值。</p></li><li><p>主从数据同步：主服务器生成RDB文件并发送给从服务器，从服务器收到RDB之后先清空自己的数据，再载入RDB文件。为了主从数据的一致性，这个期间主服务器后续的写操作会记录到replication buffer缓冲区里。</p></li><li><p>发送新操作：主服务器发送replication buffer里面的写操作给从服务器，从服务器执行这些操作。第一次同步完成。</p></li></ul><h3 id="命令传播">命令传播</h3><p>第一次同步完成之后双方会维护一个TCP连接，后续主服务器的写命令通过TCP连接发送给从服务器，保证主从一致。</p><h3 id="压力分摊">压力分摊</h3><p>为了分摊服务器的压力，生成和传输RDB的工作可以分摊到经理从服务器上。</p><h3 id="增量复制">增量复制</h3><p>如果服务器网路断开，在恢复之后，会把网络断开期间主服务器接收到的写操作命令同步给从服务器。 </p><h2 id="5-主服务器如何知道要将哪些增量数据发送给从服务器？">5.主服务器如何知道要将哪些增量数据发送给从服务器？</h2><p>网络断开从服务器重新上线之后，会发送自己的复制偏移量到主服务器，主服务器根据偏移量之间的差距判断要执行的操作：如果从服务器要读的数据在repl_backlog_buffe中，则采用增量复制；如果不在，采用全量复制。</p><blockquote><p>什么是repl_backlog_buffer？​</p><p>repl_backlog_buffer是一个环形缓冲区，用于主从服务器断连后，从中找到差异的数据；replication offset标记缓冲区的同步进度。</p></blockquote><h2 id="6-如何避免主从数据的不一致？">6.如何避免主从数据的不一致？</h2><p>让主从节点处于同一机房，降低网络延迟；或者由外部程序监控主从复制进度：先计算得出主从服务之间的复制进度差，如果复制进度差大于程序设定的阈值，让客户端不再在此节点读取数据，减小数据不一致的情况对业务的影响。</p><p>为了避免出现客户端和所有从节点都不能连接的情况，需要把复制进度差值的阈值设置得大一些。</p><p><a href="https://learn.lianglianglee.com/%E4%B8%93%E6%A0%8F/Redis%20%E6%A0%B8%E5%BF%83%E6%8A%80%E6%9C%AF%E4%B8%8E%E5%AE%9E%E6%88%98/32%20%20Redis%E4%B8%BB%E4%BB%8E%E5%90%8C%E6%AD%A5%E4%B8%8E%E6%95%85%E9%9A%9C%E5%88%87%E6%8D%A2%EF%BC%8C%E6%9C%89%E5%93%AA%E4%BA%9B%E5%9D%91%EF%BC%9F.md">32 Redis主从同步与故障切换，有哪些坑?</a></p><h2 id="7-什么是集群的脑裂？​">7.什么是集群的脑裂？​</h2><p>如果主节点的网络突然发生了问题与所有的从节点都失联了，但此时的主节点和客户端的网络是正常的，客户端不知道集群内部已经出现了问题，还在向这个失联的主节点写数据，此时这些数据被主节点缓存到了缓冲区里。哨兵也发现主节点失联了，就会在从节点中选举出一个leader作为主节点，会导致集群有两个主节点。</p><p>网络恢复后哨兵因为之前已经选举出一个新主节点了，它就会把旧主节点降级，然后从旧主节点会向新主节点请求数据同步，因为第一次同步是全量同步的方式，旧主节点会清空掉自己本地的数据。客户端在过程之前写入的数据就会丢失了。所以脑裂会导致集群数据的丢失。</p><h2 id="8-如何减少主从切换带来的数据丢失？​">8.如何减少主从切换带来的数据丢失？​</h2><p><strong>异步复制同步丢失</strong></p><p>配置一个阈值，一旦所有的从节点数据复制和同步的延迟都超过了阈值，主节点就会拒绝接收任何请求。对于客户端发现主节点不可写后，可以采取降级措施。将数据暂时写入本地缓存和磁盘中，在一段时间后重新写入主节点来保证数据不丢失，也可以将数据写入消息队列，等主节点恢复正常，再隔一段时间去消费消息队列中的数据，让将数据重新写入主节点。</p><p><strong>集群产生脑裂数据丢失</strong></p><p>当主节点发现「从节点下线的数量太多」，或者「网络延迟太大」的时候，那么禁止主节点进行写数据，直接把错误返回给客户端。设置主节点连接的从节点中至少有 N 个从节点，并且主节点进行数据复制时的 ACK 消息延迟不能超过 T 秒，否则，主节点就不会再接收客户端的写请求了。等到新主节点上线时，就只有新主节点能接收和处理客户端请求，此时，新写的数据会被直接写到新主节点中。而原主节点会被哨兵降为从节点，即使它的数据被清空了，也不会有新数据丢失。</p>]]></content>
      
      
      <categories>
          
          <category> 面试题 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Redis </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>JVM基础面试题</title>
      <link href="/posts/2025-01-09-JVM%E5%9F%BA%E7%A1%80%E9%9D%A2%E8%AF%95%E9%A2%98.html"/>
      <url>/posts/2025-01-09-JVM%E5%9F%BA%E7%A1%80%E9%9D%A2%E8%AF%95%E9%A2%98.html</url>
      
        <content type="html"><![CDATA[<p><img src="2025-01-09-JVM%E5%9F%BA%E7%A1%80%E9%9D%A2%E8%AF%95%E9%A2%98/diagram.png" alt=""></p><h1>Java内存区域</h1><h2 id="1-⭐️说说JMM">1.⭐️说说JMM</h2><p><strong>主要概念</strong></p><ol><li><p><strong>内存可见性</strong>：指一个线程对共享变量的修改对其他线程的可见性。JMM（Java内存模型）确保一个线程对共享变量的更新能被其他线程及时看到。为实现内存可见性，JMM引入“主内存”和“工作内存”概念，线程对共享变量的操作先在工作内存中进行，然后通过执行顺序符合程序逻辑的规则同步到主内存。</p></li><li><p><strong>线程间的操作顺序</strong>：JMM定义了线程操作的顺序规则，包括程序顺序规则、锁规则、volatile规则等。程序顺序规则保证在一个线程内操作按代码顺序执行；锁规则保证获取和释放锁的顺序性；volatile规则确保volatile变量的读写操作有一定的可见性和顺序性。</p></li><li><p><strong>原子性</strong>：原子性保证了操作的不可分割性。JMM规定了哪些操作是原子的，在执行这些操作时，不会被其他线程打断。在Java中，基本数据类型的读取和写入（如int、long）是原子的，但对于复合操作（如i++）则不是原子的。为保证原子性，通常需要使用同步机制或原子类（如AtomicInteger）。</p></li><li><p><strong>内存屏障</strong>：内存屏障（Memory Barriers）是JMM使用的一种机制，用于实现内存可见性和操作顺序规则。屏障的作用是阻止编译器和处理器对指令的重排序，确保代码执行顺序符合程序的预期。</p></li></ol><p><strong>关键概念和规则</strong></p><ul><li><p><strong>volatile关键字</strong>：volatile修饰的变量会被直接读写于主内存，避免了线程对变量的缓存，从而保证了内存的可见性。此外，volatile变量的读操作具有一定的顺序性，即保证在volatile变量的写操作之前发生的操作一定在写操作之后对其他线程可见。</p></li><li><p><strong>synchronized关键字</strong>：synchronized关键字用于实现同步，它不仅保证了内存可见性，还保证了操作的原子性。每次获取和释放锁时，都会强制刷新工作内存中的变量到主内存，并且强制使主内存中的变量更新到工作内存中，以确保其他线程能看到这些修改。</p></li><li><p><strong>happens-before原则</strong>：JMM中的happens-before原则用于描述操作之间的先后顺序。若操作A happens-before操作B，则操作A的结果对操作B可见。这个原则用于确定多线程程序中不同操作的执行顺序。</p></li></ul><p>Java内存模型通过定义一套规则，确保多线程环境下的内存访问行为是有序和一致的。通过使用volatile、synchronized和原子类等机制，程序员可以更好地控制和协调代码执行，确保代码在多线程环境下的正确性 。 </p><h2 id="2-字符串常量池的作用了解吗">2.字符串常量池的作用了解吗</h2><p><img src="2025-01-09-JVM%E5%9F%BA%E7%A1%80%E9%9D%A2%E8%AF%95%E9%A2%98/image-14.png" alt=""></p><h2 id="3-说下对JVM内存模型的理解">3.说下对JVM内存模型的理解</h2><p>首先<strong>JVM本质上是运行在操作系统之上的程序</strong>。我们编写的Java代码，经由 <code>javac</code> 编译器编译为二进制字节码。操作系统底层只能执行机器码指令，像C语言这类底层语言，经编译后直接生成机器码，因此执行效率较高。然而，C语言程序无法跨平台运行，需针对每个平台分别编译。与之不同，<strong>JVM充当了字节码与机器码之间的桥梁</strong>，通过在不同平台安装JVM，Java实现了跨平台特性。</p><p><strong>Java的内存结构主要由类加载器、运行时数据区、执行引擎和本地方法接口等部分组成。</strong></p><p>类加载器负责将字节码文件加载到Java的运行时数据区中。运行时数据区是Java程序运行时使用的内存区域，<strong>从线程角度可划分为线程私有和线程共享两部分</strong>。线程私有部分包含栈、本地方法栈和程序计数器。栈用于存储方法调用相关信息，本地方法栈则为本地方法服务，程序计数器记录当前线程执行的字节码指令地址。线程共享部分主要有方法区和堆内存。通常，我们创建的对象都存储在堆内存中；而<strong>方法区存储类的元数据、字节码以及常量池等信息</strong>。在不同的JDK版本中，方法区有诸多变化，<strong>例如在JDK 8中，方法区被称为元空间，它不再使用堆内存，而是采用本地内存来存储类相关数据，这主要是因为当下框架大量使用反射机制</strong>，运行时会动态加载众多类，若方法区仍在堆内存中，易导致堆内存难以控制。</p><p><strong>执行引擎具备重要功能</strong>，它能够将字节码解释为机器码，同时采用JIT（即时编译）技术，将热点代码编译为机器码，以提升执行效率。此外，虽然执行引擎并不直接负责垃圾回收，但它与垃圾回收机制紧密协作，确保内存的有效管理与回收。</p><p>本地方法接口是Java与本地代码（如C、C++）交互的桥梁。Java通过本地方法接口，可<strong>以调用本地代码实现一些Java本身难以完成的功能，如访问操作系统底层资源、提高性能敏感代码的执行效率等。</strong>当Java程序调用本地方法时，JVM会在本地方法栈中为该方法创建栈帧，并通过JNI（Java Native Interface）规范来处理Java与本地代码之间的数据传递和方法调用。例如，在开发涉及硬件操作、图形处理等应用时，常借助本地方法调用C或C++编写的高效代码来实现复杂功能。本地方法在拓展Java功能边界，提升系统性能方面发挥着重要作用。 </p><p><img src="2025-01-09-JVM%E5%9F%BA%E7%A1%80%E9%9D%A2%E8%AF%95%E9%A2%98/image-13.png" alt=""></p><p><img src="2025-01-09-JVM%E5%9F%BA%E7%A1%80%E9%9D%A2%E8%AF%95%E9%A2%98/image-12.png" alt=""></p><h2 id="4-内存溢出与内存泄漏的区别">4.内存溢出与内存泄漏的区别</h2><p><img src="2025-01-09-JVM%E5%9F%BA%E7%A1%80%E9%9D%A2%E8%AF%95%E9%A2%98/image.png" alt=""></p><h2 id="5-对象分配规则">5.对象分配规则</h2><p><img src="2025-01-09-JVM%E5%9F%BA%E7%A1%80%E9%9D%A2%E8%AF%95%E9%A2%98/image-1.png" alt=""></p><h2 id="6-⭐️JVM为什么使用元空间替换了永久代">6.⭐️JVM为什么使用元空间替换了永久代</h2><p>虚拟机使用元空间替代永久代的原因如下：</p><ol><li><p>内存管理：永久代由虚拟机自身控制内存管理，无法动态调整；元空间用本地内存管理，可按需动态分配和释放内存，提高利用率。</p></li><li><p>永久代内存溢出：永久代存储类元数据等，应用加载大量类或用大量字符串常量时可能溢出；元空间无固定大小限制，可自动扩展。</p></li><li><p>类的卸载：永久代类卸载机制复杂，难完全卸载；元空间用本地内存，更易实现类卸载，减少内存占用。</p></li><li><p>性能优化：元空间采用更高效数据结构和算法，如指针碰撞分配内存，减少碎片化，提高分配效率；还支持并发类加载和卸载操作，提升性能。</p></li></ol><p>综上，元空间内存管理更好、性能更高、特性更灵活，能更好满足现代应用程序需求，所以虚拟机选择用元空间替代永久代。 </p><h2 id="7-说一下堆和栈的区别？">7.说一下堆和栈的区别？</h2><ol><li><p>堆的物理地址分配是不连续的，性能较慢；栈的物理地址分配是连续的，性能相对较快。</p></li><li><p>堆存放的是对象的实例和数组；栈存放的是局部变量，操作数栈，返回结果等。</p></li><li><p>堆是线程共享的；栈是线程私有的。</p></li></ol><h2 id="8-栈溢出的原因？">8.栈溢出的原因？</h2><p>由于 HotSpot 不区分虚拟机和本地方法栈，设置本地方法栈大小的参数没有意义，栈容量只能由 -Xss 参数来设定，存在两种异常：</p><ul><li><p>StackOverflowError：如果线程请求的栈深度大于虚拟机所允许的深度，将抛出 StackOverflowError，例如一个递归方法不断调用自己。该异常有明确错误堆栈可供分析，容易定位到问题所在。</p></li><li><p>OutOfMemoryError：如果 JVM 栈可以动态扩展，当扩展无法申请到足够内存时会抛出 OutOfMemoryError。HotSpot 不支持虚拟机栈扩展，所以除非在创建线程申请内存时就因无法获得足够内存而出现 OOM，否则在线程运行时是不会因为扩展而导致溢出的。</p></li></ul><h2 id="9-运行时常量池溢出的原因？">9.运行时常量池溢出的原因？</h2><p>String 的 intern 方法是一个本地方法，作用是如果字符串常量池中已包含一个等于此 String 对象的字符串，则返回池中这个字符串的 String 对象的引用，否则将此 String 对象包含的字符串添加进池中，因此可以通过引用返回。</p><p>在 JDK6 及之前常量池分配在永久代，可通过 -XX:PermSize 和 -XX:MaxPermSize 限制永久代大小，间接限制常量池。在 while 死循环中调用 intern 方法导致运行时常量池溢出。在 JDK7 后不会出现该问题，因为存放在永久代的字符串常量池已经被移至堆中。</p><h2 id="10-方法区溢出的原因？">10.方法区溢出的原因？</h2><p>方法区主要存放<strong>类型信息，如类名、访问修饰符、常量池、字段描述、方法描述</strong>等。只要不断在运行时产生大量类，方法区就会溢出。例如使用 JDK 反射或 CGLib 直接操作字节码在运行时生成大量的类。很多框架如 Spring、Hibernate 等对类增强时都会使用 CGLib 这类字节码技术，增强的类越多就需要越大的方法区保证动态生成的新类型可以载入内存，也就更容易导致方法区溢出。</p><p>JDK8 使用元空间取代永久代，HotSpot 提供了一些参数作为元空间防御措施，例如 -XX:MetaspaceSize 指定元空间初始大小，达到该值会触发 GC 进行类型卸载，同时收集器会对该值进行调整，如果释放大量空间就适当降低该值，如果释放很少空间就适当提高。</p><h1>类加载机制</h1><h2 id="1-说下类加载器机制与双亲委派">1.说下类加载器机制与双亲委派</h2><p>首先<strong>类加载器</strong>主要是复杂从各种渠道将我们的字节码文件加载到我们的内存中，然后底层会调用native方法将我们的类相关信息写入到我们<strong>元空间</strong>中，主要保存我们类的所有信息，然后会在方法区创建当前类的class对象，方便我们后续通过java代码获取类信息，里面会持有一个指向元空间中类的指针。</p><p>类加载器主要有四大种，<strong>系统、扩展、应用以及自定义类加载器</strong>，内部类加载的机制采用的是双亲委派机制，主要目的是<strong>防止我们的核心类库被修改</strong>，以及我们的类被重复加载，底层原理就是加载类的时候层层向上委托，到顶层类加载器判断有没有加载过这个类，若没有尝试加载，如果加载不到再层层向下委托重复上述步骤。例如我们自定义一个包名和类名完全相同的String，它会层层向上传递给系统类加载器，发现没有加载过就尝试加载，结果一下子加载到了，那就用它加载的。底层的实现是在我们defineclass方法中实现的，当然我们也可以<strong>通过实现Classloader来实现我们自定义的类加载逻辑</strong>，甚至打破双亲委派机制，比如：我们可以使用类加载器对我们的字节码进行加解密等。 </p><h2 id="2-什么是类加载？类加载的过程？">2.什么是类加载？类加载的过程？</h2><p><img src="../../../../../../../images/image-10.png" alt=""></p><p>类加载流程，有加载、验证、准备、解析、初始化这几个步骤。</p><ul><li><p>加载：</p><ol><li><p>通过类的全限定名获取定义此类的二进制字节流。</p></li><li><p>将字节流所代表的静态存储结构转换为方法区的运行时数据结构。</p></li><li><p>在<strong>内存中生成一个代表该类的 Class 对象，作为方法区类信息的访问入口</strong>。</p></li></ol></li><li><p>验证：<strong>确保 Class 文件的字节流中包含的信息符合虚拟机规范，保证在运行后不会危害虚拟机自身的安全。</strong>主要包括四种验证：文件格式验证，元数据验证，字节码验证，符号引用验证。</p><ul><li><p>文件格式验证：验证读进来的字节流是否符合 Class 标准格式。</p></li><li><p>元数据验证：格式对了之后，验证一下里边的数据合不合理。比如：这个类是否有父类（除了 java.lang.Object 之外，所有的类都应当有父类）。</p></li><li><p>字节码验证：分析类的方法体（Class 文件中的 Code 属性），确保方法在运行时不会危害虚拟机。</p></li><li><p>符号引用验证（发生在解析阶段）：检查常量池中引用的外部类是否存在，是否可以正常访问。</p></li></ul></li><li><p>准备：为类变量分配内存并设置类变量初始值的阶段。其中如果是 final 修饰的，意味着在 Class 文件中，该字段的属性表中存在 ConstantValue 属性，此时初值设置为代码里写的。如果不是，就设置为零值，等到初始化阶段再赋值。</p></li><li><p>解析：虚拟机将常量池内的符号引用替换为直接引用的过程。符号引用用于描述目标，直接引用直接指向目标的地址。</p></li><li><p>初始化：开始执行类中定义的 Java 代码，初始化阶段是调用类构造器的过程。</p></li></ul><h2 id="3-什么是类加载器，类加载器有哪些？">3.什么是类加载器，类加载器有哪些？</h2><p><img src="../../../../../../../images/image-11.png" alt=""></p><p>实现通过类的全限定名获取该类的二进制字节流的代码块叫做类加载器。</p><p>主要有以下四种类加载器：</p><ul><li><p>启动类加载器（bootstrap class loader）：用来加载 Java 核心类库，无法被 Java 程序直接引用。</p></li><li><p>扩展类加载器（extensions class loader）：它用来加载 Java 的扩展库。Java 虚拟机的实现会提供一个扩展库目录。该类加载器在此目录里面查找并加载 Java 类。</p></li><li><p>系统类加载器（app class loader）：它根据应用的类路径来加载 Java 类。可通过 ClassLoader.getSystemClassLoader () 获取它。</p></li><li><p>自定义类加载器（custom class loader）：通过继承 java.lang.ClassLoader 类的方式实现。</p></li></ul><h2 id="4-什么是双亲委派模型？">4.什么是双亲委派模型？</h2><p><strong>一个类加载器收到一个类的加载请求时，它首先不会自己尝试去加载它，而是把这个请求委派给父类加载器去完成</strong>，这样层层委派，因此所有的加载请求最终都会传送到顶层的启动类加载器中，只有当父类加载器反馈自己无法完成这个加载请求时，子加载器才会尝试自己去加载。</p><p>双亲委派模型的具体实现代码在 java.lang.ClassLoader 中，此类的 loadClass () 方法运行过程如下：先检查类是否已经加载过，如果没有则让父类加载器去加载。当父类加载器加载失败时抛出 ClassNotFoundException，此时尝试自己去加载。</p><h2 id="5-为什么需要双亲委派模型？">5.为什么需要双亲委派模型？</h2><p>双亲委派模型的好处：如果没有双亲委派模型而是由各个类加载器自行加载的话，如果用户编写了一<strong>个 java.lang.Object 的同名类并放在 ClassPath </strong>中，多个类加载器都去加载这个类到内存中，系统中将会出现多个不同的 Object 类，那么类之间的比较结果及类的唯一性将无法保证。</p><h2 id="6-如何判断两个类是否相等？">6.如何判断两个类是否相等？</h2><p>任意一个类都必须由类加载器和这个类本身共同确立其在虚拟机中的唯一性。</p><p>两个类只有由同一类加载器加载才有比较意义，否则即使两个类来源于同一个 Class 文件，被同一个 JVM 加载，只要类加载器不同，这两个类就必定不相等。</p><p><strong>同一个类：相同类加载器加载 + 相同类限定名</strong></p><h2 id="7-类的实例化顺序？">7.类的实例化顺序？</h2><ol><li><p>父类中的 static 代码块，当前类的 static 代码块</p></li><li><p>父类的普通代码块</p></li><li><p>父类的构造函数</p></li><li><p>当前类普通代码块</p></li><li><p>当前类的构造函数</p></li></ol><h1>垃圾回收器与内存分配策略</h1><h2 id="1-新生代GC和老年代GC有什么区别">1.新生代GC和老年代GC有什么区别</h2><p><img src="2025-01-09-JVM%E5%9F%BA%E7%A1%80%E9%9D%A2%E8%AF%95%E9%A2%98/image-6.png" alt=""></p><h2 id="2-垃圾回收算法有哪些？">2.垃圾回收算法有哪些？</h2><blockquote><p><a href="https://javaguide.cn/java/jvm/jvm-garbage-collection.html">JVM垃圾回收详解（重点）</a></p></blockquote><p>垃圾回收算法有四种，分别是标记清除法、标记整理法、复制算法、分代收集算法。</p><ul><li><p><strong>标记清除算法</strong>：首先利用可达性去遍历内存，把垃圾对象进行标记。标记结束后统一将所有垃圾对象回收掉。这种垃圾回收算法效率较低，并且会产生大量不连续的空间碎片。</p></li><li><p><strong>复制算法</strong>：半区复制，用于新生代垃圾回收。将内存分为大小相同的两块，每次使用其中的一块。当这一块的内存使用完后，就将还存活的对象复制到另一块去，然后再把使用的空间一次清理掉。特点：实现简单，运行高效，但可用内存缩小为了原来的一半，浪费空间。</p></li><li><p><strong>标记整理算法</strong>：根据老年代的特点提出的一种标记算法，标记过程仍然与标记 - 清除算法一样，但后续步骤不是直接对可回收对象进行清理，而是让所有存活的对象都向一端移动，然后直接清理掉边界以外的内存。</p></li><li><p><strong>分代收集算法</strong>：根据各个年代的特点采用最适当的收集算法。一般将堆分为新生代和老年代。</p><ul><li><p>新生代使用复制算法。</p></li><li><p>老年代使用标记清除算法或者标记整理算法。在新生代中，每次垃圾收集时都有大批对象死去，只有少量存活，使用复制算法比较合适，只需要付出少量存活对象的复制成本就可以完成收集。老年代对象存活率高，适合使用标记 - 清理或者标记 - 整理算法进行垃圾回收。</p></li></ul></li></ul><h2 id="3-有哪些垃圾回收器？">3.有哪些垃圾回收器？</h2><blockquote><p><a href="https://mcnfxurl5vzo.feishu.cn/wiki/Lp6uws3rFiEDjXkkyGGchQWQnVH#share-SO1ldvaSRou7kDxqb6ycHGbMnrc"> 博客</a></p></blockquote><p><img src="2025-01-09-JVM%E5%9F%BA%E7%A1%80%E9%9D%A2%E8%AF%95%E9%A2%98/image-9.png" alt=""></p><p>垃圾收集器（GC，Garbage Collector）和具体 JVM 实现紧密相关，不同厂商（IBM、Oracle ）、不同版本的 JVM 提供的选择不同，主要介绍 Oracle JDK 的垃圾收集器：</p><ul><li><p><strong>Serial GC：</strong>最古老的垃圾收集器，收集工作单线程，垃圾收集时会进入 “Stop - The - World” 状态。单线程设计意味着精简的 GC 实现，无需维护复杂数据结构，初始化简单，是 Client 模式下 JVM 的默认选项。老年代实现为 Serial Old，采用标记 - 整理（Mark Compact）算法，区别于新生代复制算法。对应 JVM 参数：-XX:+UseSerialGC。</p></li><li><p>ParNew GC：新生代 GC 实现，是 Serial GC 的多线程版本，常见应用场景是配合老年代的 CMS GC 工作。对应参数：-XX:+UseConcMarkSweepGC -XX:+UseParNewGC。</p></li><li><p><strong>CMS</strong>（Concurrent Mark Sweep）GC：基于标记 - 清除（Mark - Sweep）算法，设计目标是尽量减少停顿时间，对 Web 等反应时间敏感的应用重要。存在内存碎片化问题，难以避免长时间运行下发生 full GC 导致恶劣停顿，且会占用更多 CPU 资源，和用户线程争抢。</p></li><li><p><strong>Parallel GC</strong>：早期 JDK 8 等版本中，是 server 模式 JVM 的默认 GC 选择，吞吐量优先。算法和 Serial GC 相似但实现更复杂，新生代和老年代 GC 并行进行，在常见服务器环境中更高效。开启选项：-XX:+UseParallelGC。引入开发者友好配置项，可设置暂停时间或吞吐量等目标，JVM 自动适应性调整，如 -XX:MaxGCPauseMillis=value 、-XX:GCTimeRatio=N（GC 时间和用户时间比例 = 1 / (N + 1)） 。</p></li><li><p><strong>G1 GC：</strong>兼顾吞吐量和停顿时间的 GC 实现，是 Oracle JDK 9 以后的默认 GC 选项。可直观设定停顿时间目标，相比 CMS GC，最差情况表现更好。仍存在年代概念，但内存结构是类似棋盘的一个个 region。Region 之间是复制算法，整体可看作标记 - 整理（Mark - Compact）算法，能有效避免内存碎片，Java 堆很大时优势更明显。吞吐量和停顿表现不错且不断完善，CMS 在 JDK 9 中被标记为废弃（deprecated）。</p></li></ul><h2 id="4-说下JVM中一次完整的-GC-流程">4.说下JVM中一次完整的 GC 流程</h2><p>JVM中垃圾回收（GC）流程一般步骤如下：</p><ol><li><p><strong>标记阶段</strong>：从根对象（如活动线程栈帧中局部变量、静态变量、JNI引用等）出发，通过引用链标记所有可达对象。</p></li><li><p><strong>垃圾标记</strong>：标记阶段后确定不可达对象为垃圾对象，将被回收。</p></li><li><p><strong>垃圾回收</strong>：执行回收操作，回收被标记垃圾对象占用内存空间，回收方式有标记 - 清除、复制、标记 - 整理等算法。</p></li><li><p><strong>内存整理</strong>：回收后可能产生内存碎片，为提高利用率，GC可能对内存空间整理，紧凑排列存活对象，便于分配新对象。</p></li><li><p><strong>内存分配</strong>：回收和整理完成后，GC为新对象分配内存空间，分配方式有指针碰撞、空闲列表等算法。</p></li><li><p><strong>重新分配对象引用</strong>：回收和内存分配完成后，GC更新对象间引用关系，确保引用指向正确对象。</p></li></ol><p>不同GC算法和实现有差异，但整体流程大致相同，<strong>目标是回收垃圾对象、释放内存空间，并尽量减少对应用程序影响，保证程序正常运行。</strong> </p><h2 id="5-什么是指针碰撞">5.什么是指针碰撞</h2><p>在 Java 中，指针碰撞是一种垃圾收集算法中用于分配内存的一种方式。它通常用于实现停顿时间较短的垃圾收集器，如<strong>复制算法和标记 - 整理算法</strong>。</p><p>指针碰撞的基本思想是将堆内存分为两个区域：<strong>一个是已分配的对象区域，另一个是未分配的空闲区域。</strong>通过一个指针来分隔这两个区域。当需要分配对象时，垃圾收集器将对象的大小与空闲区域的大小进行比较，如果空闲区域足够容纳对象，则将指针碰撞指针向前移动对象的大小，并返回指针碰撞指针的旧值作为对象的起始地址。如果空闲区域不足以容纳对象，则进行垃圾回收操作，释放一些内存后再进行分配。</p><p>指针碰撞的优点是分配内存的速度很快，只需简单地移动一个指针即可完成。而且由于已分配的对象区域和未分配的空闲区域是连续的，所以内存的利用率也比较高。</p><p>然而，指针碰撞算法的<strong>缺点是需要保证堆内存的连续性，即堆内存必须是一块连续的内存空间。</strong>这对于某些情况下的内存分配来说可能是一个限制，因为连续的内存空间可能会受到碎片化的影响，导致无法分配足够大的对象。因此，在实际应用中，指针碰撞算法通常与其他内存分配算法结合使用，以克服其局限性。</p><h2 id="6-什么是三色标记">6.什么是三色标记</h2><p>三色标记是一种用于并发垃圾收集的算法，常用于分代垃圾收集器中的老年代的垃圾回收过程。它基于对象的可达性来判断对象是否存活，并标记出存活对象。</p><p>三色标记算法将对象分为三种状态：白色、灰色和黑色。</p><ul><li><p>白色表示对象尚未被扫描，即未被标记为存活对象。</p></li><li><p>灰色表示对象已经被扫描，但其引用的其他对象尚未被扫描。</p></li><li><p>黑色表示对象已经被扫描，并且其引用的其他对象也已经被扫描。</p></li></ul><p>垃圾收集器在开始垃圾回收时，将所有对象标记为白色。然后从根对象开始，递归地遍历对象图，将遇到的对象标记为灰色，并将其引用的对象添加到待扫描队列中。接着，垃圾收集器从待扫描队列中取出对象，将其标记为黑色，并将其引用的对象添加到待扫描队列中。这个过程会一直进行，直到待扫描队列为空。最后，所有未被标记为黑色的对象即为垃圾对象，可以被回收。</p><p>三色标记算法的优点是可以在并发执行的情况下进行垃圾回收，减少停顿时间。它通过将对象分为三种状态，避免了在并发执行过程中的同时修改和访问对象的冲突。然而，三色标记算法也有一些缺点，如可能存在标记漏标和标记误标的情况，需要额外的处理来解决这些问题。</p><h2 id="7-Java对象的定位方式">7. Java对象的定位方式</h2><p>Java 程序通过栈上的 reference 数据来操作堆上的具体对象。对象的访问方式由虚拟机实现而定，目前主流的访问方式有使用句柄和直接指针两种：</p><ul><li><p>如果使用句柄的话，那么 Java 堆中将会划分出一块内存作为句柄池，reference 中存储的就是对象的句柄地址，<strong>而句柄中包含了对象实例数据与类型数据各自的具体地址信息</strong>。使用句柄来访问的最大好处是 reference 中存储的是稳定的句柄地址，在对象被移动时只会改变句柄中的实例数据指针，而 reference 本身不需要修改。</p></li><li><p>直接指针：reference 中存储的直接就是对象的地址。对象包含到对象类型数据的指针，通过这个指针可以访问对象类型数据。使用直接指针访问方式最大的好处就是访问对象速度快，它节省了一次指针定位的时间开销，虚拟机 hotspot 主要是使用直接指针来访问对象。</p></li></ul><p><img src="2025-01-09-JVM%E5%9F%BA%E7%A1%80%E9%9D%A2%E8%AF%95%E9%A2%98/image-8.png" alt=""></p><h2 id="8-如何判断一个对象是否存活？">8.如何判断一个对象是否存活？</h2><p>对堆垃圾回收前的第一步就是要判断哪些对象已经死亡（即不再被任何途径引用的对象）。判断对象是否存活有两种方法：引用计数法和可达性分析。</p><p><strong>引用计数法</strong>：</p><p>给对象中添加一个引用计数器，每当有一个地方引用它，计数器就加1；当引用失效，计数器就减1；任何时候计数器为0的对象就是不可能再被使用的。这种方法很难解决对象之间相互循环引用的问题。比如下面的代码，obj1和obj2互相引用，这种情况下，引用计数器的值都是1，不会被垃圾回收。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">ReferenceCount</span> &#123;</span><br><span class="line">    <span class="type">Object</span> <span class="variable">instance</span> <span class="operator">=</span> <span class="literal">null</span>;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">        <span class="type">ReferenceCount</span> <span class="variable">obj1</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">ReferenceCount</span>();</span><br><span class="line">        <span class="type">ReferenceCount</span> <span class="variable">obj2</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">ReferenceCount</span>();</span><br><span class="line">        obj1.instance = obj2;</span><br><span class="line">        obj2.instance = obj1;</span><br><span class="line">        obj1 = <span class="literal">null</span>;</span><br><span class="line">        obj2 = <span class="literal">null</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong>可达性分析</strong>：</p><p>通过GC Root对象为起点，从这些节点向下搜索，搜索所走过的路径叫引用链，当一个对象到GC Root没有任何的引用链相连时，说明这个对象是不可用的。</p><h2 id="9-可作为GC-Roots的对象有哪些？">9.可作为GC Roots的对象有哪些？</h2><ul><li><p>在虚拟机栈中引用的对象，例如各个线程被调用的方法堆栈中使用到的参数、局部变量、临时变量等。</p></li><li><p>在方法区中类静态属性引用的对象，例如 Java 类的引用类型静态变量。</p></li><li><p>在方法区中常量引用的对象，例如字符串常量池 (String Table) 里的引用。</p></li><li><p>在本地方法栈中 Native 方法引用的对象。</p></li><li><p>Java 虚拟机内部的引用，如基本数据类型对应的 Class 对象，一些常驻的异常对象 (比如 NullPointExcepiton、OutOfMemoryError) 等，还有系统类加载器。</p></li><li><p>所有被同步锁 (synchronized 关键字) 持有的对象。</p></li><li><p>反映 Java 虚拟机内部情况的 JMXBean、JVMTI 中注册的回调、本地代码缓存等。</p></li></ul><h2 id="10-什么情况下类会被卸载？">10.什么情况下类会被卸载？</h2><p>需要同时满足以下 3 个条件类才可能会被卸载：</p><ul><li><p>该类所有的实例都已经被回收。</p></li><li><p>加载该类的类加载器已经被回收。</p></li><li><p>该类对应的 java.lang.Class 对象没有在任何地方被引用，无法在任何地方通过反射访问该类的方法。</p></li></ul><p>虚拟机可以对满足上述 3 个条件的类进行回收，但不一定会进行回收。</p><h2 id="11-强引用、软引用、弱引用、虚引用是什么，有什么区别？">11.强引用、软引用、弱引用、虚引用是什么，有什么区别？</h2><p><strong>强引用</strong>：在程序中普遍存在的引用赋值，类似Object obj = new Object()这种引用关系。只要强引用关系还存在，垃圾收集器就永远不会回收被引用的对象。</p><p><strong>软引用</strong>：如果内存空间足够，垃圾回收器就不会回收它，如果内存空间不足了，就会回收这些对象的内存。示例代码：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//软引用</span></span><br><span class="line">SoftReference&lt;String&gt; softRef = <span class="keyword">new</span> <span class="title class_">SoftReference</span>&lt;String&gt;(str);</span><br></pre></td></tr></table></figure><p><strong>弱引用</strong>：在进行垃圾回收时，不管当前内存空间足够与否，都会回收只具有弱引用的对象。示例代码：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//弱引用</span></span><br><span class="line">WeakReference&lt;String&gt; weakRef = <span class="keyword">new</span> <span class="title class_">WeakReference</span>&lt;String&gt;(str);</span><br></pre></td></tr></table></figure><p><strong>虚引用</strong>：虚引用并不会决定对象的生命周期。如果一个对象仅持有虚引用，那么它就和没有任何引用一样，在任何时候都可能被垃圾回收。虚引用主要是为了能在对象被收集器回收时收到一个系统通知。虚引用创建时必须搭配ReferenceQueue。示例代码：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">ReferenceQueue&lt;Object&gt; queue = <span class="keyword">new</span> <span class="title class_">ReferenceQueue</span>&lt;&gt;();</span><br><span class="line">PhantomReference&lt;Object&gt; phantom = <span class="keyword">new</span> <span class="title class_">PhantomReference</span>&lt;Object&gt;(<span class="keyword">new</span> <span class="title class_">Object</span>(), queue);</span><br></pre></td></tr></table></figure><p>一个对象如果被引用，且最高级别是虚引用，就等于没有被引用，发生gc时不管内存够不够都会被回收。虚引用看起来和弱引用没啥区别，只是必须搭配ReferenceQueue。用虚引用的目的一般是跟踪对象被回收的活动。</p><p>不同的引用类型，主要体现的是对象不同的可达性（reachable）状态和对垃圾收集的影响。</p><ul><li><p>强引用：就是我们最常见的普通对象引用，只要还有强引用指向一个对象，就能表明对象还 “活着”，垃圾收集器不会碰这种对象。对于一个普通的对象，如果没有其他的引用关系，只要超过了引用的作用域或者显式地将相应（强）引用赋值为 null，就是可以被垃圾收集的了，当然具体回收时机还是要看垃圾收集策略。</p></li><li><p>软引用：是一种相对强引用弱化一些的引用，可以让对象豁免一些垃圾收集，只有当 JVM 认为内存不足时，才会去试图回收软引用指向的对象。JVM 会确保在抛出 OutOfMemoryError 之前，清理软引用指向的对象。软引用通常用来实现内存敏感的缓存，如果还有空闲内存，就可以暂时保留缓存，当内存不足时清理掉，这样就保证了使用缓存的同时，不会耗尽内存。</p></li><li><p>弱引用：并不能使对象豁免垃圾收集，仅仅是提供一种访问在弱引用状态下对象的途径。这就可以用来构建一种没有特定约束的关系，比如，维护一种非强制性的映射关系，如果试图获取时对象还在，就使用它，否则重现实例化。</p></li><li><p>虚引用：虚引用并不会决定对象的生命周期，如果一个对象仅持有虚引用，那么它就和没有任何引用一样，在任何时候都可能被垃圾回收，也无法通过虚引用來获取对象实例。虚引用<strong>主要是为了能在对象被收集器回收时收到一个系统通知，这样可以跟踪对象被垃圾回收的活动。</strong></p></li></ul><h2 id="12-聊聊-Java-中的-GC，分别作用在什么范围">12.聊聊 Java 中的 GC，分别作用在什么范围</h2><ul><li><p>新生代收集（Minor GC / Young GC）只是新生代的垃圾收集</p></li><li><p>老年代收集（Major GC / Old GC）只是老年代的垃圾收集</p></li><li><p>整堆收集（Full GC）收集整个堆的垃圾</p></li><li><p>混合收集（Mixed GC）收集整个新生代以及部分老年代的垃圾收集（目前只有 G1 GC 会有这种行为）</p></li></ul><h2 id="13-内存的分配策略？">13.内存的分配策略？</h2><ol><li><p>对象优先在 Eden 分配：大多数情况下，对象在新生代 Eden 上分配，当 Eden 空间不够时，触发 Minor GC。</p></li><li><p>大对象直接进入老年代：大对象是指需要连续内存空间的对象，最典型的大对象有长字符串和大数组。可以设置 JVM 参数 -XX:PretenureSizeThreshold，大于此值的对象直接在老年代分配。</p></li><li><p>长期存活的对象进入老年代：通过参数 -XX:MaxTenuringThreshold 可以设置对象进入老年代的年龄阈值。对象在 Survivor 区每经过一次 Minor GC，年龄就增加 1 岁，当它的年龄增加到一定程度，就会被晋升到老年代中。</p></li><li><p>动态对象年龄判定：并非对象的年龄必须达到 MaxTenuringThreshold 才能晋升老年代，如果在 Survivor 中相同年龄所有对象大小的总和大于 Survivor 空间的一半，则年龄大于或等于该年龄的对象可以直接进入老年代，无需达到 MaxTenuringThreshold 年龄阈值。</p></li><li><p>空间分配担保：在发生 Minor GC 之前，虚拟机先检查老年代最大可用的连续空间是否大于新生代所有对象总空间，如果条件成立的话，那么 Minor GC 是安全的。如果不成立的话虚拟机会查看 HandlePromotionFailure 的值是否允许担保失败。如果允许，那么就会继续检查老年代最大可用的连续空间是否大于历次晋升到老年代对象的平均大小，如果大于，将尝试着进行一次 Minor GC；如果小于，或者 HandlePromotionFailure 的值为不允许担保失败，那么就要进行一次 Full GC。</p></li></ol><h2 id="14-对象头了解吗？">14.对象头了解吗？</h2><p>Java 内存中的对象由以下三部分组成：对象头、实例数据和对齐填充字节。</p><ul><li><p>对象头由以下三部分组成：mark word、指向类信息的指针和数组长度（数组才有）。mark word 包含：对象的哈希码、分代年龄和锁标志位。</p></li><li><p>对象的实例数据就是 Java 对象的属性和值。</p></li><li><p>对齐填充字节：因为 JVM 要求对象占的内存大小是 8byte 的倍数，因此后面有几个字节用于把对象的大小补齐至 8byte 的倍数。<br>内存对齐的主要作用是：</p></li></ul><ol><li><p>平台原因：不是所有的硬件平台都能访问任意地址上的任意数据的；某些硬件平台只能在某些地址处取某些特定类型的数据，否则抛出硬件异常。</p></li><li><p>性能原因：经过内存对齐后，CPU 的内存访问速度大大提升。</p></li></ol><h2 id="15-main方法执行过程">15.main方法执行过程</h2><p><img src="2025-01-09-JVM%E5%9F%BA%E7%A1%80%E9%9D%A2%E8%AF%95%E9%A2%98/image-7.png" alt=""></p><p>执行 main 方法的过程如下：</p><ol><li><p>编译 Application.java 后得到 Application.class 后，执行这个 class 文件，系统会启动一个 JVM 进程，从类路径中找到一个名为 Application.class 的二进制文件，将 Application 类信息加载到运行时数据区的方法区内，这个过程叫做类的加载。</p></li><li><p>JVM 找到 Application 的主程序入口，执行 main 方法。</p></li><li><p>main 方法的第一条语句为 Person p = new Person (“大彬”)，就是让 JVM 创建一个 Person 对象，但是这个时候方法区中是没有 Person 类的信息的，所以 JVM 马上加载 Person 类，把 Person 类的信息放到方法区中。</p></li><li><p>加载完 Person 类后，JVM 在堆中分配内存给 Person 对象，然后调用构造函数初始化 Person 对象，这个 Person 对象持有指向方法区中的 Person 类的类型信息的引用。</p></li><li><p>执行 p.getName () 时，JVM 根据 p 的引用找到 p 所指向的对象，然后根据此对象持有的引用定位到方法区中 Person 类的类型信息的方法表，获得 getName () 的字节码地址。</p></li><li><p>执行 getName () 方法。</p></li></ol><h2 id="16-对象创建过程">16.对象创建过程</h2><p><img src="2025-01-09-JVM%E5%9F%BA%E7%A1%80%E9%9D%A2%E8%AF%95%E9%A2%98/image-5.png" alt=""></p><p>图片展示了 Java 中对象创建过程，包含类加载检查、分配内存、初始化零值、设置对象头、执行 init 方法五个步骤，并有各步骤详细说明：</p><ol><li><p><strong>类加载检查：</strong>JVM 遇到 new 指令时，先检查能否在常量池中定位到该类的符号引用，并检查符号引用代表的类是否已被加载、解析和初始化，未完成则先进行类加载，已加载则通过检查。</p></li><li><p><strong>分配内存：</strong>类加载检查通过后 JVM 为新对象分配内存，对象所需内存大小在类加载完成后确定，JVM 会在堆中按指针碰撞或空闲列表方式为对象划分空间，选择方式依垃圾收集器算法而定。内存分配要保证线程安全，<strong>JVM 采用 CAS + 失败重试或 TLAB 方式保证。</strong>其中，CAS + 失败重试是乐观锁的一种实现，每次占用资源不加锁，而是不断尝试占用；TLAB 是线程创建时预先在堆中给线程分配一块内存，专门存放该线程运行过程中创建的对象，TLAB 满时，采用 CAS 在堆的其它内存中分配。</p></li><li><p>初始化：分配到的内存空间都初始化为零值，保证对象字段可不赋初始值就直接使用，程序能访问到对应零值。</p></li><li><p>设置对象头：在对象头中设置对象所属类、类元数据信息获取方式、对象哈希码、GC 分代年龄、是否启用偏向锁等信息。</p></li><li><p>执行 init 方法：按照程序员编写的构造方法对对象进行初始化。</p></li></ol><h1>JVM调优与故障问题排查</h1><h2 id="1-⭐️Full-GC-的触发条件？">1.⭐️Full GC 的触发条件？</h2><p>对于 Minor GC，其触发条件比较简单，当 Eden 空间满时，就将触发一次 Minor GC。而 Full GC 触发条件相对复杂，有以下情况会发生 full GC：</p><ul><li><p>调用 System.gc ()：只是建议虚拟机执行 Full GC，但是虚拟机不一定真正去执行。不建议使用这种方式，而是让虚拟机管理内存。</p></li><li><p>老年代空间不足：老年代空间不足的常见场景为前文所讲的大对象直接进入老年代、长期存活的对象进入老年代等。为了避免以上原因引起的 Full GC，应当尽量不要创建过大的对象以及数组。除此之外，可以通过 -Xmn 参数调大新生代的大小，让对象尽量在新生代被回收掉，不进入老年代。还可以通过 -XX:MaxTenuringThreshold 调大对象进入老年代的年龄，让对象在新生代多存活一段时间。</p></li><li><p>空间分配担保失败：使用复制算法的 Minor GC 需要老年代的内存空间作担保，如果担保失败会执行一次 Full GC。</p></li><li><p>JDK 1.7 及以前的永久代空间不足：在 JDK 1.7 及以前，HotSpot 虚拟机中的方法区是用永久代实现的，永久代中存放的为一些 Class 的信息、常量、静态变量等数据。当系统中要加载的类、反射的类和调用的方法较多时，永久代可能会被占满，在未配置为采用 CMS GC 的情况下也会执行 Full GC。如果经过 Full GC 仍然回收不了，那么虚拟机会抛出 java.lang.OutOfMemoryError。</p></li></ul><h2 id="2-常用的JVM启动参数有哪些">2.常用的JVM启动参数有哪些</h2><p>JVM（Java虚拟机）的启动参数用于配置和调整Java应用程序的运行时行为。以下是一些常用的JVM启动参数：</p><ol><li><p>-Xmx：指定Java堆内存的最大限制，如“-Xmx512m”表示最大堆内存为512兆字节。</p></li><li><p>-Xms：指定Java堆内存的初始大小，如“-Xms256m”表示初始堆内存为256兆字节。</p></li><li><p>-Xss：指定每个线程的堆栈大小，如“-Xss256k”表示每个线程的堆栈大小为256千字节。</p></li><li><p>-XX:MaxPermSize（Java 7及之前版本）或 -XX:MaxMetaspaceSize（Java 8及以后版本）：指定永久代（Java 7及之前）或元空间（Java 8及以后）的最大大小。</p></li><li><p>-XX:PermSize（Java 7及之前版本）或 -XX:MetaspaceSize（Java 8及以后版本）：指定永久代（Java 7及之前）或元空间（Java 8及以后）的初始大小。 </p></li><li><p>-Xmn：指定年轻代的大小，如“-Xmn256m”表示年轻代大小为256兆字节。</p></li><li><p>-XX:SurvivorRatio：指定年轻代中Eden区与Survivor区的大小比例，如“-XX:SurvivorRatio=8”表示Eden区与每个Survivor区的大小比例为8:1。 </p></li><li><p>-XX:NewRatio：指定年轻代与老年代的大小比例，如“-XX:NewRatio=2”表示年轻代和老年代的比例为1:2。 </p></li><li><p>-XX:MaxGCPauseMillis：设置垃圾回收的最大暂停时间目标，如“-XX:MaxGCPauseMillis=100”表示垃圾回收的最大暂停时间目标为100毫秒。 </p></li><li><p>-XX:ParallelGCThreads：指定并行垃圾回收线程的数量，如“-XX:ParallelGCThreads=4”表示使用4个线程进行并行垃圾回收。 </p></li><li><p>-XX:+UseConcMarkSweepGC：启用并发标记清除垃圾回收器。 </p></li><li><p>-XX:+UseG1GC：启用G1（Garbage First）垃圾回收器。 </p></li><li><p>-Dproperty=value：设置Java系统属性，可在应用程序中用System.getProperty(“property”)获取这些属性的值。 </p></li></ol><h2 id="3-常用的-JVM-调优的命令都有哪些？">3.常用的 JVM 调优的命令都有哪些？</h2><p><img src="2025-01-09-JVM%E5%9F%BA%E7%A1%80%E9%9D%A2%E8%AF%95%E9%A2%98/image-4.png" alt=""></p><p><img src="2025-01-09-JVM%E5%9F%BA%E7%A1%80%E9%9D%A2%E8%AF%95%E9%A2%98/image-3.png" alt=""></p><p><img src="2025-01-09-JVM%E5%9F%BA%E7%A1%80%E9%9D%A2%E8%AF%95%E9%A2%98/image-2.png" alt=""></p><p><img src="2025-01-09-JVM%E5%9F%BA%E7%A1%80%E9%9D%A2%E8%AF%95%E9%A2%98/image-15.png" alt=""></p><p><img src="2025-01-09-JVM%E5%9F%BA%E7%A1%80%E9%9D%A2%E8%AF%95%E9%A2%98/image-16.png" alt=""></p><h2 id="4-如何排查-OOM-的问题？">4.如何排查 OOM 的问题？</h2><p>排查 OOM（OutOfMemoryError，内存溢出）的方法：</p><ul><li><p>增加 JVM 参数 -XX:+HeapDumpOnOutOfMemoryError 和 -XX:HeapDumpPath=/tmp/heapdump.hprof，当 OOM 发生时自动 dump 堆内存信息到指定目录；</p></li><li><p>jstat 查看监控 JVM 的内存和 GC 情况，评估问题大概在什么区域；</p></li><li><p>使用 MAT 工具载入 dump 文件，分析大对象的占用情况 。</p></li></ul><h2 id="5-如何诊断java线程死锁？jstack">5.如何诊断java线程死锁？jstack</h2><blockquote><h3 id="使用jstack进行死锁诊断的详细步骤：">使用jstack进行死锁诊断的详细步骤：</h3><h4 id="步骤1-确认进程ID-PID">步骤1: 确认进程ID (PID)</h4><ol><li><p>使用ps查找进程：</p><ul><li><p>打开终端，并运行以下命令以列出所有Java进程。</p></li><li><p>找到目标Java应用的PID。</p></li></ul></li></ol><h4 id="步骤2-生成线程堆栈信息">步骤2: 生成线程堆栈信息</h4><ul><li><p>运行jstack命令：</p><ul><li><p>使用以上命令生成线程栈信息：</p></li><li><p>替换&lt;PID&gt; 为实际的进程ID。这个命令会把线程信息输出到thread_dump.txt文件中。</p></li></ul></li></ul><h4 id="步骤3-分析线程堆栈信息">步骤3: 分析线程堆栈信息</h4><ul><li><p>打开文件：</p><ul><li>使用文本编辑器打开thread_dump.txt文件。</li></ul></li><li><p>查找线程状态：</p><ul><li><p>在文件中查找BLOCKED和WAITING关键字，寻找被阻塞或等待的线程。</p></li><li><p>每个线程的信息通常以 “\n” 分隔。</p></li></ul></li><li><p>定位锁信息：</p><ul><li><p>对于BLOCKED状态的线程，检查线程正在等待的锁，通常在输出的最后部分。</p></li><li><p>对于每个WAITING状态的线程，检查它们的等待来源。</p></li></ul></li></ul><h4 id="步骤4-确定死锁">步骤4: 确定死锁</h4><ul><li><p>识别循环依赖：</p><ul><li>检查是否有两个或多个线程相互等待对方持有的锁。确认这种依赖关系之后，您可以判断存在死锁。</li></ul></li></ul><h4 id="步骤5-解决死锁">步骤5: 解决死锁</h4><ul><li><p>修改代码：</p><ul><li><p>确保所有线程获取锁的顺序一致，避免循环依赖。</p></li><li><p>考虑使用锁超时（比如tryLock()方法）。</p></li></ul></li></ul><h3 id="其他诊断死锁的方式">其他诊断死锁的方式</h3><p>JVisualVM、JConsole等都可以有效诊断Java中的线程死锁问题。 </p></blockquote>]]></content>
      
      
      <categories>
          
          <category> 面试题 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> JVM面试题 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>阿里开发规约学习总结</title>
      <link href="/posts/2025-01-09-%E9%98%BF%E9%87%8C%E5%BC%80%E5%8F%91%E8%A7%84%E7%BA%A6%E5%AD%A6%E4%B9%A0%E6%80%BB%E7%BB%93.html"/>
      <url>/posts/2025-01-09-%E9%98%BF%E9%87%8C%E5%BC%80%E5%8F%91%E8%A7%84%E7%BA%A6%E5%AD%A6%E4%B9%A0%E6%80%BB%E7%BB%93.html</url>
      
        <content type="html"><![CDATA[<p>阿里开发规约</p><p>一、编程规约</p><p>1.应该用确定有值的对象调用方法</p><p><img src="2025-01-09-%E9%98%BF%E9%87%8C%E5%BC%80%E5%8F%91%E8%A7%84%E7%BA%A6%E5%AD%A6%E4%B9%A0%E6%80%BB%E7%BB%93/clip_image002-3660519.jpg" alt="img"></p><p>2.包装类对象应该用equals比较而不要用==</p><p><img src="2025-01-09-%E9%98%BF%E9%87%8C%E5%BC%80%E5%8F%91%E8%A7%84%E7%BA%A6%E5%AD%A6%E4%B9%A0%E6%80%BB%E7%BB%93/clip_image004-3660519.jpg" alt="img"></p><p>3.任何货币金额，均以最小货币单位且整型类型来进行存储。</p><p>4.⭐️浮点数之间的等值判断，float基本数据类型不能用==来比较，浮点数包装数据类型不能用 equals来判断</p><p><img src="2025-01-09-%E9%98%BF%E9%87%8C%E5%BC%80%E5%8F%91%E8%A7%84%E7%BA%A6%E5%AD%A6%E4%B9%A0%E6%80%BB%E7%BB%93/clip_image006-3660519.jpg" alt="img"></p><p>因为：</p><p><img src="2025-01-09-%E9%98%BF%E9%87%8C%E5%BC%80%E5%8F%91%E8%A7%84%E7%BA%A6%E5%AD%A6%E4%B9%A0%E6%80%BB%E7%BB%93/clip_image008-3660519.jpg" alt="img"></p><p>5.禁止使用构造方法 BigDecimal(double)的方式把 double 值转化为 BigDecimal 对象</p><p><img src="2025-01-09-%E9%98%BF%E9%87%8C%E5%BC%80%E5%8F%91%E8%A7%84%E7%BA%A6%E5%AD%A6%E4%B9%A0%E6%80%BB%E7%BB%93/clip_image010-3660519.jpg" alt="img"></p><p>6.POJO用包装数据类型</p><p><img src="2025-01-09-%E9%98%BF%E9%87%8C%E5%BC%80%E5%8F%91%E8%A7%84%E7%BA%A6%E5%AD%A6%E4%B9%A0%E6%80%BB%E7%BB%93/clip_image012-3660519.jpg" alt="img"></p><p>7.使用索引访问用 String 的 split 方法得到的数组时，需做最后一个分隔符后有无内容的检查，否则会有抛 IndexOutOfBoundsException 的风险</p><p><img src="2025-01-09-%E9%98%BF%E9%87%8C%E5%BC%80%E5%8F%91%E8%A7%84%E7%BA%A6%E5%AD%A6%E4%B9%A0%E6%80%BB%E7%BB%93/clip_image014-3660519.jpg" alt="img"></p><p>8.循环体内，字符串的连接方式，使用 StringBuilder 的 append 方法进行扩展</p><p><img src="2025-01-09-%E9%98%BF%E9%87%8C%E5%BC%80%E5%8F%91%E8%A7%84%E7%BA%A6%E5%AD%A6%E4%B9%A0%E6%80%BB%E7%BB%93/clip_image016-3660519.jpg" alt="img"></p><p>9.慎用 Object 的 clone 方法来拷贝对象</p><p>说明： 对象 clone 方法默认是浅拷贝，若想实现深拷贝， 需覆写 clone 方法实现域对象的深度遍历式拷贝</p><p>10.类成员与方法访问控制从严</p><p><img src="2025-01-09-%E9%98%BF%E9%87%8C%E5%BC%80%E5%8F%91%E8%A7%84%E7%BA%A6%E5%AD%A6%E4%B9%A0%E6%80%BB%E7%BB%93/clip_image018-3660519.jpg" alt="img"></p><p><img src="2025-01-09-%E9%98%BF%E9%87%8C%E5%BC%80%E5%8F%91%E8%A7%84%E7%BA%A6%E5%AD%A6%E4%B9%A0%E6%80%BB%E7%BB%93/clip_image020-3660519.jpg" alt="img"></p><p>11.日期格式化时，传入 pattern 中表示年份统一使用小写的 y</p><p><img src="2025-01-09-%E9%98%BF%E9%87%8C%E5%BC%80%E5%8F%91%E8%A7%84%E7%BA%A6%E5%AD%A6%E4%B9%A0%E6%80%BB%E7%BB%93/clip_image022-3660519.jpg" alt="img"></p><p><img src="2025-01-09-%E9%98%BF%E9%87%8C%E5%BC%80%E5%8F%91%E8%A7%84%E7%BA%A6%E5%AD%A6%E4%B9%A0%E6%80%BB%E7%BB%93/clip_image024.jpg" alt="img"></p><p>12.关于 hashCode 和 equals 的处理，遵循如下规则：</p><p><img src="2025-01-09-%E9%98%BF%E9%87%8C%E5%BC%80%E5%8F%91%E8%A7%84%E7%BA%A6%E5%AD%A6%E4%B9%A0%E6%80%BB%E7%BB%93/clip_image026-3660519.jpg" alt="img"></p><p>13.ArrayList 的 subList 结果不可强转成 ArrayList，否则会抛出 ClassCastException 异常</p><p><img src="2025-01-09-%E9%98%BF%E9%87%8C%E5%BC%80%E5%8F%91%E8%A7%84%E7%BA%A6%E5%AD%A6%E4%B9%A0%E6%80%BB%E7%BB%93/clip_image028-3660519.jpg" alt="img"></p><p>14.不允许在程序任何地方中使用：</p><p>1） java.sql.Date。</p><p>不记录时间， getHours()抛出异常</p><p>2） java.sql.Time。</p><p>不记录日期， getYear()抛出异常</p><p>3） java.sql.Timestamp。</p><p>在构造</p><p>方法 super((time/1000)*1000)， 在 Timestamp 属性 fastTime 和 nanos 分别存储秒和纳秒信息。</p><p>15.使用工具类 Arrays.asList()把数组转换成集合时，不能使用其修改集合相关的方法，它的 add/remove/clear 方法会抛出 UnsupportedOperationException 异常</p><p><img src="2025-01-09-%E9%98%BF%E9%87%8C%E5%BC%80%E5%8F%91%E8%A7%84%E7%BA%A6%E5%AD%A6%E4%B9%A0%E6%80%BB%E7%BB%93/clip_image030-3660519.jpg" alt="img"></p><p>16.泛型通配符&lt;? extends T&gt;来接收返回的数据，此写法的泛型集合不能使用 add 方法，而&lt;? super T&gt;不能使用 get 方法， 两者在接口调用赋值的场景中容易出错。</p><p>说明： 扩展说一下 PECS(Producer Extends Consumer Super)原则： 第一、 频繁往外读取内容的，适合用</p><? extends T>。 第二、 经常往里插入的，适合用<? super T>17.不要在 foreach 循环里进行元素的 remove/add 操作。 remove 元素请使用 Iterator方式，如果并发操作，需要对 Iterator 对象加锁。![img](2025-01-09-阿里开发规约学习总结/clip_image032-3660519.jpg)18.⭐️使用 entrySet 遍历 Map 类集合 KV，而不是 keySet 方式进行遍历。![img](2025-01-09-阿里开发规约学习总结/clip_image034-3660519.jpg)![img](2025-01-09-阿里开发规约学习总结/clip_image036.jpg)19.线程池不允许使用 Executors 去创建，而是通ThreadPoolExecutor 的方式，这样的处理方式让写的同学更加明确线程池的运行规则，规避资源耗尽的风险说明： Executors 返回的线程池对象的弊端如下：1） FixedThreadPool 和 SingleThreadPool：允许的请求队列长度为 Integer.MAX_VALUE，可能会堆积大量的请求，从而导致 OOM。2） CachedThreadPool：允许的创建线程数量为 Integer.MAX_VALUE， 可能会创建大量的线程，从而导致 OOM。20.必须回收自定义的 ThreadLocal 变量尤其在线程池场景下，线程经常会被复用，如果不清理自定义的 ThreadLocal 变量，可能会影响后续业务逻辑和造成内存泄露等问题。尽量在代理中使用 try-finally 块进行回收。![img](2025-01-09-阿里开发规约学习总结/clip_image038-3660519.jpg)21.在使用阻塞等待获取锁的方式中，必须在 try 代码块之外，并且在加锁方法与 try 代码块之间没有任何可能抛出异常的方法调用，避免加锁成功后，在 finally 中无法解锁。说明一： 如果在 lock 方法与 try 代码块之间的方法调用抛出异常，那么无法解锁，造成其它线程无法成功获取锁。说明二： 如果 lock 方法在 try 代码块之内，可能由于其它方法抛出异常，导致在 finally 代码块中， unlock对未加锁的对象解锁，它会调用 AQS 的 tryRelease 方法（取决于具体实现类），抛出llegalMonitorStateException 异常。说明三： 在 Lock 对象的 lock 方法实现中可能抛出 unchecked 异常，产生的后果与说明二相同。![img](2025-01-09-阿里开发规约学习总结/clip_image040-3660519.jpg)![img](2025-01-09-阿里开发规约学习总结/clip_image042-3660519.jpg)22.乐观锁与悲观锁的选择并发修改同一记录时，避免更新丢失， 需要加锁。 要么在应用层加锁，要么在缓存加锁，要么在数据库层使用乐观锁，使用 version 作为更新依据。说明： 如果每次访问冲突概率小于 20%，推荐使用乐观锁，否则使用悲观锁。乐观锁的重试次数不得小于3 次。资金相关的金融敏感信息，使用悲观锁策略。说明： 乐观锁在获得锁的同时已经完成了更新操作，校验逻辑容易出现漏洞，另外，乐观锁对冲突的解决策略有较复杂的要求，处理不当容易造成系统压力或数据异常，所以资金相关的金融敏感信息不建议使用乐观锁更新。正例： 悲观锁遵循一锁、 二判、 三更新、 四释放的原则。23.使用 CountDownLatch 进行异步转同步操作使用 CountDownLatch 进行异步转同步操作，每个线程退出前必须调用 countDown 方法，线程执行代码注意 catch 异常，确保 countDown 方法被执行到，避免主线程无法执行至await 方法，直到超时才返回结果。说明： 注意，子线程抛出异常堆栈，不能在主线程 try-catch 到24.⭐️避免 Random 实例被多线程使用，虽然共享该实例是线程安全的，但会因竞争同一 seed导致的性能下降。说明： Random 实例包括 java.util.Random 的实例或者 Math.random()的方式。正例： 在 JDK7 之后，可以直接使用 API ThreadLocalRandom， 而在 JDK7 之前， 需要编码保证每个线程持有一个单独的 Random 实例。25.当 switch 括号内的变量类型为 String 并且此变量为外部参数时，必须先进行 null判断。![img](2025-01-09-阿里开发规约学习总结/clip_image044.jpg)26.在高并发场景中，避免使用” 等于” 判断作为中断或退出的条件。说明： 如果并发控制没有处理好，容易产生等值判断被“击穿” 的情况，使用大于或小于的区间判断条件来代替。反例： 判断剩余奖品数量等于 0 时，终止发放奖品，但因为并发处理错误导致奖品数量瞬间变成了负数，这样的话，活动无法终止。27.避免采用取反逻辑运算符。说明： 取反逻辑不利于快速理解，并且取反逻辑写法一般都存在对应的正向逻辑写法。正例： 使用 if (x < 628) 来表达 x 小于 628。反例： 使用 if (!(x >= 628)) 来表达 x 小于 628。二、注释规约：1.及时清理不再使用的代码段或配置信息。说明： 对于垃圾代码或过时配置，坚决清理干净，避免程序过度臃肿，代码冗余。正例： 对于暂时被注释掉，后续可能恢复使用的代码片段，在注释代码上方，统一规定使用三个斜杠(///)来说明注释掉代码的理由。 如：  Java   public static void hello() {     /// 业务方通知活动暂停     // Business business = new  Business();     // business.active();     System.out.println("it's  finished");   }  三、前后端规约1.前后端数据列表相关的接口返回，如果为空，则返回空数组[]或空集合{}说明： 此条约定有利于数据层面上的协作更加高效，减少前端很多琐碎的 null 判断。2.对于需要使用超大整数的场景，服务端一律使用 String 字符串类型返回，禁止使用Long 类型。四、异常日志1.事务场景中，抛出异常被 catch 后，如果需要回滚，一定要注意手动回滚事务。2.不要在 finally 块中使用 return。说明： try 块中的 return 语句执行成功后，并不马上返回，而是继续执行 finally 块中的语句，如果此处存在 return 语句，则在此直接返回，无情丢弃掉 try 块中的返回点。![img](2025-01-09-阿里开发规约学习总结/clip_image046.jpg)3.防止 NPE，是程序员的基本修养，注意 NPE 产生的场景：1） 返回类型为基本数据类型， return 包装数据类型的对象时，自动拆箱有可能产生 NPE。反例： public int f() { return Integer 对象}， 如果为 null，自动解箱抛 NPE。2） 数据库的查询结果可能为 null。3） 集合里的元素即使 isNotEmpty，取出的数据元素也可能为 null。4） 远程调用返回对象时，一律要求进行空指针判断，防止 NPE。5） 对于 Session 中获取的数据，建议进行 NPE 检查，避免空指针。6） 级联调用 obj.getA().getB().getC()；一连串调用，易产生 NPE。正例： 使用 JDK8 的 Optional 类来防止 NPE 问题4.在日志输出时，字符串变量之间的拼接使用占位符的方式。说明： 因为 String 字符串的拼接会使用 StringBuilder 的 append()方式，有一定的性能损耗。使用占位符仅是替换动作，可以有效提升性能。正例： logger.debug("Processing trade with id: {} and symbol: {}", id, symbol);5.生产环境禁止直接使用 System.out 或 System.err 输出日志或使用e.printStackTrace()打印异常堆栈。说明： 标准日志输出与标准错误输出文件每次 Jboss 重启时才滚动，如果大量输出送往这两个文件，容易造成文件大小超过操作系统大小限制。五，安全规约 1.用户输入的 SQL 参数严格使用参数绑定或者 METADATA 字段值限定，防止 SQL 注入，禁止字符串拼接 SQL 访问数据库。反例： 某系统签名大量被恶意修改，即是因为对于危险字符 # --没有进行转义，导致数据库更新时， where后边的信息被注释掉，对全库进行更新。2.用户请求传入的任何参数必须做有效性验证。说明： 忽略参数校验可能导致：⚫ page size 过大导致内存溢出⚫ 恶意 order by 导致数据库慢查询⚫ 缓存击穿⚫ SSRF⚫ 任意重定向⚫ SQL 注入， Shell 注入， 反序列化注入⚫ 正则输入源串拒绝服务 ReDoSJava 代码用正则来验证客户端的输入，有些正则写法验证普通用户输入没有问题，但是如果攻击人员使用的是特殊构造的字符串来验证，有可能导致死循环的结果六、数据库规约1.表达是与否概念的字段，必须使用 is_xxx 的方式命名，数据类型是 unsigned tinyint说明： 任何字段如果为非负数，必须是 unsigned。注意： POJO 类中的任何布尔类型的变量，都不要加 is 前缀，所以，需要在<resultMap>设置从 is_xxx 到Xxx 的映射关系。数据库表示是与否的值，使用 tinyint 类型，坚持 is_xxx 的命名方式是为了明确其取值含义与取值范围。正例： 表达逻辑删除的字段名 is_deleted， 1 表示删除， 0 表示未删除。2.索引命名主键索引名为 pk_字段名；唯一索引名为 uk_字段名； 普通索引名则为 idx_字段名。说明： pk_ 即 primary key； uk_ 即 unique key； idx_ 即 index 的简称。3.小数类型为 decimal，禁止使用 float 和 double。说明： 在存储的时候， float 和 double 都存在精度损失的问题，很可能在比较值的时候，得到不正确的结果。如果存储的数据范围超过 decimal 的范围，建议将数据拆成整数和小数并分开存储。4.varchar使用varchar 是可变长字符串，不预先分配存储空间，长度不要超过 5000，如果存储长度大于此值，定义字段类型为 text，独立出来一张表，用主键来对应，避免影响其它字段索引效率5.表必备三字段： id, create_time, update_time说明： 其中 id 必为主键，类型为 bigint unsigned、单表时自增、步长为 1。 create_time, update_time的类型均为 datetime 类型，前者现在时表示主动式创建，后者过去分词表示被动式更新。6.业务上具有唯一特性的字段，即使是组合字段，也必须建成唯一索引说明： 不要以为唯一索引影响了 insert 速度，这个速度损耗可以忽略，但提高查找速度是明显的； 另外，即使在应用层做了非常完善的校验控制，只要没有唯一索引，根据墨菲定律，必然有脏数据产生。7.利用覆盖索引来进行查询操作， 避免回表。说明： 如果一本书需要知道第 11 章是什么标题，会翻开第 11 章对应的那一页吗？目录浏览一下就好，这个目录就是起到覆盖索引的作用。正例： 能够建立索引的种类分为主键索引、唯一索引、普通索引三种，而覆盖索引只是一种查询的一种效果，用 explain 的结果， extra 列会出现： using index。8.⭐️利用延迟关联或者子查询优化超多分页场景说明： MySQL 并不是跳过 offset 行，而是取 offset+N 行，然后返回放弃前 offset 行，返回 N 行，那当offset 特别大的时候，效率就非常的低下，要么控制返回的总页数，要么对超过特定阈值的页数进行 SQL改写。正例： 先快速定位需要获取的 id 段，然后再关联：SELECT t1.* FROM 表 1 as t1, (select id from 表 1 where 条件 LIMIT 100000,20 ) as t2 where t1.id=t2.id9.当某一列的值全是 NULL 时， count(col)的返回结果为 0，但 sum(col)的返回结果为NULL，因此使用 sum()时需注意 NPE 问题。正例： 可以使用如下方式来避免 sum 的 NPE 问题： SELECT IFNULL(SUM(column), 0) FROM table;10.使用 ISNULL()来判断是否为 NULL 值说明： NULL 与任何值的直接比较都为 NULL。1） NULL<>NULL 的返回结果是 NULL， 而不是 false。2） NULL=NULL 的返回结果是 NULL， 而不是 true。3） NULL<>1 的返回结果是 NULL，而不是 true。反例： 在 SQL 语句中，如果在 null 前换行，影响可读性。 select * from table where column1 is null and column3 is not null; 而ISNULL(column)是一个整体，简洁易懂。从性能数据上分析， ISNULL(column)执行效率更快一些。11.⭐️数据库层面禁止使用（1）不得使用外键与级联，一切外键概念必须在应用层解决。说明： 学生表中的 student_id 是主键，那么成绩表中的 student_id 则为外键。如果更新学生表中的 student_id，同时触发成绩表中的 student_id 更新， 即为级联更新。外键与级联更新适用于单机低并发，不适合分布式、高并发集群；级联更新是强阻塞，存在数据库更新风暴的风险；外键影响数据库的插入速度。（2）禁止使用存储过程，存储过程难以调试和扩展，更没有移植性12. 在表查询中，一律不要使用 * 作为查询的字段列表，需要哪些字段必须明确写明说明： 1）增加查询分析器解析成本。 2）增减字段容易与 resultMap 配置不一致。 3）无用字段增加网络消耗，尤其是 text 类型的字段]]></content>
      
      
      <categories>
          
          <category> 学习 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 开发规范 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>实习经验</title>
      <link href="/posts/2025-01-09-%E5%AE%9E%E4%B9%A0%E7%BB%8F%E9%AA%8C.html"/>
      <url>/posts/2025-01-09-%E5%AE%9E%E4%B9%A0%E7%BB%8F%E9%AA%8C.html</url>
      
        <content type="html"><![CDATA[<h2 id="1-Git使用">1.Git使用</h2><ol><li><p>切换到本地dev分支，如没有</p><ol><li>从远程origin/dev check out一个dev分支(本地)</li></ol></li><li><p>从远程更新dev分支代码。合并方式选择rebase</p></li><li><p>从本地dev分支，切出新的开发分支，如dev_1</p></li><li><p>在dev_1上开发代码提交。</p></li><li><p>切换到本地dev分支，如没有</p><ol><li>从远程origin/dev check out一个dev分支(本地)</li></ol></li><li><p>从远程更新dev分支代码。合并方式选择rebase</p></li><li><p>idea git分支选择开发分支，dev_1</p></li><li><p>选中开发分支上的提交，cherry pick</p></li><li><p>检查本地dev分支提交是否正常</p></li><li><p>push 本地dev分支</p><ol><li><p>push提示冲突，停止push。</p></li><li><p>从远程更新dev分支代码。合并方式选择rebase，解决可能得冲突</p></li><li><p>重新push</p></li></ol></li></ol><h2 id="2-git出现merge提交">2.git出现merge提交</h2><h3 id="问题描述：">问题描述：</h3><p>在git push之后，多了一个Merge remote-tracking branch XXX 提交</p><p>如：</p><p><img src="2025-01-09-%E5%AE%9E%E4%B9%A0%E7%BB%8F%E9%AA%8C/image-11-3663206.png" alt=""></p><p>和</p><p><img src="2025-01-09-%E5%AE%9E%E4%B9%A0%E7%BB%8F%E9%AA%8C/image-10-3663206.png" alt=""></p><p>这导致有两个分支本来是在主干上的，结果新出了一个分支，一方面结构紊乱，另一方面将来合并也困难。</p><h3 id="复盘：">复盘：</h3><p>在从dev分支拉下来的代码开发时没有先pull，导致出现冲突需要合并，在合并的时候使用了git merge出现了这种状况。</p><p><img src="2025-01-09-%E5%AE%9E%E4%B9%A0%E7%BB%8F%E9%AA%8C/image-9.png" alt=""></p><h3 id="解决：">解决：</h3><p>在从dev分支上开发代码时，要先pull一下，在开发完成之后，提交代码之前也要先pull一下。即先pull再修改，先pull再push。</p><p>出现了这种问题怎么解决，先git reset</p><p><img src="2025-01-09-%E5%AE%9E%E4%B9%A0%E7%BB%8F%E9%AA%8C/image-7.png" alt=""></p><p>再git push -force，将远程dev代码改变，再从远程dev新拉一个分支dev-1，使用cherry-pick将自己要的分支加到dev-1分支上，再push到远程dev分支。</p><p>结果：</p><p><img src="2025-01-09-%E5%AE%9E%E4%B9%A0%E7%BB%8F%E9%AA%8C/image.png" alt=""></p><h2 id="3-启动不了，排查问题">3.启动不了，排查问题</h2><p>1.先看active，看看读的是local配置还是dev配置</p><p>说明是读取配置的原因</p><p>查看配置文件</p><p><img src="2025-01-09-%E5%AE%9E%E4%B9%A0%E7%BB%8F%E9%AA%8C/CGWEbNF5porf0NxbvvKcCXftnJb.png" alt=""></p><p>搜索<a href="http://nacos.dev.new.ii-ai.tech/">http://nacos.dev.new.ii-ai.tech</a></p><p><img src="2025-01-09-%E5%AE%9E%E4%B9%A0%E7%BB%8F%E9%AA%8C/YewibnOWqopZpCxrYLqcsseanqf.png" alt=""></p><p>无异常，然后说明是代码原因</p><p>2.指定为local</p><p><img src="2025-01-09-%E5%AE%9E%E4%B9%A0%E7%BB%8F%E9%AA%8C/ZN1LbSaJloOSIVxeNGjc34qJn98.png" alt=""></p><h2 id="4-读懂配置、服务挂掉问题排查">4.读懂配置、服务挂掉问题排查</h2><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">#nacos配置</span><br><span class="line">spring.cloud.nacos.config.server-addr=http://nacos.dev.new.ii-ai.tech</span><br><span class="line">spring.cloud.nacos.config.namespace=local</span><br><span class="line">#标识RPA-Mall 的服务分组</span><br><span class="line">spring.cloud.nacos.discovery.namespace=dev</span><br><span class="line">spring.cloud.nacos.discovery.register-enabled=false</span><br></pre></td></tr></table></figure><p>配置文件放在nacos里，命名空间是本地。</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">@FeignClient(name = &quot;apis-kylin&quot;, path = &quot;/kylin/api&quot;, url = &quot;$&#123;mall.kylin.host:&#125;&quot;,</span><br><span class="line">        configuration = &#123;KylinFeignConfiguration.class&#125;)</span><br></pre></td></tr></table></figure><p>先找url：${mall.kylin.host:}</p><p>再找服务名：apis-kylin（dev环境挂掉），因此要在local的配置环境里面添加${mall.kylin.host:}的字段为qa的服务。</p><h2 id="5-开发规范">5.开发规范</h2><ul><li><p>1、入参校验</p></li><li><p>2、空值预期判断，比如某个业务里面，这里不应该为空的，你就做好assertutil断言判断</p></li><li><p>3、减少For循环嵌套</p></li><li><p>4、减少for循环调接口、查数据库</p></li><li><p>5、共同的业务逻辑抽调方法</p></li><li><p>6、避免少的for循环，比如map判断是否存在某一个key value，直接先获取对象然后Objects.notnull判空</p></li></ul><h2 id="6-自己写一个微服务">6.自己写一个微服务</h2><h3 id="（1）先写配置文件">（1）先写配置文件</h3><p>配置文件放在nacos里，写自己的properties的bean</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * ocr的相关配置</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@author</span> make</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@module</span></span></span><br><span class="line"><span class="comment"> * <span class="doctag">@date</span> 2024/10/13</span></span><br><span class="line"><span class="comment"> **/</span></span><br><span class="line"><span class="meta">@Data</span></span><br><span class="line"><span class="meta">@RefreshScope</span></span><br><span class="line"><span class="meta">@ConfigurationProperties(prefix = &quot;ocr&quot;)</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">OcrConfigProperties</span> &#123;</span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 项目接口统一前缀</span></span><br><span class="line"><span class="comment">     *</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@date</span> 2022/12/03</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@see</span> String</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="meta">@Value(&quot;$&#123;ocr.globalPrefix:/shizai/ai/ocr-aws&#125;&quot;)</span></span><br><span class="line">    <span class="keyword">private</span> String globalPrefix;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * Api请求的Url地址</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="meta">@Value(&quot;$&#123;ocr.apiUrl:https://idp-sea.6estates.com/customer/extraction/fields/async&#125;&quot;)</span></span><br><span class="line">    <span class="keyword">private</span> String apiUrl;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 查询结果的等待时间</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="meta">@Value(&quot;$&#123;ocr.waitTime:30&#125;&quot;)</span></span><br><span class="line">    <span class="keyword">private</span> <span class="type">int</span> waitTime;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 拦截器白名单</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="meta">@Value(&quot;$&#123;college.filterWhiteList:&#125;&quot;)</span></span><br><span class="line">    <span class="keyword">private</span> CharSequence[] filterWhiteList;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>统一前缀添加</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Override</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">configurePathMatch</span><span class="params">(PathMatchConfigurer configurer)</span> &#123;</span><br><span class="line">    configurer.addPathPrefix(ocrConfigProperties.getGlobalPrefix(),</span><br><span class="line">            c -&gt; StrUtil.startWith(c.getPackage().getName(), <span class="string">&quot;ai.ii.ipa.aws.launcher&quot;</span>));</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="（2）写controller层，接入接口，将代码逻辑写在biz里，写全局异常处理器">（2）写controller层，接入接口，将代码逻辑写在biz里，写全局异常处理器</h3><p>利用@RestControllerAdvice和@ExceptionHandler实现</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Slf4j</span></span><br><span class="line"><span class="meta">@RestControllerAdvice</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">CommonControllerAdvice</span> &#123;</span><br><span class="line">    <span class="meta">@ExceptionHandler(ApiException.class)</span></span><br><span class="line">    <span class="keyword">public</span> ResponseObject&lt;String&gt; <span class="title function_">handleApiException</span><span class="params">(ApiException e)</span>&#123;</span><br><span class="line">        <span class="type">String</span> <span class="variable">status</span> <span class="operator">=</span> <span class="literal">null</span>;</span><br><span class="line">        <span class="type">String</span> <span class="variable">errorCode</span> <span class="operator">=</span> <span class="literal">null</span>;</span><br><span class="line">        <span class="type">String</span> <span class="variable">message</span> <span class="operator">=</span> <span class="literal">null</span>;</span><br><span class="line">        <span class="type">String</span> <span class="variable">detailMessage</span> <span class="operator">=</span> e.getMessage();</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span>(e.getStatusCode() == <span class="literal">null</span> &amp;&amp; detailMessage != <span class="literal">null</span>) &#123;</span><br><span class="line">            <span class="keyword">try</span> &#123;</span><br><span class="line">                <span class="type">ObjectMapper</span> <span class="variable">objectMapper</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">ObjectMapper</span>();</span><br><span class="line">                <span class="type">JsonNode</span> <span class="variable">jsonNode</span> <span class="operator">=</span> objectMapper.readTree(detailMessage);</span><br><span class="line">                errorCode = jsonNode.get(<span class="string">&quot;errorCode&quot;</span>).asText();</span><br><span class="line">                message = jsonNode.get(<span class="string">&quot;message&quot;</span>).asText();</span><br><span class="line">                status = jsonNode.get(<span class="string">&quot;status&quot;</span>).asText();</span><br><span class="line">            &#125;<span class="keyword">catch</span> (JsonProcessingException ex)&#123;</span><br><span class="line">                log.error(<span class="string">&quot;[&#123;&#125;] - &#123;&#125;&quot;</span>, ResultCodeEnum.INTERNAL_ERROR.getCode(), e.getMessage());</span><br><span class="line">                <span class="keyword">return</span> ResponseObject.fail(ResultCodeEnum.INTERNAL_ERROR.getCode(), e.getMessage());</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> ResponseObject.fail(ResultCodeEnum.UNKNOWN_ERROR.getCode(),e.getMessage());</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure><h3 id="（3）接口没问题，要开始鉴权。自己写一个拦截器">（3）接口没问题，要开始鉴权。自己写一个拦截器</h3><p>将拦截路径写在配置里。自己写拦截器的逻辑，根据用户的token获取用户的信息</p><p>先写配置</p><p><img src="2025-01-09-%E5%AE%9E%E4%B9%A0%E7%BB%8F%E9%AA%8C/image-8.png" alt=""></p><p>判断当前是否是免密接口</p><p><img src="2025-01-09-%E5%AE%9E%E4%B9%A0%E7%BB%8F%E9%AA%8C/image-2.png" alt=""></p><p>写一个拦截器</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Slf4j</span></span><br><span class="line"><span class="meta">@Component</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">AuthInfoLoadInterceptor</span> <span class="keyword">extends</span> <span class="title class_">HandlerInterceptorAdapter</span> &#123;</span><br><span class="line">    <span class="meta">@Resource</span></span><br><span class="line">    <span class="keyword">private</span> OcrConfigProperties ocrConfigProperties;</span><br><span class="line">    <span class="meta">@Resource</span></span><br><span class="line">    <span class="keyword">private</span> LoginHeaderAuthenticationTypePlug loginHeaderAuthenticationTypePlug;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> <span class="type">boolean</span> <span class="title function_">preHandle</span><span class="params">(<span class="meta">@Nonnull</span> HttpServletRequest request,</span></span><br><span class="line"><span class="params">                             <span class="meta">@Nonnull</span> HttpServletResponse response,</span></span><br><span class="line"><span class="params">                             <span class="meta">@Nonnull</span> Object handler)</span> <span class="keyword">throws</span> Exception &#123;</span><br><span class="line">        <span class="comment">//判断当前方法是免登。不免登，则进行登录校验</span></span><br><span class="line">        <span class="keyword">if</span> (!isNoLogin(request, handler)) &#123;</span><br><span class="line">            <span class="comment">//进行鉴权</span></span><br><span class="line">            loginHeaderAuthenticationTypePlug.checkIsLogin(request, handler);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> <span class="built_in">super</span>.preHandle(request, response, handler);</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br></pre></td></tr></table></figure><p>获取token进行登录校验</p><p>用户登录走的是UIC服务，用户信息存在redis里，key是一个token,value是一个用户详细信息的对象。获取到了详细信息之后将信息存到线程本地变量里面</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> Boolean <span class="title function_">checkIsLogin</span><span class="params">(HttpServletRequest request, Object handler)</span> &#123;</span><br><span class="line">    <span class="type">String</span> <span class="variable">token</span> <span class="operator">=</span> request.getHeader(UserAuthCenter.RPA_TOKEN_HEADER);</span><br><span class="line">    AssertUtil.isTrue(StrUtil.isNotBlank(token), ResultCodeEnum.UNAUTHORIZED.getCode(), <span class="string">&quot;用户未登录&quot;</span>);</span><br><span class="line">    UserAuthCenter.setRpaToken(token);</span><br><span class="line">    <span class="type">UICTokenUserInfo</span> <span class="variable">tokenInfoDTO</span> <span class="operator">=</span> <span class="literal">null</span>;</span><br><span class="line">    <span class="keyword">try</span> &#123;</span><br><span class="line">        <span class="comment">//从redis获取token对应用户信息， 没有则接口获取，3分钟后redis过期</span></span><br><span class="line">        tokenInfoDTO = manager.get(RedisCacheKeyConstant.getWebUserToken(token),</span><br><span class="line">                () -&gt; getCurrentWebUserInfo(token), <span class="number">180L</span>);</span><br><span class="line">    &#125; <span class="keyword">catch</span> (Exception e) &#123;</span><br><span class="line">        log.warn(StrUtil.format(<span class="string">&quot;get webUser by token fail, token:&#123;&#125;, message: &#123;&#125;&quot;</span>, token, e.getMessage()));</span><br><span class="line">    &#125;</span><br><span class="line">    AssertUtil.isTrue(Objects.nonNull(tokenInfoDTO), ResultCodeEnum.UNAUTHORIZED.getCode(), <span class="string">&quot;用户未登录&quot;</span>);</span><br><span class="line">    <span class="comment">//设置线程变量</span></span><br><span class="line">    UserAuthCenter.setWebUser(tokenInfoDTO);</span><br><span class="line">    <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>添加拦截器</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Override</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">addInterceptors</span><span class="params">(InterceptorRegistry registry)</span> &#123;</span><br><span class="line">    registry.addInterceptor(authInfoLoadInterceptor)</span><br><span class="line">            .addPathPatterns(<span class="string">&quot;/**&quot;</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="（4）接入UIC微服务，将第三方API的配置信息放入UIC的数据源中，从此处读取。">（4）接入UIC微服务，将第三方API的配置信息放入UIC的数据源中，从此处读取。</h3><p>采用feign调用，要写一些DTO和配置</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@FeignClient(name = &quot;uic-user&quot;, path = &quot;/uic-user/v1&quot;, contextId = &quot;openUicUserFeignClient&quot;,</span></span><br><span class="line"><span class="meta">        configuration = UicV2FeignConfiguration.class)</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">interface</span> <span class="title class_">OpenUicUserFeignClient</span> &#123;</span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 查询用户列表</span></span><br><span class="line"><span class="comment">     *</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> param 参数</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@return</span> &#123;<span class="doctag">@link</span> ResponseObject&lt; List &lt; UserDTO &gt;&gt;&#125;</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="meta">@GetMapping(&quot;/openApi/users/list&quot;)</span></span><br><span class="line">    ResponseObject&lt;List&lt;UserDTO&gt;&gt; <span class="title function_">listUserByUserUids</span><span class="params">(<span class="meta">@SpringQueryMap</span> UicOpenUserQueryRequest param)</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="（5）⭐️自定义注解-AOP将用户的操作日志记录到数据库中。">（5）⭐️自定义注解+AOP将用户的操作日志记录到数据库中。</h3><p>基于Spring AOP + EL表达式将用户操作自动入库</p><p><strong>实例</strong></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 统一ocr接口</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@PARAM</span>: <span class="doctag">@param</span> param</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@Author</span>: Make</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@DATE</span>: 2024/10/25</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@RETURN</span>: <span class="doctag">@return</span></span></span><br><span class="line"><span class="comment"> **/</span></span><br><span class="line"><span class="meta">@LogRecord(objectType = ResourceType.TENANT, objectId = &quot;#webUser.tenantId&quot;,</span></span><br><span class="line"><span class="meta">        operationContent = &quot;&#123;#webUser.userName&#125; 使用ocr-aws提取 &#123;#param.fileType&#125; 文件类型数据&quot;, operationType = OperationType.SELECT)</span></span><br><span class="line"><span class="meta">@PostMapping(&quot;/AWS-OCR&quot;)</span></span><br><span class="line"><span class="keyword">public</span> ResponseObject&lt;ApiResponse&gt; <span class="title function_">ocrAws</span><span class="params">(<span class="meta">@Valid</span> AwsOcrControllerParam param)</span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(ocrCommonBiz.havePermission())&#123;</span><br><span class="line">        <span class="type">SixEstateApiParam</span> <span class="variable">apiParam</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">SixEstateApiParam</span>();</span><br><span class="line">        BeanUtils.copyProperties(param, apiParam);</span><br><span class="line">        apiParam.setFileName(UserAuthCenter.getWebUser().getAccountUUID() + <span class="string">&quot;_&quot;</span> + param.getFileContent().getOriginalFilename());</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            apiParam.setFileContent(param.getFileContent().getBytes());</span><br><span class="line">            <span class="keyword">return</span> ResponseObject.success(ocrCommonBiz.Extract(apiParam));</span><br><span class="line">        &#125;<span class="keyword">catch</span> (IOException e)&#123;</span><br><span class="line">            log.info(<span class="string">&quot;文件读取失败&quot;</span>, e);</span><br><span class="line">        &#125;<span class="keyword">finally</span> &#123;</span><br><span class="line">            <span class="type">File</span> <span class="variable">tmp</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">File</span>(<span class="string">&quot;ocr-aws-launcher/target/classes/tmp/&quot;</span>  + apiParam.getFileName());</span><br><span class="line">            <span class="keyword">if</span> (tmp.exists()) &#123;</span><br><span class="line">                FileUtil.del(tmp);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> ResponseObject.fail(ResultCodeEnum.UNAUTHORIZED.getCode(), <span class="string">&quot;用户无功能权限！&quot;</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong>先定义一个日志记录注解</strong></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Retention(RetentionPolicy.RUNTIME)</span></span><br><span class="line"><span class="meta">@Target(ElementType.METHOD)</span></span><br><span class="line"><span class="meta">@Documented</span></span><br><span class="line"><span class="keyword">public</span> <span class="meta">@interface</span> LogRecord &#123;</span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 资源类型</span></span><br><span class="line"><span class="comment">     *</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@return</span> &#123;<span class="doctag">@link</span> ResourceType&#125;</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    ResourceType <span class="title function_">objectType</span><span class="params">()</span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 操作类型</span></span><br><span class="line"><span class="comment">     *</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@return</span> &#123;<span class="doctag">@link</span> OperationType&#125;</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    OperationType <span class="title function_">operationType</span><span class="params">()</span> <span class="keyword">default</span> OperationType.UNKNOWN;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 资源id</span></span><br><span class="line"><span class="comment">     *</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@return</span> &#123;<span class="doctag">@link</span> String&#125;</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    String <span class="title function_">objectId</span><span class="params">()</span> <span class="keyword">default</span> <span class="string">&quot;&quot;</span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 操作描述</span></span><br><span class="line"><span class="comment">     *</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@return</span> &#123;<span class="doctag">@link</span> String&#125;</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    String <span class="title function_">operationDescription</span><span class="params">()</span> <span class="keyword">default</span> <span class="string">&quot;&quot;</span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 操作内容</span></span><br><span class="line"><span class="comment">     *</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@return</span> &#123;<span class="doctag">@link</span> String&#125;</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    String <span class="title function_">operationContent</span><span class="params">()</span> <span class="keyword">default</span> <span class="string">&quot;&quot;</span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 是否记录参数</span></span><br><span class="line"><span class="comment">     *</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@return</span> boolean</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="type">boolean</span> <span class="title function_">isRecordParam</span><span class="params">()</span> <span class="keyword">default</span> <span class="literal">true</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong>再利用基于JDK动态代理的AOP去增强这个自定义注解</strong></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">LogAspect</span> &#123;</span><br><span class="line">    <span class="meta">@Resource</span></span><br><span class="line">    <span class="keyword">private</span> OperateLogService operateLogService;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 设置操作日志切入点，记录操作日志，在注解位置切入代码</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="meta">@Pointcut(value = &quot;@annotation(ai.ii.ipa.aws.util.log.annotation.LogRecord)&quot;)</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">logPointcut</span><span class="params">()</span> &#123;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="meta">@Around(value = &quot;logPointcut() &amp;&amp; @annotation(logRecord)&quot;)</span></span><br><span class="line"><span class="keyword">public</span> Object <span class="title function_">around</span><span class="params">(ProceedingJoinPoint jp, LogRecord logRecord)</span> <span class="keyword">throws</span> Throwable &#123;</span><br><span class="line">    <span class="type">UICTokenUserInfo</span> <span class="variable">webUser</span> <span class="operator">=</span> UserAuthCenter.getWebUser();</span><br><span class="line">    ...</span><br></pre></td></tr></table></figure><p><strong>增强的具体实现：环绕通知：</strong></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Around(value = &quot;logPointcut() &amp;&amp; @annotation(logRecord)&quot;)</span></span><br><span class="line"><span class="keyword">public</span> Object <span class="title function_">around</span><span class="params">(ProceedingJoinPoint jp, LogRecord logRecord)</span> <span class="keyword">throws</span> Throwable &#123;</span><br><span class="line">    <span class="type">UICTokenUserInfo</span> <span class="variable">webUser</span> <span class="operator">=</span> UserAuthCenter.getWebUser();</span><br><span class="line">    <span class="type">RequestAttributes</span> <span class="variable">requestAttributes</span> <span class="operator">=</span> RequestContextHolder.getRequestAttributes();</span><br><span class="line">    <span class="type">HttpServletRequest</span> <span class="variable">request</span> <span class="operator">=</span> (HttpServletRequest) requestAttributes.resolveReference(RequestAttributes.REFERENCE_REQUEST);</span><br><span class="line"></span><br><span class="line">    <span class="type">OperateLog</span> <span class="variable">logEntity</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">OperateLog</span>();</span><br><span class="line">    logEntity.setOperUrl(request.getRequestURI());</span><br><span class="line">    logEntity.setOperUserName(webUser.getUserName());</span><br><span class="line">    logEntity.setOperUserRealname(webUser.getRealName());</span><br><span class="line">    logEntity.setOperUserIp(IpUtils.getIp(request));</span><br><span class="line">    logEntity.setOperType(logRecord.operationType().getCode().toString());</span><br><span class="line">    logEntity.setOperDescription(logRecord.operationDescription());</span><br><span class="line">    logEntity.setOperObjectType(logRecord.objectType().getType());</span><br><span class="line">    <span class="comment">//请求的参数</span></span><br><span class="line">    Map&lt;String, Object&gt; data = getDataMap(jp);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (logRecord.isRecordParam()) &#123;</span><br><span class="line">        <span class="keyword">if</span>(data.get(<span class="string">&quot;param&quot;</span>) != <span class="literal">null</span>)&#123;</span><br><span class="line">            <span class="type">AwsOcrControllerParam</span> <span class="variable">param</span> <span class="operator">=</span> (AwsOcrControllerParam) data.get(<span class="string">&quot;param&quot;</span>);</span><br><span class="line">            <span class="type">SixEstateApiParam</span> <span class="variable">newParam</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">SixEstateApiParam</span>();</span><br><span class="line">            BeanUtils.copyProperties(param, newParam);</span><br><span class="line">            newParam.setFileName(param.getFileContent().getOriginalFilename());</span><br><span class="line">            data.put(<span class="string">&quot;param&quot;</span>, newParam);</span><br><span class="line">        &#125;</span><br><span class="line">        logEntity.setOperParam(JSONObject.toJSONString(data));</span><br><span class="line">    &#125;</span><br><span class="line">    logEntity.setSystemUserId(webUser.getTenantUserId());</span><br><span class="line">    <span class="keyword">try</span> &#123;</span><br><span class="line">        <span class="comment">// @Around需要手动执行.proceed()操作;</span></span><br><span class="line">        <span class="type">Object</span> <span class="variable">result</span> <span class="operator">=</span> jp.proceed();</span><br><span class="line">        logEntity.setOperResult(JSONObject.toJSONString(result));</span><br><span class="line">        logEntity.setStatus(UserOperationStatusType.SUCCESS.getType());</span><br><span class="line">        data.put(<span class="string">&quot;result&quot;</span>, result);</span><br><span class="line">        <span class="keyword">return</span> result;</span><br><span class="line">    &#125; <span class="keyword">catch</span> (Exception e) &#123;</span><br><span class="line">        Map&lt;String, String&gt; result = <span class="keyword">new</span> <span class="title class_">HashMap</span>&lt;&gt;();</span><br><span class="line">        result.put(<span class="string">&quot;result&quot;</span>, <span class="string">&quot;fail&quot;</span>);</span><br><span class="line">        result.put(<span class="string">&quot;exceptionMessage&quot;</span>, e.getMessage());</span><br><span class="line">        result.put(<span class="string">&quot;exceptionName&quot;</span>, e.getClass().getName());</span><br><span class="line"></span><br><span class="line">        logEntity.setOperResult(JSONObject.toJSONString(result));</span><br><span class="line">        logEntity.setStatus(UserOperationStatusType.FAIL.getType());</span><br><span class="line">        log.info(logEntity.toString(), e);</span><br><span class="line">        <span class="keyword">throw</span> e;</span><br><span class="line">    &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">        data.put(<span class="string">&quot;webUser&quot;</span>, webUser);</span><br><span class="line">        data.put(<span class="string">&quot;date&quot;</span>, DateUtil.formatDateTime(<span class="keyword">new</span> <span class="title class_">Date</span>()));</span><br><span class="line">        <span class="comment">//有设置操作文案信息，且操作成功时。</span></span><br><span class="line">        <span class="keyword">if</span> (StrUtil.isNotBlank(logRecord.operationContent())</span><br><span class="line">                &amp;&amp; UserOperationStatusType.SUCCESS.getType().equals(logEntity.getStatus())) &#123;</span><br><span class="line">            <span class="comment">//生成操作内容，操作成功时才设置描述</span></span><br><span class="line">            logEntity.setOperDescription(replaceElString(logRecord.operationContent(), data));</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">//生成objectId</span></span><br><span class="line">        <span class="type">String</span> <span class="variable">objectId</span> <span class="operator">=</span> getElString(logRecord.objectId(), data);</span><br><span class="line">        logEntity.setOperObjectId(objectId);</span><br><span class="line">        logEntity.setOperTime(LocalDateTime.now());</span><br><span class="line">        operateLogService.save(logEntity);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong>获取请求参数：</strong></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 转换request请求参数</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param</span> jp</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@return</span></span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">private</span> Map&lt;String, Object&gt; <span class="title function_">getDataMap</span><span class="params">(ProceedingJoinPoint jp)</span>&#123;</span><br><span class="line">    Map&lt;String, Object&gt; data = Maps.newHashMap();</span><br><span class="line">    Object[] paramValues = jp.getArgs();</span><br><span class="line">    String[] paramNames = ((CodeSignature) jp.getSignature()).getParameterNames();</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i &lt; paramNames.length; i++) &#123;</span><br><span class="line">        <span class="keyword">if</span> (Objects.nonNull(paramValues[i])) &#123;</span><br><span class="line">            data.put(paramNames[i], paramValues[i]);</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            data.put(paramNames[i], <span class="string">&quot;&quot;</span>);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> data;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong>EL表达式动态参数：</strong></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">private</span> String <span class="title function_">replaceElString</span><span class="params">(String elStr, Map&lt;String, Object&gt; data)</span> &#123;</span><br><span class="line">    <span class="comment">// 操作明细</span></span><br><span class="line">    <span class="keyword">try</span> &#123;</span><br><span class="line">        <span class="keyword">if</span> (StrUtil.isNotBlank(elStr)) &#123;</span><br><span class="line">            <span class="keyword">return</span> ElUtil.replaceElString(elStr, data);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125; <span class="keyword">catch</span> (Exception e) &#123;</span><br><span class="line">        log.info(e.toString(), e);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="string">&quot;&quot;</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">private</span> String <span class="title function_">getElString</span><span class="params">(String elStr, Map&lt;String, Object&gt; data)</span> &#123;</span><br><span class="line">    <span class="comment">// 操作明细</span></span><br><span class="line">    <span class="keyword">try</span> &#123;</span><br><span class="line">        <span class="keyword">if</span> (StrUtil.isNotBlank(elStr)) &#123;</span><br><span class="line">            <span class="keyword">return</span> ElUtil.parseExpression(elStr, data);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125; <span class="keyword">catch</span> (Exception e) &#123;</span><br><span class="line">        log.info(e.toString(), e);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="string">&quot;&quot;</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>PS：有时候自己起一个微服务会很麻烦，有很多代码结构要自己搞，而且后期还要接入公式生态的接口，这时就需要进行代码迁移。将college的代码进行修改后转化成ocr-aws的代码。</p><p>首先先定义一个</p><p>技巧：</p><ol><li><p>先进行mvn clean 去除target</p></li><li><p>去除.idea的配置文件</p></li><li><p>去除.iml文件，自己进行代码结构的修改</p></li></ol><h2 id="7-任务异步执行实例">7.任务异步执行实例</h2><p>需求：将社区的官方发的文章全部导出，并通过邮箱发给指定用户（文档私有化），由于文件比较多，这里采用多线程是比较合理的。</p><p>异步文件下载</p><p><img src="2025-01-09-%E5%AE%9E%E4%B9%A0%E7%BB%8F%E9%AA%8C/image-6.png" alt=""></p><p>公用线程池</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 公共线程池，不太重要的线程可以放在此处执行</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@date</span> 2023/04/06</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@see</span> ExecutorService</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="type">ExecutorService</span> <span class="variable">COMMON_EXECUTOR</span> <span class="operator">=</span> TtlExecutors.getTtlExecutorService(<span class="keyword">new</span> <span class="title class_">ThreadPoolExecutor</span>(<span class="number">10</span>, <span class="number">30</span>,</span><br><span class="line">        <span class="number">5L</span>, TimeUnit.MINUTES, <span class="keyword">new</span> <span class="title class_">LinkedBlockingQueue</span>&lt;&gt;(),</span><br><span class="line">        <span class="keyword">new</span> <span class="title class_">AdminThreadFactory</span>(<span class="string">&quot;COMMON_EXECUTOR&quot;</span>)));</span><br></pre></td></tr></table></figure><p>（1）先分页查询所有官方文章的分页</p><p>（2）根据每个文章的fileCode拿到一个富文本对象</p><p>（3）根据富文本对象，下载所有相关资源，将富文本里的资源的绝对路径改为相对路径，导出为html文件</p><p><img src="2025-01-09-%E5%AE%9E%E4%B9%A0%E7%BB%8F%E9%AA%8C/image-4.png" alt=""></p><p>（4）导出为压缩包并发送</p><h2 id="8-设计模式-优化">8.设计模式 &amp; 优化</h2><p>有八中消息类型：</p><p><img src="2025-01-09-%E5%AE%9E%E4%B9%A0%E7%BB%8F%E9%AA%8C/image-1.png" alt=""></p><p>首先，为了让用户评论、点赞与消息发送解耦，可以采用观察者模式，用户评论触发一个消息通知事件</p><p><img src="2025-01-09-%E5%AE%9E%E4%B9%A0%E7%BB%8F%E9%AA%8C/image-3.png" alt=""></p><p>在处理消息时，不同的消息类型有不同的策略。</p><p>比如点赞消息时先聚合到redis，再迁移到数据库</p><p><img src="2025-01-09-%E5%AE%9E%E4%B9%A0%E7%BB%8F%E9%AA%8C/image-5.png" alt=""></p><p>官方消息是直接存消息表，在用户登录的时候将官方消息迁移到用户消息接收表（这样可以避免数据库压力太大）</p><p><img src="2025-01-09-%E5%AE%9E%E4%B9%A0%E7%BB%8F%E9%AA%8C/image-24.png" alt=""></p><p>用户的回复消息，是要先存入到消息表，生成一个消息id，再存入消息接受表。给消息id和用户id加唯一索引，这样可以避免用户收到重复的消息。</p><p><img src="2025-01-09-%E5%AE%9E%E4%B9%A0%E7%BB%8F%E9%AA%8C/image-26.png" alt=""></p><p>因为有三种不同的应对策略，所以可以写一个工厂来统一处理。首先先定义一个工厂，写一个消息处理的接口</p><p><img src="2025-01-09-%E5%AE%9E%E4%B9%A0%E7%BB%8F%E9%AA%8C/image-25.png" alt=""></p><p>接口</p><p><img src="2025-01-09-%E5%AE%9E%E4%B9%A0%E7%BB%8F%E9%AA%8C/image-22.png" alt=""></p><p>针对接口定义三个实现类，处理不同的消息类型</p><p>点赞消息处理</p><p><img src="2025-01-09-%E5%AE%9E%E4%B9%A0%E7%BB%8F%E9%AA%8C/image-21.png" alt=""></p><p>官方消息处理</p><p><img src="2025-01-09-%E5%AE%9E%E4%B9%A0%E7%BB%8F%E9%AA%8C/image-23.png" alt=""></p><p>回复消息处理</p><p><img src="2025-01-09-%E5%AE%9E%E4%B9%A0%E7%BB%8F%E9%AA%8C/image-18.png" alt=""></p><h2 id="9-【多线程优化】CompletableFuture使用">9.【多线程优化】<a href="https://javaguide.cn/java/concurrent/java-concurrent-questions-03.html#completablefuture-%E7%B1%BB%E6%9C%89%E4%BB%80%E4%B9%88%E7%94%A8">CompletableFuture</a>使用</h2><p>需求：将批量查询到的用户授权信息导出为文件，发送邮箱</p><p>根据请求参数获取租户以及关联租户的所有授权码文件，</p><p>需要进行用户授权码数据的导出，在这里使用CompletableFuture，采用异步的执行思想，不会阻塞主线程，当文件全部导出后，会自动回调进行后续操作。</p><p>导出完需要做后置处理。将数据导出表格文件。</p><p><img src="2025-01-09-%E5%AE%9E%E4%B9%A0%E7%BB%8F%E9%AA%8C/image-16.png" alt=""></p><p>执行完自动回调</p><p><img src="2025-01-09-%E5%AE%9E%E4%B9%A0%E7%BB%8F%E9%AA%8C/image-20.png" alt=""></p><p>将返回的数据（用户授权对象）写入到xlsx里面，用阿里巴巴的EasyExcel导出</p><p><img src="2025-01-09-%E5%AE%9E%E4%B9%A0%E7%BB%8F%E9%AA%8C/image-17.png" alt=""></p><p>不使用completableFuture，速度很慢，因为要for循环一个一个执行。使用了速度提升了。</p><h2 id="10-自动生成DAO、XML代码">10.自动生成DAO、XML代码</h2><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> ai.ii.ipa.college.launcher.mybatis;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> com.baomidou.mybatisplus.generator.AutoGenerator;</span><br><span class="line"><span class="keyword">import</span> com.baomidou.mybatisplus.generator.config.*;</span><br><span class="line"><span class="keyword">import</span> com.baomidou.mybatisplus.generator.config.rules.DateType;</span><br><span class="line"><span class="keyword">import</span> com.baomidou.mybatisplus.generator.config.rules.NamingStrategy;</span><br><span class="line"><span class="keyword">import</span> lombok.extern.slf4j.Slf4j;</span><br><span class="line"><span class="keyword">import</span> org.apache.commons.lang3.ArrayUtils;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@author</span> zhengfeipeng</span></span><br><span class="line"><span class="comment"> * &lt;p&gt;</span></span><br><span class="line"><span class="comment"> * 生成数据库表对应的 实体/Dao/Service/Controller</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="meta">@Slf4j</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">CodeGenerator</span> &#123;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 包含的表. 若空则表示该库中全部的表.</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> String[] tables = &#123;</span><br><span class="line">            <span class="string">&quot;college_examination_user_record&quot;</span>,</span><br><span class="line">            <span class="string">&quot;college_examination_user_record_exercises_rel&quot;</span>,</span><br><span class="line">    &#125;;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 排除的表.</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> String[] exTables = &#123;</span><br><span class="line">    &#125;;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">        <span class="comment">// 代码生成器</span></span><br><span class="line">        <span class="type">AutoGenerator</span> <span class="variable">mpg</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">AutoGenerator</span>();</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 全局配置</span></span><br><span class="line">        <span class="type">GlobalConfig</span> <span class="variable">gc</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">GlobalConfig</span>();</span><br><span class="line">        <span class="type">String</span> <span class="variable">projectPath</span> <span class="operator">=</span> System.getProperty(<span class="string">&quot;user.dir&quot;</span>);</span><br><span class="line">        log.debug(<span class="string">&quot;projectPath: &quot;</span> + projectPath);</span><br><span class="line">        <span class="comment">// 生成的文件输出目录</span></span><br><span class="line">        gc.setOutputDir(projectPath + <span class="string">&quot;/temp&quot;</span>);</span><br><span class="line">        <span class="comment">// 类注释中 @author 的值</span></span><br><span class="line">        gc.setAuthor(<span class="string">&quot;卫庄&quot;</span>);</span><br><span class="line">        <span class="comment">// 生成的Dao命名格式: 表名+Dao</span></span><br><span class="line">        gc.setMapperName(<span class="string">&quot;%sDao&quot;</span>);</span><br><span class="line">        <span class="comment">// 生成的实体类命名格式: T+表名</span></span><br><span class="line">        gc.setEntityName(<span class="string">&quot;%sDO&quot;</span>);</span><br><span class="line">        <span class="comment">// 数据库日期/时间戳字段在java中映射的类</span></span><br><span class="line">        gc.setDateType(DateType.TIME_PACK);</span><br><span class="line">        <span class="comment">// 是否覆盖之前生成的文件</span></span><br><span class="line">        gc.setFileOverride(<span class="literal">true</span>);</span><br><span class="line">        gc.setOpen(<span class="literal">false</span>);</span><br><span class="line">        <span class="comment">// 是否在Mapper文件中生成实体的映射</span></span><br><span class="line">        gc.setBaseResultMap(<span class="literal">true</span>);</span><br><span class="line">        gc.setBaseColumnList(<span class="literal">true</span>);</span><br><span class="line">        <span class="comment">// 实体属性 Swagger2 注解</span></span><br><span class="line">        gc.setSwagger2(<span class="literal">false</span>);</span><br><span class="line"></span><br><span class="line">        mpg.setGlobalConfig(gc);</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 数据源配置</span></span><br><span class="line">        <span class="type">DataSourceConfig</span> <span class="variable">dsc</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">DataSourceConfig</span>();</span><br><span class="line">        dsc.setUrl(<span class="string">&quot;jdbc:mysql://rm-bp1sluyi8846k48we.mysql.rds.aliyuncs.com:3306/rpa_college?serverTimezone=Asia/Shanghai&amp;useSSL=false&amp;useUnicode=true&amp;characterEncoding=UTF-8&amp;allowMultiQueries=true&quot;</span>);</span><br><span class="line">        dsc.setDriverName(<span class="string">&quot;com.mysql.cj.jdbc.Driver&quot;</span>);</span><br><span class="line">        dsc.setUsername(<span class="string">&quot;xxx&quot;</span>);</span><br><span class="line">        dsc.setPassword(<span class="string">&quot;xxx&quot;</span>);</span><br><span class="line">        mpg.setDataSource(dsc);</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 包配置</span></span><br><span class="line">        <span class="type">PackageConfig</span> <span class="variable">pc</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">PackageConfig</span>();</span><br><span class="line">        <span class="comment">//</span></span><br><span class="line">        pc.setParent(<span class="string">&quot;ai.ii.ipa.college&quot;</span>);</span><br><span class="line">        pc.setEntity(<span class="string">&quot;domain.entity&quot;</span>);</span><br><span class="line">        pc.setMapper(<span class="string">&quot;dao&quot;</span>);</span><br><span class="line">        pc.setService(<span class="string">&quot;service.basic&quot;</span>);</span><br><span class="line">        pc.setServiceImpl(<span class="string">&quot;service&quot;</span>);</span><br><span class="line">        mpg.setPackageInfo(pc);</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 策略配置</span></span><br><span class="line">        <span class="type">StrategyConfig</span> <span class="variable">strategy</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">StrategyConfig</span>();</span><br><span class="line">        strategy.setNaming(NamingStrategy.underline_to_camel);</span><br><span class="line">        strategy.setColumnNaming(NamingStrategy.underline_to_camel);</span><br><span class="line">        strategy.setEntityLombokModel(<span class="literal">true</span>);</span><br><span class="line">        strategy.setInclude(tables);</span><br><span class="line">        <span class="keyword">if</span> (ArrayUtils.isEmpty(tables)) &#123;</span><br><span class="line">            strategy.setExclude(exTables);</span><br><span class="line">        &#125;</span><br><span class="line">        strategy.setRestControllerStyle(<span class="literal">true</span>);</span><br><span class="line">        strategy.setControllerMappingHyphenStyle(<span class="literal">true</span>);</span><br><span class="line">        strategy.setTablePrefix(<span class="string">&quot;t_&quot;</span>);</span><br><span class="line">        strategy.setEntityTableFieldAnnotationEnable(<span class="literal">true</span>);</span><br><span class="line"></span><br><span class="line">        mpg.setStrategy(strategy);</span><br><span class="line"></span><br><span class="line">        <span class="type">TemplateConfig</span> <span class="variable">tc</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">TemplateConfig</span>();</span><br><span class="line">        mpg.setTemplate(tc);</span><br><span class="line">        mpg.execute();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="11-IDEA执行插件">11.IDEA执行插件</h2><p><strong>(1) Apifox</strong></p><p>一键生成接口文档</p><p><strong>(2) EasyJavaDoc</strong></p><p>文档注释</p><p><img src="2025-01-09-%E5%AE%9E%E4%B9%A0%E7%BB%8F%E9%AA%8C/image-15.png" alt=""></p><p><strong>(3) Maven Heaper</strong></p><p><strong>(4) MybatisX</strong></p><p>DAO 和xml互跳</p><p><strong>(5) Ptg</strong></p><p><img src="2025-01-09-%E5%AE%9E%E4%B9%A0%E7%BB%8F%E9%AA%8C/image-19.png" alt=""></p><p><strong>(6) Rainbow Brackets</strong></p><p>括号颜色</p><p><strong>(7) Redis Heaper</strong></p><p>IDEA查看redis</p><p><strong>(8) Tong Yi Lin Ma</strong></p><p>代码自动补全</p><p><strong>(9) DataBase Tools And SQL</strong></p><p>IDEA连接数据库</p><p><strong>(10) Grep Console</strong></p><p>控制台颜色</p><p><strong>(11) Alibaba Java Coding Guidelines</strong></p><p>阿里开发规约</p><p><strong>(12) Restful Tool</strong></p><p>右侧显示controller路径</p><h2 id="12-git-comment规范">12.git comment规范</h2><p><img src="2025-01-09-%E5%AE%9E%E4%B9%A0%E7%BB%8F%E9%AA%8C/image-13.png" alt=""></p><h2 id="13-设计表的经验">13.设计表的经验</h2><p>（1）一开始设计的是没有用户点赞表，每次点赞从消息记录查，这样很不符合设计理念，消息表就只应该存和查消息。</p><p>（2）对于不能为负数的字段，一定要用unsigned</p><h2 id="14-实习中遇到的问题">14.实习中遇到的问题</h2><h3 id="（1）PRD阅读">（1）PRD阅读</h3><p>我在实习中遇到的最多的问题其实还是经验问题。比如在我一开始做社区的时候，没有深入的阅读PRD，直接很快就开发了，这导致开发效率很低，为了实现PRD的需求，经常需要一边开发，一遍边表。比如，我最开始设计社区的时候，对于呈现用户的点赞记录，采用的是从消息表去找有没有记录，这样是很不合理的，因为后面如果做消息聚合，就找不到用户的点赞记录了，所以后面又加了个用户点赞表。</p><p>我想说的就是，在开发前，一定要多多阅读PRD，尽量把表设计完善，不要一边开发一边改表。</p><p>①一开始设计表的时候，对于官方发送通知，我采取的是给每个用户插入一条消息记录，这样会导致数据库表的数据记录很多，在用户量多的时候表会直接炸掉，后面经过师兄的指导，采用了这个设计方案：即用户在登录了查看消息的时候，拉取到官方消息。</p><p><strong>① 设计模式优化</strong></p><p>采用公司内部提供的事件函数，将用户评论和发送消息这两个事件解耦。即用户发送评论成功后，触发一个异步事件，在监听到这个事件之后，从消息事件处理工厂拿出一个hander对象处理这个事件。</p><p>比如：</p><p><strong>为什么不用消息队列？</strong>-----用消息队列当然也能实现这个功能，但是我的理解是如果是不同的系统之间才用消息队列。比如你一个消息在消费时需要调用另外一个服务的接口，这个时候可以用MQ。而社区一整个是一个系统，暂时还没有用到MQ异步调用别的服务接口的场景。</p><p><strong>②对于点赞消息聚合写</strong></p><p>会发现，采用Mysql一条一条将数据插入的性能是很低的，需要建立频繁的连接。所以我采用的是从Redis定时将一批数据插入到数据库中。公司内部有实现高速批量插入数据的接口（要开mysql的设置）。</p><p>虽然这样会有丢失数据的风险，但是对于点赞消息这种不算重要的消息是值得的。</p><p><strong>③数据库聚合</strong></p><p>按照接收者id + 通知对象id 对同一个用户，同一内容的点赞消息在数据库里做聚合，即不为每一条点赞消息都插入一条记录。这能够大大缓解数据库的存储压力，并且有利于以后数据库的分库分表。</p><p><strong>④多线程异步优化</strong></p><p>官方文档私有化(asyncDownload)：</p><p>在实在学院里，Admin的后台里有一个接口的功能是将官方文档私有化。具体功能就是将文件下载下来，然后发送邮件给指定用户。在这里采用了CompletableFuture，无需阻塞主线程。在下载完文档后(CompletableFuture.allOf)自动回调发送邮箱的接口。提升文档私有化接口的性能。</p><h2 id="15-为什么在实际开发中不建议用BeanUtil-copyProperties">15.为什么在实际开发中不建议用BeanUtil.copyProperties</h2><h3 id="（1）性能问题">（1）性能问题</h3><p><code>BeanUtils.copyProperties</code> 是一种通过反射机制实现的属性复制。反射通常会比直接赋值或手动编写的赋值代码慢，尤其是在大量数据需要复制时，性能开销可能会显得比较大。对于高性能要求的场景，如处理大数据量时，频繁使用反射可能会影响系统的响应速度。</p><h3 id="（2）维护性差">（2）维护性差</h3><p>如果项目中大量使用 <code>BeanUtils.copyProperties</code>，尤其是在源对象和目标对象之间没有完全一致的字段或属性类型时，复制的逻辑可能变得不清晰且容易出错。你还需要确保每次源对象和目标对象结构发生变化时都修改代码，从而影响代码的可维护性。</p><h3 id="（3）解决方案：使用MapStruct">（3）解决方案：使用MapStruct</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Mapper(componentModel = &quot;spring&quot;, unmappedTargetPolicy = ReportingPolicy.IGNORE)</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">interface</span> <span class="title class_">CollegeCommunityParamConvert</span> &#123;</span><br><span class="line">    <span class="meta">@Mappings(&#123;</span></span><br><span class="line"><span class="meta">        @Mapping(target = &quot;id&quot; , source = &quot;id&quot;),</span></span><br><span class="line"><span class="meta">        @Mapping(target = &quot;userUid&quot; , source = &quot;userUid&quot;),</span></span><br><span class="line"><span class="meta">        @Mapping(target = &quot;updateUserName&quot; , source = &quot;updateUserName&quot;),</span></span><br><span class="line"><span class="meta">        @Mapping(target = &quot;isUnban&quot; ,source = &quot;isUnban&quot;),</span></span><br><span class="line"><span class="meta">        @Mapping(target = &quot;banReason&quot; , source = &quot;banReason&quot;),</span></span><br><span class="line"><span class="meta">        @Mapping(target = &quot;startBanTime&quot; , expression=&quot;java(toLocalDateTime(param.getStartBanTime()))&quot;),</span></span><br><span class="line"><span class="meta">        @Mapping(target = &quot;endBanTime&quot; , expression=&quot;java(toLocalDateTime(param.getEndBanTime()))&quot;)</span></span><br><span class="line"><span class="meta">        &#125;)</span></span><br><span class="line">    CollegeCommunityBlacklistDO <span class="title function_">convert</span><span class="params">(CollegeCommunityBlackListUpdateParam param)</span>;</span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 默认方法：LocalDateTime 转 毫秒</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">default</span> Long <span class="title function_">toMilliseconds</span><span class="params">(LocalDateTime time)</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> ai.ii.ipa.college.util.date.LocalDateTimeUtils.localDateTimeToMillisecond(time);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 默认方法：将时间戳转为 LocalDateTime</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">default</span> LocalDateTime <span class="title function_">toLocalDateTime</span><span class="params">(Long timestamp)</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> LocalDateTimeUtils.millisecondToLocalDateTime(timestamp);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="16-根据条件批量插入">16.根据条件批量插入</h2><p><strong>如果在业务里写，业务复杂化了：</strong></p><p><img src="2025-01-09-%E5%AE%9E%E4%B9%A0%E7%BB%8F%E9%AA%8C/image-14.png" alt=""></p><p><strong>正确写法：</strong></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br></pre></td><td class="code"><pre><span class="line">&lt;insert id=<span class="string">&quot;addOfficialMessagesToUserMessages&quot;</span> parameterType=<span class="string">&quot;CollegeCommunityMessageReceiveDO&quot;</span>&gt;</span><br><span class="line">    INSERT INTO <span class="title function_">college_community_message_receive</span> <span class="params">(</span></span><br><span class="line"><span class="params">        notification_object_id,</span></span><br><span class="line"><span class="params">        post_title,</span></span><br><span class="line"><span class="params">        send_user_uid,</span></span><br><span class="line"><span class="params">        send_user_name,</span></span><br><span class="line"><span class="params">        accept_user_uid,</span></span><br><span class="line"><span class="params">        msg_id,</span></span><br><span class="line"><span class="params">        content,</span></span><br><span class="line"><span class="params">        notification_object_type,</span></span><br><span class="line"><span class="params">        create_time</span></span><br><span class="line"><span class="params">    )</span></span><br><span class="line">    SELECT</span><br><span class="line">        msg.notification_object_id,</span><br><span class="line">        msg.post_title,</span><br><span class="line">        msg.send_user_uid,</span><br><span class="line">        msg.send_user_name,</span><br><span class="line">        #&#123;param.acceptUserUid, jdbcType=VARCHAR&#125;,</span><br><span class="line">        msg.id,</span><br><span class="line">        msg.content,</span><br><span class="line">        #&#123;param.notificationObjectType, jdbcType=INTEGER&#125;,</span><br><span class="line">        msg.create_time</span><br><span class="line">    FROM</span><br><span class="line">        college_community_message msg</span><br><span class="line">    WHERE</span><br><span class="line">        NOT <span class="title function_">EXISTS</span> <span class="params">(</span></span><br><span class="line"><span class="params">                SELECT <span class="number">1</span></span></span><br><span class="line"><span class="params">                FROM college_community_message_receive cmr</span></span><br><span class="line"><span class="params">                WHERE cmr.accept_user_uid = #&#123;param.acceptUserUid, jdbcType=VARCHAR&#125;</span></span><br><span class="line"><span class="params">                  AND cmr.msg_id = msg.id</span></span><br><span class="line"><span class="params">            )</span></span><br><span class="line">      AND msg.notification_object_type = #&#123;param.notificationObjectType, jdbcType=INTEGER&#125;;</span><br><span class="line">&lt;/insert&gt;</span><br></pre></td></tr></table></figure><h2 id="17-为什么项目中所有的定时都需要引入XXL-JOB">17.为什么项目中所有的定时都需要引入XXL-JOB</h2><p>比如ES索引的自动刷新，以及spring的@Scheduled都是不建议使用的，因为项目一旦上线，所有节点会一起刷新ES索引，这样会损耗性能，造成不必要的负担。应该采用XXL-JOB进行统一管理。</p><h2 id="18-Spring-使用自定义事件工具类">18.Spring 使用自定义事件工具类</h2><p>观察者模式解耦：<a href="https://blog.csdn.net/crazymakercircle/article/details/128627663?fromshare=blogdetail&amp;sharetype=blogdetail&amp;sharerId=128627663&amp;sharerefer=PC&amp;sharesource=m0_51088567&amp;sharefrom=from_link">通过事件总线EventBus/AsyncEventBus进行JAVA模块解耦 (史上最全)_java eventbus-CSDN博客</a></p><h3 id="1-外层调用Util">(1).外层调用Util</h3><p><img src="2025-01-09-%E5%AE%9E%E4%B9%A0%E7%BB%8F%E9%AA%8C/image-12.png" alt=""></p><h3 id="2-Util获取事件的Bean">(2)Util获取事件的Bean</h3><p>在这里不能使用@Resource进行依赖注入，因为在这个Bean进行初始化中使用到了ApplicationContext，在运行时通过类型或名称获取指定的 Bean。</p><p>@Resource:静态依赖注入，注入的是单一、确定的 Bean。</p><p><code>ApplicationContext</code>，可以动态按名称或类型获取多个不同的 Bean。这在需要根据运行时条件决定使用哪个 Bean 时特别有用。</p><p><img src="2025-01-09-%E5%AE%9E%E4%B9%A0%E7%BB%8F%E9%AA%8C/image-40.png" alt=""></p><h3 id="3-调用Bean的方法：">(3)调用Bean的方法：</h3><p><img src="2025-01-09-%E5%AE%9E%E4%B9%A0%E7%BB%8F%E9%AA%8C/image-41.png" alt=""></p><h3 id="4-在Bean里面定义同步事件总线和异步事件总线">(4)在Bean里面定义同步事件总线和异步事件总线</h3><p><img src="2025-01-09-%E5%AE%9E%E4%B9%A0%E7%BB%8F%E9%AA%8C/image-39.png" alt=""></p><h3 id="5-自定义注解并监听">(5) 自定义注解并监听</h3><p><img src="2025-01-09-%E5%AE%9E%E4%B9%A0%E7%BB%8F%E9%AA%8C/image-38.png" alt=""></p><h3 id="6-使用-PostConstruct在Bean进行初始化时，自动执行一些操作。此处执行获取所有带有-EventBusListener-的-bean，将他们注册为监听者">(6)使用@PostConstruct在Bean进行初始化时，自动执行一些操作。此处执行获取所有带有 @EventBusListener 的 bean，将他们注册为监听者</h3><p><img src="2025-01-09-%E5%AE%9E%E4%B9%A0%E7%BB%8F%E9%AA%8C/image-36.png" alt=""></p><h2 id="19-【规约】插入和更新的代码不要放Biz里，封装在Service里">19.【规约】插入和更新的代码不要放Biz里，封装在Service里</h2><p><img src="2025-01-09-%E5%AE%9E%E4%B9%A0%E7%BB%8F%E9%AA%8C/image-37.png" alt=""></p><p><strong>MP的显式泛型调用写法，值得学习：</strong></p><p>Wrappers.&lt;CollegeCommunityPostTagRelDO&gt; <em>lambdaQuery</em>()</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">Wrappers.&lt;CollegeCommunityPostTagRelDO&gt; lambdaQuery()</span><br><span class="line">       .eq(CollegeCommunityPostTagRelDO::getTagId,tagId)</span><br></pre></td></tr></table></figure><h2 id="20-SQL语句">20.SQL语句</h2><h3 id="1-动态SQL—-in的使用">(1) 动态SQL— in的使用</h3><p><img src="2025-01-09-%E5%AE%9E%E4%B9%A0%E7%BB%8F%E9%AA%8C/image-27.png" alt=""></p><h3 id="2-动态插入">(2) 动态插入</h3><p><img src="2025-01-09-%E5%AE%9E%E4%B9%A0%E7%BB%8F%E9%AA%8C/image-28.png" alt=""></p><h3 id="3-多条件分页查询">(3) 多条件分页查询</h3><p><img src="2025-01-09-%E5%AE%9E%E4%B9%A0%E7%BB%8F%E9%AA%8C/image-29.png" alt=""></p><h3 id="4-GROUP-CONCAT">(4) GROUP_CONCAT</h3><p><img src="2025-01-09-%E5%AE%9E%E4%B9%A0%E7%BB%8F%E9%AA%8C/image-30.png" alt=""></p><p><strong>效果：</strong></p><p><img src="2025-01-09-%E5%AE%9E%E4%B9%A0%E7%BB%8F%E9%AA%8C/image-31.png" alt=""></p><h3 id="5-choose">(5) choose</h3><p><img src="2025-01-09-%E5%AE%9E%E4%B9%A0%E7%BB%8F%E9%AA%8C/image-32.png" alt=""></p><h3 id="6-ONLY-FULL-GROUP-BY-问题">(6) ONLY_FULL_GROUP_BY 问题</h3><p><strong>ONLY_FULL_GROUP_BY</strong>是MySQL的一个SQL模式（SQL_MODE）之一，它要求在使用GROUP BY语句时，SELECT列表、HAVING条件或ORDER BY列表中的每个列，要么是聚合函数的一部分（如COUNT(), SUM(), AVG()等），要么必须在GROUP BY子句中明确指定。</p><p>虽然ONLY_FULL_GROUP_BY模式下select中的列必须在group by中出现，但是经过测试后发现 <strong>若group by 后面分组字段是唯一索引或者是主键，那么select后面可以跟其他的列</strong></p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">ONLY_FULL_GROUP_BY：对于GROUP BY聚合操作，如果在SELECT中的列，没有在GROUP BY中出现，那么这个SQL是不合法的，因为列不在GROUP BY从句中</span><br><span class="line">NO_AUTO_VALUE_ON_ZERO：该值影响自增长列的插入。默认设置下，插入0或NULL代表生成下一个自增长值。如果用户希望插入的值为0，而该列又是自增长的，那么这个选项就有用了。</span><br><span class="line">STRICT_TRANS_TABLES：在该模式下，如果一个值不能插入到一个事务表中，则中断当前的操作，对非事务表不做限制</span><br><span class="line">NO_ZERO_IN_DATE：在严格模式下，不允许日期和月份为零</span><br><span class="line">NO_ZERO_DATE：设置该值，mysql数据库不允许插入零日期，插入零日期会抛出错误而不是警告。</span><br><span class="line">ERROR_FOR_DIVISION_BY_ZERO：在INSERT或UPDATE过程中，如果数据被零除，则产生错误而非警告。如果未给出该模式，那么数据被零除时MySQL返回NULL</span><br><span class="line">NO_AUTO_CREATE_USER：禁止GRANT创建密码为空的用户</span><br><span class="line">NO_ENGINE_SUBSTITUTION：如果需要的存储引擎被禁用或未编译，那么抛出错误。不设置此值时，用默认的存储引擎替代，并抛出一个异常</span><br><span class="line">PIPES_AS_CONCAT：将”||”视为字符串的连接操作符而非或运算符，这和Oracle数据库是一样的，也和字符串的拼接函数Concat相类似</span><br><span class="line">ANSI_QUOTES：启用ANSI_QUOTES后，不能用双引号来引用字符串，因为它被解释为识别符</span><br><span class="line"></span><br></pre></td></tr></table></figure><p><img src="2025-01-09-%E5%AE%9E%E4%B9%A0%E7%BB%8F%E9%AA%8C/image-33.png" alt=""></p><h2 id="21-自定义注解进行请求限流">21.自定义注解进行请求限流</h2><p><img src="2025-01-09-%E5%AE%9E%E4%B9%A0%E7%BB%8F%E9%AA%8C/image-34.png" alt=""></p><h3 id="（1）自定义注解">（1）自定义注解</h3><p><img src="2025-01-09-%E5%AE%9E%E4%B9%A0%E7%BB%8F%E9%AA%8C/image-35.png" alt=""></p><h3 id="（2）注解切面类">（2）注解切面类</h3><p><img src="2025-01-09-%E5%AE%9E%E4%B9%A0%E7%BB%8F%E9%AA%8C/image-56.png" alt=""></p><p>（3）构建Key</p><p><img src="2025-01-09-%E5%AE%9E%E4%B9%A0%E7%BB%8F%E9%AA%8C/image-42.png" alt=""></p><p><img src="2025-01-09-%E5%AE%9E%E4%B9%A0%E7%BB%8F%E9%AA%8C/image-43.png" alt=""></p><p>从注解参数中获取Key生成类来生成Key</p><p><img src="2025-01-09-%E5%AE%9E%E4%B9%A0%E7%BB%8F%E9%AA%8C/image-44.png" alt=""></p><h3 id="（3）自定义获取Key的函数">（3）自定义获取Key的函数</h3><p><img src="2025-01-09-%E5%AE%9E%E4%B9%A0%E7%BB%8F%E9%AA%8C/image-45.png" alt=""></p><p><img src="2025-01-09-%E5%AE%9E%E4%B9%A0%E7%BB%8F%E9%AA%8C/image-46.png" alt=""></p><p>读取函数的入参</p><p><img src="2025-01-09-%E5%AE%9E%E4%B9%A0%E7%BB%8F%E9%AA%8C/image-47.png" alt=""></p><h3 id="（4）构建Value">（4）构建Value</h3><p><img src="2025-01-09-%E5%AE%9E%E4%B9%A0%E7%BB%8F%E9%AA%8C/image-48.png" alt=""></p><p><img src="2025-01-09-%E5%AE%9E%E4%B9%A0%E7%BB%8F%E9%AA%8C/image-49.png" alt=""></p><p><img src="2025-01-09-%E5%AE%9E%E4%B9%A0%E7%BB%8F%E9%AA%8C/image-50.png" alt=""></p><p>构建参数的Md5</p><p><img src="2025-01-09-%E5%AE%9E%E4%B9%A0%E7%BB%8F%E9%AA%8C/image-51.png" alt=""></p><h3 id="（5）从redis里判断是否有这个key，没有就新增">（5）从redis里判断是否有这个key，没有就新增</h3><p><img src="2025-01-09-%E5%AE%9E%E4%B9%A0%E7%BB%8F%E9%AA%8C/image-52.png" alt=""></p><p><img src="2025-01-09-%E5%AE%9E%E4%B9%A0%E7%BB%8F%E9%AA%8C/image-53.png" alt=""></p><h2 id="22-泛型使用">22.泛型使用</h2><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 批量删除帖子及其相关数据</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@PARAM</span>: <span class="doctag">@param</span> postIds</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@RETURN</span>:</span></span><br><span class="line"><span class="comment"> **/</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">deletePostRelatedRecords</span><span class="params">(List&lt;Long&gt; postIds)</span> &#123;</span><br><span class="line">    <span class="comment">// 查询关联关系</span></span><br><span class="line">    List&lt;AdminCollegeCommunityPostRelDTO&gt; postRelDtos = collegeCommunityPostService.listPostRel(postIds);</span><br><span class="line">    <span class="comment">// 初始化关联ID集合</span></span><br><span class="line">    Map&lt;String, Set&lt;?&gt;&gt; relatedIdsMap = <span class="keyword">new</span> <span class="title class_">HashMap</span>&lt;&gt;();</span><br><span class="line">    relatedIdsMap.put(<span class="string">&quot;postUuids&quot;</span>, <span class="keyword">new</span> <span class="title class_">HashSet</span>&lt;String&gt;());</span><br><span class="line">    relatedIdsMap.put(<span class="string">&quot;replyIds&quot;</span>, <span class="keyword">new</span> <span class="title class_">HashSet</span>&lt;Long&gt;());</span><br><span class="line">    relatedIdsMap.put(<span class="string">&quot;topicRelIds&quot;</span>, <span class="keyword">new</span> <span class="title class_">HashSet</span>&lt;Long&gt;());</span><br><span class="line">    relatedIdsMap.put(<span class="string">&quot;tagRelIds&quot;</span>, <span class="keyword">new</span> <span class="title class_">HashSet</span>&lt;Long&gt;());</span><br><span class="line">    relatedIdsMap.put(<span class="string">&quot;attachmentIds&quot;</span>, <span class="keyword">new</span> <span class="title class_">HashSet</span>&lt;Long&gt;());</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 收集关联关系</span></span><br><span class="line">    postRelDtos.forEach(dto -&gt; &#123;</span><br><span class="line">        Optional.ofNullable(dto.getPostUuid()).ifPresent(uuid -&gt; ((Set&lt;String&gt;) relatedIdsMap.get(<span class="string">&quot;postUuids&quot;</span>)).add(uuid));</span><br><span class="line">        Optional.ofNullable(dto.getReplyId()).ifPresent(id -&gt; ((Set&lt;Long&gt;) relatedIdsMap.get(<span class="string">&quot;replyIds&quot;</span>)).add(id));</span><br><span class="line">        Optional.ofNullable(dto.getTopicRelId()).ifPresent(id -&gt; ((Set&lt;Long&gt;) relatedIdsMap.get(<span class="string">&quot;topicRelIds&quot;</span>)).add(id));</span><br><span class="line">        Optional.ofNullable(dto.getTagRelId()).ifPresent(id -&gt; ((Set&lt;Long&gt;) relatedIdsMap.get(<span class="string">&quot;tagRelIds&quot;</span>)).add(id));</span><br><span class="line">        Optional.ofNullable(dto.getAttachmentRelId()).ifPresent(id -&gt; ((Set&lt;Long&gt;) relatedIdsMap.get(<span class="string">&quot;attachmentIds&quot;</span>)).add(id));</span><br><span class="line">    &#125;);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 批量删除关联记录</span></span><br><span class="line">    batchRemoveIfNotEmpty((Set&lt;String&gt;) relatedIdsMap.get(<span class="string">&quot;postUuids&quot;</span>), collegeCommunityPostAttachmentService::removeByPostUuid);</span><br><span class="line">    batchRemoveIfNotEmpty((Set&lt;Long&gt;) relatedIdsMap.get(<span class="string">&quot;replyIds&quot;</span>), collegeCommunityReplyService::removeByIds);</span><br><span class="line">    batchRemoveIfNotEmpty((Set&lt;Long&gt;) relatedIdsMap.get(<span class="string">&quot;topicRelIds&quot;</span>), collegeCommunityTopicPostRelService::removeByIds);</span><br><span class="line">    batchRemoveIfNotEmpty((Set&lt;Long&gt;) relatedIdsMap.get(<span class="string">&quot;tagRelIds&quot;</span>), collegeCommunityPostTagRelService::removeByIds);</span><br><span class="line">    batchRemoveIfNotEmpty((Set&lt;Long&gt;) relatedIdsMap.get(<span class="string">&quot;attachmentIds&quot;</span>), collegeCommunityPostAttachmentService::removeByIds);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 删除相关记录</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param</span> removeFunction</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@PARAM</span>: <span class="doctag">@param</span> set</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@RETURN</span>:</span></span><br><span class="line"><span class="comment"> **/</span></span><br><span class="line"><span class="keyword">public</span> &lt;T&gt; <span class="keyword">void</span> <span class="title function_">batchRemoveIfNotEmpty</span><span class="params">(Set&lt;T&gt; set, Consumer&lt;List&lt;T&gt;&gt; removeFunction)</span> &#123;</span><br><span class="line">    <span class="keyword">if</span> (CollUtil.isNotEmpty(set)) &#123;</span><br><span class="line">        removeFunction.accept(<span class="keyword">new</span> <span class="title class_">ArrayList</span>&lt;&gt;(set));</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="23-更自由的白名单">23.更自由的白名单</h2><h3 id="（1）自定义注解-2">（1）自定义注解</h3><p><img src="2025-01-09-%E5%AE%9E%E4%B9%A0%E7%BB%8F%E9%AA%8C/image-54.png" alt=""></p><h3 id="（2）在对应的Controller上加上对应的类">（2）在对应的Controller上加上对应的类</h3><p><img src="2025-01-09-%E5%AE%9E%E4%B9%A0%E7%BB%8F%E9%AA%8C/image-55.png" alt=""></p><h3 id="（3）写拦截器">（3）写拦截器</h3><p><img src="2025-01-09-%E5%AE%9E%E4%B9%A0%E7%BB%8F%E9%AA%8C/image-67.png" alt=""></p><h3 id="（4）免登判断">（4）免登判断</h3><p><img src="2025-01-09-%E5%AE%9E%E4%B9%A0%E7%BB%8F%E9%AA%8C/image-57.png" alt=""></p><p><img src="2025-01-09-%E5%AE%9E%E4%B9%A0%E7%BB%8F%E9%AA%8C/image-58.png" alt=""></p><p>或者根据配置进行免登判断</p><p><img src="2025-01-09-%E5%AE%9E%E4%B9%A0%E7%BB%8F%E9%AA%8C/image-59.png" alt=""></p><h2 id="24-Docker部署项目">24.Docker部署项目</h2><h3 id="（1）Maven打包">（1）Maven打包</h3><p><img src="2025-01-09-%E5%AE%9E%E4%B9%A0%E7%BB%8F%E9%AA%8C/image-60.png" alt=""></p><h3 id="（2）写Dockerfile文件">（2）写Dockerfile文件</h3><p><img src="2025-01-09-%E5%AE%9E%E4%B9%A0%E7%BB%8F%E9%AA%8C/image-61.png" alt=""></p><h3 id="（3）jar包和Dockerfile文件放在一个目录里">（3）jar包和Dockerfile文件放在一个目录里</h3><p><img src="2025-01-09-%E5%AE%9E%E4%B9%A0%E7%BB%8F%E9%AA%8C/image-62.png" alt=""></p><h3 id="（4）构建镜像">（4）构建镜像</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">docker build -t college .     </span><br></pre></td></tr></table></figure><h3 id="（5）运行">（5）运行</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">docker build --build-arg BASE_IMAGE=openjdk:<span class="number">8</span>-jdk-alpine -t college .</span><br></pre></td></tr></table></figure><h2 id="25-判断用户是否点赞的两种方案">25.判断用户是否点赞的两种方案</h2><h3 id="（1）新增一个用户点赞表">（1）新增一个用户点赞表</h3><p>当用户点赞时，先判断是否修改点赞表成功，只有成功才会给对象的点赞数目增加或者减少</p><p><img src="2025-01-09-%E5%AE%9E%E4%B9%A0%E7%BB%8F%E9%AA%8C/image-63.png" alt=""></p><h3 id="（2）使用redis的bitmap来判断用户是否点赞过">（2）使用redis的bitmap来判断用户是否点赞过</h3><h2 id="26-【⭐️优化】优化慢查询接口">26.【⭐️优化】优化慢查询接口</h2><p><strong>简洁版：</strong>添加冗余字段来优化慢查询接口，接口功能是根据一个id去查找这个id下的所有子部门。</p><p><strong>问题描述：</strong>数据结构是树型，一个部门可以对应多个子部门，一个子部门又对应很多个子部门。在控制器项目中，发现有一些公司有一万多个部门，这样数据很多而且树很深。</p><p>以往的查询策略是根据id去查询这个id的所有子部门，再根据子部门再去递归查询。这样要查询很多次数据库，导致在有些部门很多的公司调用这个接口的时间长达20s，优化后从20s变成了40ms。</p><p>所以要采取优化措施，除了对表的字段增加索引外，此次优化的主要目的是能够通过id一次性查询这个部门的所有子部门。</p><p><strong>优化方法：</strong>对数据库添加两个冗余字段，leftValue和rightValue。通过id可以根据这个id的leftValue和rightValue去查找所有对应范围<strong>[leftValue,rightValue]</strong>的值。</p><p>构建树：传进来一个树，采用dfs构建这颗树。确保子节点的leftValue和rightValue被父节点的leftValue和rightValue所包含。</p><p><img src="2025-01-09-%E5%AE%9E%E4%B9%A0%E7%BB%8F%E9%AA%8C/image-64.png" alt=""></p><p>增加单个部门：对这颗树的索引节点遍历，所有大于这个父节点的值的leftValue和rightValue加上 nodeNum * 2</p><p>删除单个部门：上述操作取反</p><p>移动部门：先删除再添加</p><p><a href="https://mcnfxurl5vzo.feishu.cn/wiki/Nk0nwR3W4iP9FLk9Pm7cXvRWnZc"> 树型查询优化</a></p><h2 id="27-feign调用的问题">27.feign调用的问题</h2><h3 id="（1）调用返回NULL">（1）调用返回NULL</h3><p>在admin服务写了，接口在college里调用。结果在admin那边能拿到数据，在college里面却拿不到。这是因为在feign里面配置了解码器，它去掉了外层的包装ResponseObject</p><p><img src="2025-01-09-%E5%AE%9E%E4%B9%A0%E7%BB%8F%E9%AA%8C/image-65.png" alt=""></p><p>解析完是返回UserExaminationCertVO，如果用Responseobject&lt;UserExaminationCertVO&gt;会直接返回NULL</p><p><img src="2025-01-09-%E5%AE%9E%E4%B9%A0%E7%BB%8F%E9%AA%8C/image-66.png" alt=""></p><h3 id="（2）为什么一般VO里面传递时间都要用Long型">（2）为什么一般VO里面传递时间都要用Long型</h3><p>因为在序列化的时候，如果时间字段是LocalDateTime类型，可能会序列化错误，导致不同feign之间的调用出现异常，所以VO中的时间一般为Long型。</p><h2 id="28-什么时候需要用到MQ">28.什么时候需要用到MQ</h2><p>学院考试有一个需求，当用户提交操作题之后，用通过webSocket通知前端，这是为了用户在客户端提交了，在web端也能正常显示。</p><p>如果是单节点，完全不用MQ。但是比如有10个节点，web端只与节点1连接了webSocket，那么其它9个节点中的一个节点在提交操作题时，web端就不能同步显示了。因此要采用MQ进行广播，当一个节点里进行操作题提交时，发送一条消息。通过广播，10个节点都能收到这一条消息，然后连接了webSocket的那个节点就能通过WebSocket通知前端。</p><p>这样，即使是多节点，web端也一直能显示实时的页面。</p>]]></content>
      
      
      <categories>
          
          <category> 学习 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 实习经验 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>好的博客分享</title>
      <link href="/posts/2024-08-09-%E5%A5%BD%E7%9A%84%E5%8D%9A%E5%AE%A2%E5%88%86%E4%BA%AB.html"/>
      <url>/posts/2024-08-09-%E5%A5%BD%E7%9A%84%E5%8D%9A%E5%AE%A2%E5%88%86%E4%BA%AB.html</url>
      
        <content type="html"><![CDATA[<p>博客</p><p>⭐️<a href="https://xiaolincoding.com/mysql/buffer_pool/buffer_pool.html#%E4%B8%BA%E4%BB%80%E4%B9%88%E8%A6%81%E6%9C%89-buffer-pool">揭开 Buffer Pool 的面纱</a></p><p>说实话，young LRU和 old LRU那块没看懂</p><p><a href="https://xiaolincoding.com/os/3_memory/cache_lru.html">4.5 如何避免预读失效和缓存污染的问题？</a></p><p><a href="https://xiaolincoding.com/os/3_memory/linux_mem.html">4.6 深入理解 Linux 虚拟内存管理</a></p><p><a href="https://xiaolincoding.com/os/3_memory/linux_mem2.html">4.7 深入理解 Linux 物理内存管理</a></p><p><a href="https://xiaolincoding.com/network/1_base/how_os_deal_network_package.html">2.3 Linux 系统是如何收发网络包的？</a></p><p>⭐️<a href="https://xiaolincoding.com/network/2_http/http_websocket.html">3.9 既然有 HTTP 协议，为什么还要有 WebSocket？</a></p><p>TCP全部</p><p><a href="https://xiaolincoding.com/network/3_tcp/tcp_queue.html">4.4 TCP 半连接队列和全连接队列</a></p><p><a href="https://xiaolincoding.com/network/3_tcp/tcp_optimize.html">4.5 如何优化 TCP?</a></p><p><a href="https://xiaolincoding.com/network/3_tcp/tcp_stream.html">4.6 如何理解是 TCP 面向字节流协议？</a></p><p><a href="https://xiaolincoding.com/network/3_tcp/isn_deff.html">4.7 为什么 TCP 每次建立连接时，初始化序列号都要不一样呢？</a></p><p><a href="https://xiaolincoding.com/network/3_tcp/challenge_ack.html">4.9 已建立连接的TCP，收到SYN会发生什么？</a></p><p>…</p><p><a href="https://xiaolincoding.com/network/4_ip/ip_base.html#%E5%89%8D%E8%8F%9C-ip-%E5%9F%BA%E6%9C%AC%E8%AE%A4%E8%AF%86">5.1 IP 基础知识全家桶</a></p><p>1.CPU 缓存一致性</p><p><a href="https://xiaolincoding.com/os/1_hardware/cpu_mesi.html#cpu-cache-%E7%9A%84%E6%95%B0%E6%8D%AE%E5%86%99%E5%85%A5">2.4 CPU 缓存一致性</a>  <a href="https://mp.weixin.qq.com/s/PDUqwAIaUxNkbjvRfovaCg">十张图介绍MESI</a></p><p><img src="2024-08-09-%E5%A5%BD%E7%9A%84%E5%8D%9A%E5%AE%A2%E5%88%86%E4%BA%AB/clip_image001.jpg" alt="img"></p><p>2.CPU是如何执行任务的</p><p><a href="https://xiaolincoding.com/os/1_hardware/how_cpu_deal_task.html#cpu-%E5%A6%82%E4%BD%95%E8%AF%BB%E5%86%99%E6%95%B0%E6%8D%AE%E7%9A%84">2.5 CPU 是如何执行任务的？</a></p><p><img src="2024-08-09-%E5%A5%BD%E7%9A%84%E5%8D%9A%E5%AE%A2%E5%88%86%E4%BA%AB/clip_image002.jpg" alt="img"></p><p>3.内存满了，会发生什么？</p><p><a href="https://xiaolincoding.com/os/3_memory/mem_reclaim.html#%E5%86%85%E5%AD%98%E5%88%86%E9%85%8D%E7%9A%84%E8%BF%87%E7%A8%8B%E6%98%AF%E6%80%8E%E6%A0%B7%E7%9A%84">4.3 内存满了，会发生什么？</a></p><p><img src="2024-08-09-%E5%A5%BD%E7%9A%84%E5%8D%9A%E5%AE%A2%E5%88%86%E4%BA%AB/clip_image003.jpg" alt="img"></p><p>4.垃圾回收机制与垃圾回收器</p><p><a href="https://javaguide.cn/java/jvm/jvm-garbage-collection.html">JVM垃圾回收详解（重点）</a></p><p><img src="2024-08-09-%E5%A5%BD%E7%9A%84%E5%8D%9A%E5%AE%A2%E5%88%86%E4%BA%AB/clip_image004.jpg" alt="img"></p><p>（1）对CMS垃圾回收器的理解</p><p><img src="2024-08-09-%E5%A5%BD%E7%9A%84%E5%8D%9A%E5%AE%A2%E5%88%86%E4%BA%AB/clip_image006.jpg" alt="img"></p><p>CMS是一个老年代的垃圾回收器  CMS垃圾回收器的步骤：  ￮    初始标记： 短暂停顿STW，标记直接与 root 相连的对象（根对象）；  ￮    并发标记： 同时开启 GC 和用户线程，用一个闭包结构去记录可达对象。但在这个阶段结束，这个闭包结构并不能保证包含当前所有的可达对象。因为用户线程可能会不断的更新引用域，所以 GC 线程无法保证可达性分析的实时性。所以这个算法里会跟踪记录这些发生引用更新的地方。  ￮    重新标记： 重新标记阶段就是为了修正并发标记期间因为用户程序继续运行而导致标记产生变动的那一部分对象的标记记录，这个阶段的停顿时间一般会比初始标记阶段的时间稍长，远远比并发标记阶段时间短  ￮    并发清除： 开启用户线程，同时 GC 线程开始对未标记的区域做清扫。     CMS优点：并发、低停顿  CMS缺点：对CPU的使用率高，会抢占用户线程的CPU执行时机进行GC，导致用户程序执行卡顿。因为使用标记清楚算法会导致大量空间碎片</p><p>（2）对G1垃圾回收器的理解</p><p><img src="2024-08-09-%E5%A5%BD%E7%9A%84%E5%8D%9A%E5%AE%A2%E5%88%86%E4%BA%AB/clip_image008.jpg" alt="img"></p><p>G1把堆空间分割成若干个region，每个regin既可以是Eden区，也可以是幸存区，也可以是老年代，这种细粒度的分割方式是得G1垃圾回收器能够更精细的控制内存，并且由于每个region是固定的，所以它能够预测停顿时间。  在每个region内部通过指针碰撞分配内存，这样可以使内存分配更规整。这样就避免了收集整个堆，而是按照若干个Region集进行收集，同时维护一个优先级列表，跟踪各个Region回收的“价值，优先收集价值高的Region。  G1收集器的运行过程大致可划分为以下四个步骤：  ￮    初始标记（initial mark），标记了从GC Root开始直接关联可达的对象。STW（Stop  the World）执行。  ￮    并发标记（concurrent marking），和用户线程并发执行，从GC Root开始对堆中对象进行可达性  分析，递归扫描整个堆里的对象图，找出要回收的对象、  ￮    最终标记（Remark），STW，标记再并发标记过程中产生的垃圾。 = 重新标记（标记的范围更小）  ￮    筛选回收（Live Data Counting And Evacuation），制定回收计划，选择多个Region 构成回收  集，把回收集中Region的存活对象复制到空的Region中，再清理掉整个旧Region的全部空间。需  要STW。</p><p>（3）对ZGC的了解</p><p>相关博客</p><p><a href="https://mp.weixin.qq.com/s/Ywj3XMws0IIK-kiUllN87Q">极致八股文之JVM垃圾回收器G1&amp;ZGC详解</a></p><p><a href="https://mp.weixin.qq.com/s/ExkB40cq1_Z0ooDzXn7CVw">从历代GC算法角度剖析ZGC</a></p><p><a href="https://tech.meituan.com/2020/08/06/new-zgc-practice-in-meituan.html">新一代垃圾回收器 ZGC 的探索与实践 - 美团技术团队</a></p><p>5.分布式事务</p><p>[05 海量并发场景下，如何回答分布式事务一致性问题?](<a href="https://learn.lianglianglee.com/%E4%B8%93%E6%A0%8F/%E6%9E%B6%E6%9E%84%E8%AE%BE%E8%AE%A1%E9%9D%A2%E8%AF%95%E7%B2%BE%E8%AE%B2/05">https://learn.lianglianglee.com/专栏/架构设计面试精讲/05</a>  海量并发场景下，如何回答分布式事务一致性问题？.md)</p><p><img src="2024-08-09-%E5%A5%BD%E7%9A%84%E5%8D%9A%E5%AE%A2%E5%88%86%E4%BA%AB/clip_image009.jpg" alt="img"></p><p>6.进程之间通信方式</p><p><a href="https://xiaolincoding.com/os/4_process/process_commu.html">5.2 进程间有哪些通信方式？</a></p><p><img src="2024-08-09-%E5%A5%BD%E7%9A%84%E5%8D%9A%E5%AE%A2%E5%88%86%E4%BA%AB/clip_image010.jpg" alt="img"></p><p>7.线程崩溃了进程也会直接崩溃吗</p><p><a href="https://xiaolincoding.com/os/4_process/thread_crash.html#%E7%BA%BF%E7%A8%8B%E5%B4%A9%E6%BA%83-%E8%BF%9B%E7%A8%8B%E4%B8%80%E5%AE%9A%E4%BC%9A%E5%B4%A9%E6%BA%83%E5%90%97">5.7 线程崩溃了，进程也会崩溃吗？</a></p><p><img src="2024-08-09-%E5%A5%BD%E7%9A%84%E5%8D%9A%E5%AE%A2%E5%88%86%E4%BA%AB/clip_image011.jpg" alt="img"></p><p>8.操作系统文件系统全家桶（70%）</p><p><a href="https://xiaolincoding.com/os/6_file_system/file_system.html#%E6%96%87%E4%BB%B6%E7%B3%BB%E7%BB%9F%E7%9A%84%E5%9F%BA%E6%9C%AC%E7%BB%84%E6%88%90">7.1 文件系统全家桶</a></p><p><img src="2024-08-09-%E5%A5%BD%E7%9A%84%E5%8D%9A%E5%AE%A2%E5%88%86%E4%BA%AB/clip_image012.jpg" alt="img"></p><p>9.进程写文件时，进程发生了崩溃，已写入的数据会丢失吗？</p><p><a href="https://xiaolincoding.com/os/6_file_system/pagecache.html#page-cache">7.2 进程写文件时，进程发生了崩溃，已写入的数据会丢失吗？</a></p><p><img src="2024-08-09-%E5%A5%BD%E7%9A%84%E5%8D%9A%E5%AE%A2%E5%88%86%E4%BA%AB/clip_image013.jpg" alt="img"></p><p>10.什么是一致性哈希？</p><p><a href="https://xiaolincoding.com/os/8_network_system/hash.html">9.4 什么是一致性哈希？</a></p><p><img src="2024-08-09-%E5%A5%BD%E7%9A%84%E5%8D%9A%E5%AE%A2%E5%88%86%E4%BA%AB/clip_image014.jpg" alt="img"></p><p>11.CompletableFuture原理</p><p><a href="https://tech.meituan.com/2022/05/12/principles-and-practices-of-completablefuture.html">CompletableFuture原理与实践-外卖商家端API的异步化</a>  <a href="https://blog.csdn.net/u013905744/article/details/109134516">java8中CompletableFuture异步处理超时的方法_completablefuture 超时-CSDN博客</a></p><p><img src="2024-08-09-%E5%A5%BD%E7%9A%84%E5%8D%9A%E5%AE%A2%E5%88%86%E4%BA%AB/clip_image015.jpg" alt="img"></p><p>12.Guava的eventBus的原理</p><p><a href="https://cloud.tencent.com/developer/article/1377032">Guava原理深度解析</a></p><p><img src="2024-08-09-%E5%A5%BD%E7%9A%84%E5%8D%9A%E5%AE%A2%E5%88%86%E4%BA%AB/clip_image016.jpg" alt="img"></p><p>13.美团线程池最佳实践</p><p><a href="https://tech.meituan.com/2020/04/02/java-pooling-pratice-in-meituan.html">Java线程池实现原理及其在美团业务中的实践</a></p><p><img src="2024-08-09-%E5%A5%BD%E7%9A%84%E5%8D%9A%E5%AE%A2%E5%88%86%E4%BA%AB/clip_image017.jpg" alt="img"></p><p>14.分布式ID设计</p><p><a href="https://javaguide.cn/distributed-system/distributed-id.html">分布式ID介绍&amp;实现方案总结</a>  <a href="https://tech.meituan.com/2017/04/21/mt-leaf.html">Leaf——美团点评分布式ID生成系统</a>  <a href="https://www.cnblogs.com/shoshana-kong/p/17319231.html">雪花算法的详解及时间回拨解决方案 - 白露~ - 博客园</a></p><p><img src="2024-08-09-%E5%A5%BD%E7%9A%84%E5%8D%9A%E5%AE%A2%E5%88%86%E4%BA%AB/clip_image018.jpg" alt="img"></p><p>15.改进型LRU：如何避免预读失效和缓存污染的问题？</p><p><a href="https://xiaolincoding.com/os/3_memory/cache_lru.html#linux-%E5%92%8C-mysql-%E7%9A%84%E7%BC%93%E5%AD%98">4.5 如何避免预读失效和缓存污染的问题？</a></p><p>13JUC的博客</p><p>上</p><p><a href="https://javaguide.cn/java/concurrent/java-concurrent-questions-01.html">Java并发常见面试题总结（上）</a></p><p><a href="https://javaguide.cn/java/concurrent/java-concurrent-questions-01.html#%E2%AD%90%EF%B8%8F%E8%AF%B4%E8%AF%B4%E7%BA%BF%E7%A8%8B%E7%9A%84%E7%94%9F%E5%91%BD%E5%91%A8%E6%9C%9F%E5%92%8C%E7%8A%B6%E6%80%81">⭐️说说线程的生命周期和状态?</a>  <a href="https://javaguide.cn/java/concurrent/java-concurrent-questions-01.html#%E2%AD%90%EF%B8%8F%E6%AD%BB%E9%94%81">⭐️死锁</a></p><p>中</p><p><a href="https://javaguide.cn/java/concurrent/java-concurrent-questions-02.html">Java并发常见面试题总结（中）</a></p><p><a href="https://javaguide.cn/java/concurrent/java-concurrent-questions-02.html#%E2%AD%90%EF%B8%8Fjmm-java-%E5%86%85%E5%AD%98%E6%A8%A1%E5%9E%8B">JMM(Java 内存模型)</a>  <a href="https://javaguide.cn/java/concurrent/java-concurrent-questions-02.html#%E2%AD%90%EF%B8%8Fvolatile-%E5%85%B3%E9%94%AE%E5%AD%97">⭐️volatile 关键字</a>  <a href="https://javaguide.cn/java/concurrent/java-concurrent-questions-02.html#%E2%AD%90%EF%B8%8F%E4%B9%90%E8%A7%82%E9%94%81%E5%92%8C%E6%82%B2%E8%A7%82%E9%94%81">⭐️乐观锁和悲观锁</a>  <a href="https://javaguide.cn/java/concurrent/java-concurrent-questions-02.html#%E2%AD%90%EF%B8%8Fsynchronized-%E5%BA%95%E5%B1%82%E5%8E%9F%E7%90%86%E4%BA%86%E8%A7%A3%E5%90%97">⭐️synchronized 底层原理了解吗？</a>  <a href="https://javaguide.cn/java/concurrent/java-concurrent-questions-02.html#%E2%AD%90%EF%B8%8Fsynchronized-%E5%92%8C-volatile-%E6%9C%89%E4%BB%80%E4%B9%88%E5%8C%BA%E5%88%AB">⭐️synchronized 和 volatile 有什么区别？</a>  常用工具：<a href="https://javaguide.cn/java/concurrent/java-concurrent-questions-02.html#reentrantlock">ReentrantLock</a>、<a href="https://javaguide.cn/java/concurrent/java-concurrent-questions-02.html#stampedlock">StampedLock</a>、<a href="https://javaguide.cn/java/concurrent/java-concurrent-questions-02.html#atomic-%E5%8E%9F%E5%AD%90%E7%B1%BB">Atomic 原子类</a></p><p>下</p><p><a href="https://javaguide.cn/java/concurrent/java-concurrent-questions-03.html">Java并发常见面试题总结（下）</a></p><p><a href="https://javaguide.cn/java/concurrent/java-concurrent-questions-03.html#threadlocal">ThreadLocal</a></p><p><a href="https://javaguide.cn/java/concurrent/java-concurrent-questions-03.html#%E7%BA%BF%E7%A8%8B%E6%B1%A0">线程池</a></p><p><a href="https://javaguide.cn/java/concurrent/java-concurrent-questions-03.html#future">Future</a></p><p><a href="https://javaguide.cn/java/concurrent/java-concurrent-questions-03.html#aqs">AQS</a></p>]]></content>
      
      
      <categories>
          
          <category> 学习 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 外挂标签 </tag>
            
            <tag> 学习 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>学习方法优化与反思</title>
      <link href="/posts/2023454z.html"/>
      <url>/posts/2023454z.html</url>
      
        <content type="html"><![CDATA[<h1>学习方法优化</h1><h2 id="1-学习方法">1.学习方法</h2><p>​学习一门新技术，要先看官网自己做总结，把自己对应的理解输出成为一篇文档，然后再看别人的博客进行对比。因为知识再传播的过程中可能会被异化掉，别人的理解不一定对，要带着思考去看别人的博客。</p><h2 id="2-好的博客介绍">2.好的博客介绍</h2>]]></content>
      
      
      <categories>
          
          <category> 学习方法优化 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 外挂标签 </tag>
            
            <tag> 学习 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>排序算法总结</title>
      <link href="/posts/2024-06-09-%E6%8E%92%E5%BA%8F%E7%AE%97%E6%B3%95%E6%80%BB%E7%BB%93.html"/>
      <url>/posts/2024-06-09-%E6%8E%92%E5%BA%8F%E7%AE%97%E6%B3%95%E6%80%BB%E7%BB%93.html</url>
      
        <content type="html"><![CDATA[<p><img src="2024-06-09-%E6%8E%92%E5%BA%8F%E7%AE%97%E6%B3%95%E6%80%BB%E7%BB%93/1.png" alt="1"></p><p><a href="https://leetcode.cn/problems/sort-an-array/solutions/179489/fu-xi-ji-chu-pai-xu-suan-fa-java-by-liweiwei1419">912. 排序数组 - 力扣（LeetCode）</a></p><h1>1.快速排序</h1><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> java.util.Random;</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">final</span> <span class="type">Random</span> <span class="variable">rand</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Random</span>();</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="type">int</span>[] sortArray(<span class="type">int</span>[] nums) &#123;</span><br><span class="line">        quickSort(nums, <span class="number">0</span>, nums.length - <span class="number">1</span>);</span><br><span class="line">        <span class="keyword">return</span> nums;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">void</span> <span class="title function_">quickSort</span><span class="params">(<span class="type">int</span>[] nums, <span class="type">int</span> left, <span class="type">int</span> right)</span> &#123;</span><br><span class="line">        <span class="keyword">if</span>(left&lt;right)&#123;</span><br><span class="line">            <span class="type">int</span> <span class="variable">pivot</span> <span class="operator">=</span> partition(nums, left, right);</span><br><span class="line">            quickSort(nums, left, pivot - <span class="number">1</span>);</span><br><span class="line">            quickSort(nums, pivot + <span class="number">1</span>, right);</span><br><span class="line">        &#125;</span><br><span class="line">        </span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">private</span> <span class="type">int</span> <span class="title function_">partition</span><span class="params">(<span class="type">int</span>[] nums, <span class="type">int</span> left, <span class="type">int</span> right)</span> &#123;</span><br><span class="line">        <span class="comment">// 随机选择pivot并交换到left位置</span></span><br><span class="line">        <span class="type">int</span> <span class="variable">randomIndex</span> <span class="operator">=</span> rand.nextInt(right - left + <span class="number">1</span>) + left;</span><br><span class="line">        swap(nums, left, randomIndex);</span><br><span class="line">        <span class="type">int</span> <span class="variable">pivot</span> <span class="operator">=</span> nums[left];</span><br><span class="line">        <span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> left;</span><br><span class="line">        <span class="comment">// 循环不变量：每次的i相当于是指向&lt;pivot的最后一个元素。最后一定是pivot左边都是小于，右边都是大于</span></span><br><span class="line">        <span class="comment">/*</span></span><br><span class="line"><span class="comment">            (left,i]小于pivot</span></span><br><span class="line"><span class="comment">            [j , right] 大于等于pivot</span></span><br><span class="line"><span class="comment">        */</span></span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">j</span> <span class="operator">=</span> left + <span class="number">1</span>; j &lt;= right; j++) &#123;</span><br><span class="line">            <span class="keyword">if</span> (nums[j] &lt; pivot) &#123;</span><br><span class="line">                i++;</span><br><span class="line">                swap(nums, j, i);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        swap(nums, left, i);</span><br><span class="line">        <span class="keyword">return</span> i;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">void</span> <span class="title function_">swap</span><span class="params">(<span class="type">int</span>[] nums, <span class="type">int</span> i, <span class="type">int</span> j)</span> &#123;</span><br><span class="line">        <span class="type">int</span> <span class="variable">temp</span> <span class="operator">=</span> nums[i];</span><br><span class="line">        nums[i] = nums[j];</span><br><span class="line">        nums[j] = temp;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h1>2.归并排序</h1><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> leetcode.com.base.sort;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">MergeSort</span> &#123;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 归并排序的入口方法，对外提供排序功能</span></span><br><span class="line">    <span class="keyword">public</span> <span class="type">int</span>[] sortArray(<span class="type">int</span>[] nums) &#123;</span><br><span class="line">        <span class="keyword">return</span> mergeSort(nums, <span class="number">0</span>, nums.length - <span class="number">1</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="type">int</span>[] mergeSort(<span class="type">int</span>[] nums, <span class="type">int</span> left, <span class="type">int</span> right) &#123;</span><br><span class="line">        <span class="keyword">if</span> (left &gt;= right) &#123;</span><br><span class="line">            <span class="keyword">return</span> nums;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="type">int</span> <span class="variable">mid</span> <span class="operator">=</span> (right + left) / <span class="number">2</span>;</span><br><span class="line">        <span class="comment">// 对左半部分数组进行归并排序</span></span><br><span class="line">        mergeSort(nums, left, mid);</span><br><span class="line">        <span class="comment">// 对右半部分数组进行归并排序</span></span><br><span class="line">        mergeSort(nums, mid + <span class="number">1</span>, right);</span><br><span class="line">        <span class="comment">// 合并左右两部分已排序好的子数组</span></span><br><span class="line">        <span class="keyword">return</span> merge(nums, left, mid, right);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="type">int</span>[] merge(<span class="type">int</span>[] nums, <span class="type">int</span> left, <span class="type">int</span> mid, <span class="type">int</span> right) &#123;</span><br><span class="line">        <span class="comment">// 创建临时数组用于存放合并后的元素</span></span><br><span class="line">        <span class="type">int</span>[] temp = <span class="keyword">new</span> <span class="title class_">int</span>[right - left + <span class="number">1</span>];</span><br><span class="line">        <span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> left;  <span class="comment">// 左子数组指针</span></span><br><span class="line">        <span class="type">int</span> <span class="variable">j</span> <span class="operator">=</span> mid + <span class="number">1</span>;  <span class="comment">// 右子数组指针</span></span><br><span class="line">        <span class="type">int</span> <span class="variable">t</span> <span class="operator">=</span> <span class="number">0</span>;  <span class="comment">// 临时数组指针</span></span><br><span class="line"></span><br><span class="line">        <span class="keyword">while</span> (i &lt;= mid &amp;&amp; j &lt;= right) &#123;</span><br><span class="line">            <span class="keyword">if</span> (nums[i] &lt;= nums[j]) &#123;</span><br><span class="line">                temp[t++] = nums[i++];</span><br><span class="line">            &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                temp[t++] = nums[j++];</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 处理左子数组剩余元素</span></span><br><span class="line">        <span class="keyword">while</span> (i &lt;= mid) &#123;</span><br><span class="line">            temp[t++] = nums[i++];</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 处理右子数组剩余元素</span></span><br><span class="line">        <span class="keyword">while</span> (j &lt;= right) &#123;</span><br><span class="line">            temp[t++] = nums[j++];</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 将临时数组中的元素复制回原数组</span></span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">k</span> <span class="operator">=</span> <span class="number">0</span>; k &lt; temp.length; k++) &#123;</span><br><span class="line">            nums[left + k] = temp[k];</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> nums;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">        <span class="type">MergeSort</span> <span class="variable">mergeSort</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">MergeSort</span>();</span><br><span class="line">        <span class="type">int</span>[] nums = &#123; <span class="number">9</span>, <span class="number">5</span>, <span class="number">7</span>, <span class="number">1</span>, <span class="number">3</span> &#125;;</span><br><span class="line">        <span class="type">int</span>[] sortedArray = mergeSort.sortArray(nums);</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> num : sortedArray) &#123;</span><br><span class="line">            System.out.print(num + <span class="string">&quot; &quot;</span>);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h1>3.冒泡排序：</h1><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> leetcode.com.base.sort;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">BubbleSort</span> &#123;</span><br><span class="line">    <span class="comment">// 冒泡排序：超时</span></span><br><span class="line">    <span class="keyword">public</span> <span class="type">int</span>[] sortArray(<span class="type">int</span>[] nums) &#123;</span><br><span class="line">        <span class="type">int</span> <span class="variable">len</span> <span class="operator">=</span> nums.length;</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> len - <span class="number">1</span>; i &gt;= <span class="number">0</span>; i--) &#123;</span><br><span class="line">            <span class="comment">// 先默认数组是有序的，只要发生一次交换，就必须进行下一轮比较，</span></span><br><span class="line">            <span class="comment">// 如果在内层循环中，都没有执行一次交换操作，说明此时数组已经是升序数组</span></span><br><span class="line">            <span class="type">boolean</span> <span class="variable">sorted</span> <span class="operator">=</span> <span class="literal">true</span>;</span><br><span class="line">            <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">j</span> <span class="operator">=</span> <span class="number">0</span>; j &lt; i; j++) &#123;</span><br><span class="line">                <span class="keyword">if</span> (nums[j] &gt; nums[j + <span class="number">1</span>]) &#123;</span><br><span class="line">                    swap(nums, j, j + <span class="number">1</span>);</span><br><span class="line">                    sorted = <span class="literal">false</span>;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">if</span> (sorted) &#123;</span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> nums;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">void</span> <span class="title function_">swap</span><span class="params">(<span class="type">int</span>[] nums, <span class="type">int</span> index1, <span class="type">int</span> index2)</span> &#123;</span><br><span class="line">        <span class="type">int</span> <span class="variable">temp</span> <span class="operator">=</span> nums[index1];</span><br><span class="line">        nums[index1] = nums[index2];</span><br><span class="line">        nums[index2] = temp;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">        <span class="type">BubbleSort</span> <span class="variable">bubbleSort</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">BubbleSort</span>();</span><br><span class="line">        <span class="type">int</span>[] nums = &#123;<span class="number">5</span>, <span class="number">3</span>, <span class="number">8</span>, <span class="number">6</span>, <span class="number">2</span>&#125;;</span><br><span class="line">        <span class="type">int</span>[] sortedNums = bubbleSort.sortArray(nums);</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> num : sortedNums) &#123;</span><br><span class="line">            System.out.print(num + <span class="string">&quot; &quot;</span>);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h1>4.堆排序</h1><h2 id="数组：">数组：</h2><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> leetcode.com.base.sort;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 堆排序</span></span><br><span class="line"><span class="comment"> * 关键：下沉函数：num,0,len</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@Author</span>: Make</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@DATE</span>: 2024/12/18</span></span><br><span class="line"><span class="comment"> **/</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">HeapSort</span> &#123;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 对外暴露的堆排序方法，用于对给定的整数数组进行排序并返回排序后的数组</span></span><br><span class="line"><span class="comment">     *</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> nums 待排序的整数数组</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@return</span> 排序后的整数数组</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">public</span> <span class="type">int</span>[] sortArray(<span class="type">int</span>[] nums) &#123;</span><br><span class="line">        <span class="type">int</span> <span class="variable">len</span> <span class="operator">=</span> nums.length;</span><br><span class="line">        <span class="comment">// 将数组整理成堆</span></span><br><span class="line">        heapify(nums);</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 循环不变量：区间 [0, i] 堆有序</span></span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> len - <span class="number">1</span>; i &gt;= <span class="number">1</span>; ) &#123;</span><br><span class="line">            <span class="comment">// 把堆顶元素（当前最大）交换到数组末尾</span></span><br><span class="line">            swap(nums, <span class="number">0</span>, i);</span><br><span class="line">            <span class="comment">// 逐步减少堆有序的部分</span></span><br><span class="line">            i--;</span><br><span class="line">            <span class="comment">// 下标 0 位置下沉操作，使得区间 [0, i] 堆有序</span></span><br><span class="line">            siftDown(nums, <span class="number">0</span>, i);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> nums;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 将数组整理成堆（堆有序）</span></span><br><span class="line"><span class="comment">     * 思路是从最后一个非叶子节点开始，依次对每个节点进行下沉操作，以构建大顶堆</span></span><br><span class="line"><span class="comment">     *</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> nums 待整理成堆的数组</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">void</span> <span class="title function_">heapify</span><span class="params">(<span class="type">int</span>[] nums)</span> &#123;</span><br><span class="line">        <span class="type">int</span> <span class="variable">len</span> <span class="operator">=</span> nums.length;</span><br><span class="line">        <span class="comment">// 只需要从 i = (len - 1) / 2 这个位置开始逐层下移</span></span><br><span class="line">        <span class="comment">// 因为完全二叉树中，从 (len - 1) / 2 位置往后的节点都是叶子节点，无需下沉操作</span></span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> (len - <span class="number">1</span>) / <span class="number">2</span>; i &gt;= <span class="number">0</span>; i--) &#123;</span><br><span class="line">            <span class="comment">// len - 1 要记住</span></span><br><span class="line">            siftDown(nums, i, len - <span class="number">1</span>);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 下沉操作，用于维护堆的性质（大顶堆情况下，父节点大于子节点）</span></span><br><span class="line"><span class="comment">     *</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> nums 数组</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> k    当前下沉元素的下标</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> end  [0, end] 是 nums 的有效部分</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">void</span> <span class="title function_">siftDown</span><span class="params">(<span class="type">int</span>[] nums, <span class="type">int</span> k, <span class="type">int</span> end)</span> &#123;</span><br><span class="line">        <span class="comment">// 当前节点（下标为k）至少有左子节点</span></span><br><span class="line">        <span class="keyword">while</span> (<span class="number">2</span> * k + <span class="number">1</span> &lt;= end) &#123;</span><br><span class="line">            <span class="comment">// 左子节点下标j = 2 * k + 1</span></span><br><span class="line">            <span class="type">int</span> <span class="variable">j</span> <span class="operator">=</span> <span class="number">2</span> * k + <span class="number">1</span>;</span><br><span class="line">            <span class="comment">// 判断右子节点（下标为j + 1）是否存在且比左子节点大</span></span><br><span class="line">            <span class="keyword">if</span> (j + <span class="number">1</span> &lt;= end &amp;&amp; nums[j + <span class="number">1</span>] &gt; nums[j]) &#123;</span><br><span class="line">                <span class="comment">// 如果是，则让j指向右子节点（因为要找子节点中的较大值与父节点比较）</span></span><br><span class="line">                j++;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="comment">// 如果子节点值大于当前节点值，就调用swap方法交换它们的位置</span></span><br><span class="line">            <span class="keyword">if</span> (nums[j] &gt; nums[k]) &#123;</span><br><span class="line">                swap(nums, j, k);</span><br><span class="line">            &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="comment">// 交换完下沉</span></span><br><span class="line">            k = j;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 交换数组中两个指定下标的元素</span></span><br><span class="line"><span class="comment">     *</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> nums   数组</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> index1 要交换的第一个元素下标</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> index2 要交换的第二个元素下标</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">void</span> <span class="title function_">swap</span><span class="params">(<span class="type">int</span>[] nums, <span class="type">int</span> index1, <span class="type">int</span> index2)</span> &#123;</span><br><span class="line">        <span class="type">int</span> <span class="variable">temp</span> <span class="operator">=</span> nums[index1];</span><br><span class="line">        nums[index1] = nums[index2];</span><br><span class="line">        nums[index2] = temp;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">        <span class="type">HeapSort</span> <span class="variable">heapSort</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">HeapSort</span>();</span><br><span class="line">        <span class="type">int</span>[] nums = &#123; <span class="number">4</span>, <span class="number">6</span>, <span class="number">8</span>, <span class="number">5</span>, <span class="number">9</span> &#125;;</span><br><span class="line">        <span class="type">int</span>[] sortedNums = heapSort.sortArray(nums);</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> num : sortedNums) &#123;</span><br><span class="line">            System.out.print(num + <span class="string">&quot; &quot;</span>);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="优先队列：">优先队列：</h2><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> leetcode.com.base.sort;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> java.util.PriorityQueue;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">HeapSortWithPriorityQueue</span> &#123;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 使用优先队列实现堆排序的方法，对给定整数数组进行排序并返回排序后的数组</span></span><br><span class="line"><span class="comment">     *</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> nums 待排序的整数数组</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@return</span> 排序后的整数数组</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="type">int</span>[] sortArray(<span class="type">int</span>[] nums) &#123;</span><br><span class="line">        PriorityQueue&lt;Integer&gt; priorityQueue = <span class="keyword">new</span> <span class="title class_">PriorityQueue</span>&lt;&gt;();</span><br><span class="line">        <span class="comment">// 将数组元素依次添加到优先队列中</span></span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> num : nums) &#123;</span><br><span class="line">            priorityQueue.add(num);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="type">int</span>[] sortedNums = <span class="keyword">new</span> <span class="title class_">int</span>[nums.length];</span><br><span class="line">        <span class="type">int</span> <span class="variable">index</span> <span class="operator">=</span> <span class="number">0</span>;</span><br><span class="line">        <span class="comment">// 依次从优先队列中取出元素，放入新数组中，此时取出的元素就是按照从小到大顺序的</span></span><br><span class="line">        <span class="keyword">while</span> (!priorityQueue.isEmpty()) &#123;</span><br><span class="line">            sortedNums[index++] = priorityQueue.poll();</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> sortedNums;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">        <span class="type">int</span>[] nums = &#123;<span class="number">4</span>, <span class="number">6</span>, <span class="number">8</span>, <span class="number">5</span>, <span class="number">9</span>&#125;;</span><br><span class="line">        <span class="type">int</span>[] sortedNums = sortArray(nums);</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> num : sortedNums) &#123;</span><br><span class="line">            System.out.print(num + <span class="string">&quot; &quot;</span>);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> 刷题 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 排序算法 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Git基础</title>
      <link href="/posts/2023-01-09-Git%E5%9F%BA%E7%A1%80.html"/>
      <url>/posts/2023-01-09-Git%E5%9F%BA%E7%A1%80.html</url>
      
        <content type="html"><![CDATA[<p>Git面试题</p><p>1.Git常用命令</p><figure class="highlight markdown"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="language-xml"><span class="tag">&lt;<span class="name">img</span> <span class="attr">src</span>=<span class="string">&quot;/assets/avatar.webp&quot;</span> <span class="attr">alt</span>=<span class="string">&quot;示例图片&quot;</span> <span class="attr">style</span>=<span class="string">&quot;zoom:50%;&quot;</span> /&gt;</span></span></span><br></pre></td></tr></table></figure><p><img src="2023-01-09-Git%E5%9F%BA%E7%A1%80/clip_image002.jpg" alt="img"></p><p>这里也对Gt中的一些核心概念扫个盲：</p><p>working tree工作区：也就是平时编写代码的，已修改未add加入git tack的文件都属于工作区</p><p>index staging area索引暂存区：工作区的文件add后就会加入索引暂存区，这里的主要目的是区分那些文件有被git管理，那些没有，在没有commit时，这些文件并不会加入git的分支</p><p>local branch分支：也叫本地分支（区别于远程分支）git管理版本的最小单位，commit后的内容会加入 git的版本控制，所有基于git的进度同步都是基于commit去比较，git版本历史记录就是一串串的 commit,不同分支就是不同串的commit提交记录</p><p>remote-tracking ref：远程分支追踪，这个是远程分支和镜像分支</p><p>remote repo：远程仓库，用来同步和储存所有代码的地方那题那题那回答这个问题一个思路就是从初始化一个仓库开始，直到和远程仓库完成一次交互，不用说太多，以下常用的足以，说多了更像是背答案</p><p>常用命令</p><p>•     git init初始化一个仓库</p><p>•     git clone xxx克隆一个远程仓库</p><p>•     git add将文件加入git暂存区</p><p>•     git commit将暂存区文件提交的本地分支那</p><p>•     git status查看当前工作区所有文件变更</p><p>•     git push将本地分支推送到远程分支</p><p>•     git pull拉取远程分支到本地</p><p>•     git log查看git提交日志</p><p>•     git cherry-pick摘樱桃，把某一个commit记录合并进当前分支</p><p>2.Git rebase和Git merge有什么区别？</p><p>git rebase变基，有代码分支诘癖的用的多，可以让分支变得很干净，不会像merge每次合并都会有一个merge的 commit记录，但是rebase是把双刃剑，变基会导致commit链的状态变化，如果这个改变没有及时同步给其他人，变基将是一场灾难，所以不要盲目追随rebase带来的收益，也要评估使用风险，git的本质是方便代码协作，这个应该放在第一位，相比较来说，merge更普世，更方便大家追踪记录。</p><p>参考：<a href="https://learn.lianglianglee.com/%e6%96%87%e7%ab%a0/%e6%bc%ab%e7%94%bb%e8%ae%b2%e8%a7%a3%20git%20rebase%20VS%20git%20merge.md">https://learn.lianglianglee.com/文章/漫画讲解 git rebase VS git merge.md</a></p><p>3.Git fetch 和 git pull的区别</p><p>git pull远程分支 = git fetch + git merge远程分支</p><p>git fetch：从远程获取最新版本到本地，但不会自动merge,用于从远程跟踪分支下载和查看其他人完成的最新提交，但不将这些提交合并到本地存储库中。它从远程存储库中获取更改并将其存储在本地存储库中</p><p>git pull:从远程获取最新版本并merge到本地，它会自动将提交合并到您的本地存储库中，而无需查看提交</p><p>4.讲一下Git pull 原理</p><p>git pull基于本地的FETCH_HEAD记录，对比本地的FETCH_HEAD与远程仓库分支的commit版本号，如果不同就会先git fetch远程仓库到本地，然后利用git merge将其与本地的分支合并，基本可以认为是git pull是git fetch+ git merge</p><p><a href="https://www.cnblogs.com/tfxz/p/12823693.html">详解git pull和git fetch的区别(原理) - 超级小白龙 - 博客园</a></p><p>5.pul的时候会遇到冲突的情况，如何解决冲突的？</p><p>这个问题就是考察你有没有实际解决过代码冲突问题，建议跟着博客操作一遍除了固定的流程，一旦出现代码冲突，一定要及时和冲突人同步信息，不管冲突会不会导致别人提交的代码被删除都要吱一声。</p><p>回答 ：</p><p>1.找到冲突点，仔细检查冲突内容</p><p>2.修改冲突，删除多余信息，冲突提示符号等内容</p><p>3.git add冲突文件</p><p>4.git commit提交修改</p><p>正常开发冲突应该是尽可能的避免，如果一旦出现冲突看下面的文章分析去解决，还有就是和冲突人对其工作信息，认真思考下，工作是否安排合理，是否有方法避免冲突再次发生。</p><p><a href="https://juejin.cn/post/7064134612129644558">如何优雅解决git 中冲突?一般情况下，出现分支的场景有如下: 多个分支代码合并到一个分支时 多个分支向同一个远端分支推 - 掘金</a></p>]]></content>
      
      
      <categories>
          
          <category> 学习 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Git </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>MyBatis Plus 入门</title>
      <link href="/posts/2023-01-09-MyBatis-Plus-%E5%85%A5%E9%97%A8.html"/>
      <url>/posts/2023-01-09-MyBatis-Plus-%E5%85%A5%E9%97%A8.html</url>
      
        <content type="html"><![CDATA[<h1>MyBatisPlus</h1><p>Mybatis:</p><ol><li>给数据库每张表设置一个实体类，其中方法可以用lomck自动生成</li><li>定义一个接口，比如userDao，在接口里添加一些对数据库操作的方法</li><li>在Mapper里的配置文件对应映射，每个方法注入sql语句。</li><li>运行，使用SqlSessionFactory导入配置文件</li></ol><p><strong>1.MyBatis</strong></p><p>连接数据库：</p><p><img src="2023-01-09-MyBatis-Plus-%E5%85%A5%E9%97%A8/clip_image002.jpg" alt="img"></p><p>定义UserDao及其中接口</p><p><img src="2023-01-09-MyBatis-Plus-%E5%85%A5%E9%97%A8/clip_image004.jpg" alt="img"></p><p>修改Mapper映射文件：</p><p><img src="2023-01-09-MyBatis-Plus-%E5%85%A5%E9%97%A8/clip_image006.jpg" alt="img"></p><p>注册映射UserDao.xml</p><p><img src="2023-01-09-MyBatis-Plus-%E5%85%A5%E9%97%A8/clip_image008.jpg" alt="img"></p><p><strong>添加****resource</strong></p><p><img src="2023-01-09-MyBatis-Plus-%E5%85%A5%E9%97%A8/clip_image010.jpg" alt="img"></p><p>开始运行</p><p><img src="2023-01-09-MyBatis-Plus-%E5%85%A5%E9%97%A8/clip_image012.jpg" alt="img"></p><p>什么事是PO、VO2.MyBatisPlus</p><p><img src="2023-01-09-MyBatis-Plus-%E5%85%A5%E9%97%A8/clip_image014.jpg" alt="img"></p><p><img src="2023-01-09-MyBatis-Plus-%E5%85%A5%E9%97%A8/clip_image016.jpg" alt="img"></p><p><strong>2.1 Wrapper</strong></p><p><img src="2023-01-09-MyBatis-Plus-%E5%85%A5%E9%97%A8/clip_image018.jpg" alt="img"></p><p><img src="2023-01-09-MyBatis-Plus-%E5%85%A5%E9%97%A8/clip_image020.jpg" alt="img"></p><p><img src="2023-01-09-MyBatis-Plus-%E5%85%A5%E9%97%A8/clip_image022.jpg" alt="img"></p><p><strong>2.1.1 QueryWrapper</strong></p><p><img src="2023-01-09-MyBatis-Plus-%E5%85%A5%E9%97%A8/clip_image024.jpg" alt="img"></p><p><strong>2.1.2 UpdateWrapper</strong></p><p><img src="2023-01-09-MyBatis-Plus-%E5%85%A5%E9%97%A8/clip_image026.jpg" alt="img"></p><p><strong>2.1.3 LambdaQueryWrapper</strong></p><p>不直接写死，通过反射来知晓属性名</p><p><img src="2023-01-09-MyBatis-Plus-%E5%85%A5%E9%97%A8/clip_image028.jpg" alt="img"></p><p><strong>2.2.<strong><strong>自定义</strong></strong>SQL</strong></p><table><thead><tr><th><img src="2023-01-09-MyBatis-Plus-%E5%85%A5%E9%97%A8/clip_image030.jpg" alt="img"></th><th><img src="2023-01-09-MyBatis-Plus-%E5%85%A5%E9%97%A8/clip_image032.jpg" alt="img"></th></tr></thead><tbody><tr><td></td><td></td></tr></tbody></table><p><strong>2.3.Service****接口</strong></p><p><img src="2023-01-09-MyBatis-Plus-%E5%85%A5%E9%97%A8/clip_image034.jpg" alt="img"></p><p><strong>2.3.1.CRUD</strong></p><p><img src="2023-01-09-MyBatis-Plus-%E5%85%A5%E9%97%A8/clip_image036.jpg" alt="img"></p><p><img src="2023-01-09-MyBatis-Plus-%E5%85%A5%E9%97%A8/clip_image038.jpg" alt="img"></p><p><img src="2023-01-09-MyBatis-Plus-%E5%85%A5%E9%97%A8/clip_image040.jpg" alt="img"></p><p><img src="2023-01-09-MyBatis-Plus-%E5%85%A5%E9%97%A8/clip_image042.jpg" alt="img"></p><p><img src="2023-01-09-MyBatis-Plus-%E5%85%A5%E9%97%A8/clip_image044.jpg" alt="img"></p><p>**2.3.2.**<strong>基本用法</strong></p><p><img src="2023-01-09-MyBatis-Plus-%E5%85%A5%E9%97%A8/clip_image046.jpg" alt="img"></p><p>一些代码可直接写在Controller层</p><p><img src="2023-01-09-MyBatis-Plus-%E5%85%A5%E9%97%A8/clip_image048.jpg" alt="img"></p><p><img src="2023-01-09-MyBatis-Plus-%E5%85%A5%E9%97%A8/clip_image050.jpg" alt="img"></p><p>复杂一点的功能需要自定义sql语句</p><p><img src="2023-01-09-MyBatis-Plus-%E5%85%A5%E9%97%A8/clip_image052.jpg" alt="img"></p><p><strong>2.3.3.Lambda</strong></p><p><img src="2023-01-09-MyBatis-Plus-%E5%85%A5%E9%97%A8/clip_image054.jpg" alt="img"></p><p><img src="2023-01-09-MyBatis-Plus-%E5%85%A5%E9%97%A8/clip_image056.jpg" alt="img"></p><p><img src="2023-01-09-MyBatis-Plus-%E5%85%A5%E9%97%A8/clip_image058.jpg" alt="img"></p><p><strong>2.4</strong> <strong>扩展功能</strong></p><p><img src="2023-01-09-MyBatis-Plus-%E5%85%A5%E9%97%A8/clip_image060.jpg" alt="img"></p><p><img src="2023-01-09-MyBatis-Plus-%E5%85%A5%E9%97%A8/clip_image062.jpg" alt="img"></p><p><img src="2023-01-09-MyBatis-Plus-%E5%85%A5%E9%97%A8/clip_image064.jpg" alt="img"></p><p><strong>2.5</strong> <strong>插件功能</strong></p><p><img src="2023-01-09-MyBatis-Plus-%E5%85%A5%E9%97%A8/clip_image066.jpg" alt="img"></p><p><img src="2023-01-09-MyBatis-Plus-%E5%85%A5%E9%97%A8/clip_image068.jpg" alt="img"></p><p><img src="2023-01-09-MyBatis-Plus-%E5%85%A5%E9%97%A8/clip_image070.jpg" alt="img"></p><p>你要的数据不在一张表里，这时候就需要DTO</p><p><img src="2023-01-09-MyBatis-Plus-%E5%85%A5%E9%97%A8/clip_image072.jpg" alt="img"></p><p><img src="2023-01-09-MyBatis-Plus-%E5%85%A5%E9%97%A8/clip_image074.jpg" alt="img"></p><p><img src="2023-01-09-MyBatis-Plus-%E5%85%A5%E9%97%A8/clip_image076.jpg" alt="img"></p>]]></content>
      
      
      <categories>
          
          <category> 学习 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> MyBatis Plus </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>MySQL面试题</title>
      <link href="/posts/2023-01-09-MySQL%E9%9D%A2%E8%AF%95%E9%A2%98.html"/>
      <url>/posts/2023-01-09-MySQL%E9%9D%A2%E8%AF%95%E9%A2%98.html</url>
      
        <content type="html"><![CDATA[<h1>前言</h1><p><strong>面试题来自小林Coding以及自己的总结，如有侵权可联系我删除哦</strong></p><p><strong>MySQL面试题</strong></p><p><strong>学习</strong></p><p><strong>1.MySQL分库分表问题</strong></p><p><img src="2023-01-09-MySQL%E9%9D%A2%E8%AF%95%E9%A2%98/clip_image001.jpg" alt="img"></p><p><strong>MySQL面试题</strong></p><p><strong>一、SQL语法</strong></p><p><strong>1. where 1=1会不会影响性能？</strong></p><p><img src="2023-01-09-MySQL%E9%9D%A2%E8%AF%95%E9%A2%98/clip_image003.jpg" alt="img"></p><p><strong>2. count主键和count非主键结果会不同吗？</strong></p><p><img src="2023-01-09-MySQL%E9%9D%A2%E8%AF%95%E9%A2%98/clip_image005.jpg" alt="img"></p><p><strong>3. MySQL内连接、外连接有什么区别？</strong></p><p><img src="2023-01-09-MySQL%E9%9D%A2%E8%AF%95%E9%A2%98/clip_image007.jpg" alt="img"></p><p><img src="2023-01-09-MySQL%E9%9D%A2%E8%AF%95%E9%A2%98/clip_image009.jpg" alt="img"></p><p><strong>4. ⭐️外连接时</strong> <strong>on</strong> <strong>和</strong> <strong>where</strong> <strong>过滤条件区别？</strong></p><p><img src="2023-01-09-MySQL%E9%9D%A2%E8%AF%95%E9%A2%98/clip_image011.jpg" alt="img"></p><p><img src="2023-01-09-MySQL%E9%9D%A2%E8%AF%95%E9%A2%98/clip_image013.jpg" alt="img"></p><p><strong>5. ⭐️delete、</strong> <strong>drop、</strong> <strong>truncate有什么区别？</strong></p><p><img src="2023-01-09-MySQL%E9%9D%A2%E8%AF%95%E9%A2%98/clip_image015.jpg" alt="img"></p><p><img src="2023-01-09-MySQL%E9%9D%A2%E8%AF%95%E9%A2%98/clip_image017.jpg" alt="img"></p><p><strong>6.</strong> <strong>数据库三大范式是什么</strong></p><p><img src="2023-01-09-MySQL%E9%9D%A2%E8%AF%95%E9%A2%98/clip_image019.jpg" alt="img"></p><p><strong>7. UNION</strong> <strong>与UNION ALL</strong> <strong>的区别？</strong></p><p><img src="2023-01-09-MySQL%E9%9D%A2%E8%AF%95%E9%A2%98/clip_image021.jpg" alt="img"></p><p><img src="2023-01-09-MySQL%E9%9D%A2%E8%AF%95%E9%A2%98/clip_image023.jpg" alt="img"></p><p><strong>8. count(1)、count(*)</strong> <strong>与</strong> <strong>count(列名)</strong> <strong>的区别？</strong></p><p><img src="2023-01-09-MySQL%E9%9D%A2%E8%AF%95%E9%A2%98/clip_image025.jpg" alt="img"></p><p><strong>9. ❎mysql</strong> <strong>中in</strong> <strong>和exists</strong> <strong>的区别</strong></p><p>当谈到MySQL中的IN和EXISTS时，它们都是用于查询和筛选数据的条件语句，但有一些重要的区别：</p><ol><li><strong>IN关键字</strong>：使用IN条件时，需提供一个固定值的列表，然后将其与指定列的值比较。如果列中的值与列表中的任何一个值匹配，就会返回结果。IN条件适用于确定某个字段的值是否在给定的值列表中。</li></ol><p>例如，SELECT * FROM table_name WHERE column_name IN (value1, value2, value3);</p><p>如果column_name的值与value1、value2或value3中的任何一个相匹配，那么这条记录将会被返回。</p><ol start="2"><li><strong>EXISTS关键字</strong>：使用EXISTS条件时，需要用子查询。查询的结果并不重要，而是判断子查询是否返回了至少一行结果。如果子查询返回了结果，EXISTS条件就会被认为是满足的。EXISTS条件适合用于判断某个条件是否至少存在于子查询的结果中。</li></ol><p>例如，SELECT * FROM table_name WHERE EXISTS (SELECT * FROM another_table WHERE condition);</p><p>如果子查询(SELECT * FROM another_table WHERE condition)返回了至少一行结果，那么主查询中的记录将会被返回。</p><p>总结来说：</p><p>•     使用IN条件时，比较的是指定列的值是否在给定的值列表中。</p><p>•     使用EXISTS条件时，判断的是子查询是否返回了至少一行结果 。</p><p><strong>10. MySQL多表查询时有哪些连接方式</strong></p><p><img src="2023-01-09-MySQL%E9%9D%A2%E8%AF%95%E9%A2%98/clip_image027.jpg" alt="img"></p><p><strong>二、存储引擎</strong></p><p><strong>1. MySQL为什么默认引擎是InnoDB</strong></p><p><img src="2023-01-09-MySQL%E9%9D%A2%E8%AF%95%E9%A2%98/clip_image029.jpg" alt="img"></p><p><strong>2. ⭐️一条SQL的执行过程是怎样的</strong></p><p><img src="2023-01-09-MySQL%E9%9D%A2%E8%AF%95%E9%A2%98/clip_image031.jpg" alt="img"></p><p><img src="2023-01-09-MySQL%E9%9D%A2%E8%AF%95%E9%A2%98/clip_image033.jpg" alt="img"></p><p><img src="2023-01-09-MySQL%E9%9D%A2%E8%AF%95%E9%A2%98/clip_image035.jpg" alt="img"></p><p><strong>3. MySQL存储引擎有哪些？</strong></p><p><img src="2023-01-09-MySQL%E9%9D%A2%E8%AF%95%E9%A2%98/clip_image037.jpg" alt="img"></p><p><strong>4. MyISAM</strong> <strong>和</strong> <strong>InnoDB</strong> <strong>存储引擎有什么区别？</strong></p><p><img src="2023-01-09-MySQL%E9%9D%A2%E8%AF%95%E9%A2%98/clip_image039.jpg" alt="img"></p><p><img src="2023-01-09-MySQL%E9%9D%A2%E8%AF%95%E9%A2%98/clip_image041.jpg" alt="img"></p><p><strong>5. ⭐️用</strong> <strong>count（*）哪个存储引擎会更快？</strong></p><p><img src="2023-01-09-MySQL%E9%9D%A2%E8%AF%95%E9%A2%98/clip_image043.jpg" alt="img"></p><p><strong>6. ⭐️NULL</strong> <strong>值是如何存储的？</strong></p><p><img src="2023-01-09-MySQL%E9%9D%A2%E8%AF%95%E9%A2%98/clip_image045.jpg" alt="img"></p><p><img src="2023-01-09-MySQL%E9%9D%A2%E8%AF%95%E9%A2%98/clip_image047.jpg" alt="img"></p><p><strong>7.⭐️Char和VarChar的区别</strong></p><p><img src="2023-01-09-MySQL%E9%9D%A2%E8%AF%95%E9%A2%98/clip_image049.jpg" alt="img"></p><p><strong>8.</strong> <strong>假如说一个字段是varchar（10），但它其实只有6个字节，那他在内存中占的存储空间是多少？在文件中占的存储空间是多少？</strong></p><p><img src="2023-01-09-MySQL%E9%9D%A2%E8%AF%95%E9%A2%98/clip_image051.jpg" alt="img"></p><p><strong>9. ⭐️如果硬件内存特别大，MySQL缓存能否替代</strong> <strong>redis？</strong></p><p><img src="2023-01-09-MySQL%E9%9D%A2%E8%AF%95%E9%A2%98/clip_image053.jpg" alt="img"></p><p><strong>10.</strong> <strong>自增主键会遇到什么问题</strong></p><p><img src="2023-01-09-MySQL%E9%9D%A2%E8%AF%95%E9%A2%98/clip_image055.jpg" alt="img"></p><p><strong>11.⭐️InnoDB存储结构</strong></p><p>数据在MySQL是以内存和磁盘两种形式存在的。</p><p><img src="2023-01-09-MySQL%E9%9D%A2%E8%AF%95%E9%A2%98/clip_image057.jpg" alt="img"></p><p>内存中</p><p><img src="2023-01-09-MySQL%E9%9D%A2%E8%AF%95%E9%A2%98/clip_image059.jpg" alt="img"></p><p>磁盘中</p><p><img src="2023-01-09-MySQL%E9%9D%A2%E8%AF%95%E9%A2%98/clip_image061.jpg" alt="img"></p><p><img src="2023-01-09-MySQL%E9%9D%A2%E8%AF%95%E9%A2%98/clip_image063.jpg" alt="img"></p><p>系统表空间（共享）：</p><p><img src="2023-01-09-MySQL%E9%9D%A2%E8%AF%95%E9%A2%98/clip_image065.jpg" alt="img"></p><p>独立表空间：（每个表）</p><p>每个表都有自己独立的表空间，每个表的数据和索引都会存在自己的表空间中。</p><p>独立表空间的作用：可以实现单表在不同数据库中的移动。独立表空间的空间可以回收（在执行删除或者清空操作后，存储空间会还给操作系统）</p><p>通用表空间（共享）：</p><p>类似与系统表空间，也是共享的，可以存储多个表数据。相比与独立表空间 通用表空间由于是多表共享的空间，消耗的内存更少一点，占有的磁盘空间也会更小。</p><p>回滚表空间：</p><p>用来保存回滚日志的。undo log默认是保存在系统表空间ibdata1文件中。</p><p>Undo 独立表空间的设置：0表示不开启undo独立表空间。</p><p><img src="2023-01-09-MySQL%E9%9D%A2%E8%AF%95%E9%A2%98/clip_image067.jpg" alt="img"></p><p>临时表空间：</p><p><img src="2023-01-09-MySQL%E9%9D%A2%E8%AF%95%E9%A2%98/clip_image069.jpg" alt="img"></p><p>流程</p><p>初始创建会分配6个页，随着数据量的增多，达到32个页会再次申请一个完整的区。</p><p>组-区–&gt;页—&gt;行</p><p><img src="2023-01-09-MySQL%E9%9D%A2%E8%AF%95%E9%A2%98/clip_image071.jpg" alt="img"></p><p><img src="2023-01-09-MySQL%E9%9D%A2%E8%AF%95%E9%A2%98/clip_image073.jpg" alt="img"></p><p><img src="2023-01-09-MySQL%E9%9D%A2%E8%AF%95%E9%A2%98/clip_image075.jpg" alt="img"></p><p>逻辑概念：段</p><p><img src="2023-01-09-MySQL%E9%9D%A2%E8%AF%95%E9%A2%98/clip_image077.jpg" alt="img"></p><p>磁盘结构总结：</p><p>在我们<strong>新建表之后或生成一个表空间idb文件</strong>，文件中以“页”结构来存储，同时通过页和内存进行交互。页中里有行，其中行表示每一条记录。根据程序的局部性原理，InnoDB为将64个页组成一个区，通常会按照“区”来申请连续的磁盘空间。为了管理大量的“区”，由256个区构成一个区组。在这些之外，还有一个用来标记“区”和零散页的逻辑概念“段”。主要管理索引数中的叶子、非叶子节点。</p><p><img src="2023-01-09-MySQL%E9%9D%A2%E8%AF%95%E9%A2%98/clip_image079.jpg" alt="img"></p><p><strong>三、索引结构（重要）</strong></p><p><strong>1. ⭐️什么是索引？索引有哪些优缺点？</strong></p><p>索引是数据库中用于提高数据检索性能的排序的数据结构。它类似于书籍的目录，通过建立特定的数据结构将列或多个列的值与它们在数据表中对应的行关联起来，以加快查询速度。</p><p>索引的优点包括：</p><p>a.   提高查询性能：索引可以加快数据库查找数据的速度，通过快速定位到符合查询条件的数据行，减少了数据库进行全表扫描的开销，从而显著提高查询效率。</p><p>b.   唯一性约束：通过在索引上设置唯一性约束，可以确保数据的唯一性，防止重复数据的插入。</p><p>然而，索引也有一些缺点：</p><p>a.   占用存储空间：索引通常需要占用一定的磁盘空间。过多的索引可能会增加存储成本。</p><p>b.   索引维护的开销：当对数据表进行插入、更新或删除操作时，索引也需要进行相应的维护操作，这可能导致数据写入的性能下降，更新更缓慢。</p><p>因此，在设计数据库时，需要根据具体查询需求、数据特点和系统环境来决定是否以及如何建立索引，以平衡查询性能和维护成本。</p><p><strong>2. ⭐️MySQL</strong> <strong>索引类型?</strong></p><p><img src="2023-01-09-MySQL%E9%9D%A2%E8%AF%95%E9%A2%98/clip_image081.jpg" alt="img"></p><p><img src="2023-01-09-MySQL%E9%9D%A2%E8%AF%95%E9%A2%98/clip_image083.jpg" alt="img"></p><p><strong>3. ⭐️InnodB</strong> <strong>引擎的索引数据结构是什么？</strong></p><p><img src="2023-01-09-MySQL%E9%9D%A2%E8%AF%95%E9%A2%98/clip_image085.jpg" alt="img"></p><p><strong>4. MySQL</strong> <strong>为什么使用</strong> <strong>B+树？</strong></p><p><img src="2023-01-09-MySQL%E9%9D%A2%E8%AF%95%E9%A2%98/clip_image087.jpg" alt="img"></p><p><img src="2023-01-09-MySQL%E9%9D%A2%E8%AF%95%E9%A2%98/clip_image089.jpg" alt="img"></p><p><img src="2023-01-09-MySQL%E9%9D%A2%E8%AF%95%E9%A2%98/clip_image091.jpg" alt="img"></p><p><strong>5. ⭐️为什么索引用</strong> <strong>B+树？而不用红黑树？</strong></p><p><img src="2023-01-09-MySQL%E9%9D%A2%E8%AF%95%E9%A2%98/clip_image093.jpg" alt="img"></p><p><strong>6.</strong> <strong>为什么索引用</strong> <strong>B+树？而不用B树？</strong></p><p><img src="2023-01-09-MySQL%E9%9D%A2%E8%AF%95%E9%A2%98/clip_image095.jpg" alt="img"></p><p><strong>7.</strong> <strong>为什么索引用</strong> <strong>B+树？而不用哈希表？</strong></p><p><img src="2023-01-09-MySQL%E9%9D%A2%E8%AF%95%E9%A2%98/clip_image097.jpg" alt="img"></p><p><strong>8.</strong> <strong>聚簇索引和非聚簇索引有什么区别？</strong></p><p><img src="2023-01-09-MySQL%E9%9D%A2%E8%AF%95%E9%A2%98/clip_image099.jpg" alt="img"></p><p><strong>9. insert</strong> <strong>操作对B+树结构的改变是怎么样的？</strong></p><p><img src="2023-01-09-MySQL%E9%9D%A2%E8%AF%95%E9%A2%98/clip_image101.jpg" alt="img"></p><p><img src="2023-01-09-MySQL%E9%9D%A2%E8%AF%95%E9%A2%98/clip_image103.jpg" alt="img"></p><p><img src="2023-01-09-MySQL%E9%9D%A2%E8%AF%95%E9%A2%98/clip_image105.jpg" alt="img"></p><p><strong>10.</strong> <strong>假如一张表有两千万的数据，B+树的高度是多少？怎么算的？</strong></p><p><img src="2023-01-09-MySQL%E9%9D%A2%E8%AF%95%E9%A2%98/clip_image107.jpg" alt="img"></p><p><img src="2023-01-09-MySQL%E9%9D%A2%E8%AF%95%E9%A2%98/clip_image109.jpg" alt="img"></p><p><strong>11.MyISAM索引与InnoDB索引的区别？</strong></p><p><img src="2023-01-09-MySQL%E9%9D%A2%E8%AF%95%E9%A2%98/clip_image111.jpg" alt="img"></p><p><strong>12. ⭐️为什么MySQL要用B+树而不用跳表呢？</strong></p><p><img src="2023-01-09-MySQL%E9%9D%A2%E8%AF%95%E9%A2%98/clip_image113.jpg" alt="img"></p><p><strong>四、索引应用</strong></p><p><strong>1.</strong> <strong>创建索引时需要注意什么？</strong></p><p>在创建索引时，需要注意以下几点：</p><ol><li>选择适当的列：根据实际查询需求和数据特点，选择合适的列作为索引列。通常情况下，选择经常被用于查询条件、排序或聚合操作的列作为索引列可以获得更好的性能。</li><li>避免过多索引：过多的索引会增加存储空间的开销，并且在数据写入时需要维护多个索引结构，导致性能下降。因此，只创建必要的索引，避免不必要的冗余索引。</li><li>考虑复合索引：对于多个列的组合查询条件，可以考虑创建复合索引。复合索引可以覆盖多个列，减少查询时需要访问的索引数量，提高查询效率。</li><li>注意索引的顺序：对于多列索引，考虑索引的顺序。将最常用的列放在索引的前面，以提高查询性能。</li><li>使用合适的数据类型：选择合适的数据类型可以减小索引的大小，提高索引的效率。尽量避免使用过长或过大的数据类型作为索引列。</li></ol><p><strong>2.</strong> <strong>什么时候不要使用索引？</strong></p><p>建立了索引，虽然能提升查询效率，但是它带来了两个代价，第一个是空间代价，因为<strong>需要多构建一颗b+树</strong>，会占用磁盘空间。第二个是更新时间代价，每次增删改索引，都需要动态维护b+树，以满足b+树的有序性。</p><p>所以，我认识到如果一张表经常被增删修改的话，也就是写多读少的场景下，不建立索引会更好，因为这时候维护索引的开销可能会超过索引带来的性能提升。</p><p>还有一点，如果表中某个列的值高度重复，那么建了索引也没用，优化器会选择全表扫描，这样建立的索引会占用存储空间，也会影响增删改的效率，选择不用索引会更好。</p><p><strong>3.</strong> <strong>什么是最左前缀原则？</strong></p><p><img src="2023-01-09-MySQL%E9%9D%A2%E8%AF%95%E9%A2%98/clip_image115.jpg" alt="img"></p><p><strong>4.</strong> <strong>索引失效的情况有哪些</strong></p><p><a href="https://xiaolincoding.com/mysql/index/index_lose.html">索引失效有哪些？</a></p><p><img src="2023-01-09-MySQL%E9%9D%A2%E8%AF%95%E9%A2%98/clip_image117.jpg" alt="img"></p><p><strong>5. ⭐️MySQL</strong> <strong>有哪些索引？</strong></p><p>分析</p><p>主键索引、唯一索引、普通索引、前缀索引、联合索引。</p><p>•     主键索引：主键索引就是建立在主键字段上的索引，通常在创建表的时候一起创建，一张表最多只有一个主键索引，索引列的值不允许有空值。</p><p>Java   ALTER TABLE products ADD  PRIMARY KEY (product_id);</p><p>•     唯一索引：唯一索引建立在UNIQUE字段上的索引，一张表可以有多个唯一索引，索引列的值必须唯一，但是允许有空值。</p><p>Java   ALTER TABLE employees ADD  UNIQUE idx_unique_employee_id (employee_id);</p><p>•     普通索引：普通索引就是建立在普通字段上的索引，既不要求字段为主键，也不要求字段为UNIQUE。</p><p>Java   ALTER TABLE products ADD INDEX  idx_product_price (price);</p><p>•     前缀索引：前缀索引是指对字符类型字段的前几个字符建立的索引，而不是在整个字段上建立的索引，前缀索引可以建立在字段类型为char、varchar、binary、varbinary的列上。使用前缀索引的目的是为了减少索引占用的存储空间，提升查询效率。</p><p>Java   CREATE INDEX idx_title_prefix  ON articles (title(10));</p><p>•     联合索引：通过将多个字段组合成一个索引，该索引就被称为联合索引。</p><p>Java   ALTER TABLE employees ADD  INDEX idx_employee_department_job (department, job_title);</p><p>回答</p><p>我了解到MySQL有主键索引、唯一索引、普通索引、前缀索引、联合索引这几种索引。Innodb引擎会要求每一张数据库表都必须要有一个主键索引，比如表里的id字段就是主键索引。</p><p>然后针对查询比较频繁的字段，我们可以对这个字段建立普通索引，如果是多个字段的话，可以考虑建立联合索引，利用索引覆盖的特性提高查询效率。</p><p>对于长文本、字符串等类型的字段，比如文章标题、商品名称等，我们可以只对这些字段的前缀部分建立索引，也就是建立前缀索引，这样可以减少索引的存储空间。</p><p><strong>6.</strong> <strong>普通索引和唯一索引有什么区别？哪个更新性能更好？</strong></p><p>分析</p><p>哪个更新性能更好，要从InooDB引擎的change buffer的角度去分析。</p><p>回答</p><p>普通索引列的值是可以重复的，而唯一索引列的值是必须唯一的，当我们对唯一索引插入了一条重复的值，会因为唯一性约束而报错。</p><p>我认为普通索引的更新性能会更好，因为普通索引在更新的时候，如果更新的数据页不在内存的话，可以直接把更新操作缓存在change buffer中，更新操作就结束了，但是，唯一索引因为需要有唯一性约束，如果更新的数据页不在内存的话，需要从磁盘读取对应的的数据页到内存，判断到没有冲突，这里会涉及磁盘随机IO的访问。</p><p>普通索引因为能使用change buffer特性，所以普通索引的更新相比于唯一索引，减少了随机磁盘访问，所以更新性能更好。</p><table><thead><tr><th><img src="2023-01-09-MySQL%E9%9D%A2%E8%AF%95%E9%A2%98/clip_image119.jpg" alt="img"></th><th><img src="2023-01-09-MySQL%E9%9D%A2%E8%AF%95%E9%A2%98/clip_image121.jpg" alt="img"></th></tr></thead><tbody><tr><td></td><td></td></tr></tbody></table><p><strong>7.</strong> <strong>主键怎么设置？追问：假如你不设置会怎么样？</strong></p><p><img src="2023-01-09-MySQL%E9%9D%A2%E8%AF%95%E9%A2%98/clip_image123.jpg" alt="img"></p><p><strong>8. ⭐️为什么要建索引？</strong></p><p>如果没有建立索引，我们查询数据的话，搜索时间复杂度是O(n)，这样的查询效率还是比较低的，为了提高查询效率，我们可以建立索引。</p><p>建立了索引后数据都会按照顺序存储，这时候我们可以利用类似二分查找的方式快速查找数据，B+树索引是多叉树，搜索时间复杂度是O(logN)，这样就提高了查询速度，除此之外还可以避免外部排序和使用临时表等问题，以及将随机I/O变为顺序I/O。</p><p><strong>9. ⭐️我们一般选择什么样的字段来建立索引？</strong></p><p><strong>适用索引的场景：</strong></p><p>•     字段有唯一性限制的，比如商品编码；</p><p>•     经常用于WHERE查询条件的字段，这样能够提高整个表的查询速度，如果查询条件不是一个字段，可以建立联合索引。</p><p>•     经常用于GROUP BY和ORDER BY的字段，这样在查询的时候就不需要再去做一次排序了，因为我们都已经知道了建立索引之后在B+Tree中的记录都是排序好的。</p><p><strong>不适合索引的场景：</strong></p><p>•     WHERE条件，GROUP BY，ORDER BY里用不到的字段，索引的价值是快速定位，如果起不到定位的字段通常是不需要创建索引的，因为索引是会占用物理空间的。</p><p>•     字段中存在大量重复数据，不需要创建索引，比如性别字段，只有男女，如果数据库表中，男女的记录分布均匀，那么无论搜索哪个值都可能得到一半的数据。在这些情况下，还不如不要索引，因为MySQL还有一个查询优化器，查询优化器发现某个值出现在表的数据行中的百分比很高的时候，它一般会忽略索引，进行全表扫描。</p><p>•     经常更新的字段不用创建索引，比如不要对电商项目的用户余额建立索引，因为索引字段频繁修改，由于要维护B+Tree的有序性，那么就需要频繁的重建索引，这个过程是会影响数据库性能的。</p><p><strong>回答</strong></p><p>可以对频繁<strong>用于WHERE查询条件的字段建立索引</strong>，这样能够提高整张表的查询速度，如果查询条件不是一个字段，可以考虑建立联合索引。还有对于经常用于排序、分组的字段建立索引，这样在查询的时候就不需要再去做一次排序了，因为建立索引之后在B+树中的数据都是排序好的。</p><p>不过，<strong>对于一些区分度不高的字段，比如性别字段，只有男女，不建议建立索引，如果数据库表中，男女的记录分布均匀，那么无论搜索哪个值都可能得到一半的数据，在这种情况下，MySQL的优化器发现某个值在表中出现的比例很高的时候，它一般会忽略索引，进行全表扫描，这时候建立的索引就没有起到作用，反而还占用了存储空间。</strong></p><p>读多写少数据多，where order group。</p><p><strong>9. ⭐️索引越多越好吗？</strong></p><p><img src="2023-01-09-MySQL%E9%9D%A2%E8%AF%95%E9%A2%98/clip_image125.jpg" alt="img"></p><p><strong>10. ⭐️索引怎么优化？</strong></p><p><strong>覆盖索引优化</strong></p><p>假设我们只需要查询商品名称和价格这两个数据，这时候我们可以对这两个字段建立联合索引，即「商品名称、价格」作为一个联合索引，针对select product_id,product_name,price from table where product_name = “iphone”;的语句，这时候就利用覆盖索引优化了，因为索引中已经包含这两个字段数据了，所以查询将不会再次检索主键索引，从而避免回表，减少了大量的I/O操作。</p><p><strong>主键索引最好是自增的</strong></p><p>如果我们使用自增主键，那么每次插入的新数据就会按顺序添加到当前索引节点的位置，不需要移动已有的数据，当页面写满，就会自动开辟一个新页面。因为每次插入一条新记录，都是追加操作，不需要重新移动数据，因此这种插入数据的方法效率非常高。</p><p>如果我们使用非自增主键，由于每次插入主键的索引值都是随机的，因此每次插入新的数据时，就可能会插入到现有数据页中间的某个位置，这将不得不移动其它数据来满足新数据的插入，甚至需要从一个页面复制数据到另外一个页面，我们通常将这种情况称为页分裂。页分裂还有可能造成大量的内存碎片，导致索引结构不紧凑，从而影响查询效率。</p><p><strong>防止索引失效</strong></p><p>￮    当我们使用左或者左右模糊匹配的时候，也就是like %xx或者like %xx%这两种方式都会造成索引失效；</p><p>￮    当我们查询条件中对索引列做了计算、函数、类型转换操作，这些情况下都会造成索引失效；</p><p>￮    联合索引要正确使用需要遵循最左匹配原则，也就是按照最左优先的方式进行索引的匹配，否则就会导致索引失效；</p><p>￮    在WHERE子句中，如果OR前的条件是索引列，而在OR后的条件列不是索引列，那么索引会失效。</p><p><strong>前缀索引优化</strong></p><p>使用前缀索引可以减小索引字段大小，可以增加一个索引页中存储的索引数，有效提高索引的查询速度。在一些大字符串的字段作为索引时，使用前缀索引可以帮助我们减小索引的大小。</p><p><strong>我用过这几种优化的方式</strong></p><p>￮    对于只需要查询几个字段数据的SQL来说，我们可以对这些字段建立联合索引，这样查询方式就变成了覆盖索引，避免了回表，减少了大量的I/O操作。</p><p>￮    我们的主键索引最好是递增的值，因为我们索引是按顺序存储的数据，如果主键的值是随机的值，可能会引发页分裂的现象，页分裂会导致大量的内存碎片，这样索引结构不紧凑了，就会影响查询效率。</p><p>￮    我们要避免写出发生索引失效的SQL的语句，比如不要对索引进行计算、函数、类型转换操作，联合索引要能正确使用需要遵循最左匹配原则等等。</p><p>￮    对于一些大字符串的索引，我们可以考虑用前缀索引只对索引列的前缀部分建立索引，节省索引的存储空间，提高查询性能。</p><p><strong>11.</strong> <strong>建立了索引，查询的时候一定会用到索引吗？</strong></p><p><img src="2023-01-09-MySQL%E9%9D%A2%E8%AF%95%E9%A2%98/clip_image127.jpg" alt="img"></p><p><strong>12. ⭐️如果我定义了一个varchar类型的日期字段，并且有一个数据是“20230922’，如果这个日期字段上有索引，那如果我查询的wher条件是where time=20230922</strong> <strong>不加单引号，还会命中索引|吗？为什么？</strong></p><p><img src="2023-01-09-MySQL%E9%9D%A2%E8%AF%95%E9%A2%98/clip_image129.jpg" alt="img"></p><p><strong>13.⭐️ MySQL</strong> <strong>最新版本解决了索引失效的哪些情况了吗？</strong></p><p><img src="2023-01-09-MySQL%E9%9D%A2%E8%AF%95%E9%A2%98/clip_image131.jpg" alt="img"></p><p><img src="2023-01-09-MySQL%E9%9D%A2%E8%AF%95%E9%A2%98/clip_image133.jpg" alt="img"></p><p><img src="2023-01-09-MySQL%E9%9D%A2%E8%AF%95%E9%A2%98/clip_image135.jpg" alt="img"></p><p><strong>14.</strong> <strong>建立联合索引有什么需要注意的？</strong></p><p><img src="2023-01-09-MySQL%E9%9D%A2%E8%AF%95%E9%A2%98/clip_image137.jpg" alt="img"></p><p><strong>15. ❓了解索引下推吗？什么情况下会下推到引擎去处理？</strong></p><p><img src="2023-01-09-MySQL%E9%9D%A2%E8%AF%95%E9%A2%98/clip_image139.jpg" alt="img"></p><p><img src="2023-01-09-MySQL%E9%9D%A2%E8%AF%95%E9%A2%98/clip_image141.jpg" alt="img"></p><p><img src="2023-01-09-MySQL%E9%9D%A2%E8%AF%95%E9%A2%98/clip_image143.jpg" alt="img"></p><p><strong>16.</strong> <strong>联合索引（ab,c），下面的查询语句会不会走索引？如果走具体是哪些字段能走？</strong></p><p><img src="2023-01-09-MySQL%E9%9D%A2%E8%AF%95%E9%A2%98/clip_image145.jpg" alt="img"></p><p><strong>17. where a&gt;1 and b = 2 and c &lt;3怎么建立索引？</strong></p><p><img src="2023-01-09-MySQL%E9%9D%A2%E8%AF%95%E9%A2%98/clip_image147.jpg" alt="img"></p><p><strong>18. where a=？</strong> <strong>And b=？</strong> <strong>order by c</strong> <strong>怎么建立索引？‘</strong></p><p><img src="2023-01-09-MySQL%E9%9D%A2%E8%AF%95%E9%A2%98/clip_image149.jpg" alt="img"></p><p><strong>19. where a&gt;100 and b=100 and c=123 order by d</strong> <strong>怎么建立联合索引？</strong></p><p><img src="2023-01-09-MySQL%E9%9D%A2%E8%AF%95%E9%A2%98/clip_image151.jpg" alt="img"></p><p><strong>20. select b from table where a = 10 and c&gt;20</strong> <strong>怎么创建索引？</strong></p><p><img src="2023-01-09-MySQL%E9%9D%A2%E8%AF%95%E9%A2%98/clip_image153.jpg" alt="img"></p><p><strong>21. selectid, name from XX where age &gt; 10 and name like 'xx％’，有联合索引（name,age），说一下查询过程</strong></p><p><img src="2023-01-09-MySQL%E9%9D%A2%E8%AF%95%E9%A2%98/clip_image155.jpg" alt="img"></p><p><strong>22. where id NOT IN</strong> <strong>（？，？，？）</strong> <strong>会走索引吗？</strong></p><p><img src="2023-01-09-MySQL%E9%9D%A2%E8%AF%95%E9%A2%98/clip_image157.jpg" alt="img"></p><p><strong>23. ⭐️如果查询条件中包含索引列和非索引/列，MySQL的具体查询流程是什么样的？</strong></p><p><img src="2023-01-09-MySQL%E9%9D%A2%E8%AF%95%E9%A2%98/clip_image159.jpg" alt="img"></p><p><strong>24.❓联合索引底层数据结构</strong></p><p><a href="https://blog.csdn.net/feichitianxia/article/details/107997795">https://blog.csdn.net/feichitianxia/article/details/107997795</a></p><p><strong>五、事务</strong></p><p><strong>1.⭐️事务ACID</strong></p><p><img src="2023-01-09-MySQL%E9%9D%A2%E8%AF%95%E9%A2%98/clip_image161.jpg" alt="img"></p><p><strong>2.</strong> <strong>事务的隔离级别有哪些</strong></p><p><img src="2023-01-09-MySQL%E9%9D%A2%E8%AF%95%E9%A2%98/clip_image163.jpg" alt="img"></p><p><img src="2023-01-09-MySQL%E9%9D%A2%E8%AF%95%E9%A2%98/clip_image165.jpg" alt="img"></p><p><img src="2023-01-09-MySQL%E9%9D%A2%E8%AF%95%E9%A2%98/clip_image167.jpg" alt="img"></p><p><strong>3. ❓讲讲你对MVCC的理解</strong></p><p>分析：</p><p>从MVCC是什么？解决了什么问题？MVCC实现原理？这三个方向回答。</p><p>注意，不用展开讲解可见性规则的判断，不然这个问题要回答很长时间，面试官可能会不耐烦，如果他追问，才去回答。</p><p>回答</p><p>MVCC是多版本并发控制，是通过记录历史版本数据，解决读写并发冲突问题，避免了读数据时加锁，提高了事务的并发性能。</p><p>MySQL将历史数据存储在undo log中，结构逻辑上类似一个链表，MySQL数据行上有两个隐藏列，一个是事务ID，一个就是指向undo log的指针。</p><p>事务开启后，执行第一条select语句的时候，会创建ReadView，ReadView记录了当前未提交的事务，通过与历史数据的事务ID比较，就可以根据可见性规则进行判断，判断这条记录是否可见，如果可见就直接将这个数据返回给客户端，如果不可见就继续往undo log版本链查找第一个可见的数据。需要展开说说可见性规则吗？</p><p><img src="2023-01-09-MySQL%E9%9D%A2%E8%AF%95%E9%A2%98/clip_image169.jpg" alt="img"></p><p><strong>4.并发事务带来哪些问题</strong></p><p><img src="2023-01-09-MySQL%E9%9D%A2%E8%AF%95%E9%A2%98/clip_image171.jpg" alt="img"></p><p><strong>5.</strong> <strong>事务的隔离性如何保证？</strong></p><p><img src="2023-01-09-MySQL%E9%9D%A2%E8%AF%95%E9%A2%98/clip_image173.jpg" alt="img"></p><p><strong>6.</strong> <strong>事务的持久性如何保证？</strong></p><p><img src="2023-01-09-MySQL%E9%9D%A2%E8%AF%95%E9%A2%98/clip_image175.jpg" alt="img"></p><table><thead><tr><th><img src="2023-01-09-MySQL%E9%9D%A2%E8%AF%95%E9%A2%98/clip_image177.jpg" alt="img"></th><th><img src="2023-01-09-MySQL%E9%9D%A2%E8%AF%95%E9%A2%98/clip_image179.jpg" alt="img"></th></tr></thead><tbody><tr><td></td><td></td></tr></tbody></table><p><strong>7.</strong> <strong>事务的原子性如何保证？</strong></p><p><img src="2023-01-09-MySQL%E9%9D%A2%E8%AF%95%E9%A2%98/clip_image181.jpg" alt="img"></p><p><img src="2023-01-09-MySQL%E9%9D%A2%E8%AF%95%E9%A2%98/clip_image183.jpg" alt="img"></p><p><strong>8.⭐️ MySQL事务和Redis</strong> <strong>事务有什么区别？</strong></p><p><img src="2023-01-09-MySQL%E9%9D%A2%E8%AF%95%E9%A2%98/clip_image185.jpg" alt="img"></p><p><strong>9. MySQL默认的隔离级别是什么？怎么实现的？</strong></p><p><img src="2023-01-09-MySQL%E9%9D%A2%E8%AF%95%E9%A2%98/clip_image187.jpg" alt="img"></p><p><strong>10. MVCC的如何判断行记录对某一个事务是否可见</strong></p><p><img src="2023-01-09-MySQL%E9%9D%A2%E8%AF%95%E9%A2%98/clip_image189.jpg" alt="img"></p><p><img src="2023-01-09-MySQL%E9%9D%A2%E8%AF%95%E9%A2%98/clip_image191.jpg" alt="img"></p><p><img src="2023-01-09-MySQL%E9%9D%A2%E8%AF%95%E9%A2%98/clip_image193.jpg" alt="img"></p><p><img src="2023-01-09-MySQL%E9%9D%A2%E8%AF%95%E9%A2%98/clip_image195.jpg" alt="img"></p><p><strong>11. ⭐️读已提交和可重复读隔离级别实现</strong> <strong>MVCC的区别？</strong></p><p><img src="2023-01-09-MySQL%E9%9D%A2%E8%AF%95%E9%A2%98/clip_image197.jpg" alt="img"></p><p><strong>12.</strong> <strong>为什么互联网公司用读已提交隔离级别？</strong></p><p><img src="2023-01-09-MySQL%E9%9D%A2%E8%AF%95%E9%A2%98/clip_image199.jpg" alt="img"></p><p><strong>13. ⭐️可重复读隔离级别是如何解决不可重复读的？</strong></p><p><img src="2023-01-09-MySQL%E9%9D%A2%E8%AF%95%E9%A2%98/clip_image201.jpg" alt="img"></p><p><strong>14. ⭐️可重复读隔离级别是怎么解决幻读的？</strong></p><p><img src="2023-01-09-MySQL%E9%9D%A2%E8%AF%95%E9%A2%98/clip_image203.jpg" alt="img"></p><p><strong>15.</strong> <strong>可重复读隔离级别解决了什么问题？有没有完全解决幻读？</strong></p><p><img src="2023-01-09-MySQL%E9%9D%A2%E8%AF%95%E9%A2%98/clip_image205.jpg" alt="img"></p><p><img src="2023-01-09-MySQL%E9%9D%A2%E8%AF%95%E9%A2%98/clip_image207.jpg" alt="img"></p><p><img src="2023-01-09-MySQL%E9%9D%A2%E8%AF%95%E9%A2%98/clip_image209.jpg" alt="img"></p><p><strong>16. ⭐️可重复读隔离级别，MVCC完全解决了</strong> <strong>不可重复读问题吗？</strong></p><p><img src="2023-01-09-MySQL%E9%9D%A2%E8%AF%95%E9%A2%98/clip_image211.jpg" alt="img"></p><p><strong>六、⭐️锁</strong></p><p><strong>1. MySQL</strong> <strong>中有哪几种锁？</strong></p><p><img src="2023-01-09-MySQL%E9%9D%A2%E8%AF%95%E9%A2%98/clip_image213.jpg" alt="img"></p><p><strong>2.</strong> <strong>什么是覆盖索引？</strong></p><p><img src="2023-01-09-MySQL%E9%9D%A2%E8%AF%95%E9%A2%98/clip_image215.jpg" alt="img"></p><p><strong>3.什么是索引下推</strong></p><p><img src="2023-01-09-MySQL%E9%9D%A2%E8%AF%95%E9%A2%98/clip_image217.jpg" alt="img"></p><p><strong>4.</strong> <strong>了解MySQL锁升级吗</strong></p><p>MysQL锁升级是指在并发事务执行过程中，当某个事务的锁无法满足当前所需的锁，会自动将该事务的锁级别升级为更高级别的锁。</p><p><img src="2023-01-09-MySQL%E9%9D%A2%E8%AF%95%E9%A2%98/clip_image219.jpg" alt="img"></p><p><strong>5.</strong> <strong>如何解决MySQL死锁问题</strong></p><p>MySQL在并发环境下可能会出现死锁问题。死锁是指两个或多个事务互相等待对方释放资源，导致无法继续执行的情况。</p><p>解决死锁问题的方法通常有以下几种：</p><ol><li>**调整事务隔离级别：**通过将事务隔离级别降低为读未提交（或读已提交），可以减少死锁的发生率。但是要注意隔离级别的降低可能引发脏读、不可重复读等数据一致性问题，在选择时需要权衡利弊。</li><li>**优化查询和事务逻辑：**分析造成死锁的原因，优化查询语句和事务逻辑，尽量缩短事务持有锁的时间，减少死锁的可能性。比如按照相同的顺序获取锁，避免跨事务的循环依赖等。</li><li>**使用行级锁：**行级锁可以较小地限制锁的范围，从而减少死锁的可能性。将表的锁粒度调整为行级别，可以减少事务之间的冲突。</li><li>**设置合理的超时间和重试机制：**当发生死锁时，可以设置适当的超时间，在一定时间内尝试解锁操作。如果超过设定的时间仍未成功，则进行死锁处理，如终止较早请求的事务或进行回滚等。</li></ol><p><strong>6.</strong> <strong>高并发场景下，如何安全修改同一行数据</strong></p><p><img src="2023-01-09-MySQL%E9%9D%A2%E8%AF%95%E9%A2%98/clip_image221.jpg" alt="img"></p><p><strong>7. MySQL怎么实现乐观锁？</strong></p><p><img src="2023-01-09-MySQL%E9%9D%A2%E8%AF%95%E9%A2%98/clip_image223.jpg" alt="img"></p><p><strong>8.</strong> <strong>在线上修改表结构，会发生什么？</strong></p><p><img src="2023-01-09-MySQL%E9%9D%A2%E8%AF%95%E9%A2%98/clip_image225.jpg" alt="img"></p><p><img src="2023-01-09-MySQL%E9%9D%A2%E8%AF%95%E9%A2%98/clip_image227.jpg" alt="img"></p><p><strong>9.⭐️Innodb</strong> <strong>存储引擎中的行级锁有哪些？（重要）</strong></p><p><img src="2023-01-09-MySQL%E9%9D%A2%E8%AF%95%E9%A2%98/clip_image229.jpg" alt="img"></p><p><img src="2023-01-09-MySQL%E9%9D%A2%E8%AF%95%E9%A2%98/clip_image231.jpg" alt="img"></p><p><img src="2023-01-09-MySQL%E9%9D%A2%E8%AF%95%E9%A2%98/clip_image233.jpg" alt="img"></p><p><img src="2023-01-09-MySQL%E9%9D%A2%E8%AF%95%E9%A2%98/clip_image235.jpg" alt="img"></p><p><img src="2023-01-09-MySQL%E9%9D%A2%E8%AF%95%E9%A2%98/clip_image237.jpg" alt="img"></p><p><strong>10.</strong> <strong>间隙锁的工作原理是什么？</strong></p><p><img src="2023-01-09-MySQL%E9%9D%A2%E8%AF%95%E9%A2%98/clip_image239.jpg" alt="img"></p><p><strong>11.</strong> <strong>一条Update语句没有带where条件，加的是什么锁？</strong></p><p><img src="2023-01-09-MySQL%E9%9D%A2%E8%AF%95%E9%A2%98/clip_image241.jpg" alt="img"></p><p><img src="2023-01-09-MySQL%E9%9D%A2%E8%AF%95%E9%A2%98/clip_image243.jpg" alt="img"></p><p><strong>12.⭐️</strong> <strong>带了where条件没有命中索引，加的是什么锁？</strong></p><p><img src="2023-01-09-MySQL%E9%9D%A2%E8%AF%95%E9%A2%98/clip_image245.jpg" alt="img"></p><p><img src="2023-01-09-MySQL%E9%9D%A2%E8%AF%95%E9%A2%98/clip_image247.jpg" alt="img"></p><p><strong>13. ⭐️两条更新语句更新同一条记录，加的是什么锁？</strong></p><p><strong>同等问题：</strong></p><p><img src="2023-01-09-MySQL%E9%9D%A2%E8%AF%95%E9%A2%98/clip_image249.jpg" alt="img"></p><p><img src="2023-01-09-MySQL%E9%9D%A2%E8%AF%95%E9%A2%98/clip_image251.jpg" alt="img"></p><p><img src="2023-01-09-MySQL%E9%9D%A2%E8%AF%95%E9%A2%98/clip_image253.jpg" alt="img"></p><p><img src="2023-01-09-MySQL%E9%9D%A2%E8%AF%95%E9%A2%98/clip_image255.jpg" alt="img"></p><p><strong>14.</strong> <strong>可重复读场景，下面的场景会发生什么？</strong></p><p><img src="2023-01-09-MySQL%E9%9D%A2%E8%AF%95%E9%A2%98/clip_image257.jpg" alt="img"></p><p><img src="2023-01-09-MySQL%E9%9D%A2%E8%AF%95%E9%A2%98/clip_image259.jpg" alt="img"></p><p><strong>15.了解过MySQL</strong> <strong>死锁问题吗？</strong></p><p><img src="2023-01-09-MySQL%E9%9D%A2%E8%AF%95%E9%A2%98/clip_image261.jpg" alt="img"></p><p><strong>16.⭐️ MySQL</strong> <strong>怎么排查死锁问题？</strong></p><p><img src="2023-01-09-MySQL%E9%9D%A2%E8%AF%95%E9%A2%98/clip_image263.jpg" alt="img"></p><p><strong>17. ⭐️MySQL</strong> <strong>怎么避免死锁？</strong></p><p><img src="2023-01-09-MySQL%E9%9D%A2%E8%AF%95%E9%A2%98/clip_image265.jpg" alt="img"></p><p><img src="2023-01-09-MySQL%E9%9D%A2%E8%AF%95%E9%A2%98/clip_image267.jpg" alt="img"></p><p><strong>七、日志</strong></p><p><strong>1. Undo log是如何回滚事务的</strong></p><p>在数据库中，Undo Log通常用于实现事务的回滚操作。当事务执行更新操作时，数据库会将相应的旧数据记录在Undo Log中，用于回滚事  务时还原到事务开始前的状态。以下是Undo Log回滚事务的一般步骤：  首先，获取事务的回滚指针或Undo Log的起始位置。  从Undo Log的末尾开始逆向扫描，按照事务操作的逆序依次处理每个日志记录。  然后，针对INSERT操作，执行DELETE操作来撤销插入的数据。对于UPDATE操作，使用Undo Log中记录的旧值将数据还原到之前的  状态。  在回滚过程中，对于已经提交的其他事务所做的修改需要跳过，只处理属于当前回滚事务的Undo Log记录。  按照逆序依次处理所有的日志记录，直到达到回滚指针位置或Undo Log的起始位置。  回滚完成后，清除或标记已回滚的Undo Log记录。  而日志，事务回滚是通过执行Undo Log中记录的反向操作，将事务的修改操作撤销，恢复到事务开始前的状态。</p><p><strong>2. ⭐️MySQL</strong> <strong>日志：undo log、redo log、</strong> <strong>binlog</strong> <strong>有什么用？</strong></p><p><img src="2023-01-09-MySQL%E9%9D%A2%E8%AF%95%E9%A2%98/clip_image269.jpg" alt="img"></p><p><strong>3. redo log</strong> <strong>和</strong> <strong>binlog</strong> <strong>的区别和应用场景？</strong></p><p><img src="2023-01-09-MySQL%E9%9D%A2%E8%AF%95%E9%A2%98/clip_image271.jpg" alt="img"></p><p><strong>4. redlo log</strong> <strong>和</strong> <strong>bin log</strong> <strong>在恢复数据库有什么区别？</strong></p><p><img src="2023-01-09-MySQL%E9%9D%A2%E8%AF%95%E9%A2%98/clip_image273.jpg" alt="img"></p><p><strong>5.</strong> <strong>为什么崩溃恢复不用binlog</strong> <strong>而用redolog？</strong></p><p><img src="2023-01-09-MySQL%E9%9D%A2%E8%AF%95%E9%A2%98/clip_image275.jpg" alt="img"></p><p><img src="2023-01-09-MySQL%E9%9D%A2%E8%AF%95%E9%A2%98/clip_image277.jpg" alt="img"></p><p><strong>6. ❓binlog的三种格式是什么？</strong></p><p><img src="2023-01-09-MySQL%E9%9D%A2%E8%AF%95%E9%A2%98/clip_image279.jpg" alt="img"></p><p><strong>7.redo log</strong> <strong>是怎么实现持久化的？</strong></p><p><img src="2023-01-09-MySQL%E9%9D%A2%E8%AF%95%E9%A2%98/clip_image281.jpg" alt="img"></p><p><strong>8. redo log除了崩溃恢复还有什么其他作用？</strong></p><p><img src="2023-01-09-MySQL%E9%9D%A2%E8%AF%95%E9%A2%98/clip_image283.jpg" alt="img"></p><p><strong>9.</strong> <strong>为什么需要两阶段提交？</strong></p><p><img src="2023-01-09-MySQL%E9%9D%A2%E8%AF%95%E9%A2%98/clip_image285.jpg" alt="img"></p><p><strong>10.⭐️</strong> <strong>两阶段提交的过程？</strong></p><p><img src="2023-01-09-MySQL%E9%9D%A2%E8%AF%95%E9%A2%98/clip_image287.jpg" alt="img"></p><p><strong>八、性能调优</strong></p><p><strong>1. ⭐️如何快速定位慢SQL</strong></p><p><img src="2023-01-09-MySQL%E9%9D%A2%E8%AF%95%E9%A2%98/clip_image289.jpg" alt="img"></p><p><img src="2023-01-09-MySQL%E9%9D%A2%E8%AF%95%E9%A2%98/clip_image291.jpg" alt="img"></p><p><strong>2. ⭐️慢SQL你是怎么优化的</strong></p><p><img src="2023-01-09-MySQL%E9%9D%A2%E8%AF%95%E9%A2%98/clip_image293.jpg" alt="img"></p><p><img src="2023-01-09-MySQL%E9%9D%A2%E8%AF%95%E9%A2%98/clip_image295.jpg" alt="img"></p><p><strong>3.</strong> <strong>为什么需要数据库连接池呢?</strong></p><p><img src="2023-01-09-MySQL%E9%9D%A2%E8%AF%95%E9%A2%98/clip_image297.jpg" alt="img"></p><p><strong>4.MySQL记录货币用什么字段类型</strong></p><p><img src="2023-01-09-MySQL%E9%9D%A2%E8%AF%95%E9%A2%98/clip_image299.jpg" alt="img"></p><p><strong>5.</strong> <strong>数据库</strong> <strong>cpu</strong> <strong>飙升，你会如何处理</strong></p><p><img src="2023-01-09-MySQL%E9%9D%A2%E8%AF%95%E9%A2%98/clip_image301.jpg" alt="img"></p><p><strong>6. ⭐️怎么查看一条语句是否走了索引？explain的输出</strong></p><p><img src="2023-01-09-MySQL%E9%9D%A2%E8%AF%95%E9%A2%98/clip_image303.jpg" alt="img"></p><p><strong>7. extra</strong> <strong>字段中的</strong> <strong>using index</strong> <strong>和</strong> <strong>using where</strong> <strong>的区别？</strong></p><p><img src="2023-01-09-MySQL%E9%9D%A2%E8%AF%95%E9%A2%98/clip_image305.jpg" alt="img"></p><p><strong>8. ❓深分页场景如何优化？</strong></p><p><img src="2023-01-09-MySQL%E9%9D%A2%E8%AF%95%E9%A2%98/clip_image307.jpg" alt="img"></p><p><img src="2023-01-09-MySQL%E9%9D%A2%E8%AF%95%E9%A2%98/clip_image309.jpg" alt="img"></p><p><strong>9.</strong> <strong>如果</strong> <strong>SQL和索引都没问题，查询还是很慢怎么办？</strong></p><p><img src="2023-01-09-MySQL%E9%9D%A2%E8%AF%95%E9%A2%98/clip_image311.jpg" alt="img"></p><p><strong>10. ⭐️MySQL中like模糊查询如何优化</strong></p><p><img src="2023-01-09-MySQL%E9%9D%A2%E8%AF%95%E9%A2%98/clip_image313.jpg" alt="img"></p><p><img src="2023-01-09-MySQL%E9%9D%A2%E8%AF%95%E9%A2%98/clip_image315.jpg" alt="img"></p><p><img src="2023-01-09-MySQL%E9%9D%A2%E8%AF%95%E9%A2%98/clip_image317.jpg" alt="img"></p><p><img src="2023-01-09-MySQL%E9%9D%A2%E8%AF%95%E9%A2%98/clip_image319.jpg" alt="img"></p><p><strong>九、高可用</strong></p><p><strong>1.</strong> <strong>讲讲主从复制原理与延迟</strong></p><p><img src="2023-01-09-MySQL%E9%9D%A2%E8%AF%95%E9%A2%98/clip_image321.jpg" alt="img"></p><p><img src="2023-01-09-MySQL%E9%9D%A2%E8%AF%95%E9%A2%98/clip_image323.jpg" alt="img"></p><p><strong>2.</strong> <strong>如何优化深分页limit 1000000</strong></p><p><img src="2023-01-09-MySQL%E9%9D%A2%E8%AF%95%E9%A2%98/clip_image325.jpg" alt="img"></p><p><strong>3. MySQL</strong> <strong>有哪些高可用方案</strong></p><p><img src="2023-01-09-MySQL%E9%9D%A2%E8%AF%95%E9%A2%98/clip_image327.jpg" alt="img"></p><p><strong>4.</strong> <strong>说下你对分库分表的理解</strong></p><p><img src="2023-01-09-MySQL%E9%9D%A2%E8%AF%95%E9%A2%98/clip_image329.jpg" alt="img"></p><p><strong>5. ⭐️分库分表下如何实现精准分页？</strong></p><p><img src="2023-01-09-MySQL%E9%9D%A2%E8%AF%95%E9%A2%98/clip_image331.jpg" alt="img"></p><p><strong>6. ⭐️MySQL提供了几种复制模式？默认的复制模式是什么？</strong></p><p><img src="2023-01-09-MySQL%E9%9D%A2%E8%AF%95%E9%A2%98/clip_image333.jpg" alt="img"></p><p><strong>7. MySQL</strong> <strong>主从架构中，读写分离怎么实现？</strong></p><p><img src="2023-01-09-MySQL%E9%9D%A2%E8%AF%95%E9%A2%98/clip_image335.jpg" alt="img"></p><p><strong>8.MySQL主库挂了怎么办</strong></p><p><img src="2023-01-09-MySQL%E9%9D%A2%E8%AF%95%E9%A2%98/clip_image337.jpg" alt="img"></p><p><strong>9. ❓分库分表后，会产生什么问题？怎么解决？</strong></p><p><img src="2023-01-09-MySQL%E9%9D%A2%E8%AF%95%E9%A2%98/clip_image339.jpg" alt="img"></p><p><img src="2023-01-09-MySQL%E9%9D%A2%E8%AF%95%E9%A2%98/clip_image341.jpg" alt="img"></p>]]></content>
      
      
      <categories>
          
          <category> 面试题 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> MySQL </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Redis学习笔记</title>
      <link href="/posts/2023-01-09-Redis%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0.html"/>
      <url>/posts/2023-01-09-Redis%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0.html</url>
      
        <content type="html"><![CDATA[<h1>Redis学习</h1><p><strong>Redis学习</strong></p><p><strong>Redis学习</strong></p><ol><li><strong>基本概念</strong></li></ol><p><img src="2023-01-09-Redis%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/clip_image002.jpg" alt="img"></p><p><img src="2023-01-09-Redis%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/clip_image004.jpg" alt="img"></p><p><img src="2023-01-09-Redis%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/clip_image006.jpg" alt="img"></p><p><img src="2023-01-09-Redis%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/clip_image008.jpg" alt="img"></p><p><img src="2023-01-09-Redis%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/clip_image010.jpg" alt="img"></p><p><img src="2023-01-09-Redis%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/clip_image012.jpg" alt="img"></p><p><strong>通用命令：</strong></p><p><img src="2023-01-09-Redis%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/clip_image014.jpg" alt="img"></p><p><strong>1.1 String</strong></p><p><img src="2023-01-09-Redis%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/clip_image016.jpg" alt="img"></p><p><img src="2023-01-09-Redis%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/clip_image018.jpg" alt="img"></p><p><img src="2023-01-09-Redis%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/clip_image020.jpg" alt="img"></p><p><strong>1.2 Lists</strong></p><p><img src="2023-01-09-Redis%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/clip_image022.jpg" alt="img"></p><p><img src="2023-01-09-Redis%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/clip_image024.jpg" alt="img"></p><p><img src="2023-01-09-Redis%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/clip_image026.jpg" alt="img"></p><p><strong>1.3</strong> <strong>集合set</strong></p><p><img src="2023-01-09-Redis%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/clip_image028.jpg" alt="img"></p><p><img src="2023-01-09-Redis%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/clip_image030.jpg" alt="img"></p><p><img src="2023-01-09-Redis%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/clip_image032.jpg" alt="img"></p><p><img src="2023-01-09-Redis%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/clip_image034.jpg" alt="img"></p><p><strong>例子：</strong></p><p><img src="2023-01-09-Redis%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/clip_image036.jpg" alt="img"></p><p><img src="2023-01-09-Redis%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/clip_image038.jpg" alt="img"></p><p><img src="2023-01-09-Redis%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/clip_image040.jpg" alt="img"></p><p><strong>1.4</strong> <strong>有序集合SortedSet</strong></p><p><img src="2023-01-09-Redis%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/clip_image042.jpg" alt="img"></p><p><img src="2023-01-09-Redis%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/clip_image044.jpg" alt="img"></p><p><img src="2023-01-09-Redis%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/clip_image046.jpg" alt="img"></p><p><img src="2023-01-09-Redis%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/clip_image048.jpg" alt="img"></p><p><strong>例子</strong></p><p><img src="2023-01-09-Redis%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/clip_image050.jpg" alt="img"></p><p><img src="2023-01-09-Redis%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/clip_image052.jpg" alt="img"></p><p><img src="2023-01-09-Redis%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/clip_image054.jpg" alt="img"></p><p><strong>1.5</strong> <strong>哈希</strong></p><p><img src="2023-01-09-Redis%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/clip_image056.jpg" alt="img"></p><p><img src="2023-01-09-Redis%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/clip_image058.jpg" alt="img"></p><p><img src="2023-01-09-Redis%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/clip_image060.jpg" alt="img"></p><ol start="2"><li><strong>基本知识</strong></li></ol><p><strong>2.1 redis持久化</strong></p><p><img src="2023-01-09-Redis%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/clip_image062.jpg" alt="img"></p><p>RDB每隔一段时间存储，因此对数据恢复的完整性不敏感。2.2 redis持久化——RDB</p><p><img src="2023-01-09-Redis%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/clip_image064.jpg" alt="img"></p><p>不断的追加，会导致文件大小比RDB大，但胜在数据敏感。2.3 redis持久化——AOF</p><p><img src="2023-01-09-Redis%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/clip_image066.jpg" alt="img"></p><table><thead><tr><th><img src="2023-01-09-Redis%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/clip_image068.jpg" alt="img"></th><th><img src="2023-01-09-Redis%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/clip_image070.jpg" alt="img"></th></tr></thead><tbody><tr><td></td><td></td></tr></tbody></table><p><strong>2.4</strong> <strong>主从</strong></p><p><img src="2023-01-09-Redis%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/clip_image072.jpg" alt="img"></p><p><img src="2023-01-09-Redis%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/clip_image074.jpg" alt="img"></p><p><strong>2.5</strong> <strong>事务处理</strong></p><p><img src="2023-01-09-Redis%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/clip_image076.jpg" alt="img"></p><p><img src="2023-01-09-Redis%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/clip_image078.jpg" alt="img"></p><p><img src="2023-01-09-Redis%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/clip_image080.jpg" alt="img"></p><p><img src="2023-01-09-Redis%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/clip_image082.jpg" alt="img"></p><p><strong>3.Redis分布式锁</strong></p><p><img src="2023-01-09-Redis%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/clip_image084.jpg" alt="img"></p><p>Lua脚本：</p><p><img src="2023-01-09-Redis%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/clip_image086.jpg" alt="img"></p><p>获取锁</p><p><img src="2023-01-09-Redis%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/clip_image088.jpg" alt="img"></p><p>释放锁</p><p><img src="2023-01-09-Redis%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/clip_image090.jpg" alt="img"></p><p><img src="2023-01-09-Redis%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/clip_image092.jpg" alt="img"></p><p><img src="2023-01-09-Redis%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/clip_image094.jpg" alt="img"></p><p>**<br>3.1 Redisson**</p><p><img src="2023-01-09-Redis%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/clip_image096.jpg" alt="img"></p><p><img src="2023-01-09-Redis%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/clip_image098.jpg" alt="img"></p><p><img src="2023-01-09-Redis%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/clip_image100.jpg" alt="img"></p><ol start="3"><li><strong>分布式缓存</strong></li></ol><p><img src="2023-01-09-Redis%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/clip_image102.jpg" alt="img"></p><p>3.1 <strong>持久化</strong></p><p><strong>RDB</strong></p><table><thead><tr><th></th><th><img src="2023-01-09-Redis%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/clip_image104.jpg" alt="img"></th></tr></thead><tbody><tr><td></td><td></td></tr></tbody></table><p><img src="2023-01-09-Redis%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/clip_image106.jpg" alt="img"></p><p><img src="2023-01-09-Redis%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/clip_image108.jpg" alt="img"></p><p><img src="2023-01-09-Redis%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/clip_image110.jpg" alt="img"></p><p><strong>AOF</strong></p><p><img src="2023-01-09-Redis%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/clip_image112.jpg" alt="img"></p><p><img src="2023-01-09-Redis%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/clip_image114.jpg" alt="img"></p><p>重写AOF</p><p><img src="2023-01-09-Redis%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/clip_image116.jpg" alt="img"></p><p>对比</p><p><img src="2023-01-09-Redis%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/clip_image118.jpg" alt="img"></p><p>3.2 <strong>主从集群</strong></p><p><img src="2023-01-09-Redis%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/clip_image120.jpg" alt="img"></p><p>开启主从：</p><p><img src="2023-01-09-Redis%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/clip_image122.jpg" alt="img"></p><p>数据同步原理：</p><p><img src="2023-01-09-Redis%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/clip_image124.jpg" alt="img"></p><p><img src="2023-01-09-Redis%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/clip_image126.jpg" alt="img"></p><p>全量同步总结：</p><p><img src="2023-01-09-Redis%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/clip_image128.jpg" alt="img"></p><p><img src="2023-01-09-Redis%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/clip_image130.jpg" alt="img"></p><p><img src="2023-01-09-Redis%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/clip_image132.jpg" alt="img"></p><p><img src="2023-01-09-Redis%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/clip_image134.jpg" alt="img"></p><p>3.3 <strong>Redis哨兵机制</strong></p><p><img src="2023-01-09-Redis%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/clip_image136.jpg" alt="img"></p><p>哨兵如何判断节点是否正常工作（心跳机制）</p><p><img src="2023-01-09-Redis%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/clip_image138.jpg" alt="img"></p><p><img src="2023-01-09-Redis%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/clip_image140.jpg" alt="img"></p><p><img src="2023-01-09-Redis%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/clip_image142.jpg" alt="img"></p><p><img src="2023-01-09-Redis%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/clip_image144.jpg" alt="img"></p><p>使用：</p><p>启动sentinel实例</p><p><img src="2023-01-09-Redis%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/clip_image146.jpg" alt="img"></p><p>然后配置每个实例</p><p><img src="2023-01-09-Redis%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/clip_image148.jpg" alt="img"></p><p>RedisTemplate配置哨兵</p><p><img src="2023-01-09-Redis%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/clip_image150.jpg" alt="img"></p><p><img src="2023-01-09-Redis%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/clip_image152.jpg" alt="img"></p><p><img src="2023-01-09-Redis%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/clip_image154.jpg" alt="img"></p><p><strong>3.4分片集群</strong></p><p><img src="2023-01-09-Redis%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/clip_image156.jpg" alt="img"></p><p>创建集群：</p><p><img src="2023-01-09-Redis%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/clip_image158.jpg" alt="img"></p><p>散列插槽：</p><p><img src="2023-01-09-Redis%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/clip_image160.jpg" alt="img"></p><p><img src="2023-01-09-Redis%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/clip_image162.jpg" alt="img"></p><p><img src="2023-01-09-Redis%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/clip_image164.jpg" alt="img"></p><p>集群伸缩</p><p><img src="2023-01-09-Redis%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/clip_image166.jpg" alt="img"></p><p>故障转移：</p><p><img src="2023-01-09-Redis%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/clip_image168.jpg" alt="img"></p><p><img src="2023-01-09-Redis%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/clip_image170.jpg" alt="img"></p><p>RedisTemplate访问分片集群：</p><p><img src="2023-01-09-Redis%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/clip_image172.jpg" alt="img"></p>]]></content>
      
      
      <categories>
          
          <category> 学习 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Redis </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Markdown语法与外挂标签写法汇总</title>
      <link href="/posts/2013454d.html"/>
      <url>/posts/2013454d.html</url>
      
        <content type="html"><![CDATA[<h1>1.Markdown语法自带格式</h1><div class="note info flat"><p>参考：<a href="https://blog.csdn.net/u014061630/article/details/81359144">Markdown语法图文全面详解(10分钟学会)</a></p></div><div class="note warning flat"><p>注意：此页面偶尔会存在CSS冲突问题!</p></div><h2 id="1-1-代码块">1.1 代码块</h2><div class="tabs" id="分栏"><ul class="nav-tabs"><li class="tab active"><button type="button" data-href="#分栏-1">示例源码</button></li><li class="tab"><button type="button" data-href="#分栏-2">渲染演示</button></li></ul><div class="tab-contents"><div class="tab-item-content active" id="分栏-1"><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">\```shell</span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">VSCode终端</span></span><br><span class="line">hexo clean; hexo s</span><br><span class="line">hexo clean; hexo g; hexo d</span><br><span class="line">git add .; git commit -m &quot;npm publish&quot;; npm version patch; </span><br><span class="line">git push</span><br><span class="line"><span class="meta prompt_"></span></span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">Cmder终端</span></span><br><span class="line">hexo clean &amp;&amp; hexo s</span><br><span class="line">hexo clean &amp;&amp; hexo g &amp;&amp; hexo d</span><br><span class="line">git add . &amp;&amp; git commit -m &quot;npm publish&quot; &amp;&amp; npm version patch</span><br><span class="line">git push</span><br><span class="line">\```</span><br></pre></td></tr></table></figure><button type="button" class="tab-to-top" aria-label="scroll to top"><i class="fas fa-arrow-up"></i></button></div><div class="tab-item-content" id="分栏-2"><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta prompt_"># </span><span class="language-bash">VSCode终端</span></span><br><span class="line">hexo clean; hexo s</span><br><span class="line">hexo clean; hexo g; hexo d</span><br><span class="line">git add .; git commit -m &quot;npm publish&quot;; npm version patch; </span><br><span class="line">git push</span><br><span class="line"><span class="meta prompt_"></span></span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">Cmder终端</span></span><br><span class="line">hexo clean &amp;&amp; hexo s</span><br><span class="line">hexo clean &amp;&amp; hexo g &amp;&amp; hexo d</span><br><span class="line">git add . &amp;&amp; git commit -m &quot;npm publish&quot; &amp;&amp; npm version patch</span><br><span class="line">git push</span><br></pre></td></tr></table></figure><button type="button" class="tab-to-top" aria-label="scroll to top"><i class="fas fa-arrow-up"></i></button></div></div></div><h2 id="1-2-多级标题">1.2 多级标题</h2><div class="tabs" id="分栏"><ul class="nav-tabs"><li class="tab active"><button type="button" data-href="#分栏-1">示例源码</button></li><li class="tab"><button type="button" data-href="#分栏-2">渲染演示</button></li></ul><div class="tab-contents"><div class="tab-item-content active" id="分栏-1"><figure class="highlight markdown"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="section"># H1</span></span><br><span class="line"><span class="section">## H2</span></span><br><span class="line"><span class="section">### H3</span></span><br><span class="line"><span class="section">#### H4</span></span><br><span class="line"><span class="section">##### H5</span></span><br><span class="line"><span class="section">###### H6</span></span><br></pre></td></tr></table></figure><button type="button" class="tab-to-top" aria-label="scroll to top"><i class="fas fa-arrow-up"></i></button></div><div class="tab-item-content" id="分栏-2"><p>见本文章标题!</p><button type="button" class="tab-to-top" aria-label="scroll to top"><i class="fas fa-arrow-up"></i></button></div></div></div><h2 id="1-3-文字样式">1.3 文字样式</h2><div class="tabs" id="分栏"><ul class="nav-tabs"><li class="tab active"><button type="button" data-href="#分栏-1">示例源码</button></li><li class="tab"><button type="button" data-href="#分栏-2">渲染演示</button></li></ul><div class="tab-contents"><div class="tab-item-content active" id="分栏-1"><figure class="highlight markdown"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="language-xml"><span class="tag">&lt;<span class="name">u</span>&gt;</span></span>下划线演示<span class="language-xml"><span class="tag">&lt;/<span class="name">u</span>&gt;</span></span></span><br><span class="line"></span><br><span class="line">文字<span class="strong">**加粗**</span>演示</span><br><span class="line"></span><br><span class="line">文字<span class="emphasis">*斜体*</span>演示</span><br><span class="line"></span><br><span class="line">文本<span class="code">`高亮`</span>演示</span><br><span class="line"></span><br><span class="line">文本~~删除~~线演示</span><br><span class="line"></span><br><span class="line"><span class="language-xml"><span class="tag">&lt;<span class="name">font</span> <span class="attr">size</span> = <span class="string">5</span>&gt;</span></span>5号字<span class="language-xml"><span class="tag">&lt;/<span class="name">font</span>&gt;</span></span></span><br><span class="line"><span class="language-xml"><span class="tag">&lt;<span class="name">font</span> <span class="attr">face</span>=<span class="string">&quot;黑体&quot;</span>&gt;</span></span>黑体<span class="language-xml"><span class="tag">&lt;/<span class="name">font</span>&gt;</span></span></span><br><span class="line"><span class="language-xml"><span class="tag">&lt;<span class="name">font</span> <span class="attr">color</span>=<span class="string">blue</span>&gt;</span></span>蓝色<span class="language-xml"><span class="tag">&lt;/<span class="name">font</span>&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="language-xml"><span class="tag">&lt;<span class="name">table</span>&gt;</span></span><span class="language-xml"><span class="tag">&lt;<span class="name">tr</span>&gt;</span></span><span class="language-xml"><span class="tag">&lt;<span class="name">td</span> <span class="attr">bgcolor</span>=<span class="string">MistyRose</span>&gt;</span></span>这里的背景色是：MistyRosen，此处输入任意想输入的内容<span class="language-xml"><span class="tag">&lt;/<span class="name">td</span>&gt;</span></span><span class="language-xml"><span class="tag">&lt;/<span class="name">tr</span>&gt;</span></span><span class="language-xml"><span class="tag">&lt;/<span class="name">table</span>&gt;</span></span></span><br></pre></td></tr></table></figure><button type="button" class="tab-to-top" aria-label="scroll to top"><i class="fas fa-arrow-up"></i></button></div><div class="tab-item-content" id="分栏-2"><p><u>下划线演示</u></p><p>文字<strong>加粗</strong>演示</p><p>文字<em>斜体</em>演示</p><p>文本<code>高亮</code>演示</p><p>文本<s>删除</s>线演示</p><p><font size = 5>5号字</font><br><font face="黑体">黑体</font><br><font color=blue>蓝色</font></p><table><tr><td bgcolor=MistyRose>这里的背景色是：MistyRosen，此处输入任意想输入的内容</td></tr></table><button type="button" class="tab-to-top" aria-label="scroll to top"><i class="fas fa-arrow-up"></i></button></div></div></div><div class="note info flat"><p>上述要点可参考:<a href="https://blog.csdn.net/qq_43732429/article/details/108034518">【Markdown语法】字体颜色大小及文字底色设置</a></p></div><h2 id="1-4-引用">1.4 引用</h2><div class="tabs" id="分栏"><ul class="nav-tabs"><li class="tab active"><button type="button" data-href="#分栏-1">示例源码</button></li><li class="tab"><button type="button" data-href="#分栏-2">渲染演示</button></li></ul><div class="tab-contents"><div class="tab-item-content active" id="分栏-1"><figure class="highlight markdown"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="quote">&gt;  Java</span></span><br><span class="line"><span class="quote">&gt; 二级引用演示</span></span><br><span class="line"><span class="quote">&gt; MySQL</span></span><br><span class="line"><span class="quote">&gt; &gt;外键</span></span><br><span class="line"><span class="quote">&gt; &gt;</span></span><br><span class="line"><span class="quote">&gt; &gt;事务</span></span><br><span class="line"><span class="quote">&gt; &gt;</span></span><br><span class="line"><span class="quote">&gt; &gt;<span class="strong">**行级锁**</span>(引用内部一样可以用格式)</span></span><br><span class="line"><span class="quote">&gt; </span></span><br><span class="line"><span class="quote">&gt; ....</span></span><br></pre></td></tr></table></figure><button type="button" class="tab-to-top" aria-label="scroll to top"><i class="fas fa-arrow-up"></i></button></div><div class="tab-item-content" id="分栏-2"><blockquote><p>Java<br>二级引用演示<br>MySQL</p><blockquote><p>外键</p><p>事务</p><p><strong>行级锁</strong>(引用内部一样可以用格式)</p></blockquote><p>…</p></blockquote><button type="button" class="tab-to-top" aria-label="scroll to top"><i class="fas fa-arrow-up"></i></button></div></div></div><h2 id="1-5-分割线">1.5 分割线</h2><div class="tabs" id="分栏"><ul class="nav-tabs"><li class="tab active"><button type="button" data-href="#分栏-1">示例源码</button></li><li class="tab"><button type="button" data-href="#分栏-2">渲染演示</button></li></ul><div class="tab-contents"><div class="tab-item-content active" id="分栏-1"><figure class="highlight markdown"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">---</span><br><span class="line"><span class="strong">**<span class="emphasis">*</span></span></span><br></pre></td></tr></table></figure><button type="button" class="tab-to-top" aria-label="scroll to top"><i class="fas fa-arrow-up"></i></button></div><div class="tab-item-content" id="分栏-2"><hr><hr><button type="button" class="tab-to-top" aria-label="scroll to top"><i class="fas fa-arrow-up"></i></button></div></div></div><h2 id="1-6-列表-跟空格都可以">1.6 列表(*,+,-跟空格都可以)</h2><h3 id="1-6-1-无序列表">1.6.1 无序列表</h3><div class="tabs" id="分栏"><ul class="nav-tabs"><li class="tab active"><button type="button" data-href="#分栏-1">示例源码</button></li><li class="tab"><button type="button" data-href="#分栏-2">渲染演示</button></li></ul><div class="tab-contents"><div class="tab-item-content active" id="分栏-1"><figure class="highlight markdown"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="bullet">*</span> Java</span><br><span class="line"><span class="bullet">*</span> Python</span><br><span class="line"><span class="bullet">*</span> ...</span><br><span class="line"></span><br><span class="line"><span class="bullet">+</span> Java</span><br><span class="line"><span class="bullet">+</span> Python</span><br><span class="line"><span class="bullet">+</span> ...</span><br><span class="line"></span><br><span class="line"><span class="bullet">-</span> Java</span><br><span class="line"><span class="bullet">-</span> Python</span><br><span class="line"><span class="bullet">-</span> ...</span><br></pre></td></tr></table></figure><button type="button" class="tab-to-top" aria-label="scroll to top"><i class="fas fa-arrow-up"></i></button></div><div class="tab-item-content" id="分栏-2"><ul><li>Java</li><li>Python</li><li>…</li></ul><ul><li>Java</li><li>Python</li><li>…</li></ul><ul><li>Java</li><li>Python</li><li>…</li></ul><button type="button" class="tab-to-top" aria-label="scroll to top"><i class="fas fa-arrow-up"></i></button></div></div></div><h3 id="1-6-2-有序列表">1.6.2 有序列表</h3><div class="tabs" id="分栏"><ul class="nav-tabs"><li class="tab active"><button type="button" data-href="#分栏-1">示例源码</button></li><li class="tab"><button type="button" data-href="#分栏-2">渲染演示</button></li></ul><div class="tab-contents"><div class="tab-item-content active" id="分栏-1"><figure class="highlight markdown"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="section"># 注意后面有空格</span></span><br><span class="line"><span class="bullet">1.</span> </span><br><span class="line"><span class="bullet">2.</span> </span><br><span class="line"><span class="bullet">3.</span> </span><br><span class="line"><span class="bullet">4.</span> </span><br></pre></td></tr></table></figure><button type="button" class="tab-to-top" aria-label="scroll to top"><i class="fas fa-arrow-up"></i></button></div><div class="tab-item-content" id="分栏-2"><ol><li></li><li></li><li></li><li></li></ol><button type="button" class="tab-to-top" aria-label="scroll to top"><i class="fas fa-arrow-up"></i></button></div></div></div><h2 id="1-7-图片">1.7 图片</h2><div class="tabs" id="分栏"><ul class="nav-tabs"><li class="tab active"><button type="button" data-href="#分栏-1">示例源码</button></li><li class="tab"><button type="button" data-href="#分栏-2">渲染演示</button></li></ul><div class="tab-contents"><div class="tab-item-content active" id="分栏-1"><figure class="highlight markdown"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="section"># 本地图片</span></span><br><span class="line"><span class="language-xml"><span class="tag">&lt;<span class="name">img</span> <span class="attr">src</span>=<span class="string">&quot;/assets/pusheencode.webp&quot;</span> <span class="attr">alt</span>=<span class="string">&quot;示例图片&quot;</span> <span class="attr">style</span>=<span class="string">&quot;zoom:50%;&quot;</span> /&gt;</span></span></span><br><span class="line"><span class="section"># 在线图片</span></span><br><span class="line">![<span class="string">code</span>](<span class="link">https://cdn.jsdelivr.net/gh/fomalhaut1998/markdown_pic/img/code.png</span>)</span><br></pre></td></tr></table></figure><button type="button" class="tab-to-top" aria-label="scroll to top"><i class="fas fa-arrow-up"></i></button></div><div class="tab-item-content" id="分栏-2"><p>本地图片:<br><img src="/assets/pusheencode.webp" alt="示例图片" style="zoom:50%;" /><br>在线图片:<br><img src="https://cdn.jsdelivr.net/gh/fomalhaut1998/markdown_pic/img/code.png" alt="code"></p><button type="button" class="tab-to-top" aria-label="scroll to top"><i class="fas fa-arrow-up"></i></button></div></div></div><h2 id="1-8-表格">1.8 表格</h2><div class="tabs" id="分栏"><ul class="nav-tabs"><li class="tab active"><button type="button" data-href="#分栏-1">示例源码</button></li><li class="tab"><button type="button" data-href="#分栏-2">渲染演示</button></li></ul><div class="tab-contents"><div class="tab-item-content active" id="分栏-1"><figure class="highlight markdown"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">| 项目标号 | 资金     | 备注 |</span><br><span class="line">| -------- | -------- | ---- |</span><br><span class="line">| 1        | 100，000 | 无   |</span><br><span class="line">| 2        | 200，000 | 无   |</span><br><span class="line">| 3        | 300,600  | 重要 |</span><br></pre></td></tr></table></figure><button type="button" class="tab-to-top" aria-label="scroll to top"><i class="fas fa-arrow-up"></i></button></div><div class="tab-item-content" id="分栏-2"><table><thead><tr><th>项目标号</th><th>资金</th><th>备注</th></tr></thead><tbody><tr><td>1</td><td>100，000</td><td>无</td></tr><tr><td>2</td><td>200，000</td><td>无</td></tr><tr><td>3</td><td>300,600</td><td>重要</td></tr></tbody></table><button type="button" class="tab-to-top" aria-label="scroll to top"><i class="fas fa-arrow-up"></i></button></div></div></div><h2 id="1-9-公式">1.9 公式</h2><div class="tabs" id="分栏"><ul class="nav-tabs"><li class="tab active"><button type="button" data-href="#分栏-1">示例源码</button></li><li class="tab"><button type="button" data-href="#分栏-2">渲染演示</button></li></ul><div class="tab-contents"><div class="tab-item-content active" id="分栏-1"><figure class="highlight markdown"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">$$</span><br><span class="line">\Gamma(z)=\int<span class="emphasis">_0^\infty t^&#123;z-1&#125;e^&#123;-t&#125;dt.</span></span><br><span class="line"><span class="emphasis">$$</span></span><br></pre></td></tr></table></figure><button type="button" class="tab-to-top" aria-label="scroll to top"><i class="fas fa-arrow-up"></i></button></div><div class="tab-item-content" id="分栏-2"><p>$$<br>\Gamma(z)=\int_0^\infty t^{z-1}e^{-t}dt.<br>$$</p><button type="button" class="tab-to-top" aria-label="scroll to top"><i class="fas fa-arrow-up"></i></button></div></div></div><h1>2.Butterfly外挂标签</h1><div class="note info flat"><p>这部分参考安知鱼:<a href="https://anzhiy.cn/posts/7d58.html">基于Butterfly的外挂标签引入</a></p></div><h2 id="2-1-行内文本样式-text">2.1 行内文本样式 text</h2><div class="tabs" id="分栏"><ul class="nav-tabs"><li class="tab active"><button type="button" data-href="#分栏-1">标签语法</button></li><li class="tab"><button type="button" data-href="#分栏-2">示例源码</button></li><li class="tab"><button type="button" data-href="#分栏-3">渲染演示</button></li></ul><div class="tab-contents"><div class="tab-item-content active" id="分栏-1"><figure class="highlight markdown"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">&#123;% u 文本内容 %&#125;</span><br><span class="line">&#123;% emp 文本内容 %&#125;</span><br><span class="line">&#123;% wavy 文本内容 %&#125;</span><br><span class="line">&#123;% del 文本内容 %&#125;</span><br><span class="line">&#123;% kbd 文本内容 %&#125;</span><br><span class="line">&#123;% psw 文本内容 %&#125;</span><br></pre></td></tr></table></figure><button type="button" class="tab-to-top" aria-label="scroll to top"><i class="fas fa-arrow-up"></i></button></div><div class="tab-item-content" id="分栏-2"><figure class="highlight markdown"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="bullet">1.</span> 带 &#123;% u 下划线 %&#125; 的文本</span><br><span class="line"><span class="bullet">2.</span> 带 &#123;% emp 着重号 %&#125; 的文本</span><br><span class="line"><span class="bullet">3.</span> 带 &#123;% wavy 波浪线 %&#125; 的文本</span><br><span class="line"><span class="bullet">4.</span> 带 &#123;% del 删除线 %&#125; 的文本</span><br><span class="line"><span class="bullet">5.</span> 键盘样式的文本 &#123;% kbd command %&#125; + &#123;% kbd D %&#125;</span><br><span class="line"><span class="bullet">6.</span> 密码样式的文本：&#123;% psw 这里没有验证码 %&#125;</span><br></pre></td></tr></table></figure><button type="button" class="tab-to-top" aria-label="scroll to top"><i class="fas fa-arrow-up"></i></button></div><div class="tab-item-content" id="分栏-3"><ol><li>带 <u>下划线</u> 的文本</li><li>带 <emp>着重号</emp> 的文本</li><li>带 <wavy>波浪线</wavy> 的文本</li><li>带 <del>删除线</del> 的文本</li><li>键盘样式的文本 <kbd>command</kbd> + <kbd>D</kbd></li><li>密码样式的文本：<psw>这里没有验证码</psw></li></ol><button type="button" class="tab-to-top" aria-label="scroll to top"><i class="fas fa-arrow-up"></i></button></div></div></div><h2 id="2-2-行内文本-span">2.2 行内文本 span</h2><div class="tabs" id="分栏"><ul class="nav-tabs"><li class="tab active"><button type="button" data-href="#分栏-1">标签语法</button></li><li class="tab"><button type="button" data-href="#分栏-2">配置参数</button></li><li class="tab"><button type="button" data-href="#分栏-3">示例源码</button></li><li class="tab"><button type="button" data-href="#分栏-4">渲染演示</button></li></ul><div class="tab-contents"><div class="tab-item-content active" id="分栏-1"><figure class="highlight markdown"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">&#123;% span 样式参数(参数以空格划分), 文本内容 %&#125;</span><br></pre></td></tr></table></figure><button type="button" class="tab-to-top" aria-label="scroll to top"><i class="fas fa-arrow-up"></i></button></div><div class="tab-item-content" id="分栏-2"><ol><li><code>字体</code>: logo, code</li><li><code>颜色</code>: red,yellow,green,cyan,blue,gray</li><li><code>大小</code>: small, h4, h3, h2, h1, large, huge, ultra</li><li><code>对齐方向</code>: left, center, right</li></ol><button type="button" class="tab-to-top" aria-label="scroll to top"><i class="fas fa-arrow-up"></i></button></div><div class="tab-item-content" id="分栏-3"><figure class="highlight markdown"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="bullet">-</span> 彩色文字</span><br><span class="line">在一段话中方便插入各种颜色的标签，包括：&#123;% span red, 红色 %&#125;、&#123;% span yellow, 黄色 %&#125;、&#123;% span green, 绿色 %&#125;、&#123;% span cyan, 青色 %&#125;、&#123;% span blue, 蓝色 %&#125;、&#123;% span gray, 灰色 %&#125;。</span><br><span class="line"><span class="bullet">-</span> 超大号文字</span><br><span class="line">文档「开始」页面中的标题部分就是超大号文字。</span><br><span class="line">&#123;% span center logo large, Volantis %&#125;</span><br><span class="line">&#123;% span center small, A Wonderful Theme for Hexo %&#125;</span><br></pre></td></tr></table></figure><button type="button" class="tab-to-top" aria-label="scroll to top"><i class="fas fa-arrow-up"></i></button></div><div class="tab-item-content" id="分栏-4"><ul><li>彩色文字<br>在一段话中方便插入各种颜色的标签，包括：<span class='p red'>红色</span>、<span class='p yellow'>黄色</span>、<span class='p green'>绿色</span>、<span class='p cyan'>青色</span>、<span class='p blue'>蓝色</span>、<span class='p gray'>灰色</span>。</li><li>超大号文字<br>文档「开始」页面中的标题部分就是超大号文字。<br><span class='p center logo large'>Volantis</span><br><span class='p center small'>A Wonderful Theme for Hexo</span></li></ul><button type="button" class="tab-to-top" aria-label="scroll to top"><i class="fas fa-arrow-up"></i></button></div></div></div><h2 id="2-3-段落文本-p">2.3 段落文本 p</h2><div class="tabs" id="分栏"><ul class="nav-tabs"><li class="tab active"><button type="button" data-href="#分栏-1">标签语法</button></li><li class="tab"><button type="button" data-href="#分栏-2">配置参数</button></li><li class="tab"><button type="button" data-href="#分栏-3">示例源码</button></li><li class="tab"><button type="button" data-href="#分栏-4">渲染演示</button></li></ul><div class="tab-contents"><div class="tab-item-content active" id="分栏-1"><figure class="highlight markdown"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">&#123;% p 样式参数(参数以空格划分), 文本内容 %&#125;</span><br></pre></td></tr></table></figure><button type="button" class="tab-to-top" aria-label="scroll to top"><i class="fas fa-arrow-up"></i></button></div><div class="tab-item-content" id="分栏-2"><ol><li><code>字体</code>: logo, code</li><li><code>颜色</code>: red,yellow,green,cyan,blue,gray</li><li><code>大小</code>: small, h4, h3, h2, h1, large, huge, ultra</li><li><code>对齐方向</code>: left, center, right</li></ol><button type="button" class="tab-to-top" aria-label="scroll to top"><i class="fas fa-arrow-up"></i></button></div><div class="tab-item-content" id="分栏-3"><figure class="highlight markdown"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="bullet">-</span> 彩色文字</span><br><span class="line">在一段话中方便插入各种颜色的标签，包括：&#123;% p red, 红色 %&#125;、&#123;% p yellow, 黄色 %&#125;、&#123;% p green, 绿色 %&#125;、&#123;% p cyan, 青色 %&#125;、&#123;% p blue, 蓝色 %&#125;、&#123;% p gray, 灰色 %&#125;。</span><br><span class="line"><span class="bullet">-</span> 超大号文字</span><br><span class="line">文档「开始」页面中的标题部分就是超大号文字。</span><br><span class="line">&#123;% p center logo large, Volantis %&#125;</span><br><span class="line">&#123;% p center small, A Wonderful Theme for Hexo %&#125;</span><br></pre></td></tr></table></figure><button type="button" class="tab-to-top" aria-label="scroll to top"><i class="fas fa-arrow-up"></i></button></div><div class="tab-item-content" id="分栏-4"><ul><li>彩色文字<br>在一段话中方便插入各种颜色的标签，包括：<p class='p red'>红色</p>、<p class='p yellow'>黄色</p>、<p class='p green'>绿色</p>、<p class='p cyan'>青色</p>、<p class='p blue'>蓝色</p>、<p class='p gray'>灰色</p>。</li><li>超大号文字<br>文档「开始」页面中的标题部分就是超大号文字。</li></ul><p class='p center logo large'>Volantis</p><p class='p center small'>A Wonderful Theme for Hexo</p><button type="button" class="tab-to-top" aria-label="scroll to top"><i class="fas fa-arrow-up"></i></button></div></div></div><h2 id="2-4-引用note">2.4 引用note</h2><div class="tabs" id="分栏"><ul class="nav-tabs"><li class="tab active"><button type="button" data-href="#分栏-1">通用配置</button></li><li class="tab"><button type="button" data-href="#分栏-2">语法格式</button></li><li class="tab"><button type="button" data-href="#分栏-3">参数配置</button></li><li class="tab"><button type="button" data-href="#分栏-4">示例源码</button></li><li class="tab"><button type="button" data-href="#分栏-5">渲染演示</button></li></ul><div class="tab-contents"><div class="tab-item-content active" id="分栏-1"><figure class="highlight markdown"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">note:</span><br><span class="line">  # Note tag style values:</span><br><span class="line">  #  - simple    bs-callout old alert style. Default.</span><br><span class="line">  #  - modern    bs-callout new (v2-v3) alert style.</span><br><span class="line">  #  - flat      flat callout style with background, like on Mozilla or StackOverflow.</span><br><span class="line">  #  - disabled  disable all CSS styles import of note tag.</span><br><span class="line">  style: simple</span><br><span class="line">  icons: false</span><br><span class="line">  border<span class="emphasis">_radius: 3</span></span><br><span class="line"><span class="emphasis">  # Offset lighter of background in % for modern and flat styles (modern: -12 | 12; flat: -18 | 6).</span></span><br><span class="line"><span class="emphasis">  # Offset also applied to label tag variables. This option can work with disabled note tag.</span></span><br><span class="line"><span class="emphasis">  light_</span>bg<span class="emphasis">_offset: 0</span></span><br></pre></td></tr></table></figure><button type="button" class="tab-to-top" aria-label="scroll to top"><i class="fas fa-arrow-up"></i></button></div><div class="tab-item-content" id="分栏-2"><figure class="highlight markdown"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="section"># 自带icon</span></span><br><span class="line">&#123;% note [class] [no-icon] [style] %&#125;</span><br><span class="line">Any content (support inline tags too.io).</span><br><span class="line">&#123;% endnote %&#125;</span><br><span class="line"><span class="section"># 外部icon</span></span><br><span class="line">&#123;% note [color] [icon] [style] %&#125;</span><br><span class="line">Any content (support inline tags too.io).</span><br><span class="line">&#123;% endnote %&#125;</span><br></pre></td></tr></table></figure><button type="button" class="tab-to-top" aria-label="scroll to top"><i class="fas fa-arrow-up"></i></button></div><div class="tab-item-content" id="分栏-3"><p>1.自带icon</p><table><thead><tr><th>参数</th><th style="text-align:center">用法</th></tr></thead><tbody><tr><td>class</td><td style="text-align:center">【可选】标识，不同的标识有不同的配色 （ default / primary / success / info / warning / danger ）</td></tr><tr><td>no-icon</td><td style="text-align:center">【可选】不显示 icon</td></tr><tr><td>style</td><td style="text-align:center">【可选】可以覆盖配置中的 style （simple/modern/flat/disabled）</td></tr></tbody></table><p>2.外部icon</p><table><thead><tr><th>参数</th><th style="text-align:center">用法</th></tr></thead><tbody><tr><td>class</td><td style="text-align:center">【可选】标识，不同的标识有不同的配色 （ default / blue / pink / red / purple / orange / green ）</td></tr><tr><td>no-icon</td><td style="text-align:center">【可选】可配置自定义 icon (只支持 fontawesome 图标, 也可以配置 no-icon )</td></tr><tr><td>style</td><td style="text-align:center">【可选】可以覆盖配置中的 style （simple/modern/flat/disabled）</td></tr></tbody></table><button type="button" class="tab-to-top" aria-label="scroll to top"><i class="fas fa-arrow-up"></i></button></div><div class="tab-item-content" id="分栏-4"><details class="folding-tag" blue><summary> 1.自带icon </summary>              <div class='content'>              <p>1.<code>simple</code>样式</p><figure class="highlight markdown"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">&#123;% note simple %&#125;默认 提示块标签&#123;% endnote %&#125;</span><br><span class="line"></span><br><span class="line">&#123;% note default simple %&#125;default 提示块标签&#123;% endnote %&#125;</span><br><span class="line"></span><br><span class="line">&#123;% note primary simple %&#125;primary 提示块标签&#123;% endnote %&#125;</span><br><span class="line"></span><br><span class="line">&#123;% note success simple %&#125;success 提示块标签&#123;% endnote %&#125;</span><br><span class="line"></span><br><span class="line">&#123;% note info simple %&#125;info 提示块标签&#123;% endnote %&#125;</span><br><span class="line"></span><br><span class="line">&#123;% note warning simple %&#125;warning 提示块标签&#123;% endnote %&#125;</span><br><span class="line"></span><br><span class="line">&#123;% note danger simple %&#125;danger 提示块标签&#123;% endnote %&#125;</span><br></pre></td></tr></table></figure><p>2.<code>modern</code>样式</p><figure class="highlight markdown"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">&#123;% note modern %&#125;默认 提示块标签&#123;% endnote %&#125;</span><br><span class="line"></span><br><span class="line">&#123;% note default modern %&#125;default 提示块标签&#123;% endnote %&#125;</span><br><span class="line"></span><br><span class="line">&#123;% note primary modern %&#125;primary 提示块标签&#123;% endnote %&#125;</span><br><span class="line"></span><br><span class="line">&#123;% note success modern %&#125;success 提示块标签&#123;% endnote %&#125;</span><br><span class="line"></span><br><span class="line">&#123;% note info modern %&#125;info 提示块标签&#123;% endnote %&#125;</span><br><span class="line"></span><br><span class="line">&#123;% note warning modern %&#125;warning 提示块标签&#123;% endnote %&#125;</span><br><span class="line"></span><br><span class="line">&#123;% note danger modern %&#125;danger 提示块标签&#123;% endnote %&#125;</span><br></pre></td></tr></table></figure><p>3.<code>flat</code>样式</p><figure class="highlight markdown"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">&#123;% note flat %&#125;默认 提示块标签&#123;% endnote %&#125;</span><br><span class="line"></span><br><span class="line">&#123;% note default flat %&#125;default 提示块标签&#123;% endnote %&#125;</span><br><span class="line"></span><br><span class="line">&#123;% note primary flat %&#125;primary 提示块标签&#123;% endnote %&#125;</span><br><span class="line"></span><br><span class="line">&#123;% note success flat %&#125;success 提示块标签&#123;% endnote %&#125;</span><br><span class="line"></span><br><span class="line">&#123;% note info flat %&#125;info 提示块标签&#123;% endnote %&#125;</span><br><span class="line"></span><br><span class="line">&#123;% note warning flat %&#125;warning 提示块标签&#123;% endnote %&#125;</span><br><span class="line"></span><br><span class="line">&#123;% note danger flat %&#125;danger 提示块标签&#123;% endnote %&#125;</span><br></pre></td></tr></table></figure><p>4.<code>disabled</code>样式</p><figure class="highlight markdown"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">&#123;% note disabled %&#125;默认 提示块标签&#123;% endnote %&#125;</span><br><span class="line"></span><br><span class="line">&#123;% note default disabled %&#125;default 提示块标签&#123;% endnote %&#125;</span><br><span class="line"></span><br><span class="line">&#123;% note primary disabled %&#125;primary 提示块标签&#123;% endnote %&#125;</span><br><span class="line"></span><br><span class="line">&#123;% note success disabled %&#125;success 提示块标签&#123;% endnote %&#125;</span><br><span class="line"></span><br><span class="line">&#123;% note info disabled %&#125;info 提示块标签&#123;% endnote %&#125;</span><br><span class="line"></span><br><span class="line">&#123;% note warning disabled %&#125;warning 提示块标签&#123;% endnote %&#125;</span><br><span class="line"></span><br><span class="line">&#123;% note danger disabled %&#125;danger 提示块标签&#123;% endnote %&#125;</span><br></pre></td></tr></table></figure><p>5.<code>no-icon</code>样式</p><figure class="highlight markdown"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">&#123;% note no-icon %&#125;默认 提示块标签&#123;% endnote %&#125;</span><br><span class="line"></span><br><span class="line">&#123;% note default no-icon %&#125;default 提示块标签&#123;% endnote %&#125;</span><br><span class="line"></span><br><span class="line">&#123;% note primary no-icon %&#125;primary 提示块标签&#123;% endnote %&#125;</span><br><span class="line"></span><br><span class="line">&#123;% note success no-icon %&#125;success 提示块标签&#123;% endnote %&#125;</span><br><span class="line"></span><br><span class="line">&#123;% note info no-icon %&#125;info 提示块标签&#123;% endnote %&#125;</span><br><span class="line"></span><br><span class="line">&#123;% note warning no-icon %&#125;warning 提示块标签&#123;% endnote %&#125;</span><br><span class="line"></span><br><span class="line">&#123;% note danger no-icon %&#125;danger 提示块标签&#123;% endnote %&#125;</span><br></pre></td></tr></table></figure>              </div>            </details><details class="folding-tag" blue><summary> 2.外部icon </summary>              <div class='content'>              <p>1.<code>simple</code>样式</p><figure class="highlight markdown"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">&#123;% note &#x27;fab fa-cc-visa&#x27; simple %&#125;你是刷 Visa 还是 UnionPay&#123;% endnote %&#125;</span><br><span class="line"></span><br><span class="line">&#123;% note blue &#x27;fas fa-bullhorn&#x27; simple %&#125;2021年快到了....&#123;% endnote %&#125;</span><br><span class="line"></span><br><span class="line">&#123;% note pink &#x27;fas fa-car-crash&#x27; simple %&#125;小心开车 安全至上&#123;% endnote %&#125;</span><br><span class="line"></span><br><span class="line">&#123;% note red &#x27;fas fa-fan&#x27; simple%&#125;这是三片呢？还是四片？&#123;% endnote %&#125;</span><br><span class="line"></span><br><span class="line">&#123;% note orange &#x27;fas fa-battery-half&#x27; simple %&#125;你是刷 Visa 还是 UnionPay&#123;% endnote %&#125;</span><br><span class="line"></span><br><span class="line">&#123;% note purple &#x27;far fa-hand-scissors&#x27; simple %&#125;剪刀石头布&#123;% endnote %&#125;</span><br><span class="line"></span><br><span class="line">&#123;% note green &#x27;fab fa-internet-explorer&#x27; simple %&#125;前端最讨厌的浏览器&#123;% endnote %&#125;</span><br></pre></td></tr></table></figure><p>2.<code>modern</code>样式</p><figure class="highlight markdown"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">&#123;% note &#x27;fab fa-cc-visa&#x27; modern %&#125;你是刷 Visa 还是 UnionPay&#123;% endnote %&#125;</span><br><span class="line"></span><br><span class="line">&#123;% note blue &#x27;fas fa-bullhorn&#x27; modern %&#125;2021年快到了....&#123;% endnote %&#125;</span><br><span class="line"></span><br><span class="line">&#123;% note pink &#x27;fas fa-car-crash&#x27; modern %&#125;小心开车 安全至上&#123;% endnote %&#125;</span><br><span class="line"></span><br><span class="line">&#123;% note red &#x27;fas fa-fan&#x27; modern%&#125;这是三片呢？还是四片？&#123;% endnote %&#125;</span><br><span class="line"></span><br><span class="line">&#123;% note orange &#x27;fas fa-battery-half&#x27; modern %&#125;你是刷 Visa 还是 UnionPay&#123;% endnote %&#125;</span><br><span class="line"></span><br><span class="line">&#123;% note purple &#x27;far fa-hand-scissors&#x27; modern %&#125;剪刀石头布&#123;% endnote %&#125;</span><br><span class="line"></span><br><span class="line">&#123;% note green &#x27;fab fa-internet-explorer&#x27; modern %&#125;前端最讨厌的浏览器&#123;% endnote %&#125;</span><br></pre></td></tr></table></figure><p>3.<code>flat</code>样式</p><figure class="highlight markdown"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">&#123;% note &#x27;fab fa-cc-visa&#x27; flat %&#125;你是刷 Visa 还是 UnionPay&#123;% endnote %&#125;</span><br><span class="line"></span><br><span class="line">&#123;% note blue &#x27;fas fa-bullhorn&#x27; flat %&#125;2021年快到了....&#123;% endnote %&#125;</span><br><span class="line"></span><br><span class="line">&#123;% note pink &#x27;fas fa-car-crash&#x27; flat %&#125;小心开车 安全至上&#123;% endnote %&#125;</span><br><span class="line"></span><br><span class="line">&#123;% note red &#x27;fas fa-fan&#x27; flat%&#125;这是三片呢？还是四片？&#123;% endnote %&#125;</span><br><span class="line"></span><br><span class="line">&#123;% note orange &#x27;fas fa-battery-half&#x27; flat %&#125;你是刷 Visa 还是 UnionPay&#123;% endnote %&#125;</span><br><span class="line"></span><br><span class="line">&#123;% note purple &#x27;far fa-hand-scissors&#x27; flat %&#125;剪刀石头布&#123;% endnote %&#125;</span><br><span class="line"></span><br><span class="line">&#123;% note green &#x27;fab fa-internet-explorer&#x27; flat %&#125;前端最讨厌的浏览器&#123;% endnote %&#125;</span><br></pre></td></tr></table></figure><p>4.<code>disabled</code>样式</p><figure class="highlight markdown"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">&#123;% note &#x27;fab fa-cc-visa&#x27; disabled %&#125;你是刷 Visa 还是 UnionPay&#123;% endnote %&#125;</span><br><span class="line"></span><br><span class="line">&#123;% note blue &#x27;fas fa-bullhorn&#x27; disabled %&#125;2021年快到了....&#123;% endnote %&#125;</span><br><span class="line"></span><br><span class="line">&#123;% note pink &#x27;fas fa-car-crash&#x27; disabled %&#125;小心开车 安全至上&#123;% endnote %&#125;</span><br><span class="line"></span><br><span class="line">&#123;% note red &#x27;fas fa-fan&#x27; disabled %&#125;这是三片呢？还是四片？&#123;% endnote %&#125;</span><br><span class="line"></span><br><span class="line">&#123;% note orange &#x27;fas fa-battery-half&#x27; disabled %&#125;你是刷 Visa 还是 UnionPay&#123;% endnote %&#125;</span><br><span class="line"></span><br><span class="line">&#123;% note purple &#x27;far fa-hand-scissors&#x27; disabled %&#125;剪刀石头布&#123;% endnote %&#125;</span><br><span class="line"></span><br><span class="line">&#123;% note green &#x27;fab fa-internet-explorer&#x27; disabled %&#125;前端最讨厌的浏览器&#123;% endnote %&#125;</span><br></pre></td></tr></table></figure><p>5.<code>no-icon</code>样式</p><figure class="highlight markdown"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">&#123;% note no-icon %&#125;你是刷 Visa 还是 UnionPay&#123;% endnote %&#125;</span><br><span class="line"></span><br><span class="line">&#123;% note blue no-icon %&#125;2021年快到了....&#123;% endnote %&#125;</span><br><span class="line"></span><br><span class="line">&#123;% note pink no-icon %&#125;小心开车 安全至上&#123;% endnote %&#125;</span><br><span class="line"></span><br><span class="line">&#123;% note red no-icon %&#125;这是三片呢？还是四片？&#123;% endnote %&#125;</span><br><span class="line"></span><br><span class="line">&#123;% note orange no-icon %&#125;你是刷 Visa 还是 UnionPay&#123;% endnote %&#125;</span><br><span class="line"></span><br><span class="line">&#123;% note purple no-icon %&#125;剪刀石头布&#123;% endnote %&#125;</span><br><span class="line"></span><br><span class="line">&#123;% note green no-icon %&#125;前端最讨厌的浏览器&#123;% endnote %&#125;</span><br></pre></td></tr></table></figure>              </div>            </details><button type="button" class="tab-to-top" aria-label="scroll to top"><i class="fas fa-arrow-up"></i></button></div><div class="tab-item-content" id="分栏-5"><details class="folding-tag" blue><summary> 1.自带icon </summary>              <div class='content'>              <p>1.<code>simple</code>样式</p><div class="note simple"><p>默认 提示块标签</p></div><div class="note default simple"><p>default 提示块标签</p></div><div class="note primary simple"><p>primary 提示块标签</p></div><div class="note success simple"><p>success 提示块标签</p></div><div class="note info simple"><p>info 提示块标签</p></div><div class="note warning simple"><p>warning 提示块标签</p></div><div class="note danger simple"><p>danger 提示块标签</p></div>2.`modern`样式<div class="note modern"><p>默认 提示块标签</p></div><div class="note default modern"><p>default 提示块标签</p></div><div class="note primary modern"><p>primary 提示块标签</p></div><div class="note success modern"><p>success 提示块标签</p></div><div class="note info modern"><p>info 提示块标签</p></div><div class="note warning modern"><p>warning 提示块标签</p></div><div class="note danger modern"><p>danger 提示块标签</p></div><p>3.<code>flat</code>样式</p><div class="note flat"><p>默认 提示块标签</p></div><div class="note default flat"><p>default 提示块标签</p></div><div class="note primary flat"><p>primary 提示块标签</p></div><div class="note success flat"><p>success 提示块标签</p></div><div class="note info flat"><p>info 提示块标签</p></div><div class="note warning flat"><p>warning 提示块标签</p></div><div class="note danger flat"><p>danger 提示块标签</p></div><p>4.<code>disabled</code>样式</p><div class="note disabled"><p>默认 提示块标签</p></div><div class="note default disabled"><p>default 提示块标签</p></div><div class="note primary disabled"><p>primary 提示块标签</p></div><div class="note success disabled"><p>success 提示块标签</p></div><div class="note info disabled"><p>info 提示块标签</p></div><div class="note warning disabled"><p>warning 提示块标签</p></div><div class="note danger disabled"><p>danger 提示块标签</p></div><p>5.<code>no-icon</code>样式</p><div class="note no-icon flat"><p>默认 提示块标签</p></div><div class="note default no-icon flat"><p>default 提示块标签</p></div><div class="note primary no-icon flat"><p>primary 提示块标签</p></div><div class="note success no-icon flat"><p>success 提示块标签</p></div><div class="note info no-icon flat"><p>info 提示块标签</p></div><div class="note warning no-icon flat"><p>warning 提示块标签</p></div><div class="note danger no-icon flat"><p>danger 提示块标签</p></div>              </div>            </details><details class="folding-tag" blue><summary> 2.外部icon </summary>              <div class='content'>              <p>1.<code>simple</code>样式</p><div class="note icon-padding simple"><i class="note-icon fab fa-cc-visa"></i><p>你是刷 Visa 还是 UnionPay</p></div><div class="note blue icon-padding simple"><i class="note-icon fas fa-bullhorn"></i><p>2021年快到了…</p></div><div class="note pink icon-padding simple"><i class="note-icon fas fa-car-crash"></i><p>小心开车 安全至上</p></div><div class="note red icon-padding simple"><i class="note-icon fas fa-fan"></i><p>这是三片呢？还是四片？</p></div><div class="note orange icon-padding simple"><i class="note-icon fas fa-battery-half"></i><p>你是刷 Visa 还是 UnionPay</p></div><div class="note purple icon-padding simple"><i class="note-icon far fa-hand-scissors"></i><p>剪刀石头布</p></div><div class="note green icon-padding simple"><i class="note-icon fab fa-internet-explorer"></i><p>前端最讨厌的浏览器</p></div><p>2.<code>modern</code>样式</p><div class="note icon-padding modern"><i class="note-icon fab fa-cc-visa"></i><p>你是刷 Visa 还是 UnionPay</p></div><div class="note blue icon-padding modern"><i class="note-icon fas fa-bullhorn"></i><p>2021年快到了…</p></div><div class="note pink icon-padding modern"><i class="note-icon fas fa-car-crash"></i><p>小心开车 安全至上</p></div><div class="note red icon-padding modern"><i class="note-icon fas fa-fan"></i><p>这是三片呢？还是四片？</p></div><div class="note orange icon-padding modern"><i class="note-icon fas fa-battery-half"></i><p>你是刷 Visa 还是 UnionPay</p></div><div class="note purple icon-padding modern"><i class="note-icon far fa-hand-scissors"></i><p>剪刀石头布</p></div><div class="note green icon-padding modern"><i class="note-icon fab fa-internet-explorer"></i><p>前端最讨厌的浏览器</p></div><p>3.<code>flat</code>样式</p><div class="note icon-padding flat"><i class="note-icon fab fa-cc-visa"></i><p>你是刷 Visa 还是 UnionPay</p></div><div class="note blue icon-padding flat"><i class="note-icon fas fa-bullhorn"></i><p>2021年快到了…</p></div><div class="note pink icon-padding flat"><i class="note-icon fas fa-car-crash"></i><p>小心开车 安全至上</p></div><div class="note red icon-padding flat"><i class="note-icon fas fa-fan"></i><p>这是三片呢？还是四片？</p></div><div class="note orange icon-padding flat"><i class="note-icon fas fa-battery-half"></i><p>你是刷 Visa 还是 UnionPay</p></div><div class="note purple icon-padding flat"><i class="note-icon far fa-hand-scissors"></i><p>剪刀石头布</p></div><div class="note green icon-padding flat"><i class="note-icon fab fa-internet-explorer"></i><p>前端最讨厌的浏览器</p></div><p>4.<code>disabled</code>样式</p><div class="note icon-padding disabled"><i class="note-icon fab fa-cc-visa"></i><p>你是刷 Visa 还是 UnionPay</p></div><div class="note blue icon-padding disabled"><i class="note-icon fas fa-bullhorn"></i><p>2021年快到了…</p></div><div class="note pink icon-padding disabled"><i class="note-icon fas fa-car-crash"></i><p>小心开车 安全至上</p></div><div class="note red icon-padding disabled"><i class="note-icon fas fa-fan"></i><p>这是三片呢？还是四片？</p></div><div class="note orange icon-padding disabled"><i class="note-icon fas fa-battery-half"></i><p>你是刷 Visa 还是 UnionPay</p></div><div class="note purple icon-padding disabled"><i class="note-icon far fa-hand-scissors"></i><p>剪刀石头布</p></div><div class="note green icon-padding disabled"><i class="note-icon fab fa-internet-explorer"></i><p>前端最讨厌的浏览器</p></div><p>5.<code>no-icon</code>样式</p><div class="note no-icon flat"><p>你是刷 Visa 还是 UnionPay</p></div><div class="note blue no-icon flat"><p>2021年快到了…</p></div><div class="note pink no-icon flat"><p>小心开车 安全至上</p></div><div class="note red no-icon flat"><p>这是三片呢？还是四片？</p></div><div class="note orange no-icon flat"><p>你是刷 Visa 还是 UnionPay</p></div><div class="note purple no-icon flat"><p>剪刀石头布</p></div><div class="note green no-icon flat"><p>前端最讨厌的浏览器</p></div>              </div>            </details><button type="button" class="tab-to-top" aria-label="scroll to top"><i class="fas fa-arrow-up"></i></button></div></div></div><h2 id="2-5-上标标签-tip">2.5 上标标签 tip</h2><div class="tabs" id="分栏"><ul class="nav-tabs"><li class="tab active"><button type="button" data-href="#分栏-1">标签语法</button></li><li class="tab"><button type="button" data-href="#分栏-2">配置参数</button></li><li class="tab"><button type="button" data-href="#分栏-3">示例源码</button></li><li class="tab"><button type="button" data-href="#分栏-4">渲染演示</button></li></ul><div class="tab-contents"><div class="tab-item-content active" id="分栏-1"><figure class="highlight markdown"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">&#123;% tip [参数，可选] %&#125;文本内容&#123;% endtip %&#125;</span><br></pre></td></tr></table></figure><button type="button" class="tab-to-top" aria-label="scroll to top"><i class="fas fa-arrow-up"></i></button></div><div class="tab-item-content" id="分栏-2"><ol><li><code>样式</code>: success,error,warning,bolt,ban,home,sync,cogs,key,bell</li><li><code>自定义图标</code>: 支持fontawesome。</li></ol><button type="button" class="tab-to-top" aria-label="scroll to top"><i class="fas fa-arrow-up"></i></button></div><div class="tab-item-content" id="分栏-3"><figure class="highlight markdown"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">&#123;% tip %&#125;default&#123;% endtip %&#125;</span><br><span class="line">&#123;% tip info %&#125;info&#123;% endtip %&#125;</span><br><span class="line">&#123;% tip success %&#125;success&#123;% endtip %&#125;</span><br><span class="line">&#123;% tip error %&#125;error&#123;% endtip %&#125;</span><br><span class="line">&#123;% tip warning %&#125;warning&#123;% endtip %&#125;</span><br><span class="line">&#123;% tip bolt %&#125;bolt&#123;% endtip %&#125;</span><br><span class="line">&#123;% tip ban %&#125;ban&#123;% endtip %&#125;</span><br><span class="line">&#123;% tip home %&#125;home&#123;% endtip %&#125;</span><br><span class="line">&#123;% tip sync %&#125;sync&#123;% endtip %&#125;</span><br><span class="line">&#123;% tip cogs %&#125;cogs&#123;% endtip %&#125;</span><br><span class="line">&#123;% tip key %&#125;key&#123;% endtip %&#125;</span><br><span class="line">&#123;% tip bell %&#125;bell&#123;% endtip %&#125;</span><br><span class="line">&#123;% tip fa-atom %&#125;自定义font awesome图标&#123;% endtip %&#125;</span><br></pre></td></tr></table></figure><button type="button" class="tab-to-top" aria-label="scroll to top"><i class="fas fa-arrow-up"></i></button></div><div class="tab-item-content" id="分栏-4"><div class="tip "><p>default</p></div><div class="tip info"><p>info</p></div><div class="tip success"><p>success</p></div><div class="tip error"><p>error</p></div><div class="tip warning"><p>warning</p></div><div class="tip bolt"><p>bolt</p></div><div class="tip ban"><p>ban</p></div><div class="tip home"><p>home</p></div><div class="tip sync"><p>sync</p></div><div class="tip cogs"><p>cogs</p></div><div class="tip key"><p>key</p></div><div class="tip bell"><p>bell</p></div><div class="tip fa-atom"><p>自定义font awesome图标</p></div><button type="button" class="tab-to-top" aria-label="scroll to top"><i class="fas fa-arrow-up"></i></button></div></div></div><h2 id="2-6-动态标签-anima">2.6 动态标签 anima</h2><div class="tabs" id="分栏"><ul class="nav-tabs"><li class="tab active"><button type="button" data-href="#分栏-1">示例源码</button></li><li class="tab"><button type="button" data-href="#分栏-2">配置参数</button></li><li class="tab"><button type="button" data-href="#分栏-3">示例源码</button></li><li class="tab"><button type="button" data-href="#分栏-4">渲染演示</button></li></ul><div class="tab-contents"><div class="tab-item-content active" id="分栏-1"><figure class="highlight markdown"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">&#123;% tip [参数，可选] %&#125;文本内容&#123;% endtip %&#125;</span><br></pre></td></tr></table></figure><button type="button" class="tab-to-top" aria-label="scroll to top"><i class="fas fa-arrow-up"></i></button></div><div class="tab-item-content" id="分栏-2"><div class="note info flat"><ol><li>将所需的CSS类添加到图标（或DOM中的任何元素）。</li><li>对于父级悬停样式，需要给目标元素添加指定CSS类，同时还要给目标元素的父级元素添加CSS类<code>faa-parent animated-hover</code>。（详情见示例及示例源码）<br>You can regulate the speed of the animation by adding the CSS class or . faa-fastfaa-slow</li><li>可以通过给目标元素添加CSS类<code>faa-fast</code>或<code>faa-slow</code>来控制动画快慢。</li></ol></div><button type="button" class="tab-to-top" aria-label="scroll to top"><i class="fas fa-arrow-up"></i></button></div><div class="tab-item-content" id="分栏-3"><p>1.On DOM load（当页面加载时显示动画）</p><figure class="highlight markdown"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">&#123;% tip warning faa-horizontal animated %&#125;warning&#123;% endtip %&#125;</span><br><span class="line">&#123;% tip ban faa-flash animated %&#125;ban&#123;% endtip %&#125;</span><br></pre></td></tr></table></figure><p>2.调整动画速度</p><figure class="highlight markdown"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">&#123;% tip warning faa-horizontal animated faa-fast %&#125;warning&#123;% endtip %&#125;</span><br><span class="line">&#123;% tip ban faa-flash animated faa-slow %&#125;ban&#123;% endtip %&#125;</span><br></pre></td></tr></table></figure><p>3.On hover（当鼠标悬停时显示动画）</p><figure class="highlight markdown"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">&#123;% tip warning faa-horizontal animated-hover %&#125;warning&#123;% endtip %&#125;</span><br><span class="line">&#123;% tip ban faa-flash animated-hover %&#125;ban&#123;% endtip %&#125;</span><br></pre></td></tr></table></figure><p>4.On parent hover（当鼠标悬停在父级元素时显示动画）</p><figure class="highlight markdown"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">&#123;% tip warning faa-parent animated-hover %&#125;<span class="language-xml"><span class="tag">&lt;<span class="name">p</span> <span class="attr">class</span>=<span class="string">&quot;faa-horizontal&quot;</span>&gt;</span></span>warning<span class="language-xml"><span class="tag">&lt;/<span class="name">p</span>&gt;</span></span>&#123;% endtip %&#125;</span><br><span class="line">&#123;% tip ban faa-parent animated-hover %&#125;<span class="language-xml"><span class="tag">&lt;<span class="name">p</span> <span class="attr">class</span>=<span class="string">&quot;faa-flash&quot;</span>&gt;</span></span>ban<span class="language-xml"><span class="tag">&lt;/<span class="name">p</span>&gt;</span></span>&#123;% endtip %&#125;</span><br></pre></td></tr></table></figure><button type="button" class="tab-to-top" aria-label="scroll to top"><i class="fas fa-arrow-up"></i></button></div><div class="tab-item-content" id="分栏-4"><p>1.On DOM load（当页面加载时显示动画）</p><div class="tip warning faa-horizontal animated"><p>warning</p></div><div class="tip ban faa-flash animated"><p>ban</p></div>2.调整动画速度<div class="tip warning faa-horizontal animated faa-fast"><p>warning</p></div><div class="tip ban faa-flash animated faa-slow"><p>ban</p></div>3.On hover（当鼠标悬停时显示动画）<div class="tip warning faa-horizontal animated-hover"><p>warning</p></div><div class="tip ban faa-flash animated-hover"><p>ban</p></div>4.On parent hover（当鼠标悬停在父级元素时显示动画）<div class="tip warning faa-parent animated-hover"><p class="faa-horizontal">warning</p></div><div class="tip ban faa-parent animated-hover"><p class="faa-flash">ban</p></div><button type="button" class="tab-to-top" aria-label="scroll to top"><i class="fas fa-arrow-up"></i></button></div></div></div><h2 id="2-7-复选列表-checkbox">2.7 复选列表 checkbox</h2><div class="tabs" id="分栏"><ul class="nav-tabs"><li class="tab active"><button type="button" data-href="#分栏-1">标签语法</button></li><li class="tab"><button type="button" data-href="#分栏-2">配置参数</button></li><li class="tab"><button type="button" data-href="#分栏-3">示例源码</button></li><li class="tab"><button type="button" data-href="#分栏-4">渲染演示</button></li></ul><div class="tab-contents"><div class="tab-item-content active" id="分栏-1"><figure class="highlight markdown"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">&#123;% checkbox 样式参数（可选）, 文本（支持简单md） %&#125;</span><br></pre></td></tr></table></figure><button type="button" class="tab-to-top" aria-label="scroll to top"><i class="fas fa-arrow-up"></i></button></div><div class="tab-item-content" id="分栏-2"><ol><li><code>样式</code>: plus, minus, times</li><li><code>颜色</code>: red,yellow,green,cyan,blue,gray</li><li><code>选中状态</code>: checked</li></ol><button type="button" class="tab-to-top" aria-label="scroll to top"><i class="fas fa-arrow-up"></i></button></div><div class="tab-item-content" id="分栏-3"><figure class="highlight markdown"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">&#123;% checkbox 纯文本测试 %&#125;</span><br><span class="line">&#123;% checkbox checked, 支持简单的 [<span class="string">markdown</span>](<span class="link">https://guides.github.com/features/mastering-markdown/</span>) 语法 %&#125;</span><br><span class="line">&#123;% checkbox red, 支持自定义颜色 %&#125;</span><br><span class="line">&#123;% checkbox green checked, 绿色 + 默认选中 %&#125;</span><br><span class="line">&#123;% checkbox yellow checked, 黄色 + 默认选中 %&#125;</span><br><span class="line">&#123;% checkbox cyan checked, 青色 + 默认选中 %&#125;</span><br><span class="line">&#123;% checkbox blue checked, 蓝色 + 默认选中 %&#125;</span><br><span class="line">&#123;% checkbox plus green checked, 增加 %&#125;</span><br><span class="line">&#123;% checkbox minus yellow checked, 减少 %&#125;</span><br><span class="line">&#123;% checkbox times red checked, 叉 %&#125;</span><br></pre></td></tr></table></figure><button type="button" class="tab-to-top" aria-label="scroll to top"><i class="fas fa-arrow-up"></i></button></div><div class="tab-item-content" id="分栏-4"><div class='checkbox'><input type="checkbox" />            <p>纯文本测试</p>            </div><div class='checkbox checked'><input type="checkbox" checked="checked"/>            <p>支持简单的 <a href="https://guides.github.com/features/mastering-markdown/">markdown</a> 语法</p>            </div><div class='checkbox red'><input type="checkbox" />            <p>支持自定义颜色</p>            </div><div class='checkbox green checked'><input type="checkbox" checked="checked"/>            <p>绿色 + 默认选中</p>            </div><div class='checkbox yellow checked'><input type="checkbox" checked="checked"/>            <p>黄色 + 默认选中</p>            </div><div class='checkbox cyan checked'><input type="checkbox" checked="checked"/>            <p>青色 + 默认选中</p>            </div><div class='checkbox blue checked'><input type="checkbox" checked="checked"/>            <p>蓝色 + 默认选中</p>            </div><div class='checkbox plus green checked'><input type="checkbox" checked="checked"/>            <p>增加</p>            </div><div class='checkbox minus yellow checked'><input type="checkbox" checked="checked"/>            <p>减少</p>            </div><div class='checkbox times red checked'><input type="checkbox" checked="checked"/>            <p>叉</p>            </div><button type="button" class="tab-to-top" aria-label="scroll to top"><i class="fas fa-arrow-up"></i></button></div></div></div><h2 id="2-8-单选列表-radio">2.8 单选列表 radio</h2><div class="tabs" id="分栏"><ul class="nav-tabs"><li class="tab active"><button type="button" data-href="#分栏-1">标签语法</button></li><li class="tab"><button type="button" data-href="#分栏-2">配置参数</button></li><li class="tab"><button type="button" data-href="#分栏-3">示例源码</button></li><li class="tab"><button type="button" data-href="#分栏-4">渲染演示</button></li></ul><div class="tab-contents"><div class="tab-item-content active" id="分栏-1"><figure class="highlight markdown"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">&#123;% radio 样式参数（可选）, 文本（支持简单md） %&#125;</span><br></pre></td></tr></table></figure><button type="button" class="tab-to-top" aria-label="scroll to top"><i class="fas fa-arrow-up"></i></button></div><div class="tab-item-content" id="分栏-2"><ol><li><code>颜色</code>: red,yellow,green,cyan,blue,gray</li><li><code>选中状态</code>: checked</li></ol><button type="button" class="tab-to-top" aria-label="scroll to top"><i class="fas fa-arrow-up"></i></button></div><div class="tab-item-content" id="分栏-3"><figure class="highlight markdown"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">&#123;% radio 纯文本测试 %&#125;</span><br><span class="line">&#123;% radio checked, 支持简单的 [<span class="string">markdown</span>](<span class="link">https://guides.github.com/features/mastering-markdown/</span>) 语法 %&#125;</span><br><span class="line">&#123;% radio red, 支持自定义颜色 %&#125;</span><br><span class="line">&#123;% radio green, 绿色 %&#125;</span><br><span class="line">&#123;% radio yellow, 黄色 %&#125;</span><br><span class="line">&#123;% radio cyan, 青色 %&#125;</span><br><span class="line">&#123;% radio blue, 蓝色 %&#125;</span><br></pre></td></tr></table></figure><button type="button" class="tab-to-top" aria-label="scroll to top"><i class="fas fa-arrow-up"></i></button></div><div class="tab-item-content" id="分栏-4"><div class='checkbox'><input type="radio" />            <p>纯文本测试</p>            </div><div class='checkbox checked'><input type="radio" checked="checked"/>            <p>支持简单的 <a href="https://guides.github.com/features/mastering-markdown/">markdown</a> 语法</p>            </div><div class='checkbox red'><input type="radio" />            <p>支持自定义颜色</p>            </div><div class='checkbox green'><input type="radio" />            <p>绿色</p>            </div><div class='checkbox yellow'><input type="radio" />            <p>黄色</p>            </div><div class='checkbox cyan'><input type="radio" />            <p>青色</p>            </div><div class='checkbox blue'><input type="radio" />            <p>蓝色</p>            </div><button type="button" class="tab-to-top" aria-label="scroll to top"><i class="fas fa-arrow-up"></i></button></div></div></div><h2 id="2-9-时间轴-timeline">2.9 时间轴 timeline</h2><div class="tabs" id="分栏"><ul class="nav-tabs"><li class="tab active"><button type="button" data-href="#分栏-1">标签语法</button></li><li class="tab"><button type="button" data-href="#分栏-2">配置参数</button></li><li class="tab"><button type="button" data-href="#分栏-3">示例源码</button></li><li class="tab"><button type="button" data-href="#分栏-4">渲染演示</button></li></ul><div class="tab-contents"><div class="tab-item-content active" id="分栏-1"><figure class="highlight markdown"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">&#123;% timeline 时间线标题（可选）[,color] %&#125;</span><br><span class="line">&lt;!-- timeline 时间节点（标题） --&gt;</span><br><span class="line">正文内容</span><br><span class="line">&lt;!-- endtimeline --&gt;</span><br><span class="line">&lt;!-- timeline 时间节点（标题） --&gt;</span><br><span class="line">正文内容</span><br><span class="line">&lt;!-- endtimeline --&gt;</span><br><span class="line">&#123;% endtimeline %&#125;</span><br></pre></td></tr></table></figure><button type="button" class="tab-to-top" aria-label="scroll to top"><i class="fas fa-arrow-up"></i></button></div><div class="tab-item-content" id="分栏-2"><ol><li><code>title</code>:标题/时间线</li><li><code>color</code>:<code>timeline</code>颜色:default(留空) / blue / pink / red / purple / orange / green</li></ol><button type="button" class="tab-to-top" aria-label="scroll to top"><i class="fas fa-arrow-up"></i></button></div><div class="tab-item-content" id="分栏-3"><figure class="highlight markdown"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line">&#123;% timeline 时间轴样式,blue %&#125;</span><br><span class="line"></span><br><span class="line">&lt;!-- timeline 2020-07-24 [<span class="string">2.6.6 -&gt; 3.0</span>](<span class="link">https://github.com/volantis-x/hexo-theme-volantis/releases</span>) --&gt;</span><br><span class="line"></span><br><span class="line"><span class="bullet">1.</span> 如果有 <span class="code">`hexo-lazyload-image`</span> 插件，需要删除并重新安装最新版本，设置 <span class="code">`lazyload.isSPA: true`</span>。</span><br><span class="line"><span class="bullet">2.</span> 2.x 版本的 css 和 js 不适用于 3.x 版本，如果使用了 <span class="code">`use_cdn: true`</span> 则需要删除。</span><br><span class="line"><span class="bullet">3.</span> 2.x 版本的 fancybox 标签在 3.x 版本中被重命名为 gallery 。</span><br><span class="line"><span class="bullet">4.</span> 2.x 版本的置顶 <span class="code">`top: true`</span> 改为了 <span class="code">`pin: true`</span>，并且同样适用于 <span class="code">`layout: page`</span> 的页面。</span><br><span class="line"><span class="bullet">5.</span> 如果使用了 <span class="code">`hexo-offline`</span> 插件，建议卸载，3.0 版本默认开启了 pjax 服务。</span><br><span class="line"></span><br><span class="line">&lt;!-- endtimeline --&gt;</span><br><span class="line"></span><br><span class="line">&lt;!-- timeline 2020-05-15 [<span class="string">2.6.3 -&gt; 2.6.6</span>](<span class="link">https://github.com/volantis-x/hexo-theme-volantis/releases/tag/2.6.6</span>) --&gt;</span><br><span class="line"></span><br><span class="line">不需要额外处理。</span><br><span class="line"></span><br><span class="line">&lt;!-- endtimeline --&gt;</span><br><span class="line"></span><br><span class="line">&lt;!-- timeline 2020-04-20 [<span class="string">2.6.2 -&gt; 2.6.3</span>](<span class="link">https://github.com/volantis-x/hexo-theme-volantis/releases/tag/2.6.3</span>) --&gt;</span><br><span class="line"></span><br><span class="line"><span class="bullet">1.</span> 全局搜索 <span class="code">`seotitle`</span> 并替换为 <span class="code">`seo_title`</span>。</span><br><span class="line"><span class="bullet">2.</span> group 组件的索引规则有变，使用 group 组件的文章内，<span class="code">`group: group_name`</span> 对应的组件名必须是 <span class="code">`group_name`</span>。</span><br><span class="line"><span class="bullet">2.</span> group 组件的列表名优先显示文章的 <span class="code">`short_title`</span> 其次是 <span class="code">`title`</span>。</span><br><span class="line"></span><br><span class="line">&lt;!-- endtimeline --&gt;</span><br><span class="line"></span><br><span class="line">&#123;% endtimeline %&#125;</span><br></pre></td></tr></table></figure><button type="button" class="tab-to-top" aria-label="scroll to top"><i class="fas fa-arrow-up"></i></button></div><div class="tab-item-content" id="分栏-4"><div class="timeline blue"><div class='timeline-item headline'><div class='timeline-item-title'><div class='item-circle'><p>时间轴样式</p></div></div></div><div class='timeline-item'><div class='timeline-item-title'><div class='item-circle'><p>2020-07-24 <a href="https://github.com/volantis-x/hexo-theme-volantis/releases">2.6.6 -&gt; 3.0</a></p></div></div><div class='timeline-item-content'><ol><li>如果有 <code>hexo-lazyload-image</code> 插件，需要删除并重新安装最新版本，设置 <code>lazyload.isSPA: true</code>。</li><li>2.x 版本的 css 和 js 不适用于 3.x 版本，如果使用了 <code>use_cdn: true</code> 则需要删除。</li><li>2.x 版本的 fancybox 标签在 3.x 版本中被重命名为 gallery 。</li><li>2.x 版本的置顶 <code>top: true</code> 改为了 <code>pin: true</code>，并且同样适用于 <code>layout: page</code> 的页面。</li><li>如果使用了 <code>hexo-offline</code> 插件，建议卸载，3.0 版本默认开启了 pjax 服务。</li></ol></div></div><div class='timeline-item'><div class='timeline-item-title'><div class='item-circle'><p>2020-05-15 <a href="https://github.com/volantis-x/hexo-theme-volantis/releases/tag/2.6.6">2.6.3 -&gt; 2.6.6</a></p></div></div><div class='timeline-item-content'><p>不需要额外处理。</p></div></div><div class='timeline-item'><div class='timeline-item-title'><div class='item-circle'><p>2020-04-20 <a href="https://github.com/volantis-x/hexo-theme-volantis/releases/tag/2.6.3">2.6.2 -&gt; 2.6.3</a></p></div></div><div class='timeline-item-content'><ol><li>全局搜索 <code>seotitle</code> 并替换为 <code>seo_title</code>。</li><li>group 组件的索引规则有变，使用 group 组件的文章内，<code>group: group_name</code> 对应的组件名必须是 <code>group_name</code>。</li><li>group 组件的列表名优先显示文章的 <code>short_title</code> 其次是 <code>title</code>。</li></ol></div></div></div><button type="button" class="tab-to-top" aria-label="scroll to top"><i class="fas fa-arrow-up"></i></button></div></div></div><h2 id="2-10-链接卡片-link">2.10 链接卡片 link</h2><div class="tabs" id="分栏"><ul class="nav-tabs"><li class="tab active"><button type="button" data-href="#分栏-1">标签语法</button></li><li class="tab"><button type="button" data-href="#分栏-2">示例源码</button></li><li class="tab"><button type="button" data-href="#分栏-3">渲染演示</button></li></ul><div class="tab-contents"><div class="tab-item-content active" id="分栏-1"><figure class="highlight markdown"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">&#123;% link 标题, 链接, 图片链接（可选） %&#125;</span><br></pre></td></tr></table></figure><button type="button" class="tab-to-top" aria-label="scroll to top"><i class="fas fa-arrow-up"></i></button></div><div class="tab-item-content" id="分栏-2"><figure class="highlight markdown"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">&#123;% link 糖果屋教程贴, https://akilar.top/posts/615e2dec/, https://cdn.cbd.int/akilar-candyassets@1.0.36/image/siteicon/favicon.ico %&#125;</span><br></pre></td></tr></table></figure><button type="button" class="tab-to-top" aria-label="scroll to top"><i class="fas fa-arrow-up"></i></button></div><div class="tab-item-content" id="分栏-3"><div class="tag link"><a class="link-card" title="糖果屋教程贴" href="https://akilar.top/posts/615e2dec/"><div class="left"><img src="https://cdn.cbd.int/akilar-candyassets@1.0.36/image/siteicon/favicon.ico"/></div><div class="right"><p class="text">糖果屋教程贴</p><p class="url">https://akilar.top/posts/615e2dec/</p></div></a></div><button type="button" class="tab-to-top" aria-label="scroll to top"><i class="fas fa-arrow-up"></i></button></div></div></div><h2 id="2-11-按钮-btns">2.11 按钮 btns</h2><div class="tabs" id="分栏"><ul class="nav-tabs"><li class="tab active"><button type="button" data-href="#分栏-1">标签语法</button></li><li class="tab"><button type="button" data-href="#分栏-2">参数配置</button></li><li class="tab"><button type="button" data-href="#分栏-3">示例源码</button></li><li class="tab"><button type="button" data-href="#分栏-4">渲染演示</button></li></ul><div class="tab-contents"><div class="tab-item-content active" id="分栏-1"><figure class="highlight markdown"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">&#123;% btns 样式参数 %&#125;</span><br><span class="line">&#123;% cell 标题, 链接, 图片或者图标 %&#125;</span><br><span class="line">&#123;% cell 标题, 链接, 图片或者图标 %&#125;</span><br><span class="line">&#123;% endbtns %&#125;</span><br></pre></td></tr></table></figure><button type="button" class="tab-to-top" aria-label="scroll to top"><i class="fas fa-arrow-up"></i></button></div><div class="tab-item-content" id="分栏-2"><ol><li>圆角样式：rounded, circle</li><li>增加文字样式：可以在容器内增加 <code>&lt;b&gt;</code>标题<code>&lt;/b&gt;</code>和<code>&lt;p&gt;</code>描述文字<code>&lt;/p&gt;</code></li><li>布局方式：<br>默认为自动宽度，适合视野内只有一两个的情况。</li></ol><table><thead><tr><th>参数</th><th>含义</th></tr></thead><tbody><tr><td>wide</td><td>宽一点的按钮</td></tr><tr><td>fill</td><td>填充布局，自动铺满至少一行，多了会换行</td></tr><tr><td>center</td><td>居中，按钮之间是固定间距</td></tr><tr><td>around</td><td>居中分散</td></tr><tr><td>grid2</td><td>等宽最多2列，屏幕变窄会适当减少列数</td></tr><tr><td>grid3</td><td>等宽最多3列，屏幕变窄会适当减少列数</td></tr><tr><td>grid4</td><td>等宽最多4列，屏幕变窄会适当减少列数</td></tr><tr><td>grid5</td><td>等宽最多5列，屏幕变窄会适当减少列数</td></tr></tbody></table><button type="button" class="tab-to-top" aria-label="scroll to top"><i class="fas fa-arrow-up"></i></button></div><div class="tab-item-content" id="分栏-3"><p>1.如果需要显示类似「团队成员」之类的一组含有头像的链接</p><figure class="highlight markdown"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">&#123;% btns circle grid5 %&#125;</span><br><span class="line">&#123;% cell xaoxuu, https://xaoxuu.com, https://cdn.jsdelivr.net/gh/xaoxuu/cdn-assets/avatar/avatar.png %&#125;</span><br><span class="line">&#123;% cell xaoxuu, https://xaoxuu.com, https://cdn.jsdelivr.net/gh/xaoxuu/cdn-assets/avatar/avatar.png %&#125;</span><br><span class="line">&#123;% cell xaoxuu, https://xaoxuu.com, https://cdn.jsdelivr.net/gh/xaoxuu/cdn-assets/avatar/avatar.png %&#125;</span><br><span class="line">&#123;% cell xaoxuu, https://xaoxuu.com, https://cdn.jsdelivr.net/gh/xaoxuu/cdn-assets/avatar/avatar.png %&#125;</span><br><span class="line">&#123;% cell xaoxuu, https://xaoxuu.com, https://cdn.jsdelivr.net/gh/xaoxuu/cdn-assets/avatar/avatar.png %&#125;</span><br><span class="line">&#123;% endbtns %&#125;</span><br></pre></td></tr></table></figure><p>2.或者含有图标的按钮</p><figure class="highlight markdown"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">&#123;% btns rounded grid5 %&#125;</span><br><span class="line">&#123;% cell 下载源码, /, fas fa-download %&#125;</span><br><span class="line">&#123;% cell 查看文档, /, fas fa-book-open %&#125;</span><br><span class="line">&#123;% endbtns %&#125;</span><br></pre></td></tr></table></figure><p>3.圆形图标 + 标题 + 描述 + 图片 + 网格5列 + 居中</p><figure class="highlight markdown"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">&#123;% btns circle center grid5 %&#125;</span><br><span class="line"><span class="language-xml"><span class="tag">&lt;<span class="name">a</span> <span class="attr">href</span>=<span class="string">&#x27;https://apps.apple.com/cn/app/heart-mate-pro-hrm-utility/id1463348922?ls=1&#x27;</span>&gt;</span></span></span><br><span class="line">  <span class="language-xml"><span class="tag">&lt;<span class="name">i</span> <span class="attr">class</span>=<span class="string">&#x27;fab fa-apple&#x27;</span>&gt;</span></span><span class="language-xml"><span class="tag">&lt;/<span class="name">i</span>&gt;</span></span></span><br><span class="line">  <span class="language-xml"><span class="tag">&lt;<span class="name">b</span>&gt;</span></span>心率管家<span class="language-xml"><span class="tag">&lt;/<span class="name">b</span>&gt;</span></span></span><br><span class="line">  &#123;% p red, 专业版 %&#125;</span><br><span class="line">  <span class="language-xml"><span class="tag">&lt;<span class="name">img</span> <span class="attr">src</span>=<span class="string">&#x27;https://cdn.jsdelivr.net/gh/fomalhaut1998/cdn-assets/qrcode/heartmate_pro.png&#x27;</span>&gt;</span></span></span><br><span class="line"><span class="language-xml"><span class="tag">&lt;/<span class="name">a</span>&gt;</span></span></span><br><span class="line"><span class="language-xml"><span class="tag">&lt;<span class="name">a</span> <span class="attr">href</span>=<span class="string">&#x27;https://apps.apple.com/cn/app/heart-mate-lite-hrm-utility/id1475747930?ls=1&#x27;</span>&gt;</span></span></span><br><span class="line">  <span class="language-xml"><span class="tag">&lt;<span class="name">i</span> <span class="attr">class</span>=<span class="string">&#x27;fab fa-apple&#x27;</span>&gt;</span></span><span class="language-xml"><span class="tag">&lt;/<span class="name">i</span>&gt;</span></span></span><br><span class="line">  <span class="language-xml"><span class="tag">&lt;<span class="name">b</span>&gt;</span></span>心率管家<span class="language-xml"><span class="tag">&lt;/<span class="name">b</span>&gt;</span></span></span><br><span class="line">  &#123;% p green, 免费版 %&#125;</span><br><span class="line">  <span class="language-xml"><span class="tag">&lt;<span class="name">img</span> <span class="attr">src</span>=<span class="string">&#x27;https://cdn.jsdelivr.net/gh/fomalhaut1998/cdn-assets/qrcode/heartmate_lite.png&#x27;</span>&gt;</span></span></span><br><span class="line"><span class="language-xml"><span class="tag">&lt;/<span class="name">a</span>&gt;</span></span></span><br><span class="line">&#123;% endbtns %&#125;</span><br></pre></td></tr></table></figure><button type="button" class="tab-to-top" aria-label="scroll to top"><i class="fas fa-arrow-up"></i></button></div><div class="tab-item-content" id="分栏-4"><p>1.如果需要显示类似「团队成员」之类的一组含有头像的链接</p><div class="btns circle grid5">            <a class="button" href='https://xaoxuu.com' title='xaoxuu'><img src='https://cdn.jsdelivr.net/gh/xaoxuu/cdn-assets/avatar/avatar.png'>xaoxuu</a><a class="button" href='https://xaoxuu.com' title='xaoxuu'><img src='https://cdn.jsdelivr.net/gh/xaoxuu/cdn-assets/avatar/avatar.png'>xaoxuu</a><a class="button" href='https://xaoxuu.com' title='xaoxuu'><img src='https://cdn.jsdelivr.net/gh/xaoxuu/cdn-assets/avatar/avatar.png'>xaoxuu</a><a class="button" href='https://xaoxuu.com' title='xaoxuu'><img src='https://cdn.jsdelivr.net/gh/xaoxuu/cdn-assets/avatar/avatar.png'>xaoxuu</a><a class="button" href='https://xaoxuu.com' title='xaoxuu'><img src='https://cdn.jsdelivr.net/gh/xaoxuu/cdn-assets/avatar/avatar.png'>xaoxuu</a>          </div>2.或者含有图标的按钮<div class="btns rounded grid5">            <a class="button" href='/' title='下载源码'><i class='fas fa-download'></i>下载源码</a><a class="button" href='/' title='查看文档'><i class='fas fa-book-open'></i>查看文档</a>          </div>3.圆形图标 + 标题 + 描述 + 图片 + 网格5列 + 居中<div class="btns circle center grid5">            <a href='https://apps.apple.com/cn/app/heart-mate-pro-hrm-utility/id1463348922?ls=1'>  <i class='fab fa-apple'></i>  <b>心率管家</b>  <p class='p red'>专业版</p>  <img src='https://cdn.jsdelivr.net/gh/fomalhaut1998/cdn-assets/qrcode/heartmate_pro.png'></a><a href='https://apps.apple.com/cn/app/heart-mate-lite-hrm-utility/id1475747930?ls=1'>  <i class='fab fa-apple'></i>  <b>心率管家</b>  <p class='p green'>免费版</p>  <img src='https://cdn.jsdelivr.net/gh/fomalhaut1998/cdn-assets/qrcode/heartmate_lite.png'></a>          </div><button type="button" class="tab-to-top" aria-label="scroll to top"><i class="fas fa-arrow-up"></i></button></div></div></div><h2 id="2-12-github卡片-ghcard">2.12 github卡片 ghcard</h2><div class="tabs" id="分栏"><ul class="nav-tabs"><li class="tab active"><button type="button" data-href="#分栏-1">标签语法</button></li><li class="tab"><button type="button" data-href="#分栏-2">参数配置</button></li><li class="tab"><button type="button" data-href="#分栏-3">示例源码</button></li><li class="tab"><button type="button" data-href="#分栏-4">渲染演示</button></li></ul><div class="tab-contents"><div class="tab-item-content active" id="分栏-1"><figure class="highlight markdown"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">&#123;% ghcard 用户名, 其它参数（可选） %&#125;</span><br><span class="line">&#123;% ghcard 用户名/仓库, 其它参数（可选） %&#125;</span><br></pre></td></tr></table></figure><button type="button" class="tab-to-top" aria-label="scroll to top"><i class="fas fa-arrow-up"></i></button></div><div class="tab-item-content" id="分栏-2"><p>使用<code>,</code>分割各个参数。写法为：<code>参数名=参数值</code><br>以下只写几个常用参数值。</p><table><thead><tr><th><strong>参数名</strong></th><th>取值</th><th>释义</th></tr></thead><tbody><tr><td>hide</td><td>stars,commits,prs,issues,contribs</td><td>隐藏指定统计</td></tr><tr><td>count_private</td><td>true</td><td>将私人项目贡献添加到总提交计数中</td></tr><tr><td>show_icons</td><td>true</td><td>显示图标</td></tr><tr><td>theme</td><td>查阅:<a href="https://github.com/anuraghazra/github-readme-stats/blob/master/themes/README.md">Available Themes</a></td><td>主题</td></tr></tbody></table><button type="button" class="tab-to-top" aria-label="scroll to top"><i class="fas fa-arrow-up"></i></button></div><div class="tab-item-content" id="分栏-3"><p>1.用户信息卡片</p><figure class="highlight markdown"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">| &#123;% ghcard fomalhaut1998 %&#125; | &#123;% ghcard fomalhaut1998, theme=vue %&#125; |</span><br><span class="line">| -- | -- |</span><br><span class="line">| &#123;% ghcard fomalhaut1998, theme=buefy %&#125; | &#123;% ghcard fomalhaut1998, theme=solarized-light %&#125; |</span><br><span class="line">| &#123;% ghcard fomalhaut1998, theme=onedark %&#125; | &#123;% ghcard fomalhaut1998, theme=solarized-dark %&#125; |</span><br><span class="line">| &#123;% ghcard fomalhaut1998, theme=algolia %&#125; | &#123;% ghcard fomalhaut1998, theme=calm %&#125; |</span><br></pre></td></tr></table></figure><p>2.仓库信息卡片</p><figure class="highlight markdown"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">| &#123;% ghcard volantis-x/hexo-theme-volantis %&#125; | &#123;% ghcard volantis-x/hexo-theme-volantis, theme=vue %&#125; |</span><br><span class="line">| -- | -- |</span><br><span class="line">| &#123;% ghcard volantis-x/hexo-theme-volantis, theme=buefy %&#125; | &#123;% ghcard volantis-x/hexo-theme-volantis, theme=solarized-light %&#125; |</span><br><span class="line">| &#123;% ghcard volantis-x/hexo-theme-volantis, theme=onedark %&#125; | &#123;% ghcard volantis-x/hexo-theme-volantis, theme=solarized-dark %&#125; |</span><br><span class="line">| &#123;% ghcard volantis-x/hexo-theme-volantis, theme=algolia %&#125; | &#123;% ghcard volantis-x/hexo-theme-volantis, theme=calm %&#125; |</span><br></pre></td></tr></table></figure><button type="button" class="tab-to-top" aria-label="scroll to top"><i class="fas fa-arrow-up"></i></button></div><div class="tab-item-content" id="分栏-4"><p>1.用户信息卡片</p><table><thead><tr><th><a class="ghcard" rel="external nofollow noopener noreferrer" href="https://github.com/fomalhaut1998"><img src="https://github-readme-stats.vercel.app/api/?username=fomalhaut1998&show_owner=true"/></a></th><th><a class="ghcard" rel="external nofollow noopener noreferrer" href="https://github.com/fomalhaut1998"><img src="https://github-readme-stats.vercel.app/api/?username=fomalhaut1998&theme=vue&show_owner=true"/></a></th></tr></thead><tbody><tr><td><a class="ghcard" rel="external nofollow noopener noreferrer" href="https://github.com/fomalhaut1998"><img src="https://github-readme-stats.vercel.app/api/?username=fomalhaut1998&theme=buefy&show_owner=true"/></a></td><td><a class="ghcard" rel="external nofollow noopener noreferrer" href="https://github.com/fomalhaut1998"><img src="https://github-readme-stats.vercel.app/api/?username=fomalhaut1998&theme=solarized-light&show_owner=true"/></a></td></tr><tr><td><a class="ghcard" rel="external nofollow noopener noreferrer" href="https://github.com/fomalhaut1998"><img src="https://github-readme-stats.vercel.app/api/?username=fomalhaut1998&theme=onedark&show_owner=true"/></a></td><td><a class="ghcard" rel="external nofollow noopener noreferrer" href="https://github.com/fomalhaut1998"><img src="https://github-readme-stats.vercel.app/api/?username=fomalhaut1998&theme=solarized-dark&show_owner=true"/></a></td></tr><tr><td><a class="ghcard" rel="external nofollow noopener noreferrer" href="https://github.com/fomalhaut1998"><img src="https://github-readme-stats.vercel.app/api/?username=fomalhaut1998&theme=algolia&show_owner=true"/></a></td><td><a class="ghcard" rel="external nofollow noopener noreferrer" href="https://github.com/fomalhaut1998"><img src="https://github-readme-stats.vercel.app/api/?username=fomalhaut1998&theme=calm&show_owner=true"/></a></td></tr></tbody></table><p>2.仓库信息卡片</p><table><thead><tr><th><a class="ghcard" rel="external nofollow noopener noreferrer" href="https://github.com/volantis-x/hexo-theme-volantis"><img src="https://github-readme-stats.vercel.app/api/pin/?username=volantis-x&repo=hexo-theme-volantis&show_owner=true"/></a></th><th><a class="ghcard" rel="external nofollow noopener noreferrer" href="https://github.com/volantis-x/hexo-theme-volantis"><img src="https://github-readme-stats.vercel.app/api/pin/?username=volantis-x&repo=hexo-theme-volantis&theme=vue&show_owner=true"/></a></th></tr></thead><tbody><tr><td><a class="ghcard" rel="external nofollow noopener noreferrer" href="https://github.com/volantis-x/hexo-theme-volantis"><img src="https://github-readme-stats.vercel.app/api/pin/?username=volantis-x&repo=hexo-theme-volantis&theme=buefy&show_owner=true"/></a></td><td><a class="ghcard" rel="external nofollow noopener noreferrer" href="https://github.com/volantis-x/hexo-theme-volantis"><img src="https://github-readme-stats.vercel.app/api/pin/?username=volantis-x&repo=hexo-theme-volantis&theme=solarized-light&show_owner=true"/></a></td></tr><tr><td><a class="ghcard" rel="external nofollow noopener noreferrer" href="https://github.com/volantis-x/hexo-theme-volantis"><img src="https://github-readme-stats.vercel.app/api/pin/?username=volantis-x&repo=hexo-theme-volantis&theme=onedark&show_owner=true"/></a></td><td><a class="ghcard" rel="external nofollow noopener noreferrer" href="https://github.com/volantis-x/hexo-theme-volantis"><img src="https://github-readme-stats.vercel.app/api/pin/?username=volantis-x&repo=hexo-theme-volantis&theme=solarized-dark&show_owner=true"/></a></td></tr><tr><td><a class="ghcard" rel="external nofollow noopener noreferrer" href="https://github.com/volantis-x/hexo-theme-volantis"><img src="https://github-readme-stats.vercel.app/api/pin/?username=volantis-x&repo=hexo-theme-volantis&theme=algolia&show_owner=true"/></a></td><td><a class="ghcard" rel="external nofollow noopener noreferrer" href="https://github.com/volantis-x/hexo-theme-volantis"><img src="https://github-readme-stats.vercel.app/api/pin/?username=volantis-x&repo=hexo-theme-volantis&theme=calm&show_owner=true"/></a></td></tr></tbody></table><button type="button" class="tab-to-top" aria-label="scroll to top"><i class="fas fa-arrow-up"></i></button></div></div></div><h2 id="2-13-github徽标-ghbdage">2.13 github徽标 ghbdage</h2><div class="tabs" id="分栏"><ul class="nav-tabs"><li class="tab active"><button type="button" data-href="#分栏-1">标签语法</button></li><li class="tab"><button type="button" data-href="#分栏-2">配置参数</button></li><li class="tab"><button type="button" data-href="#分栏-3">示例源码</button></li><li class="tab"><button type="button" data-href="#分栏-4">渲染演示</button></li></ul><div class="tab-contents"><div class="tab-item-content active" id="分栏-1"><figure class="highlight markdown"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">&#123;% bdage [right],[left],[logo]||[color],[link],[title]||[option] %&#125;</span><br></pre></td></tr></table></figure><button type="button" class="tab-to-top" aria-label="scroll to top"><i class="fas fa-arrow-up"></i></button></div><div class="tab-item-content" id="分栏-2"><ol><li><code>left</code>：徽标左边的信息，必选参数。</li><li><code>right</code>: 徽标右边的信息，必选参数，</li><li><code>logo</code>：徽标图标，图标名称详见<a href="https://simpleicons.org/">simpleicons</a>，可选参数。</li><li><code>color</code>：徽标右边的颜色，可选参数。</li><li><code>link</code>：指向的链接，可选参数。</li><li><code>title</code>：徽标的额外信息，可选参数。主要用于优化SEO，但<code>object</code>标签不会像<code>a</code>标签一样在鼠标悬停显示<code>title</code>信息。</li><li><code>option</code>：自定义参数，支持<a href="https://shields.io/">shields.io</a>的全部API参数支持，具体参数可以参看上文中的拓展写法示例。形式为<code>name1=value2&amp;name2=value2</code>。</li></ol><button type="button" class="tab-to-top" aria-label="scroll to top"><i class="fas fa-arrow-up"></i></button></div><div class="tab-item-content" id="分栏-3"><p>1.基本参数,定义徽标左右文字和图标</p><figure class="highlight markdown"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">&#123;% bdage Theme,Butterfly %&#125;</span><br><span class="line">&#123;% bdage Frame,Hexo,hexo %&#125;</span><br></pre></td></tr></table></figure><p>2.信息参数，定义徽标右侧内容背景色，指向链接</p><figure class="highlight markdown"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">&#123;% bdage CDN,JsDelivr,jsDelivr||abcdef,https://metroui.org.ua/index.html,本站使用JsDelivr为静态资源提供CDN加速 %&#125;</span><br><span class="line">//如果是跨顺序省略可选参数，仍然需要写个逗号,用作分割</span><br><span class="line">&#123;% bdage Source,GitHub,GitHub||,https://github.com/ %&#125;</span><br></pre></td></tr></table></figure><p>3.拓展参数，支持shields的API的全部参数内容</p><figure class="highlight markdown"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">&#123;% bdage Hosted,Vercel,Vercel||brightgreen,https://vercel.com/,本站采用双线部署，默认线路托管于Vercel||style=social&amp;logoWidth=20 %&#125;</span><br><span class="line">//如果是跨顺序省略可选参数组，仍然需要写双竖线||用作分割</span><br><span class="line">&#123;% bdage Hosted,Vercel,Vercel||||style=social&amp;logoWidth=20&amp;logoColor=violet %&#125;</span><br></pre></td></tr></table></figure><button type="button" class="tab-to-top" aria-label="scroll to top"><i class="fas fa-arrow-up"></i></button></div><div class="tab-item-content" id="分栏-4"><p>1.基本参数,定义徽标左右文字和图标</p><p><object class="ghbdage" style="margin-inline:5px" title="" standby="loading..." data="https://img.shields.io/badge/Butterfly-Theme-orange?logo=&color=orange&link=&"></object><br><object class="ghbdage" style="margin-inline:5px" title="" standby="loading..." data="https://img.shields.io/badge/Hexo-Frame-orange?logo=hexo&color=orange&link=&"></object></p><p>2.信息参数，定义徽标右侧内容背景色，指向链接</p><p><object class="ghbdage" style="margin-inline:5px" title="本站使用JsDelivr为静态资源提供CDN加速" standby="loading..." data="https://img.shields.io/badge/JsDelivr-CDN-orange?logo=jsDelivr&color=abcdef&link=https://metroui.org.ua/index.html&"></object><br>//如果是跨顺序省略可选参数，仍然需要写个逗号,用作分割<br><object class="ghbdage" style="margin-inline:5px" title="" standby="loading..." data="https://img.shields.io/badge/GitHub-Source-orange?logo=GitHub&color=orange&link=https://github.com/&"></object></p><p>3.拓展参数，支持shields的API的全部参数内容</p><p><object class="ghbdage" style="margin-inline:5px" title="本站采用双线部署，默认线路托管于Vercel" standby="loading..." data="https://img.shields.io/badge/Vercel-Hosted-orange?logo=Vercel&color=brightgreen&link=https://vercel.com/&style=social&logoWidth=20"></object><br>//如果是跨顺序省略可选参数组，仍然需要写双竖线||用作分割<br><object class="ghbdage" style="margin-inline:5px" title="" standby="loading..." data="https://img.shields.io/badge/Vercel-Hosted-orange?logo=Vercel&color=orange&link=&style=social&logoWidth=20&logoColor=violet"></object></p><button type="button" class="tab-to-top" aria-label="scroll to top"><i class="fas fa-arrow-up"></i></button></div></div></div><h2 id="2-14-网站卡片-sites">2.14 网站卡片 sites</h2><div class="tabs" id="分栏"><ul class="nav-tabs"><li class="tab active"><button type="button" data-href="#分栏-1">标签语法</button></li><li class="tab"><button type="button" data-href="#分栏-2">示例源码</button></li><li class="tab"><button type="button" data-href="#分栏-3">渲染演示</button></li></ul><div class="tab-contents"><div class="tab-item-content active" id="分栏-1"><figure class="highlight markdown"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">&#123;% sitegroup %&#125;</span><br><span class="line">&#123;% site 标题, url=链接, screenshot=截图链接, avatar=头像链接（可选）, description=描述（可选） %&#125;</span><br><span class="line">&#123;% site 标题, url=链接, screenshot=截图链接, avatar=头像链接（可选）, description=描述（可选） %&#125;</span><br><span class="line">&#123;% endsitegroup %&#125;</span><br></pre></td></tr></table></figure><button type="button" class="tab-to-top" aria-label="scroll to top"><i class="fas fa-arrow-up"></i></button></div><div class="tab-item-content" id="分栏-2"><figure class="highlight markdown"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">&#123;% sitegroup %&#125;</span><br><span class="line">&#123;% site xaoxuu, url=https://xaoxuu.com, screenshot=https://i.loli.net/2020/08/21/VuSwWZ1xAeUHEBC.jpg, avatar=https://cdn.jsdelivr.net/gh/fomalhaut1998/cdn-assets/avatar/avatar.png, description=简约风格 %&#125;</span><br><span class="line">&#123;% site inkss, url=https://inkss.cn, screenshot=https://i.loli.net/2020/08/21/Vzbu3i8fXs6Nh5Y.jpg, avatar=https://cdn.jsdelivr.net/gh/inkss/common@master/static/web/avatar.jpg, description=这是一段关于这个网站的描述文字 %&#125;</span><br><span class="line">&#123;% site MHuiG, url=https://blog.mhuig.top, screenshot=https://i.loli.net/2020/08/22/d24zpPlhLYWX6D1.png, avatar=https://cdn.jsdelivr.net/gh/MHuiG/imgbed@master/data/p.png, description=这是一段关于这个网站的描述文字 %&#125;</span><br><span class="line">&#123;% site Colsrch, url=https://colsrch.top, screenshot=https://i.loli.net/2020/08/22/dFRWXm52OVu8qfK.png, avatar=https://cdn.jsdelivr.net/gh/Colsrch/images/Colsrch/avatar.jpg, description=这是一段关于这个网站的描述文字 %&#125;</span><br><span class="line">&#123;% site Linhk1606, url=https://linhk1606.github.io, screenshot=https://i.loli.net/2020/08/21/3PmGLCKicnfow1x.png, avatar=https://i.loli.net/2020/02/09/PN7I5RJfFtA93r2.png, description=这是一段关于这个网站的描述文字 %&#125;</span><br><span class="line">&#123;% endsitegroup %&#125;</span><br></pre></td></tr></table></figure><button type="button" class="tab-to-top" aria-label="scroll to top"><i class="fas fa-arrow-up"></i></button></div><div class="tab-item-content" id="分栏-3"><div class="site-card-group"><a class="site-card" href="https://fomalhaut1998.com"><div class="img"><img src="https://i.loli.net/2020/08/21/VuSwWZ1xAeUHEBC.jpg"/></div><div class="info"><img src="https://cdn.jsdelivr.net/gh/fomalhaut1998/cdn-assets/avatar/avatar.png"/><span class="title">fomalhaut1998</span><span class="desc">简约风格</span></div></a><a class="site-card" href="https://inkss.cn"><div class="img"><img src="https://i.loli.net/2020/08/21/Vzbu3i8fXs6Nh5Y.jpg"/></div><div class="info"><img src="https://cdn.jsdelivr.net/gh/inkss/common@master/static/web/avatar.jpg"/><span class="title">inkss</span><span class="desc">这是一段关于这个网站的描述文字</span></div></a><a class="site-card" href="https://blog.mhuig.top"><div class="img"><img src="https://i.loli.net/2020/08/22/d24zpPlhLYWX6D1.png"/></div><div class="info"><img src="https://cdn.jsdelivr.net/gh/MHuiG/imgbed@master/data/p.png"/><span class="title">MHuiG</span><span class="desc">这是一段关于这个网站的描述文字</span></div></a><a class="site-card" href="https://colsrch.top"><div class="img"><img src="https://i.loli.net/2020/08/22/dFRWXm52OVu8qfK.png"/></div><div class="info"><img src="https://cdn.jsdelivr.net/gh/Colsrch/images/Colsrch/avatar.jpg"/><span class="title">Colsrch</span><span class="desc">这是一段关于这个网站的描述文字</span></div></a><a class="site-card" href="https://linhk1606.github.io"><div class="img"><img src="https://i.loli.net/2020/08/21/3PmGLCKicnfow1x.png"/></div><div class="info"><img src="https://i.loli.net/2020/02/09/PN7I5RJfFtA93r2.png"/><span class="title">Linhk1606</span><span class="desc">这是一段关于这个网站的描述文字</span></div></a></div><button type="button" class="tab-to-top" aria-label="scroll to top"><i class="fas fa-arrow-up"></i></button></div></div></div><h2 id="2-15-行内图片-inlineimage">2.15 行内图片 inlineimage</h2><div class="tabs" id="分栏"><ul class="nav-tabs"><li class="tab active"><button type="button" data-href="#分栏-1">标签语法</button></li><li class="tab"><button type="button" data-href="#分栏-2">参数配置</button></li><li class="tab"><button type="button" data-href="#分栏-3">示例源码</button></li><li class="tab"><button type="button" data-href="#分栏-4">渲染演示</button></li></ul><div class="tab-contents"><div class="tab-item-content active" id="分栏-1"><figure class="highlight markdown"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">&#123;% inlineimage 图片链接, height=高度（可选） %&#125;</span><br></pre></td></tr></table></figure><button type="button" class="tab-to-top" aria-label="scroll to top"><i class="fas fa-arrow-up"></i></button></div><div class="tab-item-content" id="分栏-2"><ol><li><code>高度</code>：height=20px</li></ol><button type="button" class="tab-to-top" aria-label="scroll to top"><i class="fas fa-arrow-up"></i></button></div><div class="tab-item-content" id="分栏-3"><figure class="highlight markdown"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">这是 &#123;% inlineimage https://cdn.jsdelivr.net/gh/volantis-x/cdn-emoji/aru-l/0000.gif %&#125; 一段话。</span><br><span class="line"></span><br><span class="line">这又是 &#123;% inlineimage https://cdn.jsdelivr.net/gh/volantis-x/cdn-emoji/aru-l/5150.gif, height=40px %&#125; 一段话。</span><br></pre></td></tr></table></figure><button type="button" class="tab-to-top" aria-label="scroll to top"><i class="fas fa-arrow-up"></i></button></div><div class="tab-item-content" id="分栏-4"><p>这是 <img no-lazy class="inline" src="https://cdn.jsdelivr.net/gh/volantis-x/cdn-emoji/aru-l/0000.gif" style="height:1.5em"/> 一段话。</p><p>这又是 <img no-lazy class="inline" src="https://cdn.jsdelivr.net/gh/volantis-x/cdn-emoji/aru-l/5150.gif" style="height:40px;"/> 一段话。</p><button type="button" class="tab-to-top" aria-label="scroll to top"><i class="fas fa-arrow-up"></i></button></div></div></div><h2 id="2-16-单张图片-image">2.16 单张图片 image</h2><div class="tabs" id="分栏"><ul class="nav-tabs"><li class="tab active"><button type="button" data-href="#分栏-1">标签语法</button></li><li class="tab"><button type="button" data-href="#分栏-2">参数配置</button></li><li class="tab"><button type="button" data-href="#分栏-3">示例源码</button></li><li class="tab"><button type="button" data-href="#分栏-4">渲染演示</button></li></ul><div class="tab-contents"><div class="tab-item-content active" id="分栏-1"><figure class="highlight markdown"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">&#123;% image 链接, width=宽度（可选）, height=高度（可选）, alt=描述（可选）, bg=占位颜色（可选） %&#125;</span><br></pre></td></tr></table></figure><button type="button" class="tab-to-top" aria-label="scroll to top"><i class="fas fa-arrow-up"></i></button></div><div class="tab-item-content" id="分栏-2"><ol><li>图片宽度高度：width=300px, height=32px</li><li>图片描述：alt=图片描述（butterfly需要在主题配置文件中开启图片描述）</li><li>占位背景色：bg=#f2f2f2</li></ol><button type="button" class="tab-to-top" aria-label="scroll to top"><i class="fas fa-arrow-up"></i></button></div><div class="tab-item-content" id="分栏-3"><p>1.添加描述：</p><figure class="highlight markdown"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">&#123;% image https://cdn.jsdelivr.net/gh/volantis-x/cdn-wallpaper-minimalist/2020/025.jpg, alt=每天下课回宿舍的路，没有什么故事。 %&#125;</span><br></pre></td></tr></table></figure><p>2.指定宽度</p><figure class="highlight markdown"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">&#123;% image https://cdn.jsdelivr.net/gh/volantis-x/cdn-wallpaper-minimalist/2020/025.jpg, width=400px %&#125;</span><br></pre></td></tr></table></figure><p>3.指定宽度并添加描述：</p><figure class="highlight markdown"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">&#123;% image https://cdn.jsdelivr.net/gh/volantis-x/cdn-wallpaper-minimalist/2020/025.jpg, width=400px, alt=每天下课回宿舍的路，没有什么故事。 %&#125;</span><br></pre></td></tr></table></figure><p>4.设置占位背景色：</p><figure class="highlight markdown"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">&#123;% image https://cdn.jsdelivr.net/gh/volantis-x/cdn-wallpaper-minimalist/2020/025.jpg, width=400px, bg=#1D0C04, alt=优化不同宽度浏览的观感 %&#125;</span><br></pre></td></tr></table></figure><button type="button" class="tab-to-top" aria-label="scroll to top"><i class="fas fa-arrow-up"></i></button></div><div class="tab-item-content" id="分栏-4"><p>1.添加描述：</p><div class="img-wrap"><div class="img-bg"><img class="img" src="https://cdn.jsdelivr.net/gh/volantis-x/cdn-wallpaper-minimalist/2020/025.jpg" alt="每天下课回宿舍的路，没有什么故事。"/></div><span class="image-caption">每天下课回宿舍的路，没有什么故事。</span></div>2..指定宽度<div class="img-wrap"><div class="img-bg"><img class="img" src="https://cdn.jsdelivr.net/gh/volantis-x/cdn-wallpaper-minimalist/2020/025.jpg" style="width:400px;"/></div></div>3.指定宽度并添加描述：<div class="img-wrap"><div class="img-bg"><img class="img" src="https://cdn.jsdelivr.net/gh/volantis-x/cdn-wallpaper-minimalist/2020/025.jpg" alt="每天下课回宿舍的路，没有什么故事。" style="width:400px;"/></div><span class="image-caption">每天下课回宿舍的路，没有什么故事。</span></div>4.设置占位背景色：<div class="img-wrap"><div class="img-bg" style="background:#1D0C04"><img class="img" src="https://cdn.jsdelivr.net/gh/volantis-x/cdn-wallpaper-minimalist/2020/025.jpg" alt="优化不同宽度浏览的观感" style="width:400px;"/></div><span class="image-caption">优化不同宽度浏览的观感</span></div><button type="button" class="tab-to-top" aria-label="scroll to top"><i class="fas fa-arrow-up"></i></button></div></div></div><h2 id="2-17-音频-audio">2.17 音频 audio</h2><div class="tabs" id="分栏"><ul class="nav-tabs"><li class="tab active"><button type="button" data-href="#分栏-1">标签语法</button></li><li class="tab"><button type="button" data-href="#分栏-2">示例源码</button></li><li class="tab"><button type="button" data-href="#分栏-3">渲染演示</button></li></ul><div class="tab-contents"><div class="tab-item-content active" id="分栏-1"><figure class="highlight markdown"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">&#123;% audio 音频链接 %&#125;</span><br></pre></td></tr></table></figure><button type="button" class="tab-to-top" aria-label="scroll to top"><i class="fas fa-arrow-up"></i></button></div><div class="tab-item-content" id="分栏-2"><figure class="highlight markdown"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">&#123;% audio https://github.com/volantis-x/volantis-docs/releases/download/assets/Lumia1020.mp3 %&#125;</span><br></pre></td></tr></table></figure><button type="button" class="tab-to-top" aria-label="scroll to top"><i class="fas fa-arrow-up"></i></button></div><div class="tab-item-content" id="分栏-3"><div class="audio"><audio controls preload><source src='https://github.com/volantis-x/volantis-docs/releases/download/assets/Lumia1020.mp3' type='audio/mp3'>Your browser does not support the audio tag.</audio></div><button type="button" class="tab-to-top" aria-label="scroll to top"><i class="fas fa-arrow-up"></i></button></div></div></div><h2 id="2-18-视频-video">2.18 视频 video</h2><div class="tabs" id="分栏"><ul class="nav-tabs"><li class="tab active"><button type="button" data-href="#分栏-1">标签语法</button></li><li class="tab"><button type="button" data-href="#分栏-2">标签语法</button></li><li class="tab"><button type="button" data-href="#分栏-3">示例源码</button></li><li class="tab"><button type="button" data-href="#分栏-4">渲染演示</button></li></ul><div class="tab-contents"><div class="tab-item-content active" id="分栏-1"><figure class="highlight markdown"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">&#123;% video 视频链接 %&#125;</span><br></pre></td></tr></table></figure><button type="button" class="tab-to-top" aria-label="scroll to top"><i class="fas fa-arrow-up"></i></button></div><div class="tab-item-content" id="分栏-2"><ol><li><code>对齐方向</code>：left, center, right</li><li><code>列数</code>：逗号后面直接写列数，支持 1 ～ 4 列。</li></ol><button type="button" class="tab-to-top" aria-label="scroll to top"><i class="fas fa-arrow-up"></i></button></div><div class="tab-item-content" id="分栏-3"><p>1.100%宽度</p><figure class="highlight markdown"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">&#123;% video https://github.com/volantis-x/volantis-docs/releases/download/assets/IMG<span class="emphasis">_0341.mov %&#125;</span></span><br></pre></td></tr></table></figure><p>2.50%宽度</p><figure class="highlight markdown"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">&#123;% videos, 2 %&#125;</span><br><span class="line">&#123;% video https://github.com/volantis-x/volantis-docs/releases/download/assets/IMG<span class="emphasis">_0341.mov %&#125;</span></span><br><span class="line"><span class="emphasis">&#123;% video https://github.com/volantis-x/volantis-docs/releases/download/assets/IMG_</span>0341.mov %&#125;</span><br><span class="line">&#123;% video https://github.com/volantis-x/volantis-docs/releases/download/assets/IMG<span class="emphasis">_0341.mov %&#125;</span></span><br><span class="line"><span class="emphasis">&#123;% video https://github.com/volantis-x/volantis-docs/releases/download/assets/IMG_</span>0341.mov %&#125;</span><br><span class="line">&#123;% endvideos %&#125;</span><br></pre></td></tr></table></figure><p>3.25%宽度</p><figure class="highlight markdown"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">&#123;% videos, 4 %&#125;</span><br><span class="line">&#123;% video https://github.com/volantis-x/volantis-docs/releases/download/assets/IMG<span class="emphasis">_0341.mov %&#125;</span></span><br><span class="line"><span class="emphasis">&#123;% video https://github.com/volantis-x/volantis-docs/releases/download/assets/IMG_</span>0341.mov %&#125;</span><br><span class="line">&#123;% video https://github.com/volantis-x/volantis-docs/releases/download/assets/IMG<span class="emphasis">_0341.mov %&#125;</span></span><br><span class="line"><span class="emphasis">&#123;% video https://github.com/volantis-x/volantis-docs/releases/download/assets/IMG_</span>0341.mov %&#125;</span><br><span class="line">&#123;% video https://github.com/volantis-x/volantis-docs/releases/download/assets/IMG<span class="emphasis">_0341.mov %&#125;</span></span><br><span class="line"><span class="emphasis">&#123;% video https://github.com/volantis-x/volantis-docs/releases/download/assets/IMG_</span>0341.mov %&#125;</span><br><span class="line">&#123;% video https://github.com/volantis-x/volantis-docs/releases/download/assets/IMG<span class="emphasis">_0341.mov %&#125;</span></span><br><span class="line"><span class="emphasis">&#123;% video https://github.com/volantis-x/volantis-docs/releases/download/assets/IMG_</span>0341.mov %&#125;</span><br><span class="line">&#123;% endvideos %&#125;</span><br></pre></td></tr></table></figure><button type="button" class="tab-to-top" aria-label="scroll to top"><i class="fas fa-arrow-up"></i></button></div><div class="tab-item-content" id="分栏-4"><p>1.100%宽度</p><div class="video"><video controls preload><source src='https://github.com/volantis-x/volantis-docs/releases/download/assets/IMG_0341.mov' type='video/mp4'>Your browser does not support the video tag.</video></div>2.50%宽度<div class="videos" col='2'><div class="video"><video controls preload><source src='https://github.com/volantis-x/volantis-docs/releases/download/assets/IMG_0341.mov' type='video/mp4'>Your browser does not support the video tag.</video></div><div class="video"><video controls preload><source src='https://github.com/volantis-x/volantis-docs/releases/download/assets/IMG_0341.mov' type='video/mp4'>Your browser does not support the video tag.</video></div><div class="video"><video controls preload><source src='https://github.com/volantis-x/volantis-docs/releases/download/assets/IMG_0341.mov' type='video/mp4'>Your browser does not support the video tag.</video></div><div class="video"><video controls preload><source src='https://github.com/volantis-x/volantis-docs/releases/download/assets/IMG_0341.mov' type='video/mp4'>Your browser does not support the video tag.</video></div></div>3.25%宽度<div class="videos" col='4'><div class="video"><video controls preload><source src='https://github.com/volantis-x/volantis-docs/releases/download/assets/IMG_0341.mov' type='video/mp4'>Your browser does not support the video tag.</video></div><div class="video"><video controls preload><source src='https://github.com/volantis-x/volantis-docs/releases/download/assets/IMG_0341.mov' type='video/mp4'>Your browser does not support the video tag.</video></div><div class="video"><video controls preload><source src='https://github.com/volantis-x/volantis-docs/releases/download/assets/IMG_0341.mov' type='video/mp4'>Your browser does not support the video tag.</video></div><div class="video"><video controls preload><source src='https://github.com/volantis-x/volantis-docs/releases/download/assets/IMG_0341.mov' type='video/mp4'>Your browser does not support the video tag.</video></div><div class="video"><video controls preload><source src='https://github.com/volantis-x/volantis-docs/releases/download/assets/IMG_0341.mov' type='video/mp4'>Your browser does not support the video tag.</video></div><div class="video"><video controls preload><source src='https://github.com/volantis-x/volantis-docs/releases/download/assets/IMG_0341.mov' type='video/mp4'>Your browser does not support the video tag.</video></div><div class="video"><video controls preload><source src='https://github.com/volantis-x/volantis-docs/releases/download/assets/IMG_0341.mov' type='video/mp4'>Your browser does not support the video tag.</video></div><div class="video"><video controls preload><source src='https://github.com/volantis-x/volantis-docs/releases/download/assets/IMG_0341.mov' type='video/mp4'>Your browser does not support the video tag.</video></div></div><button type="button" class="tab-to-top" aria-label="scroll to top"><i class="fas fa-arrow-up"></i></button></div></div></div><h2 id="2-19-相册-gallery">2.19 相册 gallery</h2><div class="tabs" id="分栏"><ul class="nav-tabs"><li class="tab active"><button type="button" data-href="#分栏-1">标签语法</button></li><li class="tab"><button type="button" data-href="#分栏-2">参数配置</button></li><li class="tab"><button type="button" data-href="#分栏-3">示例源码</button></li><li class="tab"><button type="button" data-href="#分栏-4">渲染演示</button></li></ul><div class="tab-contents"><div class="tab-item-content active" id="分栏-1"><p>1.gallerygroup 相册图库</p><figure class="highlight markdown"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="language-xml"><span class="tag">&lt;<span class="name">div</span> <span class="attr">class</span>=<span class="string">&quot;gallery-group-main&quot;</span>&gt;</span></span></span><br><span class="line">&#123;% galleryGroup name description link img-url %&#125;</span><br><span class="line">&#123;% galleryGroup name description link img-url %&#125;</span><br><span class="line">&#123;% galleryGroup name description link img-url %&#125;</span><br><span class="line"><span class="language-xml"><span class="tag">&lt;/<span class="name">div</span>&gt;</span></span></span><br></pre></td></tr></table></figure><p>2.gallery 相册</p><figure class="highlight markdown"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">&#123;% gallery %&#125;</span><br><span class="line">markdown 圖片格式</span><br><span class="line">&#123;% endgallery %&#125;</span><br></pre></td></tr></table></figure><button type="button" class="tab-to-top" aria-label="scroll to top"><i class="fas fa-arrow-up"></i></button></div><div class="tab-item-content" id="分栏-2"><ul><li>gallerygroup 相册图库</li></ul><table><thead><tr><th>参数名</th><th>释义</th></tr></thead><tbody><tr><td>name</td><td>图库名字</td></tr><tr><td>description</td><td>图库描述</td></tr><tr><td>link</td><td>链接到对应相册的地址</td></tr><tr><td>img-url</td><td>图库封面</td></tr></tbody></table><ul><li><p>gallery 相册</p><p>区别于旧版的Gallery相册,新的Gallery相册会自动根据图片长度进行排版，书写也更加方便，与markdown格式一样。可根据需要插入到相应的md。无需再自己配置长宽。<strong>建议在粘贴时故意使用长短、大小、横竖不一的图片</strong>，会有更好的效果。（尺寸完全相同的图片只会平铺输出，效果很糟糕）</p></li></ul><button type="button" class="tab-to-top" aria-label="scroll to top"><i class="fas fa-arrow-up"></i></button></div><div class="tab-item-content" id="分栏-3"><p>1.gallerygroup 相册图库</p><figure class="highlight markdown"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="language-xml"><span class="tag">&lt;<span class="name">div</span> <span class="attr">class</span>=<span class="string">&quot;gallery-group-main&quot;</span>&gt;</span></span></span><br><span class="line">&#123;% galleryGroup MC 在Rikkaの六花服务器里留下的足迹 &#x27;/gallery/MC/&#x27; https://cdn.cbd.int/akilar-candyassets@1.0.36/image/1.jpg %&#125;</span><br><span class="line">&#123;% galleryGroup Gundam 哦咧哇gundam哒！ &#x27;/gallery/Gundam/&#x27; https://cdn.cbd.int/akilar-candyassets@1.0.36/image/20200907110508327.png %&#125;</span><br><span class="line">&#123;% galleryGroup I-am-Akilar 某种意义上也算自拍吧 &#x27;/gallery/I-am-Akilar/&#x27; https://cdn.cbd.int/akilar-candyassets@1.0.36/image/20200907113116651.png %&#125;</span><br><span class="line"><span class="language-xml"><span class="tag">&lt;/<span class="name">div</span>&gt;</span></span></span><br></pre></td></tr></table></figure><p>2.gallery 相册</p><figure class="highlight markdown"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">&#123;% gallery %&#125;</span><br><span class="line">![](<span class="link">https://i.loli.net/2019/12/25/Fze9jchtnyJXMHN.jpg</span>)</span><br><span class="line">![](<span class="link">https://i.loli.net/2019/12/25/ryLVePaqkYm4TEK.jpg</span>)</span><br><span class="line">&#123;% endgallery %&#125;</span><br></pre></td></tr></table></figure><button type="button" class="tab-to-top" aria-label="scroll to top"><i class="fas fa-arrow-up"></i></button></div><div class="tab-item-content" id="分栏-4"><p>1.gallerygroup 相册图库</p><div class="gallery-group-main">  <figure class="gallery-group">  <img class="gallery-group-img no-lightbox" src='https://cdn.cbd.int/akilar-candyassets@1.0.36/image/1.jpg' alt="Group Image Gallery">  <figcaption>  <div class="gallery-group-name">MC</div>  <p>在Rikkaの六花服务器里留下的足迹</p>  <a href='/gallery/MC/'></a>  </figcaption>  </figure>  <figure class="gallery-group">  <img class="gallery-group-img no-lightbox" src='https://cdn.cbd.int/akilar-candyassets@1.0.36/image/20200907110508327.png' alt="Group Image Gallery">  <figcaption>  <div class="gallery-group-name">Gundam</div>  <p>哦咧哇gundam哒！</p>  <a href='/gallery/Gundam/'></a>  </figcaption>  </figure>  <figure class="gallery-group">  <img class="gallery-group-img no-lightbox" src='https://cdn.cbd.int/akilar-candyassets@1.0.36/image/20200907113116651.png' alt="Group Image Gallery">  <figcaption>  <div class="gallery-group-name">I-am-Akilar</div>  <p>某种意义上也算自拍吧</p>  <a href='/gallery/I-am-Akilar/'></a>  </figcaption>  </figure></div>2.gallery 相册<div class="fj-gallery"><p><img src="https://i.loli.net/2019/12/25/Fze9jchtnyJXMHN.jpg" alt=""><br><img src="https://i.loli.net/2019/12/25/ryLVePaqkYm4TEK.jpg" alt=""></p>          </div><button type="button" class="tab-to-top" aria-label="scroll to top"><i class="fas fa-arrow-up"></i></button></div></div></div><h2 id="2-20-折叠框-folding">2.20 折叠框 folding</h2><div class="tabs" id="分栏"><ul class="nav-tabs"><li class="tab active"><button type="button" data-href="#分栏-1">标签语法</button></li><li class="tab"><button type="button" data-href="#分栏-2">示例源码</button></li><li class="tab"><button type="button" data-href="#分栏-3">渲染演示</button></li></ul><div class="tab-contents"><div class="tab-item-content active" id="分栏-1"><p>1.gallerygroup 相册图库</p><figure class="highlight markdown"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">&#123;% folding 参数（可选）, 标题 %&#125;</span><br><span class="line">![](<span class="link">https://cdn.jsdelivr.net/gh/volantis-x/cdn-wallpaper/abstract/41F215B9-261F-48B4-80B5-4E86E165259E.jpeg</span>)</span><br><span class="line">&#123;% endfolding %&#125;</span><br></pre></td></tr></table></figure><!-- tab 参数配置 --><ol><li><p><code>颜色</code>：blue, cyan, green, yellow, red</p></li><li><p><code>状态</code>：状态填写 open 代表默认打开。</p></li></ol><button type="button" class="tab-to-top" aria-label="scroll to top"><i class="fas fa-arrow-up"></i></button></div><div class="tab-item-content" id="分栏-2"><figure class="highlight markdown"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br></pre></td><td class="code"><pre><span class="line">&#123;% folding 查看图片测试 %&#125;</span><br><span class="line"></span><br><span class="line">![](<span class="link">https://cdn.jsdelivr.net/gh/volantis-x/cdn-wallpaper/abstract/41F215B9-261F-48B4-80B5-4E86E165259E.jpeg</span>)</span><br><span class="line"></span><br><span class="line">&#123;% endfolding %&#125;</span><br><span class="line"></span><br><span class="line">&#123;% folding cyan open, 查看默认打开的折叠框 %&#125;</span><br><span class="line"></span><br><span class="line">这是一个默认打开的折叠框。</span><br><span class="line"></span><br><span class="line">&#123;% endfolding %&#125;</span><br><span class="line"></span><br><span class="line">&#123;% folding green, 查看代码测试 %&#125;</span><br><span class="line">假装这里有代码块（代码块没法嵌套代码块）</span><br><span class="line">&#123;% endfolding %&#125;</span><br><span class="line"></span><br><span class="line">&#123;% folding yellow, 查看列表测试 %&#125;</span><br><span class="line"></span><br><span class="line"><span class="bullet">-</span> haha</span><br><span class="line"><span class="bullet">-</span> hehe</span><br><span class="line"></span><br><span class="line">&#123;% endfolding %&#125;</span><br><span class="line"></span><br><span class="line">&#123;% folding red, 查看嵌套测试 %&#125;</span><br><span class="line"></span><br><span class="line">&#123;% folding blue, 查看嵌套测试2 %&#125;</span><br><span class="line"></span><br><span class="line">&#123;% folding 查看嵌套测试3 %&#125;</span><br><span class="line"></span><br><span class="line">hahaha <span class="language-xml"><span class="tag">&lt;<span class="name">span</span>&gt;</span></span><span class="language-xml"><span class="tag">&lt;<span class="name">img</span> <span class="attr">src</span>=<span class="string">&#x27;https://cdn.jsdelivr.net/gh/volantis-x/cdn-emoji/tieba/%E6%BB%91%E7%A8%BD.png&#x27;</span> <span class="attr">style</span>=<span class="string">&#x27;height:24px&#x27;</span>&gt;</span></span><span class="language-xml"><span class="tag">&lt;/<span class="name">span</span>&gt;</span></span></span><br><span class="line"></span><br><span class="line">&#123;% endfolding %&#125;</span><br><span class="line"></span><br><span class="line">&#123;% endfolding %&#125;</span><br><span class="line"></span><br><span class="line">&#123;% endfolding %&#125;</span><br></pre></td></tr></table></figure><button type="button" class="tab-to-top" aria-label="scroll to top"><i class="fas fa-arrow-up"></i></button></div><div class="tab-item-content" id="分栏-3"><details class="folding-tag" ><summary> 查看图片测试 </summary>              <div class='content'>              <p><img src="https://cdn.jsdelivr.net/gh/volantis-x/cdn-wallpaper/abstract/41F215B9-261F-48B4-80B5-4E86E165259E.jpeg" alt=""></p>              </div>            </details><details class="folding-tag" cyan open><summary> 查看默认打开的折叠框 </summary>              <div class='content'>              <p>这是一个默认打开的折叠框。</p>              </div>            </details><details class="folding-tag" green><summary> 查看代码测试 </summary>              <div class='content'>              <p>假装这里有代码块（代码块没法嵌套代码块）</p>              </div>            </details><details class="folding-tag" yellow><summary> 查看列表测试 </summary>              <div class='content'>              <ul><li>haha</li><li>hehe</li></ul>              </div>            </details><details class="folding-tag" red><summary> 查看嵌套测试 </summary>              <div class='content'>              <details class="folding-tag" blue><summary> 查看嵌套测试2 </summary>              <div class='content'>              <details class="folding-tag" ><summary> 查看嵌套测试3 </summary>              <div class='content'>              <p>hahaha <span><img src='https://cdn.jsdelivr.net/gh/volantis-x/cdn-emoji/tieba/%E6%BB%91%E7%A8%BD.png' style='height:24px'></span></p>              </div>            </details>              </div>            </details>              </div>            </details><button type="button" class="tab-to-top" aria-label="scroll to top"><i class="fas fa-arrow-up"></i></button></div></div></div><h2 id="2-21-分栏-tab">2.21 分栏 tab</h2><div class="tabs" id="分栏"><ul class="nav-tabs"><li class="tab active"><button type="button" data-href="#分栏-1">标签语法</button></li><li class="tab"><button type="button" data-href="#分栏-2">配置参数</button></li><li class="tab"><button type="button" data-href="#分栏-3">示例源码</button></li><li class="tab"><button type="button" data-href="#分栏-4">渲染演示</button></li></ul><div class="tab-contents"><div class="tab-item-content active" id="分栏-1"><figure class="highlight markdown"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">&#123;% tabs Unique name, [index] %&#125;</span><br><span class="line">&lt;!-- tab [Tab caption] [@icon] --&gt;</span><br><span class="line">Any content (support inline tags too).</span><br><span class="line">&lt;!-- endtab --&gt;</span><br><span class="line">&#123;% endtabs %&#125;</span><br></pre></td></tr></table></figure><button type="button" class="tab-to-top" aria-label="scroll to top"><i class="fas fa-arrow-up"></i></button></div><div class="tab-item-content" id="分栏-2"><ol><li><p>Unique name :</p><ul><li><p>选项卡块标签的唯一名称，不带逗号。</p></li><li><p>将在#id中用作每个标签及其索引号的前缀。</p></li><li><p>如果名称中包含空格，则对于生成#id，所有空格将由破折号代替。</p></li><li><p>仅当前帖子/页面的URL必须是唯一的！</p></li></ul></li><li><p>[index]:</p><ul><li><p>活动选项卡的索引号。</p></li><li><p>如果未指定，将选择第一个标签（1）。</p></li><li><p>如果index为-1，则不会选择任何选项卡。</p></li><li><p>可选参数。</p></li></ul></li><li><p>[Tab caption]:</p><ul><li><p>当前选项卡的标题。</p></li><li><p>如果未指定标题，则带有制表符索引后缀的唯一名称将用作制表符的标题。</p></li><li><p>如果未指定标题，但指定了图标，则标题将为空。</p></li><li><p>可选参数。</p></li></ul></li><li><p>[@icon]:</p><ul><li><p>FontAwesome图标名称（全名，看起来像“ fas fa-font”）</p></li><li><p>可以指定带空格或不带空格；</p></li><li><p>例如’Tab caption @icon’ 和 ‘Tab caption@icon’.</p></li><li><p>可选参数。</p></li></ul></li></ol><button type="button" class="tab-to-top" aria-label="scroll to top"><i class="fas fa-arrow-up"></i></button></div><div class="tab-item-content" id="分栏-3"><p>1.Demo 1 - 预设选择第一个【默认】</p><figure class="highlight markdown"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">&#123;% tabs test1 %&#125;</span><br><span class="line">&lt;!-- tab --&gt;</span><br><span class="line"><span class="strong">**This is Tab 1.**</span></span><br><span class="line">&lt;!-- endtab --&gt;</span><br><span class="line"></span><br><span class="line">&lt;!-- tab --&gt;</span><br><span class="line"><span class="strong">**This is Tab 2.**</span></span><br><span class="line">&lt;!-- endtab --&gt;</span><br><span class="line"></span><br><span class="line">&lt;!-- tab --&gt;</span><br><span class="line"><span class="strong">**This is Tab 3.**</span></span><br><span class="line">&lt;!-- endtab --&gt;</span><br><span class="line">&#123;% endtabs %&#125;</span><br></pre></td></tr></table></figure><p>2.Demo 2 - 预设选择tabs</p><figure class="highlight markdown"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">&#123;% tabs test2, 3 %&#125;</span><br><span class="line">&lt;!-- tab --&gt;</span><br><span class="line"><span class="strong">**This is Tab 1.**</span></span><br><span class="line">&lt;!-- endtab --&gt;</span><br><span class="line"></span><br><span class="line">&lt;!-- tab --&gt;</span><br><span class="line"><span class="strong">**This is Tab 2.**</span></span><br><span class="line">&lt;!-- endtab --&gt;</span><br><span class="line"></span><br><span class="line">&lt;!-- tab --&gt;</span><br><span class="line"><span class="strong">**This is Tab 3.**</span></span><br><span class="line">&lt;!-- endtab --&gt;</span><br><span class="line">&#123;% endtabs %&#125;</span><br></pre></td></tr></table></figure><p>3.Demo 3 - 没有预设值</p><figure class="highlight markdown"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">&#123;% tabs test3, -1 %&#125;</span><br><span class="line">&lt;!-- tab --&gt;</span><br><span class="line"><span class="strong">**This is Tab 1.**</span></span><br><span class="line">&lt;!-- endtab --&gt;</span><br><span class="line"></span><br><span class="line">&lt;!-- tab --&gt;</span><br><span class="line"><span class="strong">**This is Tab 2.**</span></span><br><span class="line">&lt;!-- endtab --&gt;</span><br><span class="line"></span><br><span class="line">&lt;!-- tab --&gt;</span><br><span class="line"><span class="strong">**This is Tab 3.**</span></span><br><span class="line">&lt;!-- endtab --&gt;</span><br><span class="line">&#123;% endtabs %&#125;</span><br></pre></td></tr></table></figure><p>4.Demo 4 - 自定义Tab名 + 只有icon + icon和Tab名</p><figure class="highlight markdown"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">&#123;% tabs test4 %&#125;</span><br><span class="line">&lt;!-- tab 第一个Tab --&gt;</span><br><span class="line"><span class="strong">**tab名字为第一个Tab**</span></span><br><span class="line">&lt;!-- endtab --&gt;</span><br><span class="line"></span><br><span class="line">&lt;!-- tab @fab fa-apple-pay --&gt;</span><br><span class="line"><span class="strong">**只有图标 没有Tab名字**</span></span><br><span class="line">&lt;!-- endtab --&gt;</span><br><span class="line"></span><br><span class="line">&lt;!-- tab 炸弹@fas fa-bomb --&gt;</span><br><span class="line"><span class="strong">**名字+icon**</span></span><br><span class="line">&lt;!-- endtab --&gt;</span><br><span class="line">&#123;% endtabs %&#125;</span><br></pre></td></tr></table></figure><button type="button" class="tab-to-top" aria-label="scroll to top"><i class="fas fa-arrow-up"></i></button></div><div class="tab-item-content" id="分栏-4"><p>1.Demo 1 - 预设选择第一个【默认】</p><div class="tabs" id="test1"><ul class="nav-tabs"><li class="tab active"><button type="button" data-href="#test1-1">test1 1</button></li><li class="tab"><button type="button" data-href="#test1-2">test1 2</button></li><li class="tab"><button type="button" data-href="#test1-3">test1 3</button></li></ul><div class="tab-contents"><div class="tab-item-content active" id="test1-1"><p><strong>This is Tab 1.</strong></p><button type="button" class="tab-to-top" aria-label="scroll to top"><i class="fas fa-arrow-up"></i></button></div><div class="tab-item-content" id="test1-2"><p><strong>This is Tab 2.</strong></p><button type="button" class="tab-to-top" aria-label="scroll to top"><i class="fas fa-arrow-up"></i></button></div><div class="tab-item-content" id="test1-3"><p><strong>This is Tab 3.</strong></p><button type="button" class="tab-to-top" aria-label="scroll to top"><i class="fas fa-arrow-up"></i></button></div></div></div><p>2.Demo 2 - 预设选择tabs</p><div class="tabs" id="test2"><ul class="nav-tabs"><li class="tab"><button type="button" data-href="#test2-1">test2 1</button></li><li class="tab"><button type="button" data-href="#test2-2">test2 2</button></li><li class="tab active"><button type="button" data-href="#test2-3">test2 3</button></li></ul><div class="tab-contents"><div class="tab-item-content" id="test2-1"><p><strong>This is Tab 1.</strong></p><button type="button" class="tab-to-top" aria-label="scroll to top"><i class="fas fa-arrow-up"></i></button></div><div class="tab-item-content" id="test2-2"><p><strong>This is Tab 2.</strong></p><button type="button" class="tab-to-top" aria-label="scroll to top"><i class="fas fa-arrow-up"></i></button></div><div class="tab-item-content active" id="test2-3"><p><strong>This is Tab 3.</strong></p><button type="button" class="tab-to-top" aria-label="scroll to top"><i class="fas fa-arrow-up"></i></button></div></div></div><p>3.Demo 3 - 没有预设值</p><div class="tabs" id="test3"><ul class="nav-tabs"><li class="tab"><button type="button" data-href="#test3-1">test3 1</button></li><li class="tab"><button type="button" data-href="#test3-2">test3 2</button></li><li class="tab"><button type="button" data-href="#test3-3">test3 3</button></li></ul><div class="tab-contents"><div class="tab-item-content" id="test3-1"><p><strong>This is Tab 1.</strong></p><button type="button" class="tab-to-top" aria-label="scroll to top"><i class="fas fa-arrow-up"></i></button></div><div class="tab-item-content" id="test3-2"><p><strong>This is Tab 2.</strong></p><button type="button" class="tab-to-top" aria-label="scroll to top"><i class="fas fa-arrow-up"></i></button></div><div class="tab-item-content" id="test3-3"><p><strong>This is Tab 3.</strong></p><button type="button" class="tab-to-top" aria-label="scroll to top"><i class="fas fa-arrow-up"></i></button></div></div></div><p>4.Demo 4 - 自定义Tab名 + 只有icon + icon和Tab名</p><div class="tabs" id="test4"><ul class="nav-tabs"><li class="tab active"><button type="button" data-href="#test4-1">第一个Tab</button></li><li class="tab"><button type="button" data-href="#test4-2"><i class="fab fa-apple-pay" style="text-align: center;"></i></button></li><li class="tab"><button type="button" data-href="#test4-3"><i class="fas fa-bomb"></i>炸弹</button></li></ul><div class="tab-contents"><div class="tab-item-content active" id="test4-1"><p><strong>tab名字为第一个Tab</strong></p><button type="button" class="tab-to-top" aria-label="scroll to top"><i class="fas fa-arrow-up"></i></button></div><div class="tab-item-content" id="test4-2"><p><strong>只有图标 没有Tab名字</strong></p><button type="button" class="tab-to-top" aria-label="scroll to top"><i class="fas fa-arrow-up"></i></button></div><div class="tab-item-content" id="test4-3"><p><strong>名字+icon</strong></p><button type="button" class="tab-to-top" aria-label="scroll to top"><i class="fas fa-arrow-up"></i></button></div></div></div><button type="button" class="tab-to-top" aria-label="scroll to top"><i class="fas fa-arrow-up"></i></button></div></div></div><h2 id="2-22-诗词标签-poem">2.22 诗词标签 poem</h2><div class="tabs" id="分栏"><ul class="nav-tabs"><li class="tab active"><button type="button" data-href="#分栏-1">参数配置</button></li><li class="tab"><button type="button" data-href="#分栏-2">示例源码</button></li><li class="tab"><button type="button" data-href="#分栏-3">渲染演示</button></li></ul><div class="tab-contents"><div class="tab-item-content active" id="分栏-1"><ol><li><code>title</code>：诗词标题</li><li><code>author</code>：作者，可以不写</li></ol><button type="button" class="tab-to-top" aria-label="scroll to top"><i class="fas fa-arrow-up"></i></button></div><div class="tab-item-content" id="分栏-2"><figure class="highlight markdown"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">&#123;% poem 水调歌头,苏轼 %&#125;</span><br><span class="line">丙辰中秋，欢饮达旦，大醉，作此篇，兼怀子由。</span><br><span class="line">明月几时有？把酒问青天。</span><br><span class="line">不知天上宫阙，今夕是何年？</span><br><span class="line">我欲乘风归去，又恐琼楼玉宇，高处不胜寒。</span><br><span class="line">起舞弄清影，何似在人间？</span><br><span class="line"></span><br><span class="line">转朱阁，低绮户，照无眠。</span><br><span class="line">不应有恨，何事长向别时圆？</span><br><span class="line">人有悲欢离合，月有阴晴圆缺，此事古难全。</span><br><span class="line">但愿人长久，千里共婵娟。</span><br><span class="line">&#123;% endpoem %&#125;</span><br></pre></td></tr></table></figure><button type="button" class="tab-to-top" aria-label="scroll to top"><i class="fas fa-arrow-up"></i></button></div><div class="tab-item-content" id="分栏-3"><div class='poem'><div class='poem-title'>水调歌头</div><div class='poem-author'>苏轼</div><p>丙辰中秋，欢饮达旦，大醉，作此篇，兼怀子由。<br>明月几时有？把酒问青天。<br>不知天上宫阙，今夕是何年？<br>我欲乘风归去，又恐琼楼玉宇，高处不胜寒。<br>起舞弄清影，何似在人间？</p><p>转朱阁，低绮户，照无眠。<br>不应有恨，何事长向别时圆？<br>人有悲欢离合，月有阴晴圆缺，此事古难全。<br>但愿人长久，千里共婵娟。</p></div><button type="button" class="tab-to-top" aria-label="scroll to top"><i class="fas fa-arrow-up"></i></button></div></div></div><h2 id="2-23-阿里图标-icon">2.23 阿里图标 icon</h2><div class="tabs" id="分栏"><ul class="nav-tabs"><li class="tab active"><button type="button" data-href="#分栏-1">标签语法</button></li><li class="tab"><button type="button" data-href="#分栏-2">参数配置</button></li><li class="tab"><button type="button" data-href="#分栏-3">示例源码</button></li><li class="tab"><button type="button" data-href="#分栏-4">渲染演示</button></li></ul><div class="tab-contents"><div class="tab-item-content active" id="分栏-1"><figure class="highlight markdown"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">&#123;% icon [icon-xxxx],[font-size] %&#125;</span><br></pre></td></tr></table></figure><button type="button" class="tab-to-top" aria-label="scroll to top"><i class="fas fa-arrow-up"></i></button></div><div class="tab-item-content" id="分栏-2"><ol><li><code>icon-xxxx</code>：表示图标<code>font-class</code>,可以在自己的阿里矢量图标库项目的<code>font-class</code>引用方案内查询并复制。</li><li><code>font-size</code>：表示图标大小，直接填写数字即可，单位为<code>em</code>。图标大小默认值为<code>1em</code>。</li></ol><button type="button" class="tab-to-top" aria-label="scroll to top"><i class="fas fa-arrow-up"></i></button></div><div class="tab-item-content" id="分栏-3"><figure class="highlight markdown"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line">&#123;% icon icon-rat<span class="emphasis">_zi %&#125;&#123;% icon icon-rat,2 %&#125;</span></span><br><span class="line"><span class="emphasis"></span></span><br><span class="line"><span class="emphasis">&#123;% icon icon-ox_</span>chou,3 %&#125;&#123;% icon icon-ox,4 %&#125;</span><br><span class="line"></span><br><span class="line">&#123;% icon icon-tiger<span class="emphasis">_yin,5 %&#125;&#123;% icon icon-tiger,6 %&#125;</span></span><br><span class="line"><span class="emphasis"></span></span><br><span class="line"><span class="emphasis">&#123;% icon icon-rabbit_</span>mao,1 %&#125;&#123;% icon icon-rabbit,2 %&#125;</span><br><span class="line"></span><br><span class="line">&#123;% icon icon-dragon<span class="emphasis">_chen,3 %&#125;&#123;% icon icon-dragon,4 %&#125;</span></span><br><span class="line"><span class="emphasis"></span></span><br><span class="line"><span class="emphasis">&#123;% icon icon-snake_</span>si,5 %&#125;&#123;% icon icon-snake,6 %&#125;</span><br><span class="line"></span><br><span class="line">&#123;% icon icon-horse<span class="emphasis">_wu %&#125;&#123;% icon icon-horse,2 %&#125;</span></span><br><span class="line"><span class="emphasis"></span></span><br><span class="line"><span class="emphasis">&#123;% icon icon-goat_</span>wei,3 %&#125;&#123;% icon icon-goat,4 %&#125;</span><br><span class="line"></span><br><span class="line">&#123;% icon icon-monkey<span class="emphasis">_shen,5 %&#125;&#123;% icon icon-monkey,6 %&#125;</span></span><br><span class="line"><span class="emphasis"></span></span><br><span class="line"><span class="emphasis">&#123;% icon icon-rooster_</span>you %&#125;&#123;% icon icon-rooster,2 %&#125;</span><br><span class="line"></span><br><span class="line">&#123;% icon icon-dog<span class="emphasis">_xu,3 %&#125;&#123;% icon icon-dog,4 %&#125;</span></span><br><span class="line"><span class="emphasis"></span></span><br><span class="line"><span class="emphasis">&#123;% icon icon-boar_</span>hai,5 %&#125;&#123;% icon icon-boar,6 %&#125;</span><br></pre></td></tr></table></figure><button type="button" class="tab-to-top" aria-label="scroll to top"><i class="fas fa-arrow-up"></i></button></div><div class="tab-item-content" id="分栏-4"><p><svg class="icon" style="width:1em; height:1em" aria-hidden="true"><use xlink:href="#icon-rat_zi"></use></svg><svg class="icon" style="width:2em; height:2em" aria-hidden="true"><use xlink:href="#icon-rat"></use></svg></p><p><svg class="icon" style="width:3em; height:3em" aria-hidden="true"><use xlink:href="#icon-ox_chou"></use></svg><svg class="icon" style="width:4em; height:4em" aria-hidden="true"><use xlink:href="#icon-ox"></use></svg></p><p><svg class="icon" style="width:5em; height:5em" aria-hidden="true"><use xlink:href="#icon-tiger_yin"></use></svg><svg class="icon" style="width:6em; height:6em" aria-hidden="true"><use xlink:href="#icon-tiger"></use></svg></p><p><svg class="icon" style="width:1em; height:1em" aria-hidden="true"><use xlink:href="#icon-rabbit_mao"></use></svg><svg class="icon" style="width:2em; height:2em" aria-hidden="true"><use xlink:href="#icon-rabbit"></use></svg></p><p><svg class="icon" style="width:3em; height:3em" aria-hidden="true"><use xlink:href="#icon-dragon_chen"></use></svg><svg class="icon" style="width:4em; height:4em" aria-hidden="true"><use xlink:href="#icon-dragon"></use></svg></p><p><svg class="icon" style="width:5em; height:5em" aria-hidden="true"><use xlink:href="#icon-snake_si"></use></svg><svg class="icon" style="width:6em; height:6em" aria-hidden="true"><use xlink:href="#icon-snake"></use></svg></p><p><svg class="icon" style="width:1em; height:1em" aria-hidden="true"><use xlink:href="#icon-horse_wu"></use></svg><svg class="icon" style="width:2em; height:2em" aria-hidden="true"><use xlink:href="#icon-horse"></use></svg></p><p><svg class="icon" style="width:3em; height:3em" aria-hidden="true"><use xlink:href="#icon-goat_wei"></use></svg><svg class="icon" style="width:4em; height:4em" aria-hidden="true"><use xlink:href="#icon-goat"></use></svg></p><p><svg class="icon" style="width:5em; height:5em" aria-hidden="true"><use xlink:href="#icon-monkey_shen"></use></svg><svg class="icon" style="width:6em; height:6em" aria-hidden="true"><use xlink:href="#icon-monkey"></use></svg></p><p><svg class="icon" style="width:1em; height:1em" aria-hidden="true"><use xlink:href="#icon-rooster_you"></use></svg><svg class="icon" style="width:2em; height:2em" aria-hidden="true"><use xlink:href="#icon-rooster"></use></svg></p><p><svg class="icon" style="width:3em; height:3em" aria-hidden="true"><use xlink:href="#icon-dog_xu"></use></svg><svg class="icon" style="width:4em; height:4em" aria-hidden="true"><use xlink:href="#icon-dog"></use></svg></p><p><svg class="icon" style="width:5em; height:5em" aria-hidden="true"><use xlink:href="#icon-boar_hai"></use></svg><svg class="icon" style="width:6em; height:6em" aria-hidden="true"><use xlink:href="#icon-boar"></use></svg></p><button type="button" class="tab-to-top" aria-label="scroll to top"><i class="fas fa-arrow-up"></i></button></div></div></div><h2 id="2-24-特效标签wow">2.24 特效标签wow</h2><div class="tabs" id="分栏"><ul class="nav-tabs"><li class="tab active"><button type="button" data-href="#分栏-1">示例源码</button></li><li class="tab"><button type="button" data-href="#分栏-2">渲染演示</button></li><li class="tab"><button type="button" data-href="#分栏-3">示例源码</button></li><li class="tab"><button type="button" data-href="#分栏-4">渲染演示</button></li></ul><div class="tab-contents"><div class="tab-item-content active" id="分栏-1"><figure class="highlight markdown"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">&#123;% wow [animete],[duration],[delay],[offset],[iteration] %&#125;</span><br><span class="line">内容</span><br><span class="line">&#123;% endwow %&#125;</span><br></pre></td></tr></table></figure><button type="button" class="tab-to-top" aria-label="scroll to top"><i class="fas fa-arrow-up"></i></button></div><div class="tab-item-content" id="分栏-2"><ol><li><code>animate</code>: 动画样式，效果详见<a href="https://animate.style/">animate.css参考文档</a></li><li><code>duration</code>: 选填项，动画持续时间，单位可以是<code>ms</code>也可以是<code>s</code>。例如<code>3s</code>，<code>700ms</code>。</li><li><code>delay</code>: 选填项，动画开始的延迟时间，单位可以是<code>ms</code>也可以是<code>s</code>。例如<code>3s</code>，<code>700ms</code>。</li><li><code>offset</code>: 选填项，开始动画的距离（相对浏览器底部）</li><li><code>iteration</code>: 选填项，动画重复的次数</li></ol><button type="button" class="tab-to-top" aria-label="scroll to top"><i class="fas fa-arrow-up"></i></button></div><div class="tab-item-content" id="分栏-3"><p>1.flip动画效果。</p><figure class="highlight markdown"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">&#123;% wow animate<span class="strong">__zoomIn,5s,5s,100,10 %&#125;</span></span><br><span class="line"><span class="strong">&#123;% note blue &#x27;fas fa-bullhorn&#x27; modern%&#125;</span></span><br><span class="line"><span class="strong">`zoomIn`动画效果，持续`5s`，延时`5s`，离底部`100`距离时启动，重复`10`次</span></span><br><span class="line"><span class="strong">&#123;% endnote %&#125;</span></span><br><span class="line"><span class="strong">&#123;% endwow %&#125;</span></span><br></pre></td></tr></table></figure><p>2.zoomIn动画效果，持续5s，延时5s，离底部100距离时启动，重复10次</p><figure class="highlight markdown"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">&#123;% wow animate<span class="strong">__zoomIn,5s,5s,100,10 %&#125;</span></span><br><span class="line"><span class="strong">&#123;% note blue &#x27;fas fa-bullhorn&#x27; modern%&#125;</span></span><br><span class="line"><span class="strong">`zoomIn`动画效果，持续`5s`，延时`5s`，离底部`100`距离时启动，重复`10`次</span></span><br><span class="line"><span class="strong">&#123;% endnote %&#125;</span></span><br><span class="line"><span class="strong">&#123;% endwow %&#125;</span></span><br></pre></td></tr></table></figure><p>3.slideInRight动画效果，持续5s，延时5s</p><figure class="highlight markdown"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">&#123;% wow animate<span class="strong">__slideInRight,5s,5s %&#125;</span></span><br><span class="line"><span class="strong">&#123;% note orange &#x27;fas fa-car&#x27; modern%&#125;</span></span><br><span class="line"><span class="strong">`slideInRight`动画效果，持续`5s`，延时`5s`。</span></span><br><span class="line"><span class="strong">&#123;% endnote %&#125;</span></span><br><span class="line"><span class="strong">&#123;% endwow %&#125;</span></span><br></pre></td></tr></table></figure><p>4.heartBeat动画效果，延时5s，重复10次。此处注意不用的参数位置要留空，用逗号间隔。</p><figure class="highlight markdown"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">&#123;% wow animate<span class="strong">__heartBeat,,5s,,10 %&#125;</span></span><br><span class="line"><span class="strong">&#123;% note red &#x27;fas fa-battery-half&#x27; modern%&#125;</span></span><br><span class="line"><span class="strong">`heartBeat`动画效果，延时`5s`，重复`10`次。</span></span><br><span class="line"><span class="strong">&#123;% endnote %&#125;</span></span><br><span class="line"><span class="strong">&#123;% endwow %&#125;</span></span><br></pre></td></tr></table></figure><button type="button" class="tab-to-top" aria-label="scroll to top"><i class="fas fa-arrow-up"></i></button></div><div class="tab-item-content" id="分栏-4"><p>1.flip动画效果。</p><div class='wow animate__zoomIn' data-wow-duration='5s' data-wow-delay='5s' data-wow-offset='100'  data-wow-iteration='10' ><div class="note blue icon-padding modern"><i class="note-icon fas fa-bullhorn"></i><p><code>zoomIn</code>动画效果，持续<code>5s</code>，延时<code>5s</code>，离底部<code>100</code>距离时启动，重复<code>10</code>次</p></div></div><p>2.zoomIn动画效果，持续5s，延时5s，离底部100距离时启动，重复10次</p><div class='wow animate__zoomIn' data-wow-duration='5s' data-wow-delay='5s' data-wow-offset='100'  data-wow-iteration='10' ><div class="note blue icon-padding modern"><i class="note-icon fas fa-bullhorn"></i><p><code>zoomIn</code>动画效果，持续<code>5s</code>，延时<code>5s</code>，离底部<code>100</code>距离时启动，重复<code>10</code>次</p></div></div><p>3.slideInRight动画效果，持续5s，延时5s</p><div class='wow animate__slideInRight' data-wow-duration='5s' data-wow-delay='5s' data-wow-offset=''  data-wow-iteration='' ><div class="note orange icon-padding modern"><i class="note-icon fas fa-car"></i><p><code>slideInRight</code>动画效果，持续<code>5s</code>，延时<code>5s</code>。</p></div></div><p>4.heartBeat动画效果，延时5s，重复10次。此处注意不用的参数位置要留空，用逗号间隔。</p><div class='wow animate__heartBeat' data-wow-duration='' data-wow-delay='5s' data-wow-offset=''  data-wow-iteration='10' ><div class="note red icon-padding modern"><i class="note-icon fas fa-battery-half"></i><p><code>heartBeat</code>动画效果，延时<code>5s</code>，重复<code>10</code>次。</p></div></div><button type="button" class="tab-to-top" aria-label="scroll to top"><i class="fas fa-arrow-up"></i></button></div></div></div><h2 id="2-25-进度条-progress">2.25  进度条 progress</h2><div class="note info flat"><p>进度条标签参考<a href="https://rongbuqiu.com/jdt.html">沂佰孜猫-给HEXO文章添加彩色进度条</a>。<br>源样式提取自<a href="https://zwying0814.gitbook.io/cuteen/">Cuteen</a>主题。</p></div><div class="tabs" id="分栏"><ul class="nav-tabs"><li class="tab active"><button type="button" data-href="#分栏-1">参数配置</button></li><li class="tab"><button type="button" data-href="#分栏-2">标签语法</button></li><li class="tab"><button type="button" data-href="#分栏-3">示例源码</button></li><li class="tab"><button type="button" data-href="#分栏-4">渲染演示</button></li></ul><div class="tab-contents"><div class="tab-item-content active" id="分栏-1"><figure class="highlight markdown"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">&#123;% progress [width] [color] [text] %&#125;</span><br></pre></td></tr></table></figure><button type="button" class="tab-to-top" aria-label="scroll to top"><i class="fas fa-arrow-up"></i></button></div><div class="tab-item-content" id="分栏-2"><ol><li><code>width</code>: 0到100的阿拉伯数字</li><li><code>color</code>: 颜色，取值有red,yellow,green,cyan,blue,gray</li><li><code>text</code>:进度条上的文字内容</li></ol><button type="button" class="tab-to-top" aria-label="scroll to top"><i class="fas fa-arrow-up"></i></button></div><div class="tab-item-content" id="分栏-3"><figure class="highlight markdown"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">&#123;% progress 10 red 进度条样式预览 %&#125;</span><br><span class="line">&#123;% progress 30 yellow 进度条样式预览 %&#125;</span><br><span class="line">&#123;% progress 50 green 进度条样式预览 %&#125;</span><br><span class="line">&#123;% progress 70 cyan 进度条样式预览 %&#125;</span><br><span class="line">&#123;% progress 90 blue 进度条样式预览 %&#125;</span><br><span class="line">&#123;% progress 100 gray 进度条样式预览 %&#125;</span><br></pre></td></tr></table></figure><button type="button" class="tab-to-top" aria-label="scroll to top"><i class="fas fa-arrow-up"></i></button></div><div class="tab-item-content" id="分栏-4"><div class="progress"><div class="progress-bar-animated progress-bar progress-bar-striped bg-red"  style="width: 10%" aria-valuenow="10" aria-valuemin="0" aria-valuemax="100"><p>进度条样式预览</p></div></div><div class="progress"><div class="progress-bar-animated progress-bar progress-bar-striped bg-yellow"  style="width: 30%" aria-valuenow="30" aria-valuemin="0" aria-valuemax="100"><p>进度条样式预览</p></div></div><div class="progress"><div class="progress-bar-animated progress-bar progress-bar-striped bg-green"  style="width: 50%" aria-valuenow="50" aria-valuemin="0" aria-valuemax="100"><p>进度条样式预览</p></div></div><div class="progress"><div class="progress-bar-animated progress-bar progress-bar-striped bg-cyan"  style="width: 70%" aria-valuenow="70" aria-valuemin="0" aria-valuemax="100"><p>进度条样式预览</p></div></div><div class="progress"><div class="progress-bar-animated progress-bar progress-bar-striped bg-blue"  style="width: 90%" aria-valuenow="90" aria-valuemin="0" aria-valuemax="100"><p>进度条样式预览</p></div></div><div class="progress"><div class="progress-bar-animated progress-bar progress-bar-striped bg-gray"  style="width: 100%" aria-valuenow="100" aria-valuemin="0" aria-valuemax="100"><p>进度条样式预览</p></div></div><button type="button" class="tab-to-top" aria-label="scroll to top"><i class="fas fa-arrow-up"></i></button></div></div></div><h2 id="2-26-注释-notation">2.26 注释 notation</h2><div class="tabs" id="分栏"><ul class="nav-tabs"><li class="tab active"><button type="button" data-href="#分栏-1">标签语法</button></li><li class="tab"><button type="button" data-href="#分栏-2">参数配置</button></li><li class="tab"><button type="button" data-href="#分栏-3">示例源码</button></li><li class="tab"><button type="button" data-href="#分栏-4">渲染演示</button></li></ul><div class="tab-contents"><div class="tab-item-content active" id="分栏-1"><figure class="highlight markdown"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">&#123;% nota [label] , [text] %&#125;</span><br></pre></td></tr></table></figure><button type="button" class="tab-to-top" aria-label="scroll to top"><i class="fas fa-arrow-up"></i></button></div><div class="tab-item-content" id="分栏-2"><ol><li><p><code>label</code>: 注释词汇</p></li><li><p><code>text</code>: 悬停显示的注解内容</p></li></ol><button type="button" class="tab-to-top" aria-label="scroll to top"><i class="fas fa-arrow-up"></i></button></div><div class="tab-item-content" id="分栏-3"><figure class="highlight markdown"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">&#123;% nota 把鼠标移动到我上面试试 ,可以看到注解内容出现在顶栏 %&#125;</span><br></pre></td></tr></table></figure><button type="button" class="tab-to-top" aria-label="scroll to top"><i class="fas fa-arrow-up"></i></button></div><div class="tab-item-content" id="分栏-4"><p><span class='nota' data-nota='可以看到注解内容出现在顶栏'>把鼠标移动到我上面试试</span></p><button type="button" class="tab-to-top" aria-label="scroll to top"><i class="fas fa-arrow-up"></i></button></div></div></div><h2 id="2-27-气泡注释-bubble">2.27 气泡注释 bubble</h2><div class="tabs" id="分栏"><ul class="nav-tabs"><li class="tab active"><button type="button" data-href="#分栏-1">标签语法</button></li><li class="tab"><button type="button" data-href="#分栏-2">参数配置</button></li><li class="tab"><button type="button" data-href="#分栏-3">示例源码</button></li><li class="tab"><button type="button" data-href="#分栏-4">渲染演示</button></li></ul><div class="tab-contents"><div class="tab-item-content active" id="分栏-1"><figure class="highlight markdown"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">&#123;% bubble [content] , [notation] ,[background-color] %&#125;</span><br></pre></td></tr></table></figure><button type="button" class="tab-to-top" aria-label="scroll to top"><i class="fas fa-arrow-up"></i></button></div><div class="tab-item-content" id="分栏-2"><ol><li><code>content</code>: 注释词汇</li><li><code>notation</code>: 悬停显示的注解内容</li><li><code>background-color</code>: 可选，气泡背景色。默认为“#71a4e3”</li></ol><button type="button" class="tab-to-top" aria-label="scroll to top"><i class="fas fa-arrow-up"></i></button></div><div class="tab-item-content" id="分栏-3"><figure class="highlight markdown"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">最近我学到了不少新玩意儿（虽然对很多大佬来说这些已经是旧技术了），比如CSS的&#123;% bubble 兄弟相邻选择器,&quot;例如 h1 + p &#123;margin-top:50px;&#125;&quot; %&#125;，&#123;% bubble flex布局,&quot;Flex 是 Flexible Box 的缩写，意为&quot;弹性布局&quot;，用来为盒状模型提供最大的灵活性&quot;,&quot;#ec5830&quot; %&#125;，&#123;% bubble transform变换,&quot;transform 属性向元素应用 2D 或 3D 转换。该属性允许我们对元素进行旋转、缩放、移动或倾斜。&quot;,&quot;#1db675&quot; %&#125;，animation的&#123;% bubble 贝塞尔速度曲线,&quot;贝塞尔曲线(Bézier curve)，又称贝兹曲线或贝济埃曲线，是应用于二维图形应用程序的数学曲线。一般的矢量图形软件通过它来精确画出曲线，贝兹曲线由线段与节点组成，节点是可拖动的支点，线段像可伸缩的皮筋&quot;,&quot;#de4489&quot; %&#125;写法，还有今天刚看到的&#123;% bubble clip-path,&quot;clip-path属性使用裁剪方式创建元素的可显示区域。区域内的部分显示，区域外的隐藏。&quot;,&quot;#868fd7&quot; %&#125;属性。这些对我来说很新颖的概念狠狠的冲击着我以前积累起来的设计思路。</span><br></pre></td></tr></table></figure><button type="button" class="tab-to-top" aria-label="scroll to top"><i class="fas fa-arrow-up"></i></button></div><div class="tab-item-content" id="分栏-4"><p>最近我学到了不少新玩意儿（虽然对很多大佬来说这些已经是旧技术了），比如CSS的<span class="bubble-content">兄弟相邻选择器</span><span class="bubble-notation"><span class="bubble-item" style="background-color:#71a4e3;">例如 h1 + p {margin-top:50px;}</span></span>，<span class="bubble-content">flex布局</span><span class="bubble-notation"><span class="bubble-item" style="background-color:#ec5830;">Flex 是 Flexible Box 的缩写，意为弹性布局&quot;，用来为盒状模型提供最大的灵活性&quot;</span></span>，<span class="bubble-content">transform变换</span><span class="bubble-notation"><span class="bubble-item" style="background-color:#1db675;">transform 属性向元素应用 2D 或 3D 转换。该属性允许我们对元素进行旋转、缩放、移动或倾斜。</span></span>，animation的<span class="bubble-content">贝塞尔速度曲线</span><span class="bubble-notation"><span class="bubble-item" style="background-color:#de4489;">贝塞尔曲线(Bézier curve)，又称贝兹曲线或贝济埃曲线，是应用于二维图形应用程序的数学曲线。一般的矢量图形软件通过它来精确画出曲线，贝兹曲线由线段与节点组成，节点是可拖动的支点，线段像可伸缩的皮筋</span></span>写法，还有今天刚看到的<span class="bubble-content">clip-path</span><span class="bubble-notation"><span class="bubble-item" style="background-color:#868fd7;">clip-path属性使用裁剪方式创建元素的可显示区域。区域内的部分显示，区域外的隐藏。</span></span>属性。这些对我来说很新颖的概念狠狠的冲击着我以前积累起来的设计思路。</p><button type="button" class="tab-to-top" aria-label="scroll to top"><i class="fas fa-arrow-up"></i></button></div></div></div><h2 id="2-28-引用文献-reference">2.28 引用文献 reference</h2><div class="tabs" id="分栏"><ul class="nav-tabs"><li class="tab active"><button type="button" data-href="#分栏-1">标签语法</button></li><li class="tab"><button type="button" data-href="#分栏-2">参数配置</button></li><li class="tab"><button type="button" data-href="#分栏-3">示例源码</button></li><li class="tab"><button type="button" data-href="#分栏-4">渲染演示</button></li></ul><div class="tab-contents"><div class="tab-item-content active" id="分栏-1"><figure class="highlight markdown"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">&#123;% referto [id] , [literature] %&#125;</span><br><span class="line">&#123;% referfrom [id] , [literature] , [url] %&#125;</span><br></pre></td></tr></table></figure><button type="button" class="tab-to-top" aria-label="scroll to top"><i class="fas fa-arrow-up"></i></button></div><div class="tab-item-content" id="分栏-2"><ol><li><p>referto 引用上标</p><ul><li><p><code>id</code>: 上标序号内容，需与referfrom标签的id对应才能实现跳转</p></li><li><p><code>literature</code>: 引用的参考文献名称</p></li></ul></li><li><p>referfrom 引用出处</p><ul><li><p><code>id</code>: 序号内容，需与referto标签的id对应才能实现 跳转</p></li><li><p><code>literature</code>: 引用的参考文献名称</p></li><li><p><code>url</code>: 引用的参考文献链接，可省略</p></li></ul></li></ol><button type="button" class="tab-to-top" aria-label="scroll to top"><i class="fas fa-arrow-up"></i></button></div><div class="tab-item-content" id="分栏-3"><figure class="highlight markdown"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">Akilarの糖果屋(akilar.top)是一个私人性质的博客&#123;% referto &#x27;[1]&#x27;,&#x27;Akilarの糖果屋群聊简介&#x27; %&#125;，从各类教程至生活点滴，无话不谈。建群的目的是提供一个闲聊的场所。博客采用Hexo框架&#123;% referto &#x27;[2]&#x27;,&#x27;Hexo中文文档&#x27; %&#125;，Butterfly主题&#123;% referto &#x27;[3]&#x27;,&#x27;Butterfly 安装文档(一) 快速开始&#x27; %&#125;</span><br><span class="line"></span><br><span class="line">本项目参考了Volantis&#123;% referto &#x27;[4]&#x27;,&#x27;hexo-theme-volantis 标签插件&#x27; %&#125;的标签样式。引入<span class="code">`[tag].js`</span>，并针对<span class="code">`butterfly`</span>主题修改了相应的<span class="code">`[tag].styl`</span>。在此鸣谢<span class="code">`Volantis`</span>主题众开发者。</span><br><span class="line">主要参考内容包括各个volantis的内置标签插件文档&#123;% referto &#x27;[5]&#x27;,&#x27;Volantis文档:内置标签插件&#x27; %&#125;</span><br><span class="line">Butterfly主题的各个衍生魔改&#123;% referto &#x27;[6]&#x27;,&#x27;Butterfly 安装文档:标签外挂（Tag Plugins&#x27; %&#125;&#123;% referto &#x27;[7]&#x27;,&#x27;小弋の生活馆全样式预览&#x27; %&#125;&#123;% referto &#x27;[8]&#x27;,&#x27;l-lin-font-awesome-animation&#x27; %&#125;&#123;% referto &#x27;[9]&#x27;,&#x27;小康的butterfly主题使用文档&#x27; %&#125;</span><br><span class="line"></span><br><span class="line">&#123;% referfrom &#x27;[1]&#x27;,&#x27;Akilarの糖果屋群聊简介&#x27;,&#x27;https://jq.qq.com/?<span class="emphasis">_wv=1027&amp;k=pGLB2C0N&#x27; %&#125;</span></span><br><span class="line"><span class="emphasis">&#123;% referfrom &#x27;[2]&#x27;,&#x27;Hexo中文文档&#x27;,&#x27;https://hexo.io/zh-cn/docs/&#x27; %&#125;</span></span><br><span class="line"><span class="emphasis">&#123;% referfrom &#x27;[3]&#x27;,&#x27;Butterfly 安装文档(一) 快速开始&#x27;,&#x27;https://butterfly.js.org/posts/21cfbf15/&#x27; %&#125;</span></span><br><span class="line"><span class="emphasis">&#123;% referfrom &#x27;[4]&#x27;,&#x27;hexo-theme-volantis 标签插件&#x27;,&#x27;https://volantis.js.org/v5/tag-plugins/&#x27; %&#125;</span></span><br><span class="line"><span class="emphasis">&#123;% referfrom &#x27;[5]&#x27;,&#x27;Volantis文档:内置标签插件&#x27;,&#x27;https://volantis.js.org/tag-plugins/&#x27; %&#125;</span></span><br><span class="line"><span class="emphasis">&#123;% referfrom &#x27;[6]&#x27;,&#x27;Butterfly 安装文档:标签外挂（Tag Plugins&#x27;,&#x27;https://butterfly.js.org/posts/4aa8abbe/#%E6%A8%99%E7%B1%A4%E5%A4%96%E6%8E%9B%EF%BC%88Tag-Plugins%EF%BC%89&#x27; %&#125;</span></span><br><span class="line"><span class="emphasis">&#123;% referfrom &#x27;[7]&#x27;,&#x27;小弋の生活馆全样式预览&#x27;,&#x27;https://lovelijunyi.gitee.io/posts/c898.html&#x27; %&#125;</span></span><br><span class="line"><span class="emphasis">&#123;% referfrom &#x27;[8]&#x27;,&#x27;l-lin-font-awesome-animation&#x27;,&#x27;https://github.com/l-lin/font-awesome-animation&#x27; %&#125;</span></span><br><span class="line"><span class="emphasis">&#123;% referfrom &#x27;[9]&#x27;,&#x27;小康的butterfly主题使用文档&#x27;,&#x27;https://www.antmoe.com/posts/3b43914f/&#x27; %&#125;</span></span><br></pre></td></tr></table></figure><button type="button" class="tab-to-top" aria-label="scroll to top"><i class="fas fa-arrow-up"></i></button></div><div class="tab-item-content" id="分栏-4"><p>Akilarの糖果屋(akilar.top)是一个私人性质的博客<span class="hidden-anchor" id="referto_[1]"></span><sup class="reference"><a href="#referfrom_[1]">[1]</a></sup><span class="reference-bubble"><span class="reference-item"><span class="reference-literature">Akilarの糖果屋群聊简介</span><span class="reference-title">参考资料</span></span></span>，从各类教程至生活点滴，无话不谈。建群的目的是提供一个闲聊的场所。博客采用Hexo框架<span class="hidden-anchor" id="referto_[2]"></span><sup class="reference"><a href="#referfrom_[2]">[2]</a></sup><span class="reference-bubble"><span class="reference-item"><span class="reference-literature">Hexo中文文档</span><span class="reference-title">参考资料</span></span></span>，Butterfly主题<span class="hidden-anchor" id="referto_[3]"></span><sup class="reference"><a href="#referfrom_[3]">[3]</a></sup><span class="reference-bubble"><span class="reference-item"><span class="reference-literature">Butterfly 安装文档(一) 快速开始</span><span class="reference-title">参考资料</span></span></span></p><p>本项目参考了Volantis<span class="hidden-anchor" id="referto_[4]"></span><sup class="reference"><a href="#referfrom_[4]">[4]</a></sup><span class="reference-bubble"><span class="reference-item"><span class="reference-literature">hexo-theme-volantis 标签插件</span><span class="reference-title">参考资料</span></span></span>的标签样式。引入<code>[tag].js</code>，并针对<code>butterfly</code>主题修改了相应的<code>[tag].styl</code>。在此鸣谢<code>Volantis</code>主题众开发者。<br>主要参考内容包括各个volantis的内置标签插件文档<span class="hidden-anchor" id="referto_[5]"></span><sup class="reference"><a href="#referfrom_[5]">[5]</a></sup><span class="reference-bubble"><span class="reference-item"><span class="reference-literature">Volantis文档:内置标签插件</span><span class="reference-title">参考资料</span></span></span><br>Butterfly主题的各个衍生魔改<span class="hidden-anchor" id="referto_[6]"></span><sup class="reference"><a href="#referfrom_[6]">[6]</a></sup><span class="reference-bubble"><span class="reference-item"><span class="reference-literature">Butterfly 安装文档:标签外挂（Tag Plugins</span><span class="reference-title">参考资料</span></span></span><span class="hidden-anchor" id="referto_[7]"></span><sup class="reference"><a href="#referfrom_[7]">[7]</a></sup><span class="reference-bubble"><span class="reference-item"><span class="reference-literature">小弋の生活馆全样式预览</span><span class="reference-title">参考资料</span></span></span><span class="hidden-anchor" id="referto_[8]"></span><sup class="reference"><a href="#referfrom_[8]">[8]</a></sup><span class="reference-bubble"><span class="reference-item"><span class="reference-literature">l-lin-font-awesome-animation</span><span class="reference-title">参考资料</span></span></span><span class="hidden-anchor" id="referto_[9]"></span><sup class="reference"><a href="#referfrom_[9]">[9]</a></sup><span class="reference-bubble"><span class="reference-item"><span class="reference-literature">小康的butterfly主题使用文档</span><span class="reference-title">参考资料</span></span></span></p><div class="reference-source"><span class="hidden-anchor" id="referfrom_[1]"></span><a class="reference-anchor" href="#referto_[1]">[1]<div class="reference-anchor-up fa-solid fa-angles-up"></div></a><a class="reference-link" href="https://jq.qq.com/?_wv=1027&k=pGLB2C0N">Akilarの糖果屋群聊简介</a></div><div class="reference-source"><span class="hidden-anchor" id="referfrom_[2]"></span><a class="reference-anchor" href="#referto_[2]">[2]<div class="reference-anchor-up fa-solid fa-angles-up"></div></a><a class="reference-link" href="https://hexo.io/zh-cn/docs/">Hexo中文文档</a></div><div class="reference-source"><span class="hidden-anchor" id="referfrom_[3]"></span><a class="reference-anchor" href="#referto_[3]">[3]<div class="reference-anchor-up fa-solid fa-angles-up"></div></a><a class="reference-link" href="https://butterfly.js.org/posts/21cfbf15/">Butterfly 安装文档(一) 快速开始</a></div><div class="reference-source"><span class="hidden-anchor" id="referfrom_[4]"></span><a class="reference-anchor" href="#referto_[4]">[4]<div class="reference-anchor-up fa-solid fa-angles-up"></div></a><a class="reference-link" href="https://volantis.js.org/v5/tag-plugins/">hexo-theme-volantis 标签插件</a></div><div class="reference-source"><span class="hidden-anchor" id="referfrom_[5]"></span><a class="reference-anchor" href="#referto_[5]">[5]<div class="reference-anchor-up fa-solid fa-angles-up"></div></a><a class="reference-link" href="https://volantis.js.org/tag-plugins/">Volantis文档:内置标签插件</a></div><div class="reference-source"><span class="hidden-anchor" id="referfrom_[6]"></span><a class="reference-anchor" href="#referto_[6]">[6]<div class="reference-anchor-up fa-solid fa-angles-up"></div></a><a class="reference-link" href="https://butterfly.js.org/posts/4aa8abbe/#%E6%A8%99%E7%B1%A4%E5%A4%96%E6%8E%9B%EF%BC%88Tag-Plugins%EF%BC%89">Butterfly 安装文档:标签外挂（Tag Plugins</a></div><div class="reference-source"><span class="hidden-anchor" id="referfrom_[7]"></span><a class="reference-anchor" href="#referto_[7]">[7]<div class="reference-anchor-up fa-solid fa-angles-up"></div></a><a class="reference-link" href="https://lovelijunyi.gitee.io/posts/c898.html">小弋の生活馆全样式预览</a></div><div class="reference-source"><span class="hidden-anchor" id="referfrom_[8]"></span><a class="reference-anchor" href="#referto_[8]">[8]<div class="reference-anchor-up fa-solid fa-angles-up"></div></a><a class="reference-link" href="https://github.com/l-lin/font-awesome-animation">l-lin-font-awesome-animation</a></div><div class="reference-source"><span class="hidden-anchor" id="referfrom_[9]"></span><a class="reference-anchor" href="#referto_[9]">[9]<div class="reference-anchor-up fa-solid fa-angles-up"></div></a><a class="reference-link" href="https://www.antmoe.com/posts/3b43914f/">小康的butterfly主题使用文档</a></div><button type="button" class="tab-to-top" aria-label="scroll to top"><i class="fas fa-arrow-up"></i></button></div></div></div><h2 id="2-29-PDF展示">2.29 PDF展示</h2><div class="tabs" id="分栏"><ul class="nav-tabs"><li class="tab active"><button type="button" data-href="#分栏-1">标签语法</button></li><li class="tab"><button type="button" data-href="#分栏-2">参数配置</button></li><li class="tab"><button type="button" data-href="#分栏-3">示例源码</button></li><li class="tab"><button type="button" data-href="#分栏-4">渲染演示</button></li></ul><div class="tab-contents"><div class="tab-item-content active" id="分栏-1"><figure class="highlight markdown"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">&#123;% pdf 文件路径 %&#125;</span><br></pre></td></tr></table></figure><button type="button" class="tab-to-top" aria-label="scroll to top"><i class="fas fa-arrow-up"></i></button></div><div class="tab-item-content" id="分栏-2"><ol><li><code>文件路径</code>: 可以是相对路径或者是在线链接</li></ol><button type="button" class="tab-to-top" aria-label="scroll to top"><i class="fas fa-arrow-up"></i></button></div><div class="tab-item-content" id="分栏-3"><figure class="highlight markdown"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="section"># 1.本地文件:在md文件路径下创建一个同名文件夹，其内放pdf文件名为xxx.pdf的文件</span></span><br><span class="line">&#123;% pdf xxx.pdf %&#125;</span><br><span class="line"><span class="section"># 2.在线链接</span></span><br><span class="line">&#123;% pdf https://cdn.jsdelivr.net/gh/Justlovesmile/CDN/pdf/小作文讲义.pdf %&#125;</span><br></pre></td></tr></table></figure><button type="button" class="tab-to-top" aria-label="scroll to top"><i class="fas fa-arrow-up"></i></button></div><div class="tab-item-content" id="分栏-4"><p>2.在线链接(要放到最外层才能起作用)</p><pre><code>&lt;div class=&quot;row&quot;&gt;&lt;embed src=&quot;https://cdn.jsdelivr.net/gh/Justlovesmile/CDN/pdf/小作文讲义.pdf&quot; width=&quot;100%&quot; height=&quot;550&quot; type=&quot;application/pdf&quot;&gt;&lt;/div&gt;</code></pre><button type="button" class="tab-to-top" aria-label="scroll to top"><i class="fas fa-arrow-up"></i></button></div></div></div><h2 id="2-30-Hexo-tag-map-插件">2.30 Hexo-tag-map 插件</h2><div class="tabs" id="分栏"><ul class="nav-tabs"><li class="tab active"><button type="button" data-href="#分栏-1">标签语法</button></li><li class="tab"><button type="button" data-href="#分栏-2">参数配置</button></li><li class="tab"><button type="button" data-href="#分栏-3">示例源码</button></li><li class="tab"><button type="button" data-href="#分栏-4">渲染演示</button></li></ul><div class="tab-contents"><div class="tab-item-content active" id="分栏-1"><figure class="highlight markdown"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">&#123;% + 标签值 + 经度 + 纬度 + 文本 + 缩放等级 + 宽 + 高 + 默认图层 + %&#125;</span><br></pre></td></tr></table></figure><button type="button" class="tab-to-top" aria-label="scroll to top"><i class="fas fa-arrow-up"></i></button></div><div class="tab-item-content" id="分栏-2"><table><thead><tr><th style="text-align:center">地图名</th><th style="text-align:center">标签值 &lt;必填&gt;</th><th style="text-align:center">宽 (默认 100%) / 高 (默认 360px)</th><th style="text-align:center">缩放等级 (默认 14)</th><th style="text-align:center">宽 (默认 100%) / 高 (默认 360px)</th><th style="text-align:center">默认图层 (默认 1)</th></tr></thead><tbody><tr><td style="text-align:center">混合地图</td><td style="text-align:center">map</td><td style="text-align:center">百分数或具体值 (100% 或 360px)</td><td style="text-align:center">取值 3~18</td><td style="text-align:center">百分数或具体值 (100% 或 360px)</td><td style="text-align:center">取值 1~7</td></tr><tr><td style="text-align:center">谷歌地图</td><td style="text-align:center">googleMap</td><td style="text-align:center">百分数或具体值 (100% 或 360px)</td><td style="text-align:center">取值 1~20</td><td style="text-align:center">百分数或具体值 (100% 或 360px)</td><td style="text-align:center">取值 1~3</td></tr><tr><td style="text-align:center">高德地图</td><td style="text-align:center">gaodeMap</td><td style="text-align:center">百分数或具体值 (100% 或 360px)</td><td style="text-align:center">取值 3~18</td><td style="text-align:center">百分数或具体值 (100% 或 360px)</td><td style="text-align:center">取值 1~3</td></tr><tr><td style="text-align:center">百度地图</td><td style="text-align:center">baiduMap</td><td style="text-align:center">百分数或具体值 (100% 或 360px)</td><td style="text-align:center">取值 4~18</td><td style="text-align:center">百分数或具体值 (100% 或 360px)</td><td style="text-align:center">取值 1~2</td></tr><tr><td style="text-align:center">Geoq 地图</td><td style="text-align:center">geoqMap</td><td style="text-align:center">百分数或具体值 (100% 或 360px)</td><td style="text-align:center">取值 1~18</td><td style="text-align:center">百分数或具体值 (100% 或 360px)</td><td style="text-align:center">取值 1~5</td></tr><tr><td style="text-align:center">openstreet 地图</td><td style="text-align:center">openstreetMap</td><td style="text-align:center">百分数或具体值 (100% 或 360px)</td><td style="text-align:center">取值 1~18</td><td style="text-align:center">百分数或具体值 (100% 或 360px)</td><td style="text-align:center">不支持此参数</td></tr></tbody></table><ol><li>参数之间，用英文逗号相隔</li><li>参数必须按上述事例顺序输入，不得为空</li><li>同一个页面，同一组经纬度值，只能插入一个相同标签值的地图 (若有需要，可以将第二个地图上，经度或纬度末尾删除一两个数)</li><li>参数取值必须在上述范围内</li><li>默认图层：即地图叠加层的值，默认常规地图还是卫星地图，可按地图显示顺序取值</li><li>缩放等级，数字越大，地图比例尺越小，显示的越精细</li><li>除标签值外，其他参数选填，但 每个参数的左边的参数必填</li><li>谷歌地图需要外网才能加载查看</li></ol><p>坐标获取：<a href="https://lbs.amap.com/tools/picker">高德地图坐标拾取系统</a> 、<a href="https://api.map.baidu.com/lbsapi/getpoint/index.html">百度地图坐标拾取系统</a></p><button type="button" class="tab-to-top" aria-label="scroll to top"><i class="fas fa-arrow-up"></i></button></div><div class="tab-item-content" id="分栏-3"><figure class="highlight markdown"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">&#123;% map 120.101101,30.239119 %&#125;</span><br><span class="line">&#123;% googleMap 120.101101,30.239119, 这里是西湖灵隐寺，据说求姻缘很灵验哦！ %&#125;</span><br><span class="line">&#123;% geoqMap 120.101101,30.239119, 这里是西湖灵隐寺，据说求姻缘很灵验哦！, 13, 90%, 320px, 3 %&#125;</span><br></pre></td></tr></table></figure><button type="button" class="tab-to-top" aria-label="scroll to top"><i class="fas fa-arrow-up"></i></button></div><div class="tab-item-content" id="分栏-4"><link rel="stylesheet" href="//unpkg.com/hexo-tag-map/lib/leaflet@1.7.1.css"><script data-pjax src="//unpkg.com/hexo-tag-map/lib/leaflet@1.7.1.js"></script><script data-pjax src="//unpkg.com/hexo-tag-map/lib/leaflet.ChineseTmsProviders@1.0.4.js"></script><div class="map-box" style="margin: 0.8rem 0 1.6rem 0;"><div id="map-120.101101-30.239119" style="max-width:100%; height:360px;display: block;margin:0 auto;z-index:1;border-radius: 5px;"></div></div><script type="text/javascript">var normalm=L.tileLayer.chinaProvider('GaoDe.Normal.Map',{maxZoom:20,minZoom:1,attribution:'高德地图'});var imgm=L.tileLayer.chinaProvider('GaoDe.Satellite.Map',{maxZoom:20,minZoom:1,attribution:'高德地图'});var imga=L.tileLayer.chinaProvider('GaoDe.Satellite.Annotion',{maxZoom:20,minZoom:1,attribution:'高德地图'});var normalMap=L.tileLayer.chinaProvider('Google.Normal.Map',{maxZoom:20,minZoom:1,attribution:'Google Maps'}),satelliteMap=L.tileLayer.chinaProvider('Google.Satellite.Map',{maxZoom:21,minZoom:1,attribution:'Google Maps'});routeMap=L.tileLayer.chinaProvider('Google.Satellite.Annotion',{maxZoom:21,minZoom:1});var normalMap=L.tileLayer.chinaProvider('Google.Normal.Map',{maxZoom:21,minZoom:1,attribution:'Google Maps'}),satelliteMap=L.tileLayer.chinaProvider('Google.Satellite.Map',{maxZoom:21,minZoom:1,attribution:'Google Maps'}),routeMap=L.tileLayer.chinaProvider('Google.Satellite.Annotion',{maxZoom:21,minZoom:1,attribution:'Google Maps'});var normalm1=L.tileLayer.chinaProvider('Geoq.Normal.Map',{maxZoom:21,minZoom:1,attribution:'GeoQ'});var normal=L.layerGroup([normalm]),image=L.layerGroup([imgm,imga]);var baseLayers={"高德地图":normal,"智图地图":normalm1,"谷歌地图":normalMap,"高德卫星地图":imgm,"谷歌卫星地图":satelliteMap,"高德卫星标注":image,"谷歌卫星标注":routeMap};var mymap=L.map('map-120.101101-30.239119',{center:[30.239119,120.101101],zoom:14,layers:[normal],zoomControl:false});L.control.layers(baseLayers,null).addTo(mymap);L.control.zoom({zoomInTitle:'放大',zoomOutTitle:'缩小'}).addTo(mymap);</script><br><link rel="stylesheet" href="//unpkg.com/hexo-tag-map/lib/leaflet@1.7.1.css"><script data-pjax src="//unpkg.com/hexo-tag-map/lib/leaflet@1.7.1.js"></script><script data-pjax src="//unpkg.com/hexo-tag-map/lib/leaflet.ChineseTmsProviders@1.0.4.js"></script><div id="googleMap-120.101101-30.239119" style="max-width:100%; height:360px;display: block;margin:0 auto;z-index:1;border-radius: 5px;"></div><script type="text/javascript">var normalMap=L.tileLayer.chinaProvider('Google.Normal.Map',{maxZoom:22,minZoom:1,attribution:'Google Maps'}),satelliteMap=L.tileLayer.chinaProvider('Google.Satellite.Map',{maxZoom:22,minZoom:1,attribution:'Google Maps'}),routeMap=L.tileLayer.chinaProvider('Google.Satellite.Annotion',{maxZoom:22,minZoom:1,attribution:'Google Maps'});var baseLayers={"谷歌地图":normalMap,"谷歌卫星图":satelliteMap,"谷歌卫星标注": routeMap};var overlayLayers={};var mymap=L.map("googleMap-120.101101-30.239119",{center:[30.239119,120.101101],zoom:14,layers:[normalMap],zoomControl:false});L.control.layers(baseLayers,null).addTo(mymap);L.control.zoom({zoomInTitle:'放大',zoomOutTitle:'缩小'}).addTo(mymap);var marker = L.marker(['30.239119','120.101101']).addTo(mymap);marker.bindPopup("这里是西湖灵隐寺，据说求姻缘很灵验哦！").openPopup();</script><br><link rel="stylesheet" href="//unpkg.com/hexo-tag-map/lib/leaflet@1.7.1.css"><script data-pjax src="//unpkg.com/hexo-tag-map/lib/leaflet@1.7.1.js"></script><script data-pjax src="//unpkg.com/hexo-tag-map/lib/leaflet.ChineseTmsProviders@1.0.4.js"></script><div id="geoqMap-120.101101-30.239119" style="max-width:90%; height:320px;display: block;margin:0 auto;z-index:1;border-radius: 5px;"></div><script type="text/javascript">var normalm1=L.tileLayer.chinaProvider('Geoq.Normal.Map',{maxZoom:20,minZoom:1,attribution:'GeoQ'});var normalm2=L.tileLayer.chinaProvider('Geoq.Normal.PurplishBlue',{maxZoom:20,minZoom:1,attribution:'GeoQ'});var normalm3=L.tileLayer.chinaProvider('Geoq.Normal.Gray',{maxZoom:20,minZoom:1,attribution:'GeoQ'});var normalm4=L.tileLayer.chinaProvider('Geoq.Normal.Warm',{maxZoom:20,minZoom:1,attribution:'GeoQ'});var normalm5=L.tileLayer.chinaProvider('Geoq.Theme.Hydro',{maxZoom:20,minZoom:1,attribution:'GeoQ'});var normal=L.layerGroup([normalm1,normalm2,normalm3,normalm4,normalm5]);var baseLayers={"智图地图":normalm1,"午夜蓝":normalm2,"灰色":normalm3,"暖色":normalm4,"水系":normalm5};var mymap=L.map("geoqMap-120.101101-30.239119",{center:[30.239119,120.101101],zoom:13,layers:[normalm3],zoomControl:false});L.control.layers(baseLayers,null).addTo(mymap);L.control.zoom({zoomInTitle:'放大',zoomOutTitle:'缩小'}).addTo(mymap);var marker = L.marker(['30.239119','120.101101']).addTo(mymap);marker.bindPopup("这里是西湖灵隐寺，据说求姻缘很灵验哦！").openPopup();</script><br><button type="button" class="tab-to-top" aria-label="scroll to top"><i class="fas fa-arrow-up"></i></button></div></div></div><h2 id="2-31-隐藏块">2.31 隐藏块</h2><div class="tabs" id="分栏"><ul class="nav-tabs"><li class="tab active"><button type="button" data-href="#分栏-1">标签语法</button></li><li class="tab"><button type="button" data-href="#分栏-2">参数配置</button></li><li class="tab"><button type="button" data-href="#分栏-3">示例源码</button></li><li class="tab"><button type="button" data-href="#分栏-4">渲染演示</button></li></ul><div class="tab-contents"><div class="tab-item-content active" id="分栏-1"><figure class="highlight markdown"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">&#123;% hideBlock display,bg,color %&#125;</span><br><span class="line">content</span><br><span class="line">&#123;% endhideBlock %&#125;</span><br></pre></td></tr></table></figure><button type="button" class="tab-to-top" aria-label="scroll to top"><i class="fas fa-arrow-up"></i></button></div><div class="tab-item-content" id="分栏-2"><ol><li>content：要隐藏的内容</li><li>display：展示前按钮显示的文字（可选）</li><li>bg：按钮的背景颜色（可选）</li><li>color：按钮显示的文字的颜色（可选）</li></ol><button type="button" class="tab-to-top" aria-label="scroll to top"><i class="fas fa-arrow-up"></i></button></div><div class="tab-item-content" id="分栏-3"><figure class="highlight markdown"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">&#123;% hideBlock 点我预览, blue %&#125;</span><br><span class="line">这里有张图片：</span><br><span class="line"><span class="language-xml"><span class="tag">&lt;<span class="name">img</span> <span class="attr">src</span>=<span class="string">&quot;https://s1.vika.cn/space/2022/10/30/b35fce448bc9404a8d65c3ce1e6e46eb&quot;</span> <span class="attr">alt</span>=<span class="string">&quot;image (1)&quot;</span> <span class="attr">style</span>=<span class="string">&quot;zoom:67%;&quot;</span> /&gt;</span></span></span><br><span class="line">&#123;% endhideBlock %&#125;</span><br></pre></td></tr></table></figure><button type="button" class="tab-to-top" aria-label="scroll to top"><i class="fas fa-arrow-up"></i></button></div><div class="tab-item-content" id="分栏-4"><div class="hide-block"><button type="button" class="hide-button" style="background-color:  blue;">点我预览    </button><div class="hide-content"><p>这里有张图片：<br><img src="https://s1.vika.cn/space/2022/10/30/b35fce448bc9404a8d65c3ce1e6e46eb" alt="image (1)" style="zoom:67%;" /></p></div></div><button type="button" class="tab-to-top" aria-label="scroll to top"><i class="fas fa-arrow-up"></i></button></div></div></div>]]></content>
      
      
      <categories>
          
          <category> 演示 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Markdown </tag>
            
            <tag> 外挂标签 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Hot100刷题笔记</title>
      <link href="/posts/2023-06-09-Hot100%E5%88%B7%E9%A2%98%E7%AC%94%E8%AE%B0.html"/>
      <url>/posts/2023-06-09-Hot100%E5%88%B7%E9%A2%98%E7%AC%94%E8%AE%B0.html</url>
      
        <content type="html"><![CDATA[<h1>哈希</h1><h2 id="✅两数之和">✅两数之和</h2><p><a href="https://leetcode.cn/problems/two-sum/submissions/603809505/?envType=study-plan-v2&amp;envId=top-100-liked">1. 两数之和 - 力扣（LeetCode）</a></p><h2 id="✅字母异位词分组">✅字母异位词分组</h2><p>格式输入处理看一下</p><p><a href="https://leetcode.cn/problems/group-anagrams/description/?envType=study-plan-v2&amp;envId=top-100-liked">49. 字母异位词分组 - 力扣（LeetCode）</a></p><h2 id="✅最长连续序列">✅最长连续序列</h2><p><a href="https://leetcode.cn/problems/longest-consecutive-sequence/description/?envType=study-plan-v2&amp;envId=top-100-liked">128. 最长连续序列 - 力扣（LeetCode）</a></p><p>遍历set减少而不应该遍历num，因为nums重复问题导致的超时</p><h1>双指针</h1><h2 id="✅移动零">✅移动零</h2><p>没想明白left和right之间的关系</p><p><strong>循环不变量的思想</strong></p><p><a href="https://leetcode.cn/problems/move-zeroes/description/?envType=study-plan-v2&amp;envId=top-100-liked">283. 移动零 - 力扣（LeetCode）</a></p><h2 id="❎盛最多水的容器">❎盛最多水的容器</h2><p><a href="https://leetcode.cn/problems/container-with-most-water/?envType=study-plan-v2&amp;envId=top-100-liked">11. 盛最多水的容器 - 力扣（LeetCode）</a></p><p><strong>left和right该如何更新</strong></p><h2 id="❎三数之和">❎三数之和</h2><p><a href="https://leetcode.cn/problems/3sum/?envType=study-plan-v2&amp;envId=top-100-liked">15. 三数之和 - 力扣（LeetCode）</a></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">* 关键：</span><br><span class="line">*  <span class="number">1.</span>去重那里很容易写错</span><br><span class="line">*  <span class="number">2.</span>三个指针该怎么移动？第一个指针（left）是不用写<span class="keyword">while</span>的</span><br></pre></td></tr></table></figure><h2 id="✅接雨水">✅接雨水</h2><p><a href="https://leetcode.cn/problems/trapping-rain-water/description/?envType=study-plan-v2&amp;envId=top-100-liked">42. 接雨水 - 力扣（LeetCode）</a></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">这个和单调栈还是有些不同，用的是DP的无后效性</span><br></pre></td></tr></table></figure><h1>滑动窗口</h1><h2 id="✅无重复字符的最长子串">✅无重复字符的最长子串</h2><p><a href="https://leetcode.cn/problems/longest-substring-without-repeating-characters/description/?envType=study-plan-v2&amp;envId=top-100-liked">3. 无重复字符的最长子串 - 力扣（LeetCode）</a></p><h2 id="❎找到字符串中所有字母异位词">❎找到字符串中所有字母异位词</h2><p><a href="https://leetcode.cn/problems/find-all-anagrams-in-a-string/description/?envType=study-plan-v2&amp;envId=top-100-liked">438. 找到字符串中所有字母异位词 - 力扣（LeetCode）</a></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">* 滑动窗口技巧：</span><br><span class="line">*      初始窗口为<span class="number">0</span></span><br><span class="line">*      入窗</span><br><span class="line">*      维护窗口（窗口大小一定才维护，让left++）</span><br><span class="line">*      窗口扩大</span><br></pre></td></tr></table></figure><h1>子串</h1><h2 id="❎和为-K-的子数组">❎和为 K 的子数组</h2><p><a href="https://leetcode.cn/problems/subarray-sum-equals-k/description/?envType=study-plan-v2&amp;envId=top-100-liked">560. 和为 K 的子数组 - 力扣（LeetCode）</a></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">* 看到连续，三种思路：</span><br><span class="line">*      前缀和</span><br><span class="line">*      滑动窗口</span><br><span class="line">*      dp</span><br><span class="line">* 这题一直想用滑动窗口做，却怎么样也想不出，直接寄掉了</span><br><span class="line">和最大子数组和LC53搞混了</span><br></pre></td></tr></table></figure><h2 id="❎❓⭐️滑动窗口最大值">❎❓⭐️滑动窗口最大值</h2><p><a href="https://leetcode.cn/problems/sliding-window-maximum/description/?envType=study-plan-v2&amp;envId=top-100-liked">239. 滑动窗口最大值 - 力扣（LeetCode）</a></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">采用的暴力做法，虽然不会超时，但是时间复杂度是O(nk)，手撕肯定是不行的</span><br><span class="line">List转<span class="type">int</span>[]</span><br><span class="line">    :res.stream().mapToInt(Integer::intValue).toArray();</span><br></pre></td></tr></table></figure><h2 id="❎❓⭐️最小覆盖子串">❎❓⭐️最小覆盖子串</h2><p><a href="https://leetcode.cn/problems/minimum-window-substring/description/?envType=study-plan-v2&amp;envId=top-100-liked">76. 最小覆盖子串 - 力扣（LeetCode）</a></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">* 连续应该想到滑动窗口，但是不定长的滑动窗口不知道该怎么更新</span><br><span class="line">* 技巧：</span><br><span class="line">    滑动窗口，定义一个right，一直往右移动</span><br><span class="line">    可以直接通过ascal码值判断是否覆盖</span><br></pre></td></tr></table></figure><h1>普通数组</h1><h2 id="✅⭐️最大子数组和">✅⭐️最大子数组和</h2><p><a href="https://leetcode.cn/problems/maximum-subarray/description/?envType=study-plan-v2&amp;envId=top-100-liked">53. 最大子数组和 - 力扣（LeetCode）</a></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">* 腾讯提前批手撕：</span><br><span class="line">* 看到连续子数组：</span><br><span class="line">*      前缀和暴力</span><br><span class="line">*      滑动窗口</span><br><span class="line">*      dp:看能不能分解成子问题</span><br><span class="line">*          以i结尾的dp[i]可以由以dp[i-<span class="number">1</span>]的子问题转化而来</span><br></pre></td></tr></table></figure><h2 id="❎合并区间">❎合并区间</h2><p><a href="https://leetcode.cn/problems/merge-intervals/description/?envType=study-plan-v2&amp;envId=top-100-liked">56. 合并区间 - 力扣（LeetCode）</a></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">* 优先队列的使用：</span><br><span class="line">*      Queue&lt;<span class="type">int</span>[]&gt; queue = <span class="keyword">new</span> <span class="title class_">PriorityQueue</span>&lt;&gt;((a,b)-&gt; a[<span class="number">0</span>] - b[<span class="number">0</span>]);</span><br><span class="line">* 怎么样将List&lt;<span class="type">int</span>[]&gt; 转成 <span class="type">int</span>[][],使用重载的toArray方法：</span><br><span class="line">*      res.toArray(<span class="keyword">new</span> <span class="title class_">int</span>[res.size()][]);</span><br><span class="line">* 更新去间的右值应该更新两者之间最大的那个：</span><br><span class="line">*      <span class="comment">// 这里注意更新最大值，避免[1,5]、[2,3]合并成[1,3]</span></span><br><span class="line">*                 last[<span class="number">1</span>] = Math.max(x[<span class="number">1</span>],last[<span class="number">1</span>]);</span><br></pre></td></tr></table></figure><h2 id="✅轮转数组">✅轮转数组</h2><p><a href="https://leetcode.cn/problems/rotate-array/description/?envType=study-plan-v2&amp;envId=top-100-liked">189. 轮转数组 - 力扣（LeetCode）</a></p><p>优化不会</p><p>不使用额外数组的技巧</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">rotate</span><span class="params">(<span class="type">int</span>[] nums, <span class="type">int</span> k)</span> &#123;</span><br><span class="line">        <span class="type">int</span> <span class="variable">n</span> <span class="operator">=</span> nums.length;</span><br><span class="line">        k %= n; <span class="comment">// 轮转 k 次等于轮转 k % n 次</span></span><br><span class="line">        reverse(nums, <span class="number">0</span>, n - <span class="number">1</span>);</span><br><span class="line">        reverse(nums, <span class="number">0</span>, k - <span class="number">1</span>);</span><br><span class="line">        reverse(nums, k, n - <span class="number">1</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">void</span> <span class="title function_">reverse</span><span class="params">(<span class="type">int</span>[] nums, <span class="type">int</span> i, <span class="type">int</span> j)</span> &#123;</span><br><span class="line">        <span class="keyword">while</span> (i &lt; j) &#123;</span><br><span class="line">            <span class="type">int</span> <span class="variable">temp</span> <span class="operator">=</span> nums[i];</span><br><span class="line">            nums[i++] = nums[j];</span><br><span class="line">            nums[j--] = temp;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="✅除自身以外数组的乘积">✅除自身以外数组的乘积</h2><p><a href="https://leetcode.cn/problems/product-of-array-except-self/description/?envType=study-plan-v2&amp;envId=top-100-liked">238. 除自身以外数组的乘积 - 力扣（LeetCode）</a></p><p>前缀和思想：</p><p>leftMuti[i]不包含i的左累计乘值</p><h2 id="❎缺失的第一个正数">❎缺失的第一个正数</h2><p><a href="https://leetcode.cn/problems/first-missing-positive/description/?envType=study-plan-v2&amp;envId=top-100-liked">41. 缺失的第一个正数 - 力扣（LeetCode）</a></p><p><em>下标对应问题可以在注释里举一个例子，可以方便理解</em> <em>陌生的index,要注意数组越界问题</em> <em>for中操纵i指针，注意死循环问题，如果不用交换，就不要交换</em></p><p>类似数组交换题：<a href="https://leetcode.cn/problems/find-the-duplicate-number/description/?envType=study-plan-v2&amp;envId=top-100-liked">287. 寻找重复数 - 力扣（LeetCode）</a></p><h1>矩阵</h1><h2 id="✅‼️矩阵置零">✅‼️矩阵置零</h2><p><a href="https://leetcode.cn/problems/set-matrix-zeroes/description/?envType=study-plan-v2&amp;envId=top-100-liked">73. 矩阵置零 - 力扣（LeetCode）</a></p><p>使用了额外空间，不知道常量空间的做法</p><h2 id="❎螺旋矩阵">❎螺旋矩阵</h2><p><a href="https://leetcode.cn/problems/spiral-matrix/description/?envType=study-plan-v2&amp;envId=top-100-liked">54. 螺旋矩阵 - 力扣（LeetCode）</a></p><p>走过的路径忘记标记走过</p><p>count等于0多走了一次循环</p><h2 id="✅⭐️旋转图像">✅⭐️旋转图像</h2><p><a href="https://leetcode.cn/problems/rotate-image/description/?envType=study-plan-v2&amp;envId=top-100-liked">48. 旋转图像 - 力扣（LeetCode）</a></p><p>技巧：先上下翻转，再斜着翻转</p><h2 id="✅⭐️搜索二维矩阵-II">✅⭐️搜索二维矩阵 II</h2><p><a href="https://leetcode.cn/problems/search-a-2d-matrix-ii/description/?envType=study-plan-v2&amp;envId=top-100-liked">240. 搜索二维矩阵 II - 力扣（LeetCode）</a></p><p>技巧：斜着看，从左下角往上找</p><h1>链表</h1><h2 id="1-✅相交链表">1.✅相交链表</h2><p><a href="https://leetcode.cn/problems/intersection-of-two-linked-lists/description/?envType=study-plan-v2&amp;envId=top-100-liked">160. 相交链表 - 力扣（LeetCode）</a></p><h2 id="2-❎反转链表">2.❎反转链表</h2><p><strong>头插法是新建头结点，区别于哨兵节点要负责：dummy.next = head，不然会死循环！</strong></p><p><a href="https://leetcode.cn/problems/reverse-linked-list/description/?envType=study-plan-v2&amp;envId=top-100-liked">206. 反转链表 - 力扣（LeetCode）</a></p><h2 id="3-✅回文链表">3.✅回文链表</h2><p><a href="https://leetcode.cn/problems/palindrome-linked-list/description/?envType=study-plan-v2&amp;envId=top-100-liked">234. 回文链表 - 力扣（LeetCode）</a></p><h2 id="4-❎环形链表">4.❎环形链表</h2><p><a href="https://leetcode.cn/problems/linked-list-cycle/description/?envType=study-plan-v2&amp;envId=top-100-liked">141. 环形链表 - 力扣（LeetCode）</a></p><p>写完没自己带入检查，导致没进去循环</p><h2 id="5-❎环形链表-II">5.❎环形链表 II</h2><p><a href="https://leetcode.cn/problems/linked-list-cycle-ii/description/?envType=study-plan-v2&amp;envId=top-100-liked">142. 环形链表 II - 力扣（LeetCode）</a></p><p>1.快慢指针最好从一个起点开始遍历，在循环中遍历完再终止</p><p>2.在第一次相遇之后，快指针回到起点，以相同速度走，会到相遇起点</p><h2 id="6-✅合并两个有序链表">6.✅合并两个有序链表</h2><p><a href="https://leetcode.cn/problems/merge-two-sorted-lists/description/?envType=study-plan-v2&amp;envId=top-100-liked">21. 合并两个有序链表 - 力扣（LeetCode）</a></p><h2 id="7-✅两数相加">7.✅两数相加</h2><p><a href="https://leetcode.cn/problems/add-two-numbers/description/?envType=study-plan-v2&amp;envId=top-100-liked">2. 两数相加 - 力扣（LeetCode）</a></p><p><strong>在循环里更新的东西一定不能忘，不然死循环</strong></p><p><strong>取余和除分两次操作，先计算相加值</strong></p><h2 id="8-✅删除链表的倒数第-N-个结点">8.✅删除链表的倒数第 N 个结点</h2><p><a href="https://leetcode.cn/problems/remove-nth-node-from-end-of-list/description/?envType=study-plan-v2&amp;envId=top-100-liked">19. 删除链表的倒数第 N 个结点 - 力扣（LeetCode）</a></p><p>因为删除后可能为空，所以哨兵节点很方便，要注意极限情况（节点个数为1）</p><h2 id="9-✅两两交换链表的节点">9.✅两两交换链表的节点</h2><p><a href="https://leetcode.cn/problems/swap-nodes-in-pairs/description/?envType=study-plan-v2&amp;envId=top-100-liked">24. 两两交换链表中的节点 - 力扣（LeetCode）</a></p><p>哨兵节点的应用</p><p>在注释中举一个例子可以很方便理解</p><h2 id="10-❎K-个一组翻转链表">10.❎K 个一组翻转链表</h2><p><a href="https://leetcode.cn/problems/reverse-nodes-in-k-group/description/?envType=study-plan-v2&amp;envId=top-100-liked">25. K 个一组翻转链表 - 力扣（LeetCode）</a></p><p>空指针问题一定要高度敏感，看到p.next要仔细考虑考虑p可不可能为空</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">for</span>(<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>;i &lt; k;i++)&#123;</span><br><span class="line">    <span class="comment">// 这个判断很重要</span></span><br><span class="line">    <span class="keyword">if</span>(last == <span class="literal">null</span>) <span class="keyword">break</span>;</span><br><span class="line">    last = last.next;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="11-✅随机链表的复制">11.✅随机链表的复制</h2><p><a href="https://leetcode.cn/problems/copy-list-with-random-pointer/description/?envType=study-plan-v2&amp;envId=top-100-liked">138. 随机链表的复制 - 力扣（LeetCode）</a></p><h2 id="12-❎⭐️排序链表">12.❎⭐️排序链表</h2><p><a href="https://leetcode.cn/problems/sort-list/description/?envType=study-plan-v2&amp;envId=top-100-liked">148. 排序链表 - 力扣（LeetCode）</a></p><p>一开始没有思路，但是看到评论用归并排序，马上就有思路了，有点急躁。然后while中老是忘记东西，比如：<strong>tail = tail.next;</strong></p><p><em>常数空间 + O(n*log)应该想到归并排序</em></p><h2 id="13-✅合并-K-个升序链表">13.✅合并 K 个升序链表</h2><p><a href="https://leetcode.cn/problems/merge-k-sorted-lists/description/?envType=study-plan-v2&amp;envId=top-100-liked">23. 合并 K 个升序链表 - 力扣（LeetCode）</a></p><p>很正常的归并排序思想，在注释上写测试用例的执行过程，思路会很清晰</p><h2 id="14-❎‼️⭐️LRU缓存">14.❎‼️⭐️LRU缓存</h2><p><a href="https://leetcode.cn/problems/lru-cache/description/?envType=study-plan-v2&amp;envId=top-100-liked">146. LRU 缓存 - 力扣（LeetCode）</a></p><p><em>LRU缓存</em> <em>1.哨兵节点应该也是双向的，pre指向末尾节点</em> <em>2.put相同值也算使用，要更新到最前面</em> <em>3.双向链表的操作还得再熟悉熟悉</em></p><p><img src="https://mcnfxurl5vzo.feishu.cn/space/api/box/stream/download/asynccode/?code=NjFmZDBhNGZjMDM0NjE2ZmQ3MDM2M2EyZGM3ZGQyODBfcUIydlNCZVQ0SGY1MjkyV2tZV2pjaEN6Y3k2ME9nZDhfVG9rZW46TXpEcGI1VWZ6b3R2UDB4OW1OYWNSVHN5bmJnXzE3NDMzODQyNzk6MTc0MzM4Nzg3OV9WNA" alt="img"></p><h1>二叉树</h1><h2 id="1-✅二叉树的中序遍历">1.✅二叉树的中序遍历</h2><p><a href="https://leetcode.cn/problems/binary-tree-inorder-traversal/description/?envType=study-plan-v2&amp;envId=top-100-liked">94. 二叉树的中序遍历 - 力扣（LeetCode）</a></p><p>二叉树的遍历：</p><p>有返回值</p><p>无返回值</p><h2 id="2-✅二叉树的最大深度">2.✅二叉树的最大深度</h2><p><a href="https://leetcode.cn/problems/maximum-depth-of-binary-tree/description/?envType=study-plan-v2&amp;envId=top-100-liked">104. 二叉树的最大深度 - 力扣（LeetCode）</a></p><h2 id="3-✅翻转二叉树">3.✅翻转二叉树</h2><p><a href="https://leetcode.cn/problems/invert-binary-tree/description/?envType=study-plan-v2&amp;envId=top-100-liked">226. 翻转二叉树 - 力扣（LeetCode）</a></p><h2 id="4-✅对称二叉树">4.✅对称二叉树</h2><p><a href="https://leetcode.cn/problems/symmetric-tree/description/?envType=study-plan-v2&amp;envId=top-100-liked">101. 对称二叉树 - 力扣（LeetCode）</a></p><h2 id="5-✅二叉树的直径">5.✅二叉树的直径</h2><p><a href="https://leetcode.cn/problems/diameter-of-binary-tree/description/?envType=study-plan-v2&amp;envId=top-100-liked">543. 二叉树的直径 - 力扣（LeetCode）</a></p><h2 id="6-✅二叉树的层序遍历">6.✅二叉树的层序遍历</h2><p><a href="https://leetcode.cn/problems/binary-tree-level-order-traversal/description/?envType=study-plan-v2&amp;envId=top-100-liked">102. 二叉树的层序遍历 - 力扣（LeetCode）</a></p><p>在层序遍历中先利用变量n把每一层的节点遍历</p><h2 id="7-❎-没思路-将有序数组转换为二叉搜索树">7.❎[没思路]将有序数组转换为二叉搜索树</h2><p><a href="https://leetcode.cn/problems/convert-sorted-array-to-binary-search-tree/description/?envType=study-plan-v2&amp;envId=top-100-liked">108. 将有序数组转换为二叉搜索树 - 力扣（LeetCode）</a></p><p>看到<strong>有序</strong>，为了利用这个特性，应该要用<strong>二分</strong>的</p><h2 id="8-❎-98-验证二叉搜索树">8.❎[98%]验证二叉搜索树</h2><p><a href="https://leetcode.cn/problems/validate-binary-search-tree/description/?envType=study-plan-v2&amp;envId=top-100-liked">98. 验证二叉搜索树 - 力扣（LeetCode）</a></p><p><strong>[minVal，maxVal]要用Long</strong>，且不能等于，等于不是二叉搜索树</p><h2 id="9-✅二叉搜索树中第-K-小的元素">9.✅二叉搜索树中第 K 小的元素</h2><p><a href="https://leetcode.cn/problems/kth-smallest-element-in-a-bst/description/?envType=study-plan-v2&amp;envId=top-100-liked">230. 二叉搜索树中第 K 小的元素 - 力扣（LeetCode）</a></p><p><strong>第k小用大根堆，把比堆顶小的元素都插进堆里</strong></p><p><strong>第k大用小根堆，把比堆顶大的元素都插进堆里</strong></p><h2 id="10-✅二叉树的右视图">10.✅二叉树的右视图</h2><p><a href="https://leetcode.cn/problems/binary-tree-right-side-view/description/?envType=study-plan-v2&amp;envId=top-100-liked">199. 二叉树的右视图 - 力扣（LeetCode）</a></p><p>先序遍历 + 全局动态数组，动态数组的更新用list.set(index,val)</p><h2 id="11-✅二叉树展开为链表">11.✅二叉树展开为链表</h2><p><a href="https://leetcode.cn/problems/flatten-binary-tree-to-linked-list/description/?envType=study-plan-v2&amp;envId=top-100-liked">114. 二叉树展开为链表 - 力扣（LeetCode）</a></p><h2 id="12-❎‼️❓-完全没思路-从前序与中序遍历序列构造二叉树">12.❎‼️❓[完全没思路]从前序与中序遍历序列构造二叉树</h2><p><a href="https://leetcode.cn/problems/construct-binary-tree-from-preorder-and-inorder-traversal/description/?envType=study-plan-v2&amp;envId=top-100-liked">105. 从前序与中序遍历序列构造二叉树 - 力扣（LeetCode）</a></p><p>递归的构建左子树，通过中序遍历，找到每次的左右区间。</p><p><strong>先在注释里画图，便于理解！</strong></p><h2 id="13-❎-80-路径总和-III">13.❎[80%]路径总和 III</h2><p><a href="https://leetcode.cn/problems/path-sum-iii/description/?envType=study-plan-v2&amp;envId=top-100-liked">437. 路径总和 III - 力扣（LeetCode）</a></p><p><strong>这里必须要用long,看数据范围10^9可能会数组越界</strong></p><p>注意考虑<strong>单节点</strong></p><p>能用 <strong>new ArrayList(numList)</strong>，不然会有重复值</p><h2 id="14-❎-没思路-二叉树的最近公共祖先">14.❎[没思路]二叉树的最近公共祖先</h2><p><a href="https://leetcode.cn/problems/lowest-common-ancestor-of-a-binary-tree/description/?envType=study-plan-v2&amp;envId=top-100-liked">236. 二叉树的最近公共祖先 - 力扣（LeetCode）</a></p><p><strong>1.叶子节点逐层返回的要么是null，要么是p和q之中的一个</strong></p><p><strong>2.⭐️如果遍历到了p或q剩下的就不用再遍历了，直接返回就行。此时root.left = p,root.right = null;</strong></p><h2 id="15-❎-90-二叉树中的最大路径和">15.❎[90%]二叉树中的最大路径和</h2><p><a href="https://leetcode.cn/problems/binary-tree-maximum-path-sum/description/?envType=study-plan-v2&amp;envId=top-100-liked">124. 二叉树中的最大路径和 - 力扣（LeetCode）</a></p><p>从下往上传的left,right如果是负数，要直接置为0</p><p><strong>left = left &lt; 0 ? 0 : left;</strong></p><p><strong>right = right &lt; 0 ? 0 : right;</strong></p><h1>图论</h1><h2 id="1-✅岛屿数量">1.✅岛屿数量</h2><p><a href="https://leetcode.cn/problems/number-of-islands/description/?envType=study-plan-v2&amp;envId=top-100-liked">200. 岛屿数量 - 力扣（LeetCode）</a></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">dfs</span><span class="params">(<span class="type">char</span>[][] grid,<span class="type">int</span> i,<span class="type">int</span> j)</span>&#123;</span><br><span class="line">    <span class="comment">// 右边是大于等于</span></span><br><span class="line">    <span class="keyword">if</span>(i &lt; <span class="number">0</span> || i &gt;= grid.length || j &lt; <span class="number">0</span> || j &gt;= grid[<span class="number">0</span>].length || grid[i][j] == <span class="string">&#x27;0&#x27;</span>) <span class="keyword">return</span>;</span><br><span class="line">    grid[i][j] = <span class="string">&#x27;0&#x27;</span>;</span><br><span class="line">    dfs(grid,i - <span class="number">1</span>,j);</span><br><span class="line">    dfs(grid,i + <span class="number">1</span>,j);</span><br><span class="line">    dfs(grid,i,j - <span class="number">1</span>);</span><br><span class="line">    dfs(grid,i,j + <span class="number">1</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>右边是大于等于</p><h2 id="2-✅腐烂的橘子">2.✅腐烂的橘子</h2><p><a href="https://leetcode.cn/problems/rotting-oranges/description/?envType=study-plan-v2&amp;envId=top-100-liked">994. 腐烂的橘子 - 力扣（LeetCode）</a></p><p>核心就是先int qn = queue.size()，再遍历qn</p><h2 id="3-❎⭐️-70-课程表">3.❎⭐️[70%]课程表</h2><p><a href="https://leetcode.cn/problems/course-schedule/description/?envType=study-plan-v2&amp;envId=top-100-liked">207. 课程表 - 力扣（LeetCode）</a></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">List&lt;Integer&gt; list = relMap.get(x);</span><br><span class="line"><span class="comment">// 不这样写，会有null的风险</span></span><br><span class="line"><span class="keyword">if</span>(list == <span class="literal">null</span>) <span class="keyword">continue</span>;</span><br><span class="line"><span class="keyword">for</span>(<span class="type">int</span> r : list)&#123;</span><br><span class="line">    inDu[r]--;</span><br><span class="line">    <span class="keyword">if</span>(inDu[r] == <span class="number">0</span>)&#123;</span><br><span class="line">        <span class="comment">// 这里是插入r而不是inDu[r]</span></span><br><span class="line">        queue.add(r);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="4-✅⭐️实现-Trie-前缀树">4.✅⭐️实现 Trie (前缀树)</h2><p><a href="https://leetcode.cn/problems/implement-trie-prefix-tree/description/?envType=study-plan-v2&amp;envId=top-100-liked">208. 实现 Trie (前缀树) - 力扣（LeetCode）</a></p><p>技巧在于用一个isEnd变量标记当前节点是否可以是叶子节点</p><h1>回溯</h1><h2 id="1-✅全排列">1.✅全排列</h2><p><a href="https://leetcode.cn/problems/permutations/description/?envType=study-plan-v2&amp;envId=top-100-liked">46. 全排列 - 力扣（LeetCode）</a></p><p>无重复数字比较简单，有重复数组该怎么去重呢</p><h2 id="2-✅子集">2.✅子集</h2><p><a href="https://leetcode.cn/problems/subsets/description/?envType=study-plan-v2&amp;envId=top-100-liked">78. 子集 - 力扣（LeetCode）</a></p><h2 id="3-✅电话号码的字母组合">3.✅电话号码的字母组合</h2><p><a href="https://leetcode.cn/problems/letter-combinations-of-a-phone-number/description/?envType=study-plan-v2&amp;envId=top-100-liked">17. 电话号码的字母组合 - 力扣（LeetCode）</a></p><p>输入的边界情况要考虑</p><p>字符串数组赋值要在方法体例赋值</p><h2 id="4-✅-要调试-组合总数">4.✅[要调试]组合总数</h2><p><a href="https://leetcode.cn/problems/combination-sum/description/?envType=study-plan-v2&amp;envId=top-100-liked">39. 组合总和 - 力扣（LeetCode）</a></p><p>1.解决组合问题重复的方法，可以先排序，<strong>然后给每次递归一个起始点，只能从这里开始递归</strong> 2.出现stack over flow : 不应该在回溯回滚状态的时候再一次进行dfs的 3.加注释方便理解</p><h2 id="5-❎-要调试，栈溢出-括号生成">5.❎[要调试，栈溢出]括号生成</h2><p><a href="https://leetcode.cn/problems/generate-parentheses/description/?envType=study-plan-v2&amp;envId=top-100-liked">22. 括号生成 - 力扣（LeetCode）</a></p><p>栈溢出：没有return;</p><p>必须要时刻保证左括号数要大于等于右括号数</p><h2 id="6-❎⭐️-粗心-单词搜索">6.❎⭐️[粗心]单词搜索</h2><p><a href="https://leetcode.cn/problems/word-search/description/?envType=study-plan-v2&amp;envId=top-100-liked">79. 单词搜索 - 力扣（LeetCode）</a></p><p>1.粗心大意，没有整理好自己的模板，i，j，k变量写着写着就混淆。<strong>要用好的变量命名</strong></p><p>2.别忘记起点也要标记</p><h2 id="7-❎❓分割回文串">7.❎❓分割回文串</h2><p><a href="https://leetcode.cn/problems/palindrome-partitioning/description/?envType=study-plan-v2&amp;envId=top-100-liked">131. 分割回文串 - 力扣（LeetCode）</a></p><p>第一眼没思路，其实是和《子集那题差不多的》，选一个起点start，start左边的都是已经是回文的，这样就将大问题分解成了小问题</p><h2 id="8-❎-90-N皇后">8.❎[90%]N皇后</h2><p><a href="https://leetcode.cn/problems/n-queens/description/?envType=study-plan-v2&amp;envId=top-100-liked">51. N 皇后 - 力扣（LeetCode）</a></p><p>判断斜线必须要用两个set不然会重复</p><p>一直忘记return;</p><p>行列是(r,c)</p><h1>二分查找</h1><h2 id="1-✅搜索插入位置">1.✅搜索插入位置</h2><p><a href="https://leetcode.cn/problems/search-insert-position/description/?envType=study-plan-v2&amp;envId=top-100-liked">35. 搜索插入位置 - 力扣（LeetCode）</a></p><h2 id="2-✅搜索二维矩阵">2.✅搜索二维矩阵</h2><p><a href="https://leetcode.cn/problems/search-a-2d-matrix/description/?envType=study-plan-v2&amp;envId=top-100-liked">74. 搜索二维矩阵 - 力扣（LeetCode）</a></p><p>点从二维到一维：</p><p>Z = i * n + J</p><p>I = Z / n</p><p>J = Z - I * n</p><h2 id="3-✅在排序数组中查找元素的第一个和最后一个位置">3.✅在排序数组中查找元素的第一个和最后一个位置</h2><p><a href="https://leetcode.cn/problems/find-first-and-last-position-of-element-in-sorted-array/description/?envType=study-plan-v2&amp;envId=top-100-liked">34. 在排序数组中查找元素的第一个和最后一个位置 - 力扣（LeetCode）</a></p><p>要把所有用例都看完，考虑不存在返回-1的情况</p><h2 id="4-❎⭐️搜索旋转排序数组">4.❎⭐️搜索旋转排序数组</h2><p><a href="https://leetcode.cn/problems/search-in-rotated-sorted-array/description/?envType=study-plan-v2&amp;envId=top-100-liked">33. 搜索旋转排序数组 - 力扣（LeetCode）</a></p><p><strong>二分的红蓝区间不一定是要有序的，可以抽象的表示一个概念，比如target左侧或者右侧</strong></p><p>二分每次要么更新left，要么更新right，这题太复杂，可以分类讨论更新蓝色的情况，不是蓝色就是红色</p><p>更新规则： target …mid …</p><p>这个时候mid右边都是蓝色：right = mid</p><h2 id="5-✅寻找旋转排序数组中的最小值">5.✅寻找旋转排序数组中的最小值</h2><p><a href="https://leetcode.cn/problems/find-minimum-in-rotated-sorted-array/description/?envType=study-plan-v2&amp;envId=top-100-liked">153. 寻找旋转排序数组中的最小值 - 力扣（LeetCode）</a></p><p><strong>循环不变量：</strong></p><p>数组的最后一个数要么是最小值，要么是最小值右边，而采用开区间，right最后一定是指向最小值的，所以每次判断**nums[mid] &lt;= nums[n - 1]**就更新right为mid</p><h2 id="6-❎‼️⭐️寻找两个正序数组的中位数">6.❎‼️⭐️寻找两个正序数组的中位数</h2><p><a href="https://leetcode.cn/problems/median-of-two-sorted-arrays/description/?envType=study-plan-v2&amp;envId=top-100-liked">4. 寻找两个正序数组的中位数 - 力扣（LeetCode）</a></p><p>nums1和nums2交换，防止数组越界</p><p>i,j从0开始，左边元素个数为(i + 1) + (j + 1) = (m + n + 1) / 2</p><p>(m + n + 1) / 2 向上取整，确保左边元素比右边多一个，避免奇偶讨论</p><h1>栈</h1><h2 id="1-❎-粗心-有效的括号">1.❎[粗心]有效的括号</h2><p><a href="https://leetcode.cn/problems/valid-parentheses/description/?envType=study-plan-v2&amp;envId=top-100-liked">20. 有效的括号 - 力扣（LeetCode）</a></p><p>写完代码检查下，continue漏掉了</p><p>结尾不应该直接返回true，而是应该返回栈是否为空的标志</p><h2 id="2-✅最小栈">2.✅最小栈</h2><p><a href="https://leetcode.cn/problems/min-stack/description/?envType=study-plan-v2&amp;envId=top-100-liked">155. 最小栈 - 力扣（LeetCode）</a></p><p>栈内同时保存最小值即可</p><h2 id="3-❎‼️⭐️字符串解码">3.❎‼️⭐️字符串解码</h2><p><a href="https://leetcode.cn/problems/decode-string/description/?envType=study-plan-v2&amp;envId=top-100-liked">394. 字符串解码 - 力扣（LeetCode）</a></p><p>1.关键在于strStack不是存当前字符，而是存上一轮的结果</p><p>2.遇到‘]’:正确更新 curStr，而不是重新入栈</p><h2 id="4-✅每日温度">4.✅每日温度</h2><p><a href="https://leetcode.cn/problems/daily-temperatures/description/?envType=study-plan-v2&amp;envId=top-100-liked">739. 每日温度 - 力扣（LeetCode）</a></p><p><strong>单调找、时刻确保栈内元素单调递减，如果新元素大于栈顶元素，用while把栈内小于新元素的给弹出</strong></p><h2 id="5-❎❓⭐️柱状图中最大的矩形">5.❎❓⭐️柱状图中最大的矩形</h2><p><a href="https://leetcode.cn/problems/largest-rectangle-in-histogram/description/?envType=study-plan-v2&amp;envId=top-100-liked">84. 柱状图中最大的矩形 - 力扣（LeetCode）</a></p><p>本题关键在于如何快速找到<strong>每个柱子的左边和右边第一个比它小的下标</strong>。</p><p><strong>单调栈的性质</strong>：</p><ul><li>单调栈可以帮助我们在一次遍历中快速确定“下一个更小”的元素。</li><li>具体来说，当我们从左向右扫描时，我们希望栈内的元素是单调递增的；一旦遇到一个较小的值，就说明栈顶的元素找到了右边界。</li><li>同理，从右向左扫描时也可以得到每个柱子的左边界。 这种“下一个更小元素”的问题，在算法题中非常常见，使用单调栈是经典方法。当你看到需要在一维数组中寻找每个位置的左右边界问题，就很容易联想到单调栈。</li></ul><p><strong>单调栈用于解决找上一个更小/上一个更大的元素</strong></p><p>找上一个更大的元素（把更小的弹出）：是单调递减栈，如：<a href="https://leetcode.cn/problems/daily-temperatures/description/?envType=study-plan-v2&amp;envId=top-100-liked">739. 每日温度 - 力扣（LeetCode）</a></p><p>找上一个更小的元素（把更大的弹出）：是单调递增栈，如：<a href="https://leetcode.cn/problems/largest-rectangle-in-histogram/description/?envType=study-plan-v2&amp;envId=top-100-liked">84. 柱状图中最大的矩形 - 力扣（LeetCode）</a></p><h1>堆</h1><h2 id="1-✅⭐️数组中的第k个最大元素">1.✅⭐️数组中的第k个最大元素</h2><p><a href="https://leetcode.cn/problems/kth-largest-element-in-an-array/description/?envType=study-plan-v2&amp;envId=top-100-liked">215. 数组中的第K个最大元素 - 力扣（LeetCode）</a></p><p>找第k个最大元素，建最小堆，比堆顶大的元素插入</p><p>堆排序核心：</p><p>从 n / 2 - 1开始siftDown</p><p>siftDown:主要比较当前节点，左节点（2 * i + 1），右节点的最小值，然后交换，交换完siftDown即可</p><h2 id="2-✅前K个高频元素">2.✅前K个高频元素</h2><p>看一下PriorityQueue和Map.Entry的用法</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line">public <span class="type">int</span>[] topKFrequent(<span class="type">int</span>[] nums, <span class="type">int</span> k) &#123;</span><br><span class="line">    Map<span class="operator">&lt;</span><span class="type">Integer</span>,<span class="type">Integer</span><span class="operator">&gt;</span> map <span class="operator">=</span> <span class="keyword">new</span> HashMap<span class="operator">&lt;&gt;</span>();</span><br><span class="line">    <span class="type">int</span>[] res <span class="operator">=</span> <span class="keyword">new</span> <span class="type">int</span>[k];</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i <span class="operator">=</span> <span class="number">0</span>;i <span class="operator">&lt;</span> nums.length;i<span class="operator">+</span><span class="operator">+</span>)&#123;</span><br><span class="line">        map.put(nums[i],map.getOrDefault(nums[i],<span class="number">0</span>) <span class="operator">+</span> <span class="number">1</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    PriorityQueue<span class="operator">&lt;</span>Map.Entry<span class="operator">&lt;</span><span class="type">Integer</span>,<span class="type">Integer</span><span class="operator">&gt;&gt;</span> heap <span class="operator">=</span> <span class="keyword">new</span> PriorityQueue<span class="operator">&lt;&gt;</span>((a, b)<span class="operator">-</span><span class="operator">&gt;</span>&#123;<span class="keyword">return</span> a.getValue() <span class="operator">-</span> b.getValue();&#125;);</span><br><span class="line">    <span class="type">int</span> count <span class="operator">=</span> <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">for</span>(Map.Entry<span class="operator">&lt;</span><span class="type">Integer</span>,<span class="type">Integer</span><span class="operator">&gt;</span> entry : map.entrySet())&#123;</span><br><span class="line">        if(count <span class="operator">&lt;</span> k)&#123;</span><br><span class="line">            heap.add(entry);</span><br><span class="line">            count<span class="operator">+</span><span class="operator">+</span>;</span><br><span class="line">        &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">            <span class="operator">/</span><span class="operator">/</span> 这里都是getValue</span><br><span class="line">            <span class="type">int</span> val <span class="operator">=</span> heap.peek().getValue();</span><br><span class="line">            <span class="type">int</span> newVal <span class="operator">=</span> entry.getValue();</span><br><span class="line">            if(newVal <span class="operator">&gt;</span> val)&#123;</span><br><span class="line">                heap.poll();</span><br><span class="line">                heap.add(entry);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i <span class="operator">=</span> <span class="number">0</span>; i <span class="operator">&lt;</span> k;i<span class="operator">+</span><span class="operator">+</span>)&#123;</span><br><span class="line">        res[i] <span class="operator">=</span> heap.poll().getKey();</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> res;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="3-✅‼️数据流的中位数">3.✅‼️数据流的中位数</h2><p><a href="https://leetcode.cn/problems/find-median-from-data-stream/description/?envType=study-plan-v2&amp;envId=top-100-liked">295. 数据流的中位数 - 力扣（LeetCode）</a></p><h1>贪心算法</h1><h2 id="1-✅⭐️-股票问题-买卖股票的最佳时机">1.✅⭐️[股票问题]买卖股票的最佳时机</h2><p><a href="https://leetcode.cn/problems/best-time-to-buy-and-sell-stock/description/?envType=study-plan-v2&amp;envId=top-100-liked">121. 买卖股票的最佳时机 - 力扣（LeetCode）</a></p><p><a href="https://leetcode.cn/problems/best-time-to-buy-and-sell-stock-ii/description/">122. 买卖股票的最佳时机 II - 力扣（LeetCode）</a></p><p><a href="https://leetcode.cn/problems/best-time-to-buy-and-sell-stock-iii/description/">123. 买卖股票的最佳时机 III - 力扣（LeetCode）</a></p><p><a href="https://leetcode.cn/problems/best-time-to-buy-and-sell-stock-iv/description/">188. 买卖股票的最佳时机 IV - 力扣（LeetCode）</a></p><p><a href="https://leetcode.cn/problems/best-time-to-buy-and-sell-stock-with-cooldown/description/">309. 买卖股票的最佳时机含冷冻期 - 力扣（LeetCode）</a></p><p><a href="https://leetcode.cn/problems/best-time-to-buy-and-sell-stock-with-transaction-fee/description/">714. 买卖股票的最佳时机含手续费 - 力扣（LeetCode）</a></p><h2 id="2-✅跳跃游戏">2.✅跳跃游戏</h2><p><a href="https://leetcode.cn/problems/jump-game/description/?envType=study-plan-v2&amp;envId=top-100-liked">55. 跳跃游戏 - 力扣（LeetCode）</a></p><h2 id="3-❎⭐️-错了很多次-跳跃游戏II">3.❎⭐️[错了很多次]跳跃游戏<a href="https://leetcode.cn/problems/jump-game-ii/">II</a></h2><p><a href="https://leetcode.cn/problems/jump-game-ii/description/?envType=study-plan-v2&amp;envId=top-100-liked">45. 跳跃游戏 II - 力扣（LeetCode）</a></p><p>遍历从0- &gt;length()-1</p><p>I = 0的时候跳第一次【关键】，等于end跳下一次，表示遍历到上个起跳点能到的最远距离</p><h2 id="4-✅划分字母区间">4.✅划分字母区间</h2><p><a href="https://leetcode.cn/problems/partition-labels/description/?envType=study-plan-v2&amp;envId=top-100-liked">763. 划分字母区间 - 力扣（LeetCode）</a></p><h1>动态规划</h1><h2 id="1-✅爬楼梯">1.✅爬楼梯</h2><p><a href="https://leetcode.cn/problems/climbing-stairs/?envType=study-plan-v2&amp;envId=top-100-liked">70. 爬楼梯 - 力扣（LeetCode）</a></p><p>初始化DP时要判断n的大小，不然可能会数组越界</p><p>比如dp[2]就数组越界了</p><h2 id="2-❎杨辉三角">2.❎杨辉三角</h2><p><a href="https://leetcode.cn/problems/pascals-triangle/description/?envType=study-plan-v2&amp;envId=top-100-liked">118. 杨辉三角 - 力扣（LeetCode）</a></p><p>第i行有i+1个元素</p><p>边界错误：for(int j = 0; j &lt; numRows;j++)，而是</p><p>for(int j = 0; j &lt; i+1;j++)</p><h2 id="3-❎打家劫舍">3.❎打家劫舍</h2><p><a href="https://leetcode.cn/problems/house-robber/?envType=study-plan-v2&amp;envId=top-100-liked">198. 打家劫舍 - 力扣（LeetCode）</a></p><p>dp初始状态很重要：dp[1] = Math.max(nums[0],nums[1]);</p><h2 id="4-✅-慢-完全平方数">4.✅[慢]完全平方数</h2><p><a href="https://leetcode.cn/problems/perfect-squares/?envType=study-plan-v2&amp;envId=top-100-liked">279. 完全平方数 - 力扣（LeetCode）</a></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">for</span>(<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">2</span>;i &lt;= n;i++)&#123;</span><br><span class="line">    <span class="type">int</span> <span class="variable">min</span> <span class="operator">=</span> Integer.MAX_VALUE;</span><br><span class="line">    <span class="comment">// 核心在于这里，遍历前面的所有可能的完全平方数</span></span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> <span class="variable">j</span> <span class="operator">=</span> <span class="number">1</span>;j*j &lt;= i;j++)&#123;</span><br><span class="line">        <span class="comment">// dp[1] + dp[2]</span></span><br><span class="line">        min = Math.min(min,dp[j*j] + dp[i - j*j]);</span><br><span class="line">    &#125;</span><br><span class="line">    dp[i] = min;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="5-❎零钱兑换">5.❎零钱兑换</h2><p><a href="https://leetcode.cn/problems/coin-change/description/?envType=study-plan-v2&amp;envId=top-100-liked">322. 零钱兑换 - 力扣（LeetCode）</a></p><p>思路有，但是写不对：</p><p>1.应该int min = Integer.MAX_VALUE / 2;防止越界</p><p>2.更新应该直接dp[i] = min;而不是 dp[i] = min == Integer.MAX_VALUE / 2 ? -1 : min;<strong>不然没有考虑到dp[i - coin]不存在的情况下</strong>，如果上一个不存在，那么当前dp[i]也是不存在</p><h2 id="6-❓❎⭐️单词拆分">6.❓❎⭐️单词拆分</h2><p><a href="https://leetcode.cn/problems/word-break/description/?envType=study-plan-v2&amp;envId=top-100-liked">139. 单词拆分 - 力扣（LeetCode）</a></p><p>完全没思路的一道题：</p><p>想到了从右往左划分子问题，没想到从左往右递推</p><p>看到字符串划分，第一眼想到能不能一i结尾划分子问题：</p><p>但是这题不是，f[i] 的定义表示能否把前缀 s[:i]（表示 s[0] 到 s[i−1]）划分成若干段，使得每段都在 wordDict 中。而不是以i结尾，这样左的好处是dp[0]可以直接初始化为0</p><p>且dp[j] &amp;&amp; words.contains(s.substring(j,i))天然就是左闭右开的，所以dp得长度是n+1，dp[i]是前缀</p><h2 id="7-❎最长递增子序列">7.❎最长递增子序列</h2><p><a href="https://leetcode.cn/problems/longest-increasing-subsequence/description/?envType=study-plan-v2&amp;envId=top-100-liked">300. 最长递增子序列 - 力扣（LeetCode）</a></p><p>先从左往右，然后在从右往左，在从右往左的过程中不能break</p><p><strong>res初始化要为1</strong></p><h2 id="8-❎乘积最大子数组">8.❎乘积最大子数组</h2><p><a href="https://leetcode.cn/problems/maximum-product-subarray/description/?envType=study-plan-v2&amp;envId=top-100-liked">152. 乘积最大子数组 - 力扣（LeetCode）</a></p><p>写dp第一步考虑边界情况</p><p>我还是适合闭区间，除非万不得已用开区间</p><ul><li>// 三个数可以这样比 maxDp[i] = Math.<em>max</em>(Math.<em>max</em>(maxDp[i-1] x,minDp[i-1] x),x); minDp[i] = Math.<em>min</em>(Math.<em>min</em>(minDp[i-1] x,maxDp[i-1] x),x);</li></ul><h2 id="9-❎⭐️分割等和子集">9.❎⭐️分割等和子集</h2><p><a href="https://leetcode.cn/problems/partition-equal-subset-sum/description/?envType=study-plan-v2&amp;envId=top-100-liked">416. 分割等和子集 - 力扣（LeetCode）</a></p><p>典型的背包问题：</p><p>从nums中找到一些数字，他们的和为target，没哥数字只能选一次（01背包问题）</p><h2 id="10-❎❓⭐️【没思路】最长有效括号">10.❎❓⭐️【没思路】最长有效括号</h2><p><a href="https://leetcode.cn/problems/longest-valid-parentheses/description/?envType=study-plan-v2&amp;envId=top-100-liked">32. 最长有效括号 - 力扣（LeetCode）</a></p><p>关键在于：<em>这里应该怎么记录最大？</em></p><p><strong>通过栈里上一个未匹配的下标和当前已匹配的下标相减记录长度</strong></p><h1>多维动态规划</h1><h2 id="1-✅不同路径">1.✅不同路径</h2><p><a href="https://leetcode.cn/problems/unique-paths/description/?envType=study-plan-v2&amp;envId=top-100-liked">62. 不同路径 - 力扣（LeetCode）</a></p><h2 id="2-✅最小路径和">2.✅最小路径和</h2><p><a href="https://leetcode.cn/problems/minimum-path-sum/description/?envType=study-plan-v2&amp;envId=top-100-liked">64. 最小路径和 - 力扣（LeetCode）</a></p><h2 id="3-❎⭐️‼️最长回文子串">3.❎⭐️‼️最长回文子串</h2><p><a href="https://leetcode.cn/problems/longest-palindromic-substring/description/?envType=study-plan-v2&amp;envId=top-100-liked">5. 最长回文子串 - 力扣（LeetCode）</a></p><p>区间DP，想出递推式了也没做出，主要是二维太复杂</p><ul><li>初始赋值没赋值对</li><li>填表逻辑写错了，不应该直接遍历i,j的，而应该先遍历长度，再遍历起始点</li></ul><p>这道题建议用中心扩散法去解决</p><h2 id="4-✅最长公共子序列">4.✅最长公共子序列</h2><p><a href="https://leetcode.cn/problems/longest-common-subsequence/description/?envType=study-plan-v2&amp;envId=top-100-liked">1143. 最长公共子序列 - 力扣（LeetCode）</a></p><p><strong>这道题为了防止数组越界，下标要从1开始。</strong></p><p>dp[0][i]是0，是合理的，不需要再初始化</p><h2 id="5-❎⭐️编辑距离">5.❎⭐️编辑距离</h2><p><a href="https://leetcode.cn/problems/edit-distance/description/">72. 编辑距离 - 力扣（LeetCode）</a></p><p>其实可以转化成最长公共子序列的问题</p><ul><li>只用考虑最后一个字符是否相等了两种情况<ul><li><strong>在不相等的情况下，这里只是多了一次比较（删除或者增加）</strong></li></ul></li></ul><p>这道题需要下标从1开始，并且要初始化dp数组</p><h1>技巧</h1><h2 id="1-✅只出现一次的数字">1.✅只出现一次的数字</h2><p><a href="https://leetcode.cn/problems/single-number/description/?envType=study-plan-v2&amp;envId=top-100-liked">136. 只出现一次的数字 - 力扣（LeetCode）</a></p><p>利用异或运算的可交换性</p><h2 id="2-❎多数元素">2.❎多数元素</h2><p><a href="https://leetcode.cn/problems/majority-element/description/?envType=study-plan-v2&amp;envId=top-100-liked">169. 多数元素 - 力扣（LeetCode）</a></p><h2 id="3-❎⭐️颜色分类">3.❎⭐️颜色分类</h2><p><a href="https://leetcode.cn/problems/sort-colors/description/">75. 颜色分类 - 力扣（LeetCode）</a></p><p>循环不变量很精髓，掌握了它，处理边界情况就不容易出错了</p><h2 id="4-❎‼️-没思路-下一个排列">4.❎‼️[没思路]下一个排列</h2><p><a href="https://leetcode.cn/problems/longest-valid-parentheses/description/?envType=study-plan-v2&amp;envId=top-100-liked">32. 最长有效括号 - 力扣（LeetCode）</a></p><p><strong>有时候没思路是因为测试用例太简单了，长一点就能看出规律</strong></p><p>// 可以这样局部排序 Arrays.<em>sort</em>(nums,i,nums.length);</p><h2 id="5-✅寻找重复数">5.✅寻找重复数</h2><p><a href="https://leetcode.cn/problems/find-the-duplicate-number/description/?envType=study-plan-v2&amp;envId=top-100-liked">287. 寻找重复数 - 力扣（LeetCode）</a></p><p>类似数组交换题：<a href="https://leetcode.cn/problems/first-missing-positive/description/?envType=study-plan-v2&amp;envId=top-100-liked">41. 缺失的第一个正数 - 力扣（LeetCode）</a></p>]]></content>
      
      
      <categories>
          
          <category> 刷题 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Hot100 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Spring学习笔记</title>
      <link href="/posts/2023-01-09-Spring%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0.html"/>
      <url>/posts/2023-01-09-Spring%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0.html</url>
      
        <content type="html"><![CDATA[<h1><strong>Spring</strong>笔记</h1><h2 id="一、-Spring">**一、**Spring</h2><p>Spring</p><p>SpringBoot</p><p>Spring MVC</p><p><img src="2023-01-09-Spring%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/clip_image002.jpg" alt="img"></p><p><img src="2023-01-09-Spring%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/clip_image004.jpg" alt="img"></p><p><img src="2023-01-09-Spring%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/clip_image006.jpg" alt="img"></p><p>什么是工厂？</p><p><img src="2023-01-09-Spring%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/clip_image008.jpg" alt="img"></p><p><img src="2023-01-09-Spring%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/clip_image009.jpg" alt="img"></p><ol><li><strong>学习路线</strong></li></ol><p>Spring IOC:</p><p>Spring DI</p><p>Spring AOP</p><p><img src="2023-01-09-Spring%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/clip_image011.jpg" alt="img"></p><p>为什么需要OC/DI、IOC容器和Bean？</p><p><img src="2023-01-09-Spring%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/clip_image013.jpg" alt="img"></p><p><img src="2023-01-09-Spring%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/clip_image015.jpg" alt="img"></p><p><img src="2023-01-09-Spring%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/clip_image017.jpg" alt="img"></p><p><strong>2.IOC</strong>、<strong>IOC</strong>容器、<strong>Bean</strong>、<strong>DI</strong></p><p><img src="2023-01-09-Spring%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/clip_image019.jpg" alt="img"></p><p><img src="2023-01-09-Spring%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/clip_image021.jpg" alt="img"></p><p><img src="2023-01-09-Spring%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/clip_image023.jpg" alt="img"></p><p>配置bean（id，name，scope）</p><p>依赖注入（bean里的property,name表示属性名,ref表示依赖的bean对象）</p><p><img src="2023-01-09-Spring%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/clip_image025.jpg" alt="img"></p><p>问题：</p><p><img src="2023-01-09-Spring%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/clip_image027.jpg" alt="img"></p><p>获取IOC容器</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">App</span> &#123;</span><br><span class="line"> <span class="keyword">public</span> <span class="keyword">static</span> <span class="title function_">voidmain</span><span class="params">(String[]args)</span> &#123;</span><br><span class="line"> ApplicationContextcontext = newClassPathXmlApplicationContext(<span class="string">&quot;applicationContext.xml&quot;</span>);</span><br><span class="line"> </span><br><span class="line"> &#125;</span><br></pre></td></tr></table></figure><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">App</span> &#123;</span><br><span class="line"> <span class="keyword">public</span> <span class="keyword">static</span> <span class="title function_">voidmain</span><span class="params">(String[]args)</span> &#123;</span><br><span class="line">     ApplicationContextcontext = newClassPathXmlApplicationContext(<span class="string">&quot;applicationContext.xml&quot;</span>);</span><br><span class="line">     BookServicebookService= (BookService)context.getBean(<span class="string">&quot;bookService&quot;</span>);</span><br><span class="line">     bookService.save();</span><br><span class="line">     &#125;</span><br><span class="line"> &#125;</span><br></pre></td></tr></table></figure><p>获取Bean</p><p>依赖注入：</p><p>在业务层提供BookDao的setter方法，不用再自己new了，由外部传入。</p><p>在配置文件中添加依赖注入的配置：</p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">bean</span> <span class="attr">id</span>=<span class="string">&quot;bookService&quot;</span> <span class="attr">class</span>=<span class="string">&quot;com.blog.service.impl.BookServiceImpl&quot;</span>&gt;</span></span><br><span class="line"> <span class="comment">&lt;!--配置server与dao的关系--&gt;</span></span><br><span class="line"> <span class="comment">&lt;!--</span></span><br><span class="line"><span class="comment"> property标签表示配置当前bean的属性</span></span><br><span class="line"><span class="comment"> name属性表示配置哪一个具体的属性(这里是配置bookService的bookDao属性)</span></span><br><span class="line"><span class="comment"> ref属性表示参照哪一个bean(参照当前配置文件中的bookDao)</span></span><br><span class="line"><span class="comment"> --&gt;</span></span><br><span class="line"> <span class="tag">&lt;<span class="name">property</span> <span class="attr">name</span>=<span class="string">&quot;bookDao&quot;</span> <span class="attr">ref</span>=<span class="string">&quot;bookDao&quot;</span>&gt;</span><span class="tag">&lt;/<span class="name">property</span>&gt;</span></span><br><span class="line"> <span class="tag">&lt;/<span class="name">bean</span>&gt;</span></span><br></pre></td></tr></table></figure><p><img src="2023-01-09-Spring%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/clip_image029.jpg" alt="img"></p><p><strong>3.Bean</strong>配置*</p><p><img src="2023-01-09-Spring%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/clip_image031.jpg" alt="img"></p><ol><li>bean配置别名</li></ol><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">&lt;?xml version=<span class="string">&quot;1.0&quot;</span> encoding=<span class="string">&quot;UTF-8&quot;</span>?&gt;</span></span><br><span class="line"> &lt;beansxmlns=&quot;http://www.springframework.org/schema/beans&quot;</span><br><span class="line"> xmlns:xsi=&quot;http://www.w3.org/2001/XMLSchema-instance&quot;</span><br><span class="line"> xsi:schemaLocation=&quot;http://www.springframework.org/schema/beans http://www.springframework.org/schema/beans/spring-beans.xsd&quot;&gt;</span><br><span class="line"> <span class="tag">&lt;<span class="name">bean</span> <span class="attr">id</span>=<span class="string">&quot;bookDao&quot;</span> <span class="attr">class</span>=<span class="string">&quot;com.blog.dao.impl.BookDaoImpl&quot;</span>/&gt;</span></span><br><span class="line"> <span class="comment">&lt;!--name:为bean指定别名，别名可以有多个，使用逗号，分号，空格进行分隔--&gt;</span></span><br><span class="line"> <span class="tag">&lt;<span class="name">bean</span> <span class="attr">id</span>=<span class="string">&quot;bookService&quot;</span> <span class="attr">name</span>=<span class="string">&quot;service1 service2 service3&quot;</span> <span class="attr">class</span>=<span class="string">&quot;com.blog.service.impl.BookServiceImpl&quot;</span>&gt;</span></span><br><span class="line"> <span class="tag">&lt;<span class="name">property</span> <span class="attr">name</span>=<span class="string">&quot;bookDao&quot;</span> <span class="attr">ref</span>=<span class="string">&quot;bookDao&quot;</span>&gt;</span><span class="tag">&lt;/<span class="name">property</span>&gt;</span></span><br><span class="line"> <span class="tag">&lt;/<span class="name">bean</span>&gt;</span></span><br><span class="line"> <span class="tag">&lt;/<span class="name">beans</span>&gt;</span></span><br></pre></td></tr></table></figure><ol start="2"><li>单例bean和非单例bean</li></ol><p><img src="2023-01-09-Spring%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/clip_image033.jpg" alt="img"></p><ol start="3"><li>Bean实例化</li></ol><p><img src="2023-01-09-Spring%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/clip_image035.jpg" alt="img"></p><bean id="bookDao" class="com.blog.factory.BookDaoFactory" factory-method="getBookDaoImpl"/><p>class:工厂类的类全名<br>factory-mehod:具体工厂类中创建对象的方法名</p><p><img src="2023-01-09-Spring%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/clip_image037.jpg" alt="img"></p><ol start="4"><li>bean生命周期</li></ol><p><img src="2023-01-09-Spring%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/clip_image039.jpg" alt="img"></p><p>配置生命周期<br>修改bookDao的配置</p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">bean</span> <span class="attr">id</span>=<span class="string">&quot;bookDao&quot;</span> <span class="attr">class</span>=<span class="string">&quot;com.blog.dao.impl.BookDaoImpl&quot;</span><span class="attr">init-method</span>=<span class="string">&quot;init&quot;</span> <span class="attr">destroy-method</span>=<span class="string">&quot;destroy&quot;</span>&gt;</span><span class="tag">&lt;/<span class="name">bean</span>&gt;</span></span><br></pre></td></tr></table></figure><p><img src="2023-01-09-Spring%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/clip_image041.jpg" alt="img"></p><ol start="2"><li><strong>DI</strong>相关内容**</li></ol><p><img src="2023-01-09-Spring%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/clip_image043.jpg" alt="img"></p><p><img src="2023-01-09-Spring%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/clip_image045.jpg" alt="img"></p><p><img src="2023-01-09-Spring%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/clip_image047.jpg" alt="img"></p><p>注入第三方bean（数据库）</p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">&lt;?xml version=<span class="string">&quot;1.0&quot;</span> encoding=<span class="string">&quot;UTF-8&quot;</span>?&gt;</span>  &lt;beansxmlns=&quot;http://www.springframework.org/schema/beans&quot;  xmlns:xsi=&quot;http://www.w3.org/2001/XMLSchema-instance&quot;  xmlns:context=&quot;http://www.springframework.org/schema/context&quot;  xsi:schemaLocation=&quot;  http://www.springframework.org/schema/beans  http://www.springframework.org/schema/beans/spring-beans.xsd  http://www.springframework.org/schema/context  http://www.springframework.org/schema/context/spring-context.xsd  &quot;&gt;  &lt;context:property-placeholderlocation=&quot;jdbc.properties&quot;/&gt;  <span class="tag">&lt;<span class="name">bean</span> <span class="attr">id</span>=<span class="string">&quot;dataSource&quot;</span> <span class="attr">class</span>=<span class="string">&quot;com.alibaba.druid.pool.DruidDataSource&quot;</span>&gt;</span>  <span class="tag">&lt;<span class="name">property</span> <span class="attr">name</span>=<span class="string">&quot;driverClassName&quot;</span> <span class="attr">value</span>=<span class="string">&quot;$&#123;jdbc.driverClass&#125;&quot;</span>/&gt;</span>  <span class="tag">&lt;<span class="name">property</span> <span class="attr">name</span>=<span class="string">&quot;url&quot;</span> <span class="attr">value</span>=<span class="string">&quot;$&#123;jdbc.url&#125;&quot;</span>/&gt;</span>  <span class="tag">&lt;<span class="name">property</span> <span class="attr">name</span>=<span class="string">&quot;username&quot;</span> <span class="attr">value</span>=<span class="string">&quot;$&#123;jdbc.username&#125;&quot;</span>/&gt;</span>  <span class="tag">&lt;<span class="name">property</span> <span class="attr">name</span>=<span class="string">&quot;password&quot;</span> <span class="attr">value</span>=<span class="string">&quot;$&#123;jdbc.password&#125;&quot;</span>/&gt;</span>  <span class="tag">&lt;/<span class="name">bean</span>&gt;</span>  <span class="tag">&lt;/<span class="name">beans</span>&gt;</span></span><br></pre></td></tr></table></figure><p><img src="2023-01-09-Spring%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/clip_image049.jpg" alt="img"></p><p><img src="2023-01-09-Spring%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/clip_image051.jpg" alt="img"></p><ol start="3"><li><strong>核心容器</strong></li></ol><p>5.1创建容器</p><p><img src="2023-01-09-Spring%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/clip_image053.jpg" alt="img"></p><p>5.2获取bean</p><p><img src="2023-01-09-Spring%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/clip_image055.jpg" alt="img"></p><p>5.3 beanFactory使用</p><table><thead><tr><th><img src="2023-01-09-Spring%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/clip_image057.jpg" alt="img"></th><th><img src="2023-01-09-Spring%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/clip_image059.jpg" alt="img"></th></tr></thead><tbody><tr><td></td><td></td></tr></tbody></table><p>beanFactory：IOC的顶级接口，延迟加载</p><p>ApplicationContext：Spring核心接口，立即加载</p><p>bean相关</p><p>DI相关</p><p><img src="2023-01-09-Spring%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/clip_image061.jpg" alt="img"></p><p><img src="2023-01-09-Spring%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/clip_image063.jpg" alt="img"></p><ol start="4"><li><strong>注解开发</strong></li></ol><p>使用代码+配置文件太麻烦？能不能直接在编写代码的时候就自动完成配置操作？</p><p><img src="2023-01-09-Spring%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/clip_image065.jpg" alt="img"></p><table><thead><tr><th><img src="2023-01-09-Spring%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/clip_image067.jpg" alt="img"></th><th>、</th></tr></thead><tbody><tr><td></td><td></td></tr></tbody></table><p><img src="2023-01-09-Spring%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/clip_image069.jpg" alt="img"></p><p>6.1纯注解开发</p><p><img src="2023-01-09-Spring%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/clip_image071.jpg" alt="img"></p><p><img src="2023-01-09-Spring%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/clip_image073.jpg" alt="img"></p><p><img src="2023-01-09-Spring%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/clip_image075.jpg" alt="img"></p><p><img src="2023-01-09-Spring%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/clip_image077.jpg" alt="img"></p><p>单例和非单例Scope</p><p><img src="2023-01-09-Spring%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/clip_image079.jpg" alt="img"></p><p>设置bean生命周期</p><p>@Autowired 注解通常用于注入类，而不是接口。它告诉 Spring 在容器中查找并注入匹配类型的 Bean 实例。</p><p>当你使用 @Autowired 注解来注入一个接口类型的成员变量时，Spring 会在容器中查找实现了该接口的 Bean，并尝试将其注入。然而，因为接口不能直接实例化，Spring 实际上会注入一个实现了该接口的具体类的实例。</p><p>所以，虽然你注入的是接口类型，但实际上注入的是实现了该接口的类的实例。这也是为什么当一个接口有多个实现类时，Spring 无法确定要注入哪一个实现类而报错的原因。</p><p><img src="2023-01-09-Spring%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/clip_image081.jpg" alt="img"></p><p><img src="2023-01-09-Spring%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/clip_image083.jpg" alt="img"></p><p>依赖注入</p><p>@Autowired是按照类型注入，（找到BookDao的实现类，把它注入到bookDao中）所以如果Dao接口有多个实现类时，会报错：NoUniqueBeanDefinitionException，这时需要按照名称注入。</p><p><img src="2023-01-09-Spring%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/clip_image085.jpg" alt="img"></p><p><img src="2023-01-09-Spring%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/clip_image087.jpg" alt="img"></p><p><img src="2023-01-09-Spring%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/clip_image089.jpg" alt="img"></p><p>@Qualifier：按名称注入</p><p><img src="2023-01-09-Spring%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/clip_image091.jpg" alt="img"></p><p>简单类型注入：</p><p>将变量写在Property配置文件中，导入配置文件，并通过@Value注入</p><p><img src="2023-01-09-Spring%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/clip_image093.jpg" alt="img"></p><p><img src="2023-01-09-Spring%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/clip_image095.jpg" alt="img"></p><p><img src="2023-01-09-Spring%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/clip_image097.jpg" alt="img"></p><ol start="5"><li><strong>IOC/DI</strong>注解开发管理第三方<strong>bean</strong></li></ol><p><img src="2023-01-09-Spring%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/clip_image099.jpg" alt="img"></p><table><thead><tr><th><img src="2023-01-09-Spring%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/clip_image101.jpg" alt="img"></th><th><img src="2023-01-09-Spring%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/clip_image103.jpg" alt="img"></th></tr></thead><tbody><tr><td></td><td></td></tr></tbody></table><p><strong>注册开发管理第三方</strong>bean</p><p><img src="2023-01-09-Spring%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/clip_image105.jpg" alt="img"></p><p><img src="2023-01-09-Spring%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/clip_image107.jpg" alt="img"></p><p><img src="2023-01-09-Spring%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/clip_image109.jpg" alt="img"></p><p><img src="2023-01-09-Spring%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/clip_image111.jpg" alt="img"></p><table><thead><tr><th><img src="2023-01-09-Spring%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/clip_image113.jpg" alt="img"></th><th></th></tr></thead><tbody><tr><td></td><td></td></tr></tbody></table><p><img src="2023-01-09-Spring%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/clip_image115.jpg" alt="img"></p><p>采用Import导入配置类</p><table><thead><tr><th></th><th><img src="2023-01-09-Spring%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/clip_image117.jpg" alt="img"></th></tr></thead><tbody><tr><td></td><td></td></tr></tbody></table><p>优化：连接数据库的配置不直接写死，改为从外部读入。</p><p><img src="2023-01-09-Spring%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/clip_image119.jpg" alt="img"></p><p><img src="2023-01-09-Spring%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/clip_image121.jpg" alt="img"></p><p><img src="2023-01-09-Spring%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/clip_image123.jpg" alt="img"></p><p><img src="2023-01-09-Spring%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/clip_image008.jpg" alt="img"></p><p><strong>8.Spring</strong>整合</p><p><img src="2023-01-09-Spring%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/clip_image125.jpg" alt="img"></p><p>MyBatis使用：</p><ol><li>Maven导入Java包</li><li>配置Spring的主配置类（添加组件扫描）</li><li>配置数据源的配置类，并import到主配置类中。其中属性放入jdbc.properties中</li><li>创建Mybatis的配置类，并配置SqlSessionFactory.</li><li>在Spring的主配置类中导入Mybatis的配置类</li><li>运行</li></ol><p><img src="2023-01-09-Spring%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/clip_image127.jpg" alt="img"></p><p><img src="2023-01-09-Spring%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/clip_image129.jpg" alt="img"></p><p><img src="2023-01-09-Spring%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/clip_image131.jpg" alt="img"></p><table><thead><tr><th><img src="2023-01-09-Spring%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/clip_image133.jpg" alt="img"></th><th></th></tr></thead><tbody><tr><td></td><td></td></tr></tbody></table><p><img src="2023-01-09-Spring%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/clip_image135.jpg" alt="img"></p><p><strong>9.AOP</strong>简介</p><p><img src="2023-01-09-Spring%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/clip_image137.jpg" alt="img"></p><p><img src="2023-01-09-Spring%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/clip_image139.jpg" alt="img"></p><table><thead><tr><th><img src="2023-01-09-Spring%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/clip_image141.jpg" alt="img"></th><th><img src="2023-01-09-Spring%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/clip_image143.jpg" alt="img"></th></tr></thead><tbody><tr><td></td><td></td></tr></tbody></table><p>OOP：面向对象编程</p><p>AOP：面向切面编程</p><p>AOP：不修改原有代码，增强切入点，即给切入点增加通知。由于有多个通知和多个切入点，所以对于通知和切入点的描述又称切面</p><p><img src="2023-01-09-Spring%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/clip_image145.jpg" alt="img"></p><p><img src="2023-01-09-Spring%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/clip_image147.jpg" alt="img"></p><p><img src="2023-01-09-Spring%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/clip_image149.jpg" alt="img"></p><p><strong>10.AOP</strong>例子</p><table><thead><tr><th><img src="2023-01-09-Spring%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/clip_image151.jpg" alt="img"></th><th><img src="2023-01-09-Spring%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/clip_image153.jpg" alt="img"></th></tr></thead><tbody><tr><td></td><td></td></tr></tbody></table><p><img src="2023-01-09-Spring%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/clip_image155.jpg" alt="img"></p><p><img src="2023-01-09-Spring%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/clip_image157.jpg" alt="img"></p><p><img src="2023-01-09-Spring%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/clip_image159.jpg" alt="img"></p><p>只需要在配置类中开启AOP，再设置一个通知类，在里面定义切入点和实现通知功能，并制作切面，就能保证不修改切入点的具体代码，而增强它的功能。</p><p>但是这个有什么用？为什么不直接修改切入点的代码？</p><p><img src="2023-01-09-Spring%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/clip_image161.jpg" alt="img"></p><p><img src="2023-01-09-Spring%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/clip_image163.jpg" alt="img"></p><p><img src="2023-01-09-Spring%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/clip_image165.jpg" alt="img"></p><p><img src="2023-01-09-Spring%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/clip_image167.jpg" alt="img"></p><p><img src="2023-01-09-Spring%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/clip_image169.jpg" alt="img"></p><p><strong>11.AOP</strong>工作流程</p><p><img src="2023-01-09-Spring%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/clip_image171.jpg" alt="img"></p><p><img src="2023-01-09-Spring%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/clip_image173.jpg" alt="img"></p><p>本身对象：不需要增强的对象</p><p>代理对象：目标对象会增强</p><p><img src="2023-01-09-Spring%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/clip_image175.jpg" alt="img"></p><p><img src="2023-01-09-Spring%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/clip_image177.jpg" alt="img"></p><p><strong>12.AOP</strong>配置管理**</p><table><thead><tr><th><img src="2023-01-09-Spring%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/clip_image179.jpg" alt="img"></th><th><img src="2023-01-09-Spring%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/clip_image181.jpg" alt="img"></th></tr></thead><tbody><tr><td></td><td></td></tr></tbody></table><table><thead><tr><th><img src="2023-01-09-Spring%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/clip_image183.jpg" alt="img"></th><th>环绕通知：</th></tr></thead><tbody><tr><td></td><td></td></tr></tbody></table><table><thead><tr><th><img src="2023-01-09-Spring%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/clip_image185.jpg" alt="img"></th><th></th><th><img src="2023-01-09-Spring%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/clip_image187.jpg" alt="img"></th><th><img src="2023-01-09-Spring%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/clip_image189.jpg" alt="img"></th></tr></thead><tbody><tr><td></td><td></td><td></td><td></td></tr></tbody></table><p>切入点有返回值</p><p>创建AOP的通知类</p><p>1.该类要被Spring管理，需要添加@Component</p><p>2.要标识该类是一个AOP的切面类，需要添加@Aspect</p><p>3.配置切入点表达式，需要添加一个方法，并添加@Pointcut</p><p><img src="2023-01-09-Spring%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/clip_image191.jpg" alt="img"></p><p>异常后通知</p><table><thead><tr><th><img src="2023-01-09-Spring%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/clip_image193.jpg" alt="img"></th><th></th></tr></thead><tbody><tr><td></td><td></td></tr></tbody></table><p><strong>例子：使用</strong>AOP<strong>记录万次执行的时间</strong></p><p><img src="2023-01-09-Spring%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/clip_image195.jpg" alt="img"></p><p><strong>例子：百度网盘密码数据兼容处理</strong></p><p><img src="2023-01-09-Spring%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/clip_image197.jpg" alt="img"></p><p><img src="2023-01-09-Spring%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/clip_image199.jpg" alt="img"></p><p>如果参数类型是String，去除多余空格</p><p><img src="2023-01-09-Spring%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/clip_image201.jpg" alt="img"></p><p><img src="2023-01-09-Spring%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/clip_image203.jpg" alt="img"></p><p><strong>12.AOP</strong>事务管理</p><p><img src="2023-01-09-Spring%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/clip_image205.jpg" alt="img"></p><p><img src="2023-01-09-Spring%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/clip_image207.jpg" alt="img"></p><p><strong>转账案例</strong>–<strong>需求分析</strong></p><table><thead><tr><th></th><th><img src="2023-01-09-Spring%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/clip_image209.jpg" alt="img"></th></tr></thead><tbody><tr><td></td><td></td></tr></tbody></table><p><img src="2023-01-09-Spring%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/clip_image211.jpg" alt="img"></p><p><img src="2023-01-09-Spring%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/clip_image213.jpg" alt="img"></p><table><thead><tr><th><img src="2023-01-09-Spring%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/clip_image215.jpg" alt="img"></th><th><img src="2023-01-09-Spring%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/clip_image217.jpg" alt="img"></th><th></th></tr></thead><tbody><tr><td></td><td></td><td></td></tr></tbody></table><p><img src="2023-01-09-Spring%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/clip_image219.jpg" alt="img"></p><p><img src="2023-01-09-Spring%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/clip_image221.jpg" alt="img"></p><p><img src="2023-01-09-Spring%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/clip_image223.jpg" alt="img"></p><p><strong>事务属性</strong></p><p><img src="2023-01-09-Spring%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/clip_image225.jpg" alt="img"></p><p><strong>事务传播可选值</strong></p><p><img src="2023-01-09-Spring%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/clip_image227.jpg" alt="img"></p><p><strong>Spring/Spring MVC/Spring Boot</strong></p><p>**一、**Spring</p><p><strong>1.<strong>什么是</strong>Spring</strong></p><p><img src="2023-01-09-Spring%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/clip_image229.jpg" alt="img"></p><p>**2.**它干嘛的？</p><p>简化企业开发用的开发框架</p><p>**3.**怎么学习</p><ol><li>Spring IOC</li><li>Spring AOP</li><li>Spring分层框架</li><li>J2EE应用程序</li></ol><h2 id="二、-Spring-MVC">**二、**Spring MVC</h2><h3 id="1-什么是Spring-MVC"><strong>1.<strong>什么是</strong>Spring MVC</strong></h3><p><img src="2023-01-09-Spring%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/clip_image231.jpg" alt="img"></p><h3 id="2它干嘛的">2<strong>它干嘛的</strong></h3><p>Spring MVC是Spring框架的一个子项目，主要用于构建现代Web应用程序。</p><h3 id="3-怎么学习？">**3.**怎么学习？</h3><p><img src="2023-01-09-Spring%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/clip_image233.jpg" alt="img"></p><h2 id="三、-Spring-Boot">**三、**Spring Boot</h2><h3 id="1-什么是Spring-Boot">1.什么是Spring Boot</h3><p>Spring Boot是由Pivotal团队提供的全新框架。</p><h3 id="2-它干嘛的">2.它干嘛的</h3><p>①其设计目的是用来简化Spring应用的创建、运行、调试、部署等。使用Spring Boot可以做到专注于Spring应用的开发，而无需过多关注XML的配置。Spring Boot使用“习惯优于配置”的理念，简单来说，它提供了一堆依赖打包，并已经按照使用习惯解决了依赖问题。使用Spring Boot可以不用或者只需要很少的Spring配置就可以让企业项目快速运行起来。</p><p>②以往的项目整合起来是比较繁琐复杂的，而且存在架包冲突的问题，这时候SpringBoot应运而生了，SpringBoot也就是用来做这个的。</p><p>③快速整合第三方框架</p><h3 id="3-怎么学习？-2">3.怎么学习？</h3><p>①习惯大于配置</p><p>②Maven</p>]]></content>
      
      
      <categories>
          
          <category> 学习 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Spring </tag>
            
        </tags>
      
    </entry>
    
    
  
  
</search>
