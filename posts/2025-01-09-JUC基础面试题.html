<!DOCTYPE html><html lang="zh-CN" data-theme="light"><head><div id="myscoll"></div><meta charset="UTF-8"><meta http-equiv="X-UA-Compatible" content="IE=edge"><meta name="viewport" content="width=device-width, initial-scale=1.0, maximum-scale=1.0, user-scalable=no"><title>JUC基础面试题 | OutOfLove🥝</title><meta name="keywords" content="JUC"><meta name="author" content="OutOfLove🥝"><meta name="copyright" content="OutOfLove🥝"><meta name="format-detection" content="telephone=no"><meta name="theme-color" content="ffffff"><meta name="description" content="🥧本人的JUC基础面试总结">
<meta property="og:type" content="article">
<meta property="og:title" content="JUC基础面试题">
<meta property="og:url" content="https://outoflovenicoo.github.io/posts/2025-01-09-JUC%E5%9F%BA%E7%A1%80%E9%9D%A2%E8%AF%95%E9%A2%98.html">
<meta property="og:site_name" content="OutOfLove🥝">
<meta property="og:description" content="🥧本人的JUC基础面试总结">
<meta property="og:locale" content="zh_CN">
<meta property="og:image" content="https://source.fomal.cc/img/default_cover_15.webp">
<meta property="article:published_time" content="2025-01-09T10:19:03.000Z">
<meta property="article:modified_time" content="2025-03-23T14:00:00.000Z">
<meta property="article:author" content="OutOfLove🥝">
<meta property="article:tag" content="JUC">
<meta name="twitter:card" content="summary">
<meta name="twitter:image" content="https://source.fomal.cc/img/default_cover_15.webp"><link rel="shortcut icon" href="/"><link rel="canonical" href="https://outoflovenicoo.github.io/posts/2025-01-09-JUC%E5%9F%BA%E7%A1%80%E9%9D%A2%E8%AF%95%E9%A2%98"><link rel="preconnect" href="//cdn.jsdelivr.net"/><link rel="preconnect" href="//busuanzi.ibruce.info"/><link rel="stylesheet" href="/css/index.css"><link rel="stylesheet" href="https://lf6-cdn-tos.bytecdntp.com/cdn/expire-1-M/font-awesome/6.0.0/css/all.min.css" media="print" onload="this.media='all'"><link rel="stylesheet" href="https://cdn.staticfile.org/fancyapps-ui/4.0.31/fancybox.min.css" media="print" onload="this.media='all'"><script>const GLOBAL_CONFIG = { 
  root: '/',
  algolia: undefined,
  localSearch: {"path":"/search.xml","preload":true,"languages":{"hits_empty":"找不到您查询的内容：${query}"}},
  translate: undefined,
  noticeOutdate: {"limitDay":365,"position":"top","messagePrev":"It has been","messageNext":"days since the last update, the content of the article may be outdated."},
  highlight: {"plugin":"highlighjs","highlightCopy":true,"highlightLang":true,"highlightHeightLimit":230},
  copy: {
    success: '复制成功',
    error: '复制错误',
    noSupport: '浏览器不支持'
  },
  relativeDate: {
    homepage: true,
    post: true
  },
  runtime: '',
  date_suffix: {
    just: '刚刚',
    min: '分钟前',
    hour: '小时前',
    day: '天前',
    month: '个月前'
  },
  copyright: undefined,
  lightbox: 'fancybox',
  Snackbar: undefined,
  source: {
    justifiedGallery: {
      js: 'https://cdnjs.cloudflare.com/ajax/libs/flickr-justified-gallery/2.1.2/fjGallery.min.js',
      css: 'https://cdnjs.cloudflare.com/ajax/libs/flickr-justified-gallery/2.1.2/fjGallery.min.css'
    }
  },
  isPhotoFigcaption: false,
  islazyload: true,
  isAnchor: false
}</script><script id="config-diff">var GLOBAL_CONFIG_SITE = {
  title: 'JUC基础面试题',
  isPost: true,
  isHome: false,
  isHighlightShrink: false,
  isToc: true,
  postUpdate: '2025-03-23 22:00:00'
}</script><noscript><style type="text/css">
  #nav {
    opacity: 1
  }
  .justified-gallery img {
    opacity: 1
  }

  #recent-posts time,
  #post-meta time {
    display: inline !important
  }
</style></noscript><script>(win=>{
    win.saveToLocal = {
      set: function setWithExpiry(key, value, ttl) {
        if (ttl === 0) return
        const now = new Date()
        const expiryDay = ttl * 86400000
        const item = {
          value: value,
          expiry: now.getTime() + expiryDay,
        }
        localStorage.setItem(key, JSON.stringify(item))
      },

      get: function getWithExpiry(key) {
        const itemStr = localStorage.getItem(key)

        if (!itemStr) {
          return undefined
        }
        const item = JSON.parse(itemStr)
        const now = new Date()

        if (now.getTime() > item.expiry) {
          localStorage.removeItem(key)
          return undefined
        }
        return item.value
      }
    }
  
    win.getScript = url => new Promise((resolve, reject) => {
      const script = document.createElement('script')
      script.src = url
      script.async = true
      script.onerror = reject
      script.onload = script.onreadystatechange = function() {
        const loadState = this.readyState
        if (loadState && loadState !== 'loaded' && loadState !== 'complete') return
        script.onload = script.onreadystatechange = null
        resolve()
      }
      document.head.appendChild(script)
    })
  
      win.activateDarkMode = function () {
        document.documentElement.setAttribute('data-theme', 'dark')
        if (document.querySelector('meta[name="theme-color"]') !== null) {
          document.querySelector('meta[name="theme-color"]').setAttribute('content', '#0d0d0d')
        }
      }
      win.activateLightMode = function () {
        document.documentElement.setAttribute('data-theme', 'light')
        if (document.querySelector('meta[name="theme-color"]') !== null) {
          document.querySelector('meta[name="theme-color"]').setAttribute('content', 'ffffff')
        }
      }
      const t = saveToLocal.get('theme')
    
          const now = new Date()
          const hour = now.getHours()
          const isNight = hour <= 6 || hour >= 18
          if (t === undefined) isNight ? activateDarkMode() : activateLightMode()
          else if (t === 'light') activateLightMode()
          else activateDarkMode()
        
      const asideStatus = saveToLocal.get('aside-status')
      if (asideStatus !== undefined) {
        if (asideStatus === 'hide') {
          document.documentElement.classList.add('hide-aside')
        } else {
          document.documentElement.classList.remove('hide-aside')
        }
      }
    
    const detectApple = () => {
      if(/iPad|iPhone|iPod|Macintosh/.test(navigator.userAgent)){
        document.documentElement.classList.add('apple')
      }
    }
    detectApple()
    })(window)</script><link rel="stylesheet" href="https://cdn1.tianli0.top/npm/element-ui@2.15.6/packages/theme-chalk/lib/index.css"><style id="themeColor"></style><style id="rightSide"></style><style id="transPercent"></style><style id="blurNum"></style><style id="settingStyle"></style><span id="fps"></span><style id="defineBg"></style><style id="menu_shadow"></style><svg aria-hidden="true" style="position:absolute; overflow:hidden; width:0; height:0"><symbol id="icon-sun" viewBox="0 0 1024 1024"><path d="M960 512l-128 128v192h-192l-128 128-128-128H192v-192l-128-128 128-128V192h192l128-128 128 128h192v192z" fill="#FFD878" p-id="8420"></path><path d="M736 512a224 224 0 1 0-448 0 224 224 0 1 0 448 0z" fill="#FFE4A9" p-id="8421"></path><path d="M512 109.248L626.752 224H800v173.248L914.752 512 800 626.752V800h-173.248L512 914.752 397.248 800H224v-173.248L109.248 512 224 397.248V224h173.248L512 109.248M512 64l-128 128H192v192l-128 128 128 128v192h192l128 128 128-128h192v-192l128-128-128-128V192h-192l-128-128z" fill="#4D5152" p-id="8422"></path><path d="M512 320c105.888 0 192 86.112 192 192s-86.112 192-192 192-192-86.112-192-192 86.112-192 192-192m0-32a224 224 0 1 0 0 448 224 224 0 0 0 0-448z" fill="#4D5152" p-id="8423"></path></symbol><symbol id="icon-moon" viewBox="0 0 1024 1024"><path d="M611.370667 167.082667a445.013333 445.013333 0 0 1-38.4 161.834666 477.824 477.824 0 0 1-244.736 244.394667 445.141333 445.141333 0 0 1-161.109334 38.058667 85.077333 85.077333 0 0 0-65.066666 135.722666A462.08 462.08 0 1 0 747.093333 102.058667a85.077333 85.077333 0 0 0-135.722666 65.024z" fill="#FFB531" p-id="11345"></path><path d="M329.728 274.133333l35.157333-35.157333a21.333333 21.333333 0 1 0-30.165333-30.165333l-35.157333 35.157333-35.114667-35.157333a21.333333 21.333333 0 0 0-30.165333 30.165333l35.114666 35.157333-35.114666 35.157334a21.333333 21.333333 0 1 0 30.165333 30.165333l35.114667-35.157333 35.157333 35.157333a21.333333 21.333333 0 1 0 30.165333-30.165333z" fill="#030835" p-id="11346"></path></symbol></svg><!-- hexo injector head_end start --><link rel="stylesheet" href="https://npm.elemecdn.com/hexo-butterfly-swiper/lib/swiper.min.css" media="print" onload="this.media='all'"><link rel="stylesheet" href="https://npm.elemecdn.com/hexo-butterfly-swiper/lib/swiperstyle.css" media="print" onload="this.media='all'"><link rel="stylesheet" href="https://npm.elemecdn.com/hexo-butterfly-tag-plugins-plus@latest/lib/assets/font-awesome-animation.min.css" media="defer" onload="this.media='all'"><link rel="stylesheet" href="https://npm.elemecdn.com/hexo-butterfly-tag-plugins-plus@latest/lib/tag_plugins.css" media="defer" onload="this.media='all'"><script src="https://npm.elemecdn.com/hexo-butterfly-tag-plugins-plus@latest/lib/assets/carousel-touch.js"></script><link rel="stylesheet" href="https://npm.elemecdn.com/hexo-butterfly-wowjs/lib/animate.min.css" media="print" onload="this.media='screen'"><link rel="stylesheet" href="https://npm.elemecdn.com/hexo-filter-gitcalendar/lib/gitcalendar.css" media="print" onload="this.media='all'"><!-- hexo injector head_end end --><meta name="generator" content="Hexo 6.3.0"><link rel="alternate" href="/atom.xml" title="OutOfLove🥝" type="application/atom+xml">
</head><body><div id="loading-box" onclick="document.getElementById(&quot;loading-box&quot;).classList.add(&quot;loaded&quot;)"><div class="loading-bg"><div class="loading-img"></div><div class="loading-image-dot"></div></div></div><div id="web_bg"></div><div id="sidebar"><div id="menu-mask"></div><div id="sidebar-menus"><div class="avatar-img is-center"><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="https://tuchuang.voooe.cn/images/2023/01/02/avatar.webp" onerror="onerror=null;src='/assets/r1.jpg'" alt="avatar"/></div><div class="sidebar-site-data site-data is-center"><a href="/archives/"><div class="headline">文章</div><div class="length-num">23</div></a><a href="/tags/"><div class="headline">标签</div><div class="length-num">19</div></a><a href="/categories/"><div class="headline">分类</div><div class="length-num">5</div></a></div><hr/><div class="menus_items"><div class="menus_item"><a class="site-page faa-parent animated-hover" href="/"><svg class="menu_icon faa-tada" aria-hidden="true" style="width:1.30em;height:1.30em;vertical-align:-0.15em;fill:currentColor;overflow:hidden;"><use xlink:href="#icon-home"></use></svg><span class="menu_word" style="font-size:17px"> 首页</span></a></div><div class="menus_item"><a class="site-page group faa-parent animated-hover hide" href="javascript:void(0);"><svg class="menu_icon faa-tada" aria-hidden="true" style="width:1.30em;height:1.30em;vertical-align:-0.15em;fill:currentColor;overflow:hidden;"><use xlink:href="#icon--article"></use></svg><span class="menu_word" style="font-size:17px"> 文章</span><i class="fas fa-chevron-down"></i></a><ul class="menus_item_child"><li><a class="site-page child faa-parent animated-hover" href="/archives/"><svg class="menu_icon faa-tada" aria-hidden="true" style="width:1.30em;height:1.30em;vertical-align:-0.15em;fill:currentColor;overflow:hidden;"><use xlink:href="#icon-guidang1">                   </use></svg><span class="menu_word" style="font-size:17px"> 归档</span></a></li><li><a class="site-page child faa-parent animated-hover" href="/tags/"><svg class="menu_icon faa-tada" aria-hidden="true" style="width:1.30em;height:1.30em;vertical-align:-0.15em;fill:currentColor;overflow:hidden;"><use xlink:href="#icon-sekuaibiaoqian">                   </use></svg><span class="menu_word" style="font-size:17px"> 标签</span></a></li><li><a class="site-page child faa-parent animated-hover" href="/categories/"><svg class="menu_icon faa-tada" aria-hidden="true" style="width:1.30em;height:1.30em;vertical-align:-0.15em;fill:currentColor;overflow:hidden;"><use xlink:href="#icon-fenlei">                   </use></svg><span class="menu_word" style="font-size:17px"> 分类</span></a></li></ul></div><div class="menus_item"><a class="site-page group faa-parent animated-hover hide" href="javascript:void(0);"><svg class="menu_icon faa-tada" aria-hidden="true" style="width:1.30em;height:1.30em;vertical-align:-0.15em;fill:currentColor;overflow:hidden;"><use xlink:href="#icon-pinweishenghuo"></use></svg><span class="menu_word" style="font-size:17px"> 休闲</span><i class="fas fa-chevron-down"></i></a><ul class="menus_item_child"><li><a class="site-page child faa-parent animated-hover" href="/life/music/"><svg class="menu_icon faa-tada" aria-hidden="true" style="width:1.30em;height:1.30em;vertical-align:-0.15em;fill:currentColor;overflow:hidden;"><use xlink:href="#icon-yinle">                   </use></svg><span class="menu_word" style="font-size:17px"> 八音盒</span></a></li><li><a class="site-page child faa-parent animated-hover" href="/life/movies/"><svg class="menu_icon faa-tada" aria-hidden="true" style="width:1.30em;height:1.30em;vertical-align:-0.15em;fill:currentColor;overflow:hidden;"><use xlink:href="#icon-dianying1">                   </use></svg><span class="menu_word" style="font-size:17px"> 影院</span></a></li><li><a class="site-page child faa-parent animated-hover" href="/life/games/"><svg class="menu_icon faa-tada" aria-hidden="true" style="width:1.30em;height:1.30em;vertical-align:-0.15em;fill:currentColor;overflow:hidden;"><use xlink:href="#icon-youxishoubing">                   </use></svg><span class="menu_word" style="font-size:17px"> 游戏</span></a></li></ul></div><div class="menus_item"><a class="site-page group faa-parent animated-hover hide" href="javascript:void(0);"><svg class="menu_icon faa-tada" aria-hidden="true" style="width:1.30em;height:1.30em;vertical-align:-0.15em;fill:currentColor;overflow:hidden;"><use xlink:href="#icon-xiangzi"></use></svg><span class="menu_word" style="font-size:17px"> 八宝箱</span><i class="fas fa-chevron-down"></i></a><ul class="menus_item_child"><li><a class="site-page child faa-parent animated-hover" href="/box/gallery/"><svg class="menu_icon faa-tada" aria-hidden="true" style="width:1.30em;height:1.30em;vertical-align:-0.15em;fill:currentColor;overflow:hidden;"><use xlink:href="#icon-tubiaozhizuomoban">                   </use></svg><span class="menu_word" style="font-size:17px"> 画廊</span></a></li><li><a class="site-page child faa-parent animated-hover" href="/box/animation/"><svg class="menu_icon faa-tada" aria-hidden="true" style="width:1.30em;height:1.30em;vertical-align:-0.15em;fill:currentColor;overflow:hidden;"><use xlink:href="#icon-nvwumao">                   </use></svg><span class="menu_word" style="font-size:17px"> 动画</span></a></li><li><a class="site-page child faa-parent animated-hover" href="/box/nav/"><svg class="menu_icon faa-tada" aria-hidden="true" style="width:1.30em;height:1.30em;vertical-align:-0.15em;fill:currentColor;overflow:hidden;"><use xlink:href="#icon-zhifengche">                   </use></svg><span class="menu_word" style="font-size:17px"> 网址导航</span></a></li></ul></div><div class="menus_item"><a class="site-page group faa-parent animated-hover hide" href="javascript:void(0);"><svg class="menu_icon faa-tada" aria-hidden="true" style="width:1.30em;height:1.30em;vertical-align:-0.15em;fill:currentColor;overflow:hidden;"><use xlink:href="#icon-shejiaoxinxi"></use></svg><span class="menu_word" style="font-size:17px"> 社交</span><i class="fas fa-chevron-down"></i></a><ul class="menus_item_child"><li><a class="site-page child faa-parent animated-hover" href="/social/fcircle/"><svg class="menu_icon faa-tada" aria-hidden="true" style="width:1.30em;height:1.30em;vertical-align:-0.15em;fill:currentColor;overflow:hidden;"><use xlink:href="#icon-pengyouquan">                   </use></svg><span class="menu_word" style="font-size:17px"> 朋友圈</span></a></li><li><a class="site-page child faa-parent animated-hover" href="/comments/"><svg class="menu_icon faa-tada" aria-hidden="true" style="width:1.30em;height:1.30em;vertical-align:-0.15em;fill:currentColor;overflow:hidden;"><use xlink:href="#icon-liuyan">                   </use></svg><span class="menu_word" style="font-size:17px"> 留言板</span></a></li><li><a class="site-page child faa-parent animated-hover" href="/social/link/"><svg class="menu_icon faa-tada" aria-hidden="true" style="width:1.30em;height:1.30em;vertical-align:-0.15em;fill:currentColor;overflow:hidden;"><use xlink:href="#icon-lianjie">                   </use></svg><span class="menu_word" style="font-size:17px"> 友人帐</span></a></li></ul></div><div class="menus_item"><a class="site-page group faa-parent animated-hover hide" href="javascript:void(0);"><svg class="menu_icon faa-tada" aria-hidden="true" style="width:1.30em;height:1.30em;vertical-align:-0.15em;fill:currentColor;overflow:hidden;"><use xlink:href="#icon-wangye"></use></svg><span class="menu_word" style="font-size:17px"> 网站</span><i class="fas fa-chevron-down"></i></a><ul class="menus_item_child"><li><a class="site-page child faa-parent animated-hover" href="/site/census/"><svg class="menu_icon faa-tada" aria-hidden="true" style="width:1.30em;height:1.30em;vertical-align:-0.15em;fill:currentColor;overflow:hidden;"><use xlink:href="#icon--tongjibiao">                   </use></svg><span class="menu_word" style="font-size:17px"> 网站统计</span></a></li><li><a class="site-page child faa-parent animated-hover" href="/site/echarts/"><svg class="menu_icon faa-tada" aria-hidden="true" style="width:1.30em;height:1.30em;vertical-align:-0.15em;fill:currentColor;overflow:hidden;"><use xlink:href="#icon-shujutongji1">                   </use></svg><span class="menu_word" style="font-size:17px"> 文章统计</span></a></li><li><a class="site-page child faa-parent animated-hover" href="/site/time/"><svg class="menu_icon faa-tada" aria-hidden="true" style="width:1.30em;height:1.30em;vertical-align:-0.15em;fill:currentColor;overflow:hidden;"><use xlink:href="#icon-xianxingshalou">                   </use></svg><span class="menu_word" style="font-size:17px"> 旧时光</span></a></li></ul></div><div class="menus_item"><a class="site-page group faa-parent animated-hover hide" href="javascript:void(0);"><svg class="menu_icon faa-tada" aria-hidden="true" style="width:1.30em;height:1.30em;vertical-align:-0.15em;fill:currentColor;overflow:hidden;"><use xlink:href="#icon-maoliang"></use></svg><span class="menu_word" style="font-size:17px"> 个人</span><i class="fas fa-chevron-down"></i></a><ul class="menus_item_child"><li><a class="site-page child faa-parent animated-hover" href="/personal/bb/"><svg class="menu_icon faa-tada" aria-hidden="true" style="width:1.30em;height:1.30em;vertical-align:-0.15em;fill:currentColor;overflow:hidden;"><use xlink:href="#icon-qunliaotian">                   </use></svg><span class="menu_word" style="font-size:17px"> 唠叨</span></a></li><li><a class="site-page child faa-parent animated-hover" href="/personal/love/"><svg class="menu_icon faa-tada" aria-hidden="true" style="width:1.30em;height:1.30em;vertical-align:-0.15em;fill:currentColor;overflow:hidden;"><use xlink:href="#icon-love-sign">                   </use></svg><span class="menu_word" style="font-size:17px"> 恋爱小屋</span></a></li><li><a class="site-page child faa-parent animated-hover" href="/personal/about/"><svg class="menu_icon faa-tada" aria-hidden="true" style="width:1.30em;height:1.30em;vertical-align:-0.15em;fill:currentColor;overflow:hidden;"><use xlink:href="#icon-paperplane">                   </use></svg><span class="menu_word" style="font-size:17px"> 关于</span></a></li></ul></div></div></div></div><div class="post" id="body-wrap"><header class="post-bg" id="page-header"><nav id="nav"><span id="blog_name"><a id="site-name" href="/">OutOfLove🥝</a></span><div id="menus"><div class="menus_items"><div class="menus_item"><a class="site-page faa-parent animated-hover" href="/"><svg class="menu_icon faa-tada" aria-hidden="true" style="width:1.30em;height:1.30em;vertical-align:-0.15em;fill:currentColor;overflow:hidden;"><use xlink:href="#icon-home"></use></svg><span class="menu_word" style="font-size:17px"> 首页</span></a></div><div class="menus_item"><a class="site-page group faa-parent animated-hover hide" href="javascript:void(0);"><svg class="menu_icon faa-tada" aria-hidden="true" style="width:1.30em;height:1.30em;vertical-align:-0.15em;fill:currentColor;overflow:hidden;"><use xlink:href="#icon--article"></use></svg><span class="menu_word" style="font-size:17px"> 文章</span><i class="fas fa-chevron-down"></i></a><ul class="menus_item_child"><li><a class="site-page child faa-parent animated-hover" href="/archives/"><svg class="menu_icon faa-tada" aria-hidden="true" style="width:1.30em;height:1.30em;vertical-align:-0.15em;fill:currentColor;overflow:hidden;"><use xlink:href="#icon-guidang1">                   </use></svg><span class="menu_word" style="font-size:17px"> 归档</span></a></li><li><a class="site-page child faa-parent animated-hover" href="/tags/"><svg class="menu_icon faa-tada" aria-hidden="true" style="width:1.30em;height:1.30em;vertical-align:-0.15em;fill:currentColor;overflow:hidden;"><use xlink:href="#icon-sekuaibiaoqian">                   </use></svg><span class="menu_word" style="font-size:17px"> 标签</span></a></li><li><a class="site-page child faa-parent animated-hover" href="/categories/"><svg class="menu_icon faa-tada" aria-hidden="true" style="width:1.30em;height:1.30em;vertical-align:-0.15em;fill:currentColor;overflow:hidden;"><use xlink:href="#icon-fenlei">                   </use></svg><span class="menu_word" style="font-size:17px"> 分类</span></a></li></ul></div><div class="menus_item"><a class="site-page group faa-parent animated-hover hide" href="javascript:void(0);"><svg class="menu_icon faa-tada" aria-hidden="true" style="width:1.30em;height:1.30em;vertical-align:-0.15em;fill:currentColor;overflow:hidden;"><use xlink:href="#icon-pinweishenghuo"></use></svg><span class="menu_word" style="font-size:17px"> 休闲</span><i class="fas fa-chevron-down"></i></a><ul class="menus_item_child"><li><a class="site-page child faa-parent animated-hover" href="/life/music/"><svg class="menu_icon faa-tada" aria-hidden="true" style="width:1.30em;height:1.30em;vertical-align:-0.15em;fill:currentColor;overflow:hidden;"><use xlink:href="#icon-yinle">                   </use></svg><span class="menu_word" style="font-size:17px"> 八音盒</span></a></li><li><a class="site-page child faa-parent animated-hover" href="/life/movies/"><svg class="menu_icon faa-tada" aria-hidden="true" style="width:1.30em;height:1.30em;vertical-align:-0.15em;fill:currentColor;overflow:hidden;"><use xlink:href="#icon-dianying1">                   </use></svg><span class="menu_word" style="font-size:17px"> 影院</span></a></li><li><a class="site-page child faa-parent animated-hover" href="/life/games/"><svg class="menu_icon faa-tada" aria-hidden="true" style="width:1.30em;height:1.30em;vertical-align:-0.15em;fill:currentColor;overflow:hidden;"><use xlink:href="#icon-youxishoubing">                   </use></svg><span class="menu_word" style="font-size:17px"> 游戏</span></a></li></ul></div><div class="menus_item"><a class="site-page group faa-parent animated-hover hide" href="javascript:void(0);"><svg class="menu_icon faa-tada" aria-hidden="true" style="width:1.30em;height:1.30em;vertical-align:-0.15em;fill:currentColor;overflow:hidden;"><use xlink:href="#icon-xiangzi"></use></svg><span class="menu_word" style="font-size:17px"> 八宝箱</span><i class="fas fa-chevron-down"></i></a><ul class="menus_item_child"><li><a class="site-page child faa-parent animated-hover" href="/box/gallery/"><svg class="menu_icon faa-tada" aria-hidden="true" style="width:1.30em;height:1.30em;vertical-align:-0.15em;fill:currentColor;overflow:hidden;"><use xlink:href="#icon-tubiaozhizuomoban">                   </use></svg><span class="menu_word" style="font-size:17px"> 画廊</span></a></li><li><a class="site-page child faa-parent animated-hover" href="/box/animation/"><svg class="menu_icon faa-tada" aria-hidden="true" style="width:1.30em;height:1.30em;vertical-align:-0.15em;fill:currentColor;overflow:hidden;"><use xlink:href="#icon-nvwumao">                   </use></svg><span class="menu_word" style="font-size:17px"> 动画</span></a></li><li><a class="site-page child faa-parent animated-hover" href="/box/nav/"><svg class="menu_icon faa-tada" aria-hidden="true" style="width:1.30em;height:1.30em;vertical-align:-0.15em;fill:currentColor;overflow:hidden;"><use xlink:href="#icon-zhifengche">                   </use></svg><span class="menu_word" style="font-size:17px"> 网址导航</span></a></li></ul></div><div class="menus_item"><a class="site-page group faa-parent animated-hover hide" href="javascript:void(0);"><svg class="menu_icon faa-tada" aria-hidden="true" style="width:1.30em;height:1.30em;vertical-align:-0.15em;fill:currentColor;overflow:hidden;"><use xlink:href="#icon-shejiaoxinxi"></use></svg><span class="menu_word" style="font-size:17px"> 社交</span><i class="fas fa-chevron-down"></i></a><ul class="menus_item_child"><li><a class="site-page child faa-parent animated-hover" href="/social/fcircle/"><svg class="menu_icon faa-tada" aria-hidden="true" style="width:1.30em;height:1.30em;vertical-align:-0.15em;fill:currentColor;overflow:hidden;"><use xlink:href="#icon-pengyouquan">                   </use></svg><span class="menu_word" style="font-size:17px"> 朋友圈</span></a></li><li><a class="site-page child faa-parent animated-hover" href="/comments/"><svg class="menu_icon faa-tada" aria-hidden="true" style="width:1.30em;height:1.30em;vertical-align:-0.15em;fill:currentColor;overflow:hidden;"><use xlink:href="#icon-liuyan">                   </use></svg><span class="menu_word" style="font-size:17px"> 留言板</span></a></li><li><a class="site-page child faa-parent animated-hover" href="/social/link/"><svg class="menu_icon faa-tada" aria-hidden="true" style="width:1.30em;height:1.30em;vertical-align:-0.15em;fill:currentColor;overflow:hidden;"><use xlink:href="#icon-lianjie">                   </use></svg><span class="menu_word" style="font-size:17px"> 友人帐</span></a></li></ul></div><div class="menus_item"><a class="site-page group faa-parent animated-hover hide" href="javascript:void(0);"><svg class="menu_icon faa-tada" aria-hidden="true" style="width:1.30em;height:1.30em;vertical-align:-0.15em;fill:currentColor;overflow:hidden;"><use xlink:href="#icon-wangye"></use></svg><span class="menu_word" style="font-size:17px"> 网站</span><i class="fas fa-chevron-down"></i></a><ul class="menus_item_child"><li><a class="site-page child faa-parent animated-hover" href="/site/census/"><svg class="menu_icon faa-tada" aria-hidden="true" style="width:1.30em;height:1.30em;vertical-align:-0.15em;fill:currentColor;overflow:hidden;"><use xlink:href="#icon--tongjibiao">                   </use></svg><span class="menu_word" style="font-size:17px"> 网站统计</span></a></li><li><a class="site-page child faa-parent animated-hover" href="/site/echarts/"><svg class="menu_icon faa-tada" aria-hidden="true" style="width:1.30em;height:1.30em;vertical-align:-0.15em;fill:currentColor;overflow:hidden;"><use xlink:href="#icon-shujutongji1">                   </use></svg><span class="menu_word" style="font-size:17px"> 文章统计</span></a></li><li><a class="site-page child faa-parent animated-hover" href="/site/time/"><svg class="menu_icon faa-tada" aria-hidden="true" style="width:1.30em;height:1.30em;vertical-align:-0.15em;fill:currentColor;overflow:hidden;"><use xlink:href="#icon-xianxingshalou">                   </use></svg><span class="menu_word" style="font-size:17px"> 旧时光</span></a></li></ul></div><div class="menus_item"><a class="site-page group faa-parent animated-hover hide" href="javascript:void(0);"><svg class="menu_icon faa-tada" aria-hidden="true" style="width:1.30em;height:1.30em;vertical-align:-0.15em;fill:currentColor;overflow:hidden;"><use xlink:href="#icon-maoliang"></use></svg><span class="menu_word" style="font-size:17px"> 个人</span><i class="fas fa-chevron-down"></i></a><ul class="menus_item_child"><li><a class="site-page child faa-parent animated-hover" href="/personal/bb/"><svg class="menu_icon faa-tada" aria-hidden="true" style="width:1.30em;height:1.30em;vertical-align:-0.15em;fill:currentColor;overflow:hidden;"><use xlink:href="#icon-qunliaotian">                   </use></svg><span class="menu_word" style="font-size:17px"> 唠叨</span></a></li><li><a class="site-page child faa-parent animated-hover" href="/personal/love/"><svg class="menu_icon faa-tada" aria-hidden="true" style="width:1.30em;height:1.30em;vertical-align:-0.15em;fill:currentColor;overflow:hidden;"><use xlink:href="#icon-love-sign">                   </use></svg><span class="menu_word" style="font-size:17px"> 恋爱小屋</span></a></li><li><a class="site-page child faa-parent animated-hover" href="/personal/about/"><svg class="menu_icon faa-tada" aria-hidden="true" style="width:1.30em;height:1.30em;vertical-align:-0.15em;fill:currentColor;overflow:hidden;"><use xlink:href="#icon-paperplane">                   </use></svg><span class="menu_word" style="font-size:17px"> 关于</span></a></li></ul></div></div><center id="name-container"><a id="page-name" href="javascript:scrollToTop()">PAGE_NAME</a></center><div id="nav-right"><div id="search-button"><a class="search faa-parent animated-hover" title="检索站内任何你想要的信息"><svg class="faa-tada icon" style="height:24px;width:24px;fill:currentColor;position:relative;top:6px" aria-hidden="true"><use xlink:href="#icon-valentine_-search-love-find-heart"></use></svg><span> 搜索</span></a></div><a class="meihua faa-parent animated-hover" onclick="toggleWinbox()" title="美化设置-自定义你的风格" id="meihua-button"><svg class="faa-tada icon" style="height:26px;width:26px;fill:currentColor;position:relative;top:8px" aria-hidden="true"><use xlink:href="#icon-tupian1"></use></svg></a><a class="sun_moon faa-parent animated-hover" onclick="switchNightMode()" title="浅色和深色模式转换" id="nightmode-button"><svg class="faa-tada" style="height:25px;width:25px;fill:currentColor;position:relative;top:7px" viewBox="0 0 1024 1024"><use id="modeicon" xlink:href="#icon-moon">       </use></svg></a><div id="toggle-menu"><a><i class="fas fa-bars fa-fw"></i></a></div></div></div></nav><div id="post-info"><h1 class="post-title">JUC基础面试题</h1><div id="post-meta"><div class="meta-firstline"><span class="post-meta-date"><svg class="meta_icon post-meta-icon" style="width:30px;height:30px;position:relative;top:10px"><use xlink:href="#icon-rili"></use></svg><span class="post-meta-label">发表于 </span><time class="post-meta-date-created" datetime="2025-01-09T10:19:03.000Z" title="发表于 2025-01-09 18:19:03">2025-01-09</time><span class="post-meta-separator">|</span><svg class="meta_icon post-meta-icon" style="width:18px;height:18px;position:relative;top:5px"><use xlink:href="#icon-gengxin1"></use></svg><span class="post-meta-label">更新于</span><time class="post-meta-date-updated" datetime="2025-03-23T14:00:00.000Z" title="更新于 2025-03-23 22:00:00">2025-03-23</time></span><span class="post-meta-categories"><span class="post-meta-separator">|</span><svg class="meta_icon post-meta-icon" style="width:18px;height:18px;position:relative;top:5px"><use xlink:href="#icon-biaoqian"></use></svg><a class="post-meta-categories" href="/categories/%E9%9D%A2%E8%AF%95%E9%A2%98/">面试题</a></span></div><div class="meta-secondline"><span class="post-meta-separator">|</span><span class="post-meta-wordcount"><svg class="meta_icon post-meta-icon" style="width:25px;height:25px;position:relative;top:8px"><use xlink:href="#icon-charuword"></use></svg><span class="post-meta-label">字数总计:</span><span class="word-count">2.2w</span><span class="post-meta-separator">|</span><svg class="meta_icon post-meta-icon" style="width:20px;height:20px;position:relative;top:5px"><use xlink:href="#icon-shizhong"></use></svg><span class="post-meta-label">阅读时长:</span><span>68分钟</span></span><span class="post-meta-separator">|</span><span class="post-meta-pv-cv" id="" data-flag-title="JUC基础面试题"><svg class="meta_icon post-meta-icon" style="width:25px;height:25px;position:relative;top:5px"><use xlink:href="#icon-eye"></use></svg><span class="post-meta-label">阅读量:</span><span id="busuanzi_value_page_pv"><i class="fa-solid fa-spinner fa-spin"></i></span></span></div></div></div><section class="main-hero-waves-area waves-area"><svg class="waves-svg" xmlns="http://www.w3.org/2000/svg" xlink="http://www.w3.org/1999/xlink" viewBox="0 24 150 28" preserveAspectRatio="none" shape-rendering="auto"><defs><path id="gentle-wave" d="M -160 44 c 30 0 58 -18 88 -18 s 58 18 88 18 s 58 -18 88 -18 s 58 18 88 18 v 44 h -352 Z"></path></defs><g class="parallax"><use href="#gentle-wave" x="48" y="0"></use><use href="#gentle-wave" x="48" y="3"></use><use href="#gentle-wave" x="48" y="5"></use><use href="#gentle-wave" x="48" y="7"></use></g></svg></section></header><main class="layout" id="content-inner"><div id="post"><article class="post-content" id="article-container"><h1>学习</h1>
<h2 id="1-Future">1.Future</h2>
<blockquote>
<p><a target="_blank" rel="noopener" href="https://javaguide.cn/java/concurrent/java-concurrent-questions-03.html#future-%E7%B1%BB%E6%9C%89%E4%BB%80%E4%B9%88%E7%94%A8">Future 类有什么用？</a></p>
<p><a target="_blank" rel="noopener" href="https://juejin.cn/post/6844904199625375757">Java是如何实现Future模式的?万字详解!</a></p>
</blockquote>
<p><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="2025-01-09-JUC%E5%9F%BA%E7%A1%80%E9%9D%A2%E8%AF%95%E9%A2%98/diagram.png" alt=""></p>
<h2 id="（1）Future的用法">（1）Future的用法</h2>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// DaHuoGuo.java</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">DaHuoGuo</span> &#123;</span><br><span class="line">        <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> Exception &#123;</span><br><span class="line">                FutureTask&lt;String&gt; futureTask = <span class="keyword">new</span> <span class="title class_">FutureTask</span>&lt;&gt;(<span class="keyword">new</span> <span class="title class_">Callable</span>&lt;String&gt;() &#123;</span><br><span class="line">                        <span class="meta">@Override</span></span><br><span class="line">                        <span class="keyword">public</span> String <span class="title function_">call</span><span class="params">()</span> <span class="keyword">throws</span> Exception &#123;</span><br><span class="line">                                System.out.println(Thread.currentThread().getName() + <span class="string">&quot;:&quot;</span> + <span class="string">&quot;开始烧开水...&quot;</span>);</span><br><span class="line">                                <span class="comment">// 模拟烧开水耗时</span></span><br><span class="line">                                Thread.sleep(<span class="number">2000</span>);</span><br><span class="line">                                System.out.println(Thread.currentThread().getName() + <span class="string">&quot;:&quot;</span>  + <span class="string">&quot;开水已经烧好了...&quot;</span>);</span><br><span class="line">                                <span class="keyword">return</span> <span class="string">&quot;开水&quot;</span>;</span><br><span class="line">                        &#125;</span><br><span class="line">                &#125;);</span><br><span class="line"></span><br><span class="line">                <span class="type">Thread</span> <span class="variable">thread</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Thread</span>(futureTask);</span><br><span class="line">                thread.start();</span><br><span class="line"></span><br><span class="line">                <span class="comment">// do other thing</span></span><br><span class="line">                System.out.println(Thread.currentThread().getName() + <span class="string">&quot;:&quot;</span>  + <span class="string">&quot; 此时开启了一个线程执行future的逻辑（烧开水），此时我们可以干点别的事情（比如准备火锅食材）...&quot;</span>);</span><br><span class="line">                <span class="comment">// 模拟准备火锅食材耗时</span></span><br><span class="line">                Thread.sleep(<span class="number">3000</span>);</span><br><span class="line">                System.out.println(Thread.currentThread().getName() + <span class="string">&quot;:&quot;</span>  + <span class="string">&quot;火锅食材准备好了&quot;</span>);</span><br><span class="line">                <span class="type">String</span> <span class="variable">shicai</span> <span class="operator">=</span> <span class="string">&quot;火锅食材&quot;</span>;</span><br><span class="line"></span><br><span class="line">                <span class="comment">// 开水已经稍好，我们取得烧好的开水</span></span><br><span class="line">                <span class="type">String</span> <span class="variable">boilWater</span> <span class="operator">=</span> futureTask.get();</span><br><span class="line"></span><br><span class="line">                System.out.println(Thread.currentThread().getName() + <span class="string">&quot;:&quot;</span>  + boilWater + <span class="string">&quot;和&quot;</span> + shicai + <span class="string">&quot;已经准备好，我们可以开始打火锅啦&quot;</span>);</span><br><span class="line">        &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>
<h2 id="（2）CompletableFuture的用法">（2）CompletableFuture的用法</h2>
<p>见代码CFUser</p>
<p>原理：</p>
<p><a target="_blank" rel="noopener" href="https://mcnfxurl5vzo.feishu.cn/wiki/Lp6uws3rFiEDjXkkyGGchQWQnVH#share-YTvbd2a9qoU8qRx7RU4cl8kencd"> 博客</a></p>
<hr>
<h1>面试题目</h1>
<h2 id="并发基础">并发基础</h2>
<h3 id="1-线程状态如何流转">1.线程状态如何流转</h3>
<p><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="2025-01-09-JUC%E5%9F%BA%E7%A1%80%E9%9D%A2%E8%AF%95%E9%A2%98/image-6.png" alt=""></p>
<h3 id="2-Java创建线程的方式">2.Java创建线程的方式</h3>
<p><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="2025-01-09-JUC%E5%9F%BA%E7%A1%80%E9%9D%A2%E8%AF%95%E9%A2%98/image.png" alt=""></p>
<p><a target="_blank" rel="noopener" href="https://blog.csdn.net/longshengguoji/article/details/41126119">java创建线程的三种方式及其对比_创建线程有哪几种方式-CSDN博客</a></p>
<h3 id="3-⭐️启动线程为何调用start而不是run方法">3. ⭐️启动线程为何调用start而不是run方法</h3>
<p><strong>调用start()方法会告诉jvm创建一个新的线程</strong>，并在这个新线程中执行与run()方法相关联的代码块。这个过程允许多个线程同时运行，每个线程都拥有独立的执行上下文，这意味着它们可以在互不相干的情况下执行任务。</p>
<p>与此不同，<strong>如果直接调用run()方法</strong>，它仅仅是一个普通的方法调用，不会创建新的线程。相反，它会在当前线程的上下文中执行run()方法中的代码。这将导致代码的顺序执行，没有并行性可言，因为它们都在同一个线程内执行。</p>
<p>这种区别非常重要，因为多线程编程的一个主要目标是实现并行性，从而提高程序的性能和响应能力。通过调用start()方法，可以利用多核处理器的优势，同时执行多个线程，以更有效地完成任务。而直接调用run()方法只是按照一般的方法顺序执行代码，无法发挥多线程的潜力。因此，使用start()方法来启动线程是实现并行性的关键。 </p>
<h3 id="4-wait-、notify-和-notifyAll-、sleep-、yield">4. wait()、notify()和 notifyAll()、sleep()、yield()</h3>
<ul>
<li>
<p>sleep是让线程自己拿着锁休眠，但是不释放锁，暂停线程的执行</p>
</li>
<li>
<p>wait是A线程通过对象的方法来释放自己持有的该对象的锁,并处于等待状态。Java中每一个对象都包含一个监视器锁，wait方法是当前持有锁的线程 【主动】 放弃锁并等待；wait 不是等锁，而是等一个条件，这个条件要嘛是定时时间到了，要嘛是别人notify。等到条件满足之后，才有资格去竞争锁，后续就走正常锁竞争流程了。  例如B没有释放，那确实得等B用完释放了才能获取到锁。</p>
</li>
<li>
<p><code>notifyAll()</code>：会唤醒所有在该对象的等待队列中等待的线程。</p>
</li>
<li>
<p><code>notify()</code>：只会随机唤醒一个在该对象的等待队列中等待的线程。</p>
</li>
<li>
<p>yield()方法只会给相同优先级或更高优先级的线程以运行的机会；sleep()方法给其他线程运行机会时不考虑线程的优先级，因此会给低优先级的线程以运行的机会； 线程执行 sleep()方法后转入阻塞（超时等待状态），而执行 yield()方法后转入就绪（ready）状态；扩展：</p>
</li>
</ul>
<p>为什么wait()、notify()和 notifyAll()要定义在类里</p>
<p>对象才是共享资源的单位，每一个对象都可能成为共享资源，wait方法定义在Object中是为了让每一个对象都可以方便的共享。</p>
<p>为什么 wait(), notify()和 notifyAll()必须在同步方法或者同步块中被调用？</p>
<p>共享资源时不需要关注线程，对象才是需要互斥访问的资源，因此对象的wait()方法必须在持有锁之后调用；</p>
<p>同理，notify()方法也必须在持有锁之后调用，类似于告诉别人我马上用完了，你可以过来排队等着</p>
<p>很少需要直接控制一个线程的等待状态，主要还是等待共享资源的访问权，相比控制线程本身，控制资源访问权限更符合直觉。</p>
<h3 id="5-Java-中-interrupted-和-isInterrupted-方法的区别？">5.Java 中 interrupted 和 isInterrupted 方法的区别？</h3>
<blockquote>
<p>interrupt：用于中断线程。调用该方法的线程的状态为将被置为”中断”状态。</p>
<p> 注意：线程中断仅仅是置线程的中断状态位，不会停止线程。需要用户自己去监视线程的状态为并做处理。支持线程中断的方法（也就是线程中断后会抛出interruptedException 的方法）就是在监视线程的中断状态，一旦线程的中断状态被置为“中断状态”，就会抛出中断异常。</p>
<p> interrupted：是静态方法，查看当前中断信号是true还是false并且清除中断信号。如果一个线程被中断了，第一次调用 interrupted 则返回 true，第二次和后面的就返回 false 了。</p>
<p>isInterrupted：是可以返回当前中断信号是true还是false，与interrupted最大的差别是，isInterruputed不会清除中断信号，而interrupted会清除中断信号“。</p>
</blockquote>
<h3 id="6-同步方法和同步块，哪个是更好的选择">6. 同步方法和同步块，哪个是更好的选择?</h3>
<p><strong>参考回答</strong>：</p>
<ul>
<li>
<p>同步块是更好的选择，因为它不会锁住整个对象（当然你也可以让它锁住整个对象）。同步方法会锁住整个对象，哪怕这个类中有多个不相关联的同步块，通常会导致它们停止执行并需要等待获得这个对象上的锁。</p>
</li>
<li>
<p>同步块更符合开放调用的原则，只在需要锁住的代码块锁住相应的对象，这样从侧面来说也可以避免死锁。</p>
</li>
</ul>
<p>请知道一条原则：同步的范围越小越好。 </p>
<h3 id="7-什么是线程同步和线程互斥，有哪几种实现方式？">7.什么是线程同步和线程互斥，有哪几种实现方式？</h3>
<p><strong>实现线程同步的方法</strong></p>
<ul>
<li>
<p>同步代码方法：synchronized关键字修饰的方法</p>
</li>
<li>
<p>同步代码块：synchronized关键字修饰的代码块</p>
</li>
<li>
<p>使用特殊变量域volatile实现线程同步：volatile关键字为域变量的访问提供了一种免锁机制</p>
</li>
<li>
<p>使用重入锁实现线程同步：reentrantlock类是可重入、互斥、实现了lock接口的锁，它与synchronized方法具有相同的基本行为和语义 </p>
</li>
</ul>
<h3 id="8-在监视器-Monitor-内部，是如何做线程同步的？程序应该做哪种级别的同步？">8.在监视器(Monitor)内部，是如何做线程同步的？程序应该做哪种级别的同步？</h3>
<blockquote>
<p>在 java 虚拟机中，监视器和锁在Java虚拟机中是一块使用的。监视器监视一块同步代码块，确保一次只有一个线程执行同步代码块。每一个监视器都和一个对象引用相关联。线程在获取锁之前不允许执行同步代码。 </p>
<p>一旦方法或者代码块被 synchronized 修饰，那么这个部分就放入了监视器的监视区域，确保一次只能有一个线程执行该部分的代码，线程在获取锁之前不允许执行该部分的代码</p>
<p>另外 java 还提供了显式监视器( Lock )和隐式监视器( synchronized )两种锁方案</p>
</blockquote>
<h3 id="9-如果你提交任务时，核心线程数已达到配置的数量，这时会发生什么">9.如果你提交任务时，核心线程数已达到配置的数量，这时会发生什么</h3>
<blockquote>
<p>有俩种可能：</p>
<ul>
<li>(1) 如果使用的是无界队列</li>
</ul>
<p>LinkedBlockingQueue，也就是无界队列的话，没关系，继续添加任务到阻塞队列中等待执行，因为LinkedBlockingQueue可以近乎认为是一个无穷大的队列，可以无限存放任务。</p>
<ul>
<li>(2) 如果使用的是有界队列比如</li>
</ul>
<p>ArrayBlockingQueue，任务首先会被添加到ArrayBlockingQueue中，ArrayBlockingQueue满了，会根据maximumPoolSize的值增加线程数量，如果增加了线程数量还是处理不过来，ArrayBlockingQueue继续满，那么则会使用拒绝策略RejectedExecutionHandler处理满了的任务，默认是AbortPolicy </p>
</blockquote>
<h3 id="10-在-Java-程序中怎么保证多线程的运行安全？">10.在 Java 程序中怎么保证多线程的运行安全？</h3>
<blockquote>
<p><strong>方法一</strong>：使用安全类，比如java.util.concurrent下的类，使用原子类AtomicInteger</p>
<p><strong>方法二</strong>：使用自动锁synchronized。</p>
<p><strong>方法三</strong>：使用手动锁Lock。手动锁Java示例代码如下：</p>
</blockquote>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">  Lock lock = new ReentrantLock();</span><br><span class="line">  lock.lock();</span><br><span class="line">  try &#123;</span><br><span class="line">      System.out.println(&quot;获得锁&quot;);</span><br><span class="line">  &#125; catch (Exception e) &#123;</span><br><span class="line">      // TODO: handle exception</span><br><span class="line">    &#125; finally &#123;</span><br><span class="line">     System.out.println(&quot;释放锁&quot;);</span><br><span class="line">      lock.unlock();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="11-线程类的构造方法、静态块是被哪个线程调用的">11.线程类的构造方法、静态块是被哪个线程调用的</h3>
<blockquote>
<p>这是一个非常刁钻和狡猾的问题。请记住：线程类的构造方法、静态块是被new这个线程类所在的线程所调用的，而run方法里面的代码才是被线程自身所调用的。</p>
<p>如果说上面的说法让你感到困惑，那么我举个例子，假设Thread2中new了Thread1，main函数中new了Thread2，那么：</p>
<ul>
<li>
<p>(1) Thread2的构造方法、静态块是main线程调用的，Thread2的run()方法是Thread2自己调用的</p>
</li>
<li>
<p>(2) Thread1的构造方法、静态块是Thread2调用的，Thread1的run()方法是Thread1自己调用的 </p>
</li>
</ul>
</blockquote>
<h3 id="12-Java中怎么获取一份线程dump文件？你如何在Java中获取线程堆栈？">12. Java中怎么获取一份线程dump文件？你如何在Java中获取线程堆栈？</h3>
<p><strong>参考回答</strong>：</p>
<blockquote>
<p>Dump文件是进程的内存镜像。可以把程序的执行状态通过调试器保存到dump文件中。</p>
<p>在Linux下，你可以通过命令jstack -l PID（Java进程的进程ID）来获取Java应用的dump文件。</p>
<p>在Windows下，你可以按下Ctrl + Break来获取，这样JVM就会将线程的dump文件打印到标准输出或错误文件中，它可能打印在控制台或者日志文件中，具体位置依赖应用的配置。</p>
</blockquote>
<h3 id="13-一个线程运行时发生异常会怎样？">13. 一个线程运行时发生异常会怎样？</h3>
<blockquote>
<p><strong>参考回答</strong>：</p>
<p>如果异常没有被捕获该线程将会停止执行。</p>
<p>Thread.UncaughtExceptionHandler是用于处理未捕获异常造成线程突然中断情况的一个内嵌接口。当一个未捕获异常将造成线程中断的时候，JVM会使用Thread.getUncaughtExceptionHandler()来查询线程的UncaughtExceptionHandler，并将线程和异常作为参数传递给handler的uncaughtException()方法进行处理。 </p>
</blockquote>
<h3 id="14-多线程的常用方法">14.多线程的常用方法</h3>
<table>
<thead>
<tr>
<th>方法名</th>
<th>描述</th>
</tr>
</thead>
<tbody>
<tr>
<td>sleep()isAlive()join()activeCount()enumerate()currentThread()isDaemon()setDaemon()setName()wait()notify()setPriority()</td>
<td>强迫一个线程睡眠N毫秒判断一个线程是否存活。等待线程终止。程序中活跃的线程数。枚举程序中的线程。得到当前线程。一个线程是否为守护线程。设置一个线程为守护线程。为线程设置一个名称。强迫一个线程等待。通知一个线程继续运行。设置一个线程的优先级。</td>
</tr>
</tbody>
</table>
<h3 id="15-❓介绍一下-ThreadLocal">15.❓介绍一下 ThreadLocal</h3>
<blockquote>
<p>Thread类有两个变量：threadLocals和inheritableThreadLocals。</p>
<p>这两个变量默认为null，只有当该线程调用了ThreadLocal类的get/set方法时才会创建他们，而调用ThreadLocal的get/set实际上是调用ThreadLocalMap的get/set。</p>
<p>ThreadLocalMap可理解成给ThreadLocal定制化的HashMap。</p>
<p>最终的变量放在了线程的ThreadLocalMap中，而不是ThreadLocal中，ThreadLocal只是对其进行封装，向其传递变量值。</p>
<p>用一个场景分析ThreadLocal的get/set流程：</p>
<p>首先在所有线程外部创建一个共享的ThreadLocal对象，记为TL1。在一个线程中调用TL1.get()时，首先获取到当前线程对象，记为t，然后判断t.threadLocals是否为null，如果为null，就在t中创建一个新的ThreadLocalMap对象赋值给t.threadLocals，并将&lt;TL1,null&gt;插入其中，最后get方法返回null；如果不为null，则尝试获取threadLocals中TL1所在的键值对，如果该键值对为null，则向threadLocals中通过set方法插入&lt;TL1,null&gt;，最后返回null，如果键值对不为null，则返回键值对中的值。</p>
<p>调用set方法时，流程和get基本一致，只是从读变成了写。</p>
<p>这样就可以实现不同线程访问同一个ThreadLocal（TL1）能拿到各自向其中存放的值。 </p>
</blockquote>
<p><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="2025-01-09-JUC%E5%9F%BA%E7%A1%80%E9%9D%A2%E8%AF%95%E9%A2%98/image-5.png" alt=""></p>
<h3 id="16-ThreadLocal-内存泄露问题了解吗">16.ThreadLocal 内存泄露问题了解吗</h3>
<p><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="2025-01-09-JUC%E5%9F%BA%E7%A1%80%E9%9D%A2%E8%AF%95%E9%A2%98/image-3.png" alt=""></p>
<p><strong>分析</strong></p>
<p>ThreadLocal 内存泄露也是个老生常谈的问题了，网上部分资料，包括好多面试官都把这个问题出现的主要原因归结为 ThreadLocalMaps 里 Entry Key（ThreadLocal 对象本身）使用了弱引用导致的，但是我们仔细看看引用结构，脑补一下内存泄露的场景就不难发现，真正导致内存泄露的主要原因，其实是 Thread 强引用 ThreadLocalMaps，如果 Thread 一直存在，ThreadLocalMaps Entry 中的 value 这个强引用一直存在，不被回收才是导致发生内存泄露的真正原因</p>
<blockquote>
<p>因为 ThreadLocal 本身不存储对象，是调用 Thread 中的 ThreadLocalMaps 来保存，而 Thread 强引用 ThreadLocalMaps 对象，如果 Thread 对象生命周期过长，不能及时被回收，就会导致 ThreadLocalMaps 对象里 Entry 的 value 存在内存泄露的可能。</p>
<p>当然 ThreadLocalMaps 在设计的时候也考虑过这个问题，所以 ThreadLocalMaps Key 采用了弱引用的方式，并且在 set、remove、rehash 的时候会主动清理 ThreadLocalMaps 中 Key 为 Null 的 value，但是如果 ThreadLocal 已经不被使用了 set、remove、rehash 方法也不会被调用，与此同时，如果这个线程又一直存活、不终止的话，那么一ThreadLocalMaps 中的 Value 强引用就会一直存在，也就避免不了 Value 的内存泄漏</p>
</blockquote>
<p><a target="_blank" rel="noopener" href="https://learn.lianglianglee.com/%E4%B8%93%E6%A0%8F/Java%20%E5%B9%B6%E5%8F%91%E7%BC%96%E7%A8%8B%2078%20%E8%AE%B2-%E5%AE%8C/47%20%E5%86%85%E5%AD%98%E6%B3%84%E6%BC%8F%E2%80%94%E2%80%94%E4%B8%BA%E4%BD%95%E6%AF%8F%E6%AC%A1%E7%94%A8%E5%AE%8C%20ThreadLocal%20%E9%83%BD%E8%A6%81%E8%B0%83%E7%94%A8%20remove()%EF%BC%9F.md">47 内存泄漏——为何每次用完 ThreadLocal 都要调用 remove()?</a></p>
<h3 id="17-为什么用ThreadLocal不用线程成员变量">17.为什么用ThreadLocal不用线程成员变量?</h3>
<p><strong>参考回答</strong>：</p>
<blockquote>
<p>如果用成员变量，那么成员变量必须在Thread里，不能在Runnable里，因为一个Runnable对象可以被多个Thread执行。</p>
<p>而如果在Thread中添加成员变量，就要加强Thread和Runnable的耦合，将Thread作为Runnable的成员变量，并在Runnable中调用具体的Thread变量，如果执行Runnable的Thread可能有很多子类，不同子类有不同的成员变量，则要在run方法中进行复杂处理，扩展性较低，不利于维护。而ThreadLocal就是将成员变量统一为一个Map放到线程里。 </p>
</blockquote>
<h2 id="⭐️Java并发理论（Volatile-Synchronized-CAS）">⭐️Java并发理论（Volatile/Synchronized/CAS）</h2>
<h3 id="1-线程之间如何通信及线程之间如何同步">1. 线程之间如何通信及线程之间如何同步</h3>
<p><strong>参考回答</strong>：</p>
<blockquote>
<p>- 在并发编程中，我们需要处理两个关键问题：线程之间如何通信及线程之间如何同步。通信是指线程之间以如何来交换信息。一般线程之间的通信机制有两种：共享内存和消息传递。同步是指程序中用于控制不同线程间操作发生相对顺序的机制。</p>
<p>- Java的并发采用的是共享内存模型，Java线程之间的通信总是隐式进行，整个通信过程对程序员完全透明。如果编写多线程程序的Java程序员不理解隐式进行的线程之间通信的工作机制，很可能会遇到各种奇怪的内存可见性问题。</p>
<p>- 在共享内存并发模型里，同步是显式进行的。程序员必须显式指定某个方法或者某段代码需要在线程之间互斥执行。 </p>
</blockquote>
<h3 id="2-Java内存模型（JMM）">2.Java内存模型（JMM）</h3>
<p><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="2025-01-09-JUC%E5%9F%BA%E7%A1%80%E9%9D%A2%E8%AF%95%E9%A2%98/image-4.png" alt=""></p>
<p><a target="_blank" rel="noopener" href="https://blog.csdn.net/Your_heart_private/article/details/105566207">Jvm内存模型和JMM模型结构图_java jmm模型图-CSDN博客</a></p>
<p><a target="_blank" rel="noopener" href="https://pdai.tech/md/java/jvm/java-jvm-x-introduce.html">JVM 基础 - Java 内存模型引入</a></p>
<p><a target="_blank" rel="noopener" href="https://zhuanlan.zhihu.com/p/29881777">https://zhuanlan.zhihu.com/p/29881777</a></p>
<h3 id="3-Happens-Before-原则">3.Happens-Before 原则</h3>
<p><strong>分析</strong></p>
<p>理解JMM模型如何保证并发安全性，知道指令重排，理解happens-before原则</p>
<p><strong>回答</strong></p>
<blockquote>
<p>happens-before 字面意思就是先行发生，你可以理解为A happens before B，就是A发生在B之前。</p>
<p>happens-before（HB）是在JMM中的一个很重要的规则，即一个操作的结果对于另一个操作是可见的，用来指定两个操作之间的执行顺序。 </p>
</blockquote>
<p><a target="_blank" rel="noopener" href="https://blog.51cto.com/u_11812862/3002287">阿里面试题:Java 并发编程之 happens-before 规则_51CTO博客_java happens-before原则</a></p>
<h3 id="4-Java-怎么进行并发控制？">4.Java 怎么进行并发控制？</h3>
<blockquote>
<p>并发控制中的锁一般有两种，悲观锁和乐观锁，一般来说悲观锁是基于Monitor实现的，这在Java中分别对应synchronized关键字和AQS。乐观锁是基于CAS+自旋来实现的，Java中用的比较多的是并发原子类。</p>
<p><strong>synchronized</strong></p>
<p>synchronized修饰的方法或代码块同一时间只能被一个线程执行。</p>
<p>一般有三种使用方法：</p>
<ol>
<li>
<p>修饰实例方法：调用某对象的该方法前获取该对象实例的锁。</p>
</li>
<li>
<p>修饰静态方法：调用某对象的该方法前获取该类的锁。</p>
</li>
<li>
<p>两个线程分别执行同一个对象synchronized修饰的实例方法和静态方法时不会发生互斥，因为锁的资源不同，一个锁了对象实例，一个锁了类。</p>
</li>
<li>
<p>锁对象，修饰代码块：synchronized(对象的引用)锁的是对象实例，synchronized(类.class)锁的是类。</p>
</li>
</ol>
<p>尽量不要使用synchronized(String a)因为JVM中，字符串常量池具有缓存功能！</p>
<p>synchronized不能修饰构造方法，也没必要修饰，构造方法本身就是线程安全的。</p>
<p>底层原理：尝试获取对象的monitor，monitor已被其他线程占用时，获取失败，该线程进入EntrySet。占有monitor时调用wait()进入WaitSet。调用notify()时从WaitSet里随机选一个线程唤醒，调用notifyAll时唤醒WaitSet里所有线程。</p>
<p><strong> AQS</strong></p>
<p>AQS全称是AbstractQueuedSynchronizer，它是Java中用来构建锁和同步器的基础框架，可以用于实现诸如ReentrantLock、Semaphore、CountDownLatch等多种同步工具。</p>
<p>AQS主要依赖于一个双向链表和一个volatile类型的整数state来实现同步控制。该整数state用来表示同步状态，一般情况下，state=0表示没有线程占用同步资源，state&gt;0表示有线程占用同步资源，比如ReentrantLock可以允许一个线程多次获得锁，每次state值加一。</p>
<p>AQS的主要方法有下面几个：</p>
<ul>
<li>
<p>acquire()：该方法用来获取同步状态，如果同步状态被占用，则线程将被加入等待队列中。</p>
</li>
<li>
<p>acquireInterruptibly()：与acquire()类似，但是该方法允许中断操作。</p>
</li>
<li>
<p>tryAcquire()：该方法用来尝试获取同步状态，如果成功则返回true，否则返回false。</p>
</li>
<li>
<p>release()：该方法用来释放同步状态，并唤醒等待队列中的线程。</p>
</li>
<li>
<p>acquireShared()：该方法用来获取共享式同步状态，如果同步状态被占用，则线程将被加入等待队列中。</p>
</li>
<li>
<p>releaseShared()：该方法用来释放共享式同步状态，并唤醒等待队列中的线程。</p>
</li>
</ul>
<p>AQS实现同步的关键在于，它提供了一个基于FIFO队列的等待队列，通过将等待线程加入等待队列中，然后在释放同步状态的时候，从等待队列中唤醒等待线程，从而实现了同步机制。 </p>
<p>AQS的实现主要有两种方式：独占式（Exclusive）和共享式（Shared）。独占式是指只有一个线程可以占用同步资源，比如ReentrantLock，而共享式是指多个线程可以同时占用同步资源，比如CountDownLatch。在AQS中，这两种方式的实现是基本相同的，区别在于获取和释放同步状态的方式不同。</p>
<p>以上是AQS的基本实现方式，它是Java中构建锁和同步器的核心框架，为各种同步工具的实现提供了强大的基础支持。 </p>
</blockquote>
<p><a target="_blank" rel="noopener" href="https://ls8sck0zrg.feishu.cn/wiki/Y6jkwwaHPiJw6skxQsfctlVVnMb#share-WZDZdVZqWobjF0xwtjocNSOqnQd">https://ls8sck0zrg.feishu.cn/wiki/Y6jkwwaHPiJw6skxQsfctlVVnMb#share-WZDZdVZqWobjF0xwtjocNSOqnQd</a></p>
<h3 id="5-synchronized关键字">5. synchronized关键字</h3>
<p><strong>分析</strong></p>
<p>回答synchronized作用、特性、实现方式，可以适当画图或者举例。</p>
<p><strong>回答</strong></p>
<blockquote>
<p>synchronized关键字是Java用来解决多个线程共享资源竞争问题，synchronized同步语句块实现是先执行monitorenter指令，该指令会尝试获取对象的monitor，指令指向同步代码块的开始位置，monitorexit指令则同步代码块的结束位置，synchronized关键字可以保证被它修饰的方法或者代码块在任意时刻只有一个线程执行。</p>
<p>早期的synchronized依赖操作系统实现，属于重量锁，JDK 1.6以后对其进行了大量的优化。 </p>
</blockquote>
<p><a target="_blank" rel="noopener" href="https://pdai.tech/md/java/thread/java-thread-x-key-synchronized.html">关键字: synchronized详解</a></p>
<h3 id="6-说说自己是怎么使用synchronized关键字，在项目中用到了吗">6. 说说自己是怎么使用synchronized关键字，在项目中用到了吗</h3>
<p><strong>参考回答</strong>：</p>
<blockquote>
<p>synchronized关键字最主要的三种使用方式：</p>
<ul>
<li>
<p>修饰实例方法：作用于当前对象实例加锁，进入同步代码前要获得当前对象实例的锁。</p>
</li>
<li>
<p>修饰静态方法：也就是给当前类加锁，会作用于类的所有对象实例，因为静态成员不属于任何一个实例对象，是类成员（static表明这是该类的一个静态资源，不管new了多少个对象，只有一份）。所以如果一个线程A调用一个实例对象的非静态synchronized方法，而线程B需要调用这个实例对象所属类的静态synchronized方法，是允许的，不会发生互斥现象，因为访问静态synchronized方法占用的锁是当前类的锁，而访问非静态synchronized方法占用的锁是当前实例对象锁。 </p>
</li>
<li>
<p>修饰代码块：指定加锁对象，对给定对象加锁，进入同步代码库前要获得给定对象的锁。</p>
</li>
</ul>
<p>总结：synchronized关键字加到static静态方法和synchronized(class)代码块上都是给Class类上锁。synchronized关键字加到实例方法上是给对象实例上锁。尽量不要使用synchronized(String a)因为JVM中，字符串常量池具有缓存功能！ </p>
</blockquote>
<h3 id="7-说一下synchronized底层实现原理">7. 说一下synchronized底层实现原理?</h3>
<p><strong>参考回答</strong>：</p>
<blockquote>
<p>Synchronized的语义底层是通过一个monitor（监视器锁）的对象来完成，每个对象有一个监视器锁(monitor)。每个Synchronized修饰过的代码当它的monitor被占用时就会处于锁定状态并且尝试获取monitor的所有权 ，过程：</p>
<p>1、如果monitor的进入数为0，则该线程进入monitor，然后将进入数设置为1，该线程即为monitor的所有者。</p>
<p>2、如果线程已经占有该monitor，只是重新进入，则进入monitor的进入数加1.</p>
<p>3、如果其他线程已经占用了monitor，则该线程进入阻塞状态，直到monitor的进入数为0，再重新尝试获取monitor的所有权。</p>
<p><code>synchronized是可以通过 反汇编指令javap命令，查看相应的字节码文件。 </code></p>
</blockquote>
<h3 id="8-synchronized可重入的原理">8. synchronized可重入的原理</h3>
<p><strong>参考回答</strong>：</p>
<blockquote>
<p>重入锁是指一线程获取到该锁之后，该线程可以继续获得该锁。底层原理维护一个计数器，当线程获取该锁时，计数器加一，再次获得该锁时继续加一，释放锁时，计数器减一，当计数器值为0时，表明该锁未被任何线程所持有，其它线程可以竞争获取锁。</p>
</blockquote>
<h3 id="9-什么是自旋">9. 什么是自旋</h3>
<blockquote>
<p><strong>参考回答</strong>：</p>
<ul>
<li>
<p>很多synchronized里面的代码只是一些很简单的代码，执行时间非常快，此时等待的线程都阻塞可能是一种不太值得的操作，因为线程阻塞涉及到用户态和内核态切换的问题。既然synchronized里面的代码执行得非常快，不妨让等待锁的线程不要被阻塞，而是在 线程的边界忙循环，这就是自旋。如果做了多次循环发现还没有获得锁，再阻塞，这样可能是一种更好的策略。</p>
</li>
<li>
<p>忙循环：就是程序员用循环让一个线程等待，不像传统方法wait(),sleep() 或yield() 它们都放弃了CPU控制，而忙循环不会放弃CPU，它就是在运行一个空循环。这么做的目的是为了保留CPU缓存，在多核系统中，一个等待线程醒来的时候可能会在另一个内核运行，这样会重建缓存。为了避免重建缓存和减少等待重建的时间就可以使用它了。 </p>
</li>
</ul>
<p>在Java中，自旋（Spinning）是一种线程同步技术，用于在多线程编程中实现锁机制。当一个线程试图获取一个已经被其他线程持有的锁时，该线程不会放弃CPU时间片，而是进行循环（通常是一个忙等待循环），不断检查锁是否可用。这种机制旨在减少线程上下文切换的开销，提高响应速度，但也可能浪费大量的CPU时间。</p>
<p>自旋锁是Java并发编程中的一个重要概念，通过允许线程在锁不可用时持续尝试获取锁，它可以避免线程上下文切换的开销。然而，如果锁持有时间过长，自旋线程会浪费大量CPU时间，导致性能下降。因此，自旋锁需要谨慎使用，依据具体的应用场景和需求进行选择和优化。</p>
</blockquote>
<h3 id="10-多线程中synchronized锁升级的原理是什么">10. 多线程中synchronized锁升级的原理是什么?</h3>
<p><strong>参考回答</strong>：</p>
<blockquote>
<p>synchronized锁升级原理：在锁对象的对象头里面有一个threadid字段，在第一次访问的时候threadid为空，jvm让其持有偏向锁，并将threadid设置为其线程id，再次进入的时候会先判断threadid是否与其线程id一致，如果一致则可以直接使用此对象，如果不一致，则升级偏向锁为轻量级锁，通过自旋循环一定次数来获取锁，执行一定次数之后，如果还没有正常获取到要使用的对象，此时就会把锁从轻量级升级为重量级锁，此过程就构成了synchronized锁的升级。 </p>
<p><code>锁的升级的目的：锁升级是为了减低了锁带来的性能消耗。在Java 6之后优化synchronized的实现方式，使用了偏向锁升级为轻量级锁再升级到重量级锁的方式，从而减低了锁带来的性能消耗。</code></p>
<ul>
<li>
<p>偏向锁，顾名思义，它会偏向于第一个访问锁的线程，如果在运行过程中同步锁只有一个线程访问，不存在多线程争用的情况，则线程是不需要触发同步的，减少加锁 / 解锁的一些CAS操作（比如等待队列的一些CAS操作），这种情况下，就会给线程加一个偏向锁。如果在运行过程中，遇到了其他线程抢占锁，则持有偏向锁的线程会被挂起，JVM会消除它身上的偏向锁，将锁恢复到标准的轻量级锁。</p>
</li>
<li>
<p>轻量级锁是由偏向所升级来的，偏向锁运行在一个线程进入同步块的情况下，当第二个线程加入锁争用的时候，偏向锁就会升级为轻量级锁； </p>
</li>
<li>
<p>重量级锁是synchronized，是Java虚拟机中最为基础的锁实现。在这种状态下，Java虚拟机会阻塞加锁失败的线程，并且在目标锁被释放的时候，唤醒这些线程。 </p>
</li>
</ul>
</blockquote>
<p><a target="_blank" rel="noopener" href="https://learn.lianglianglee.com/%E4%B8%93%E6%A0%8F/Java%20%E6%A0%B8%E5%BF%83%E6%8A%80%E6%9C%AF%E9%9D%A2%E8%AF%95%E7%B2%BE%E8%AE%B2/16%20%20synchronized%E5%BA%95%E5%B1%82%E5%A6%82%E4%BD%95%E5%AE%9E%E7%8E%B0%EF%BC%9F%E4%BB%80%E4%B9%88%E6%98%AF%E9%94%81%E7%9A%84%E5%8D%87%E7%BA%A7%E3%80%81%E9%99%8D%E7%BA%A7%EF%BC%9F-%E6%9E%81%E5%AE%A2%E6%97%B6%E9%97%B4.md">16 synchronized底层如何实现?什么是锁的升级、降级?-极客时间</a></p>
<blockquote>
<h3 id="11-线程B怎么知道线程A修改了变量">11. 线程B怎么知道线程A修改了变量</h3>
<p><strong>参考回答</strong>：</p>
<p>(1) volatile修饰变量</p>
<p>(2) synchronized修饰修改变量的方法</p>
<p>(3) wait/notify</p>
</blockquote>
<h3 id="12-当一个线程进入一个对象的synchronized方法A之后，其它线程是否可进入此对象的synchronized方法B">12. 当一个线程进入一个对象的synchronized方法A之后，其它线程是否可进入此对象的synchronized方法B?</h3>
<blockquote>
<p><strong>参考回答</strong>：</p>
<p>不能。其它线程只能访问该对象的非同步方法，同步方法则不能进入。因为非静态方法上的synchronized修饰符要求执行方法时要获得对象的锁，如果已经进入A方法说明对象锁已经被取走，那么试图进入B方法的线程就只能在等锁池（注意不是等待池哦）中等待对象的锁。</p>
</blockquote>
<h3 id="13-synchronized、volatile、CAS比较">13. synchronized、volatile、CAS比较</h3>
<blockquote>
<p><strong>参考回答</strong>：</p>
<p>(1) synchronized是悲观锁，属于抢占式，会引起其他线程阻塞。</p>
<p>(2) volatile提供多线程共享变量可见性和禁止指令重排序优化。 </p>
<p>(3) CAS是基于冲突检测的乐观锁（非阻塞） </p>
</blockquote>
<p><a target="_blank" rel="noopener" href="https://refblogs.com/article/582">并发编程中的synchronized、volatile和CAS操作详解 - 搬砖的码农</a></p>
<h3 id="14-synchronized和Lock有什么区别">14. synchronized和Lock有什么区别?</h3>
<blockquote>
<p><strong>参考回答</strong>：</p>
<ul>
<li>
<p>首先synchronized是Java内置关键字，在JVM层面，Lock是个接口；</p>
</li>
<li>
<p>原理区别：synchronized是内置锁，由JVM实现获取锁和释放锁的原理，还分为偏向锁、轻量级锁、重量级锁。Lock根据实现不同，有不同的原理，例如ReentrantLock内部是通过AQS来获取和释放锁的。</p>
</li>
<li>
<p>用法区别：synchronized可以给类、方法、代码块加锁；而lock只能给代码块加锁。synchronized不需要手动获取锁和释放锁，使用简单，发生异常会自动释放锁，不容易造成死锁；而lock需要自己加锁和释放锁，如果使用不当没有unLock()去释放锁就会造成死锁。</p>
</li>
<li>
<p>synchronized锁只能同时被一个线程拥有，但是Lock锁没有这个限制，例如在读写锁中的读锁，是可以同时被多个线程持有的，可是synchronized做不到。</p>
</li>
<li>
<p>synchronized锁不够灵活，一旦synchronized锁已经被某个线程获得了，此时其他线程如果还想获得，那它只能被阻塞，直到持有锁的线程运行完毕或者发生异常从而释放这个锁。如果持有锁的线程持有很长时间才释放，那么整个程序的运行效率就会降低，而且如果持有锁的线程永远不释放锁，那么尝试获取锁的线程只能永远等下去。相比之下，Lock类在等锁的过程中，如果使用的是lockInterruptibly方法，那么如果觉得等待的时间太长了不想再继续等待，可以中断退出，也可以用tryLock()等方法尝试获取锁，如果获取不到锁也可以做别的事，更加灵活。 </p>
</li>
<li>
<p>性能区别：在Java 5以及之前，synchronized的性能比较低，但是到了Java 6以后发生了变化，因为JDK对synchronized进行了很多优化，比如自适应自旋、锁消除、锁粗化、轻量级锁、偏向锁等，所以后期的Java版本里的synchronized的性能并不比Lock差。 </p>
</li>
</ul>
</blockquote>
<h3 id="15-synchronized和Lock如何选择">15. synchronized和Lock如何选择?</h3>
<p><strong>参考回答</strong>：</p>
<blockquote>
<ol>
<li>
<p>如果能不用最好既不使用Lock也不使用synchronized。因为在许多情况下你可以使用java.util.concurrent包中的机制，它会为你处理所有的加锁和解锁操作，也就是推荐优先使用工具类来加解锁。</p>
</li>
<li>
<p>如果synchronized关键字适合你的程序，那么请尽量使用它，这样可以减少编写代码的数量，减少出错的概率。因为一旦忘记在finally里unlock，代码可能会出很大的问题，而使用synchronized更安全。</p>
</li>
<li>
<p>如果特别需要Lock的特殊功能，比如尝试获取锁、可中断、超时功能等，才使用Lock。</p>
</li>
</ol>
</blockquote>
<p><a target="_blank" rel="noopener" href="https://learn.lianglianglee.com/%E4%B8%93%E6%A0%8F/Java%20%E5%B9%B6%E5%8F%91%E7%BC%96%E7%A8%8B%2078%20%E8%AE%B2-%E5%AE%8C/22%20synchronized%20%E5%92%8C%20Lock%20%E5%AD%B0%E4%BC%98%E5%AD%B0%E5%8A%A3%EF%BC%8C%E5%A6%82%E4%BD%95%E9%80%89%E6%8B%A9%EF%BC%9F.md">22 synchronized 和 Lock 孰优孰劣，如何选择?</a></p>
<h3 id="16-synchronized和ReentrantLock区别是什么">16. synchronized和ReentrantLock区别是什么?</h3>
<p><strong>参考回答</strong>：</p>
<blockquote>
<p>synchronized和ReentrantLock都是Java中提供的可重入锁，二者的主要区别有以下5个：</p>
<ul>
<li>
<p>用法不同：synchronized可以用来修饰普通方法、静态方法和代码块，而ReentrantLock只能用于代码块。</p>
</li>
<li>
<p>获取锁和释放锁的机制不同：synchronized是自动加锁和释放锁的，而ReentrantLock需要手动加锁和释放锁。</p>
</li>
<li>
<p>锁类型不同：synchronized是非公平锁，而ReentrantLock默认为非公平锁，也可以手动指定为公平锁。 </p>
</li>
<li>
<p>响应中断不同：ReentrantLock可以响应中断，解决死锁的问题，而synchronized不能响应中断。</p>
</li>
<li>
<p>底层实现不同：synchronized是JVM层面通过监视器实现的，而ReentrantLock是基于AQS</p>
</li>
</ul>
</blockquote>
<p><a target="_blank" rel="noopener" href="https://www.51cto.com/article/707239.html">https://www.51cto.com/article/707239.html</a></p>
<h3 id="17-volatile关键字的作用">17. volatile关键字的作用</h3>
<blockquote>
<p><strong>参考回答</strong>：</p>
<ul>
<li>
<p>对于可见性，Java提供了volatile关键字来保证可见性和禁止指令重排。volatile确保一个线程的修改能对其他线程是可见的。当一个共享变量被volatile修饰时，它会保证修改的值会立即被更新到主内存中，当有其他线程需要读取时，它会去内存中读取新值。</p>
</li>
<li>
<p>从实践角度而言，volatile的一个重要作用就是和CAS结合，保证了原子性，详细的可以参见java.util.concurrent.atomic包下的类，比如AtomicInteger。</p>
</li>
</ul>
</blockquote>
<h3 id="18-Java中能创建volatile数组吗">18. Java中能创建volatile数组吗?</h3>
<p><strong>参考回答</strong>：</p>
<blockquote>
<p>能，Java中可以创建volatile类型数组，不过只是一个指向数组的引用，而不是整个数组。意思是，如果改变引用指向的数组，将会受到volatile的保护，但是如果多个线程同时改变数组的元素，volatile标示符就不能起到之前的保护作用了。 </p>
</blockquote>
<h3 id="19-volatile能使得一个非原子操作变成原子操作吗">19. volatile能使得一个非原子操作变成原子操作吗?</h3>
<blockquote>
<p><strong>参考回答</strong>：</p>
<ul>
<li>
<p>关键字volatile的主要作用是使变量在多个线程间可见，但无法保证原子性，对于多个线程访问同一个实例变量需要加锁进行同步。</p>
</li>
<li>
<p>虽然volatile只能保证可见性不能保证原子性，但用volatile修饰long和double可以保证其操作原子性。（<a target="_blank" rel="noopener" href="https://blog.csdn.net/tian2342/article/details/122665957%EF%BC%89">https://blog.csdn.net/tian2342/article/details/122665957）</a></p>
</li>
</ul>
</blockquote>
<h3 id="20-synchronized和volatile的区别是什么">20. synchronized和volatile的区别是什么?</h3>
<p><strong>参考回答</strong>：</p>
<blockquote>
<ul>
<li>
<p>synchronized表示只有一个线程可以获取作用对象的锁，执行代码，阻塞其他线程。</p>
</li>
<li>
<p>volatile表示变量在CPU的寄存器中是不确定的，必须从主存中读取。保证多线程环境下变量的可见性；禁止指令重排序。</p>
</li>
</ul>
<p><strong>区别</strong></p>
<ul>
<li>
<p>volatile是变量修饰符；synchronized可以修饰方法，代码块。</p>
</li>
<li>
<p>volatile仅能实现变量的修改可见性，不能保证原子性；而synchronized则可以保证变量的修改可见性和原子性。 </p>
</li>
<li>
<p>volatile不会造成线程的阻塞；synchronized可能会造成线程的阻塞。</p>
</li>
<li>
<p>volatile标记的变量不会被编译器优化；synchronized标记的变量可以被编译器优化。</p>
</li>
<li>
<p>volatile关键字是线程同步的轻量级实现，所以volatile性能肯定比synchronized关键字要好。但是volatile关键字只能用于变量而synchronized关键字可以修饰方法以及代码块。synchronized关键字在JavaSE1.6之后进行了主要包括为了减少获得锁和释放锁带来的性能消耗而引入的偏向锁和轻量级锁以及其它各种优化之后执行效率有了显著提升，实际开发中使用synchronized关键字的场景还是更多一些。 </p>
</li>
</ul>
</blockquote>
<h3 id="21-说下你对volatile的理解">21. 说下你对volatile的理解</h3>
<blockquote>
<p>volatile是Java虚拟机提供的轻量级的同步机制，具有以下特点：</p>
<ol>
<li>
<p>保证可见性：volatile保证了多个线程对共享变量的操作是可见的。当一个线程修改了共享变量的值，其他线程会立即看到这个改变。</p>
</li>
<li>
<p>禁止指令重排：volatile通过禁止指令重排来保证顺序性。在多线程环境下，为了提高程序执行效率，编译器和处理器可能会对指令进行重新排序。但是，如果一个变量被volatile修饰，就禁止了指令重排，确保每个线程都能看到正确的操作顺序。</p>
</li>
</ol>
<p>总的来说，volatile可以确保多个线程对共享变量的操作一致，避免了数据不一致的问题。<strong>但是它不能保证原子性，因此对于需要保证原子性的操作还需要使用其他同步机制，如synchronized关键字或java.util.concurrent.atomic包中的原子类。 </strong></p>
<p><strong>volatile关键字</strong>通过以下方式禁止指令重排：</p>
<ol>
<li>
<p>内存屏障（Memory Barrier）：当编译器或处理器看到volatile修饰的变量时，它会在该变量前后插入内存屏障。内存屏障可以保证在该屏障之前的所有读写操作都必须在屏障之后的读写操作之前完成。这实际上就禁止了指令重排。</p>
</li>
<li>
<p>强制立即刷新到主内存：当一个线程向被volatile关键字修饰的变量写入数据时，虚拟机会强制这个值被立即刷新到主内存中。这确保了其他线程可以立即看到这个修改。</p>
</li>
<li>
<p>强制从主内存读取：当一个线程读取被volatile关键字修饰的变量时，虚拟机会强制要求它从主内存中读取这个值，而不是从该线程的本地缓存中读取。这确保了该线程可以立即看到其他线程对这个变量的修改。 </p>
</li>
</ol>
</blockquote>
<h2 id="线程池">线程池</h2>
<h3 id="1-什么是线程池？为什么要用线程池">1. 什么是线程池？为什么要用线程池?</h3>
<p><strong>参考回答</strong>：</p>
<blockquote>
<p>答：Java中的线程池是运用场景最多的并发框架，几乎所有需要异步或并发执行任务的程序都可以使用线程池。在开发过程中，合理地使用线程池能够带来许多好处。</p>
<ul>
<li>
<p>降低资源消耗。通过重复利用已创建的线程，降低线程创建和销毁造成的消耗。</p>
</li>
<li>
<p>提高响应速度。当任务到达时，任务可以不需要等到线程创建就能立即执行。</p>
</li>
<li>
<p>提高线程的可管理性。线程是稀缺资源，如果无限制地创建，不仅会消耗系统资源，还会降低系统的稳定性，使用线程池可以进行统一分配、调优和监控。但是，要做到合理利用 。 </p>
</li>
</ul>
</blockquote>
<h3 id="2-核心参数有哪些">2. 核心参数有哪些?</h3>
<p><strong>分析</strong>：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="title function_">ThreadPoolExecutor</span><span class="params">(<span class="type">int</span> corePoolSize,</span></span><br><span class="line"><span class="params">                          <span class="type">int</span> maximumPoolSize,</span></span><br><span class="line"><span class="params">                          <span class="type">long</span> keepAliveTime,</span></span><br><span class="line"><span class="params">                          TimeUnit unit,</span></span><br><span class="line"><span class="params">                          BlockingQueue&lt;Runnable&gt; workQueue,</span></span><br><span class="line"><span class="params">                          ThreadFactory threadFactory,</span></span><br><span class="line"><span class="params">                          RejectedExecutionHandler handler)</span> &#123;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<blockquote>
<p><strong>参考回答</strong>：</p>
<p>线程池的构造函数有7个参数：</p>
<ul>
<li>
<p>corePoolSize：核心线程数</p>
</li>
<li>
<p>maximumPoolSize：线程池能创建线程的最大个数</p>
</li>
<li>
<p>keepAliveTime：空闲线程存活时间</p>
</li>
<li>
<p>unit：时间单位，为keepAliveTime指定时间单位</p>
</li>
<li>
<p>workQueue：阻塞队列，用于保存任务的阻塞队列</p>
</li>
<li>
<p>threadFactory：创建线程的工程类</p>
</li>
<li>
<p>handler：饱和策略（拒绝策略） </p>
</li>
</ul>
</blockquote>
<h3 id="3-线程池的种类，区别和使用场景">3. 线程池的种类，区别和使用场景</h3>
<p><strong>分析</strong></p>
<blockquote>
<p><strong>参考回答</strong>：</p>
<ol>
<li>newCachedThreadPool</li>
</ol>
<p>newCachedThreadPool创建一个可缓存线程池，如果当前线程池的长度超过了处理的需要时，它可以灵活的回收空闲的线程，当需要增加时，它可以灵活的添加新的线程，而不会对池的长度作任何限制。</p>
<p>使用场景：执行很多短期异步的小程序。</p>
<ul>
<li>newFixedThreadPool</li>
</ul>
<p>创建一个定长线程池，可控制线程最大并发数，超出的线程会在队列中等待。定长线程池的大小最好根据系统资源进行设置。</p>
<p>使用场景：执行长期的任务，性能好很多。</p>
<ul>
<li>newScheduledThreadPool</li>
</ul>
<p>创建一个固定长度的线程池，而且支持定时的以及周期性的任务执行。</p>
<p>使用场景：周期性执行任务的场景。</p>
<ul>
<li>newSingleThreadExecutor</li>
</ul>
<p>创建一个单线程化的线程池，它只会用唯一的工作线程来执行任务，如果这个唯一的线程因为异常结束，那么会有一个新的线程来替代它，必须保证前一项任务执行完毕后才能执行后一项。保证所有任务按照指定顺序执行。</p>
<p>使用场景：适合多个任务顺序执行的场景，不需要考虑并发问题。 </p>
</blockquote>
<p><a target="_blank" rel="noopener" href="https://www.cnblogs.com/sachen/p/7401959.html">博客园</a></p>
<h3 id="4-线程池的拒绝策略有哪些">4. 线程池的拒绝策略有哪些</h3>
<p><strong>分析</strong></p>
<blockquote>
<p><strong>参考回答</strong>：</p>
<ul>
<li>AbortPolicy, 默认</li>
</ul>
<p>该策略是线程池的默认策略。使用该策略时，如果线程池队列满了丢掉这个任务并且抛出RejectedExecutionException异常。</p>
<ul>
<li>DiscardPolicy</li>
</ul>
<p>这个策略和AbortPolicy的silent版本，如果线程池队列满了，会直接丢掉这个任务并且不会有任何异常。</p>
<ul>
<li>DiscardOldestPolicy</li>
</ul>
<p>这个策略从字面上也很好理解，丢弃最老的。也就是说如果队列满了，会将最早进入队列的任务删掉腾出空间，再尝试加入队列。因为队列是队尾进，队头出，所以队头元素是最老的，因此每次都是移除队头元素后再尝试入队。</p>
<ul>
<li>CallerRunsPolicy</li>
</ul>
<p>使用此策略，如果添加到线程池失败，那么调用线程会自己去执行该任务，不会等待线程池中的线程去执行。就像是个急脾气的人，我等不到别人来做这件事就干脆自己干。 </p>
</blockquote>
<h3 id="5-在Java中Executor和Executors的区别">5. 在Java中Executor和Executors的区别?</h3>
<p><strong>参考回答</strong>：</p>
<blockquote>
<p>Executors工具类的不同方法按照我们的需求创建了不同的线程池，来满足业务的需求。</p>
<p>Executor接口对象能执行我们的线程任务。</p>
<p>ExecutorService接口继承了Executor接口并进行了扩展，提供了更多的方法我们能获得任务执行的状态并且可以获取任务的返回值。 </p>
</blockquote>
<h3 id="6-线程池都有哪些状态">6.线程池都有哪些状态</h3>
<p><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="2025-01-09-JUC%E5%9F%BA%E7%A1%80%E9%9D%A2%E8%AF%95%E9%A2%98/image-1.png" alt=""></p>
<p><strong>参考回答</strong>：</p>
<blockquote>
<ul>
<li>
<p>RUNNING：这是最正常的状态，接受新的任务，处理等待队列中的任务。</p>
</li>
<li>
<p>SHUTDOWN：不接受新的任务提交，但是会继续处理等待队列中的任务。</p>
</li>
<li>
<p>STOP：不接受新的任务提交，不再处理等待队列中的任务，中断正在执行任务的线程。</p>
</li>
<li>
<p>TIDYING：所有的线程都销毁了，workerCount为0，线程池的状态转换为TIDYING状态时，会执行钩子方法terminated()。</p>
</li>
<li>
<p>TERMINATED：terminated()方法结束后，线程池的状态就会变成这个。</p>
</li>
</ul>
</blockquote>
<h3 id="7-线程池中submit-和execute-方法有什么区别">7. 线程池中submit()和execute()方法有什么区别?</h3>
<blockquote>
<p><strong>参考回答</strong>：</p>
<ul>
<li>
<p>相同点：</p>
<ul>
<li>相同点就是都可以开启线程执行池中的任务。</li>
</ul>
</li>
<li>
<p>不同点：</p>
<ul>
<li>
<p>接收参数：execute()只能执行Runnable类型的任务。submit()可以执行Runnable和Callable类型的任务。</p>
</li>
<li>
<p>返回值：submit()方法可以返回持有计算结果的Future对象，而execute()没有。</p>
</li>
<li>
<p>异常处理：submit()方便Exception处理。 </p>
</li>
</ul>
</li>
</ul>
</blockquote>
<h3 id="8-分析线程池的实现原理和线程的调度过程">8. 分析线程池的实现原理和线程的调度过程</h3>
<p><strong>分析</strong></p>
<p><strong>参考回答</strong>：</p>
<blockquote>
<p>提交一个任务到线程池中，线程池的处理流程如下：</p>
<ol>
<li>
<p>如果当前运行的线程数小于核心线程数，那么就会新建一个线程来执行任务。</p>
</li>
<li>
<p>如果当前运行的线程数等于或大于核心线程数，并且任务队列没满，那么就把该任务放入到任务队列里等待执行。</p>
</li>
<li>
<p>如果任务队列满了，但是当前运行的线程数小于最大线程数的，就新建一个线程来执行任务。</p>
</li>
<li>
<p>如果当前运行的线程数已经等同于最大线程数了，新建线程将会使当前运行的线程超出最大线程数，那么当前任务会被拒绝，调用拒绝策略方法。</p>
</li>
</ol>
</blockquote>
<h3 id="9-线程池的最大线程数目根据什么确定">9. 线程池的最大线程数目根据什么确定</h3>
<p><strong>分析</strong></p>
<p><strong>参考回答</strong>：</p>
<blockquote>
<p>线程池用来执行CPU密集型任务时，设置线程数为cpu核心数+1，这样可以使得每个线程都在执行任务。用来执行IO密集型任务时，大部分线程都阻塞，所以设置线程数为2*cpu核数。 </p>
</blockquote>
<h3 id="10-线程池如何调优">10. 线程池如何调优</h3>
<p><strong>分析</strong></p>
<blockquote>
<p><strong>参考回答</strong>：</p>
<ol>
<li>
<p>CPU密集型任务配置尽可能小的线程，cpu核数+1。</p>
</li>
<li>
<p>IO密集型任务则由于线程并不是一直在执行任务，则配置尽可能多的线程，如2*cpu核数。</p>
</li>
<li>
<p>混合型任务，如果可以拆分，则将其拆分成一个CPU密集型任务和一个IO密集型任务。只要这两个任务执行的时间相差不是太大，那么分解后并发执行的吞吐率高于串行执行的吞吐率；如果这两个任务执行时间相差太大，则没必要进行分解。</p>
</li>
<li>
<p>优先级不同的任务可以使用优先级队列PriorityBlockingQueue来处理，它可以让优先级高的任务先得到执行。</p>
</li>
<li>
<p>执行时间不同的任务可以交给不同线程池来处理，或者也可以使用优先级队列，让执行时间短的任务先执行。</p>
</li>
<li>
<p>依赖数据库连接池的任务，因为线程提交SQL后需要等待数据库返回结果，线程数应该设置得较大，这样才能更好的利用CPU。</p>
</li>
<li>
<p>建议使用有界队列，有界队列能增加系统的稳定性和预警能力。可以根据需要设大一点，比如几千。使用无界队列，线程池的队列就会越来越大，有可能会撑满内存，导致整个系统不可用。 </p>
</li>
</ol>
</blockquote>
<h3 id="11-线程池如何实现动态修改">11. 线程池如何实现动态修改?</h3>
<p><strong>参考回答</strong>：</p>
<blockquote>
<ol>
<li>首先线程池提供了部分setter方法可以设置线程池的参数；</li>
</ol>
<p> a. 修改核心线程数，最大线程数，空闲线程停留时间，拒绝策略等。</p>
<p> b. 可以将线程池的配置参数放入配置中心，当需要调整的时候，去配置中心修改就行。</p>
<ul>
<li>什么时候修改呢?</li>
</ul>
<p> a. 这里需要监控报警策略，获取线程池状态指标，当指标判定为异常之后进行报警。</p>
<p> b. 分析指标异常原因，评估处理策略，最后通过上述线程池提供的接口进行动态修改。(可以将动态配置)</p>
</blockquote>
<p><strong>推荐学习</strong>：</p>
<p><a target="_blank" rel="noopener" href="https://tech.meituan.com/2020/04/02/java-pooling-pratice-in-meituan.html">Java线程池实现原理及其在美团业务中的实践</a></p>
<h3 id="12-使用无界队列的线程池会导致什么问题">12. 使用无界队列的线程池会导致什么问题?</h3>
<p><strong>参考回答</strong>：</p>
<blockquote>
<p>例如newFixedThreadPool使用了无界的阻塞队列LinkedBlockingQueue，如果线程获取一个任务后，任务的执行时间比较长，会导致队列的任务越积越多，导致机器内存使用不停飙升，最终导致OOM。 </p>
</blockquote>
<h3 id="13-线程池的问题，如果线程池当前处于空闲的状态，核心线程数量是不会被销毁的，那这几个核心线程处于什么状态？为什么处于这个状态">13. 线程池的问题，如果线程池当前处于空闲的状态，核心线程数量是不会被销毁的，那这几个核心线程处于什么状态？为什么处于这个状态?</h3>
<p><strong>分析</strong></p>
<p>这里面面试官其实想问你线程复用的逻辑，以及对线程状态机的理解，知不知道都要有一个分析思考的过程，不要一上来就回答答案或者说不知道，瞎猜。</p>
<p><strong>参考回答</strong></p>
<blockquote>
<p>首先线程本身创建和销毁都是成本比较高的，那就排除new和terminated状态，没有任务运行排除runnable状态，剩下阻塞和等待，因为线程不会销毁需要一直等待执行任务，超时等待也不太可能，最后同步锁才会进入阻塞状态，所以我猜是一直等待。 </p>
</blockquote>
<p><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="2025-01-09-JUC%E5%9F%BA%E7%A1%80%E9%9D%A2%E8%AF%95%E9%A2%98/image-2.png" alt=""></p>
<h3 id="14-如果不允许线程池丢弃任务，应该选择哪个拒绝策略？">14. 如果不允许线程池丢弃任务，应该选择哪个拒绝策略？</h3>
<p>大家应该都知道，线程池的核心线程满了，就会放在阻塞队列，阻塞队列满了会创建临时线程，如果超过最大线程数，就会触发拒绝策略。那很多人都是用直接拒绝的策略，这样任务就直接丢了。 </p>
<p>但是如果任务很重要，不允许丢弃你会怎么做呢？那大家可以把工作中用到的方案发在评论区，我给你提供几种：</p>
<ol>
<li>
<p>用CallerRunsPolicy，它会采用主线程执行任务，但是如果任务非常耗时会阻塞主线程，在高并发场景慎用！</p>
</li>
<li>
<p>将任务进行持久化，可以采用mysql、redis、或者mq异步等方案持久化，后续再对任务进行补偿执行。</p>
</li>
<li>
<p>  也可以参考netty：它会再创建新的一个异步线程处理任务。 </p>
</li>
</ol>
<p><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="2025-01-09-JUC%E5%9F%BA%E7%A1%80%E9%9D%A2%E8%AF%95%E9%A2%98/image76.png" alt=""></p>
<h3 id="15-Callable和Runnable接口有什么区别？">15. Callable和Runnable接口有什么区别？</h3>
<blockquote>
<p>Callable和Runnable接口都是用于在Java中实现多线程的接口，但它们之间有一些区别：</p>
<ol>
<li>
<p><strong>返回值</strong>：</p>
<ul>
<li>
<p>Runnable接口的run()方法没有返回值，它通常用于执行一些不需要返回结果的任务。</p>
</li>
<li>
<p>Callable接口的call()方法可以返回一个结果，它允许线程执行任务并返回结果，可以通过Future对象获取。</p>
</li>
</ul>
</li>
<li>
<p><strong>抛出异常</strong>：</p>
<ul>
<li>
<p>Runnable接口的run()方法不能抛出受检异常，只能抛出未检查异常。</p>
</li>
<li>
<p>Callable接口的call()方法可以抛出受检异常。</p>
</li>
</ul>
</li>
<li>
<p><strong>泛型</strong>：</p>
<ul>
<li>
<p>Callable接口使用了泛型，可以指定call()方法的返回类型。</p>
</li>
<li>
<p>Runnable接口没有使用泛型。</p>
</li>
</ul>
</li>
<li>
<p><strong>线程池支持</strong>：</p>
<ul>
<li>
<p>Callable接口通常与Executor框架一起使用，可以提交给ExecutorService的线程池执行。</p>
</li>
<li>
<p>Runnable接口同样可以与Executor框架一起使用，但是Callable接口提供了更丰富的功能，如取消任务、获取执行结果等。 </p>
</li>
</ul>
</li>
</ol>
</blockquote>
<h3 id="16-线程池中线程异常后：销毁还是复用？">16. 线程池中线程异常后：销毁还是复用？</h3>
<blockquote>
<p>第一个线程池拒绝策略是：</p>
<p><strong>执行策略为AbortPolicy</strong>：执行任务出现异常，向提交任务线程，即调用线程会抛出RejectedExecutionException异常，并会创建一个新的线程继续执行后续任务。</p>
<p><strong>执行策略为DiscardPolicy</strong>：内部会把异常信息吞掉，既不会把异常抛给这个线程池线程，也不会创建新的线程加入到线程池中。</p>
<p>这两种执行方式，都不会影响线程池里面其他线程的正常执行，更便于线程池的资源管理，可以防止资源被滥用，如果程序有默认处 </p>
</blockquote>
<h3 id="17-线程池阻塞队列类型">17.线程池阻塞队列类型</h3>
<blockquote>
<p>线程池常用的阻塞队列类型主要有以下几种：</p>
<ol>
<li>
<p><code>ArrayBlockingQueue</code>：基于数组实现的有界阻塞队列。其容量在创建时指定，一旦达到容量上限，新的入队操作会阻塞等待。</p>
</li>
<li>
<p><code>LinkedBlockingQueue</code>：基于链表实现的阻塞队列。默认情况下，其容量没有上限，可以看作是无界的，但也可以在创建时指定容量。</p>
</li>
<li>
<p><code>PriorityBlockingQueue</code>：无界的优先级阻塞队列，元素按照自定义的优先级规则进行排序。</p>
</li>
<li>
<p><code>SynchronousQueue</code>：不存储元素的阻塞队列，入队操作必须等待出队操作，反之亦然，常用于实现线程之间的直接传递。</p>
</li>
<li>
<p><code>DelayQueue</code>：无界的延迟阻塞队列，元素只有在指定的延迟时间到期后才能被取出。</p>
</li>
<li>
<p><code>LinkedTransferQueue</code>：无界的阻塞队列，具有高效的元素传递特性。</p>
</li>
<li>
<p><code>LinkedBlockingDeque</code>：基于链表实现的双向阻塞队列，可以从队列的头部和尾部进行插入和删除操作。</p>
</li>
</ol>
</blockquote>
<h2 id="Java中的锁">Java中的锁</h2>
<h3 id="1-Lock接口和synchronized对比同步它有什么优势">1. Lock接口和synchronized对比同步它有什么优势?</h3>
<p><strong>参考回答</strong>：</p>
<blockquote>
<p>Lock接口比同步方法和同步块提供了更具扩展性的锁操作。它们允许更灵活的结构，可以具有完全不同的性质，并且可以支持多个相关类的条件对象。</p>
<p>它的优势有：</p>
<ul>
<li>
<p><strong>(1) 可以使锁更公平。</strong></p>
</li>
<li>
<p><strong>(2) 可以使线程在等待锁的时候响应中断。</strong></p>
</li>
<li>
<p><strong>(3) 可以让线程尝试获取锁，并在无法获取锁的时候立即返回或者等待一段时间。</strong></p>
</li>
<li>
<p><strong>(4) 可以在不同的范围，以不同的顺序获取和释放锁。</strong></p>
</li>
</ul>
<p>整体上来说Lock是synchronized的扩展版，Lock提供了无条件的、可轮询的(tryLock方法)、定时的(tryLock带参方法)、可中断的(lockInterruptibly)、可多条件队列的(newCondition方法)锁操作。另外Lock的实现类基本都支持非公平锁(默认)和公平锁，synchronized只支持非公平锁，当然，在大部分情况下，非公平锁是高效的选择。 </p>
</blockquote>
<h3 id="2-乐观锁和悲观锁的理解及如何实现，有哪些实现方式">2. 乐观锁和悲观锁的理解及如何实现，有哪些实现方式?</h3>
<p><strong>参考回答</strong>：</p>
<blockquote>
<ul>
<li>
<p><strong>悲观锁：</strong>总是假设最坏的情况，每次去拿数据的时候都认为别人会修改，所以每次在拿数据的时候都会上锁，这样别人想拿这个数据就会阻塞直到它拿到锁。传统的关系型数据库里边就用到了很多这种锁机制，比如行锁，表锁等，读锁，写锁等，都是在做操作之前先上锁。再比如Java里面的同步原语synchronized关键字的实现也是悲观锁。</p>
</li>
<li>
<p><strong>乐观锁：</strong>顾名思义，就是很乐观，每次去拿数据的时候都认为别人不会修改，所以不会上锁，但是在更新的时候会判断一下在此期间别人有没有去更新这个数据，可以使用版本号等机制。乐观锁适用于多读的应用类型，这样可以提高吞吐量，像数据库提供的类似于write_condition机制，其实都是提供的乐观锁。在Java中java.util.concurrent.atomic包下面的原子变量类就是使用了乐观锁的一种实现方式CAS实现的。 </p>
</li>
</ul>
</blockquote>
<h3 id="3-什么是CAS">3. 什么是CAS</h3>
<p><strong>分析</strong></p>
<p>回答出CAS操作的原子性，系统硬件级别提供支持</p>
<p><strong>回答</strong></p>
<blockquote>
<p>CAS即CompareAndSwap，Java中可以通过CAS操作来保证原子性，原子性就是不可被中断的一系列操作或者一个操作，简单来说就是一系列操作要么全部完成，要么失败，不能被中断。</p>
<p>CAS主要包含三个参数（V，expect，update），V表示要更新的变量（内存值）、expect表示预期值（旧值）、update表示新值。算法流程是首先比较V和expect的值，如果相等，将update值赋值给V，如果不相等说明有其他线程对该变量做了更新。这个参数有的地方也会用（V，A，B）表示，其中A表示预期值，B表示新值。</p>
<p>当多个线程同时操作一个共享变量时，只有一个线程可以对变量进行成功更新，其他线程均会失败，但是失败并不会被挂起，进行再次尝试，也就是自旋。Java中的自旋锁就是利用CAS来实现的。 </p>
</blockquote>
<p><a target="_blank" rel="noopener" href="https://www.cnblogs.com/huansky/p/15746624.html">Java CAS 原理详解 - huansky - 博客园</a></p>
<h3 id="4-CAS的会产生什么问题">4. CAS的会产生什么问题?</h3>
<p><strong>参考回答</strong>：</p>
<blockquote>
<p><strong>1、ABA问题：</strong></p>
<p>比如说一个线程one从内存位置V中取出A，这时候另一个线程two也从内存中取出A，并且two进行了一些操作变成了B，然后two又将V位置的数据变成A，这时候线程one进行CAS操作发现内存中仍然是A，然后one操作成功。尽管线程one的CAS操作成功，但可能存在潜藏的问题。从Java1.5开始JDK的atomic包里提供了一个类AtomicStampedReference来解决ABA问题。</p>
<p><strong>2、循环时间长开销大：</strong></p>
<p>对于资源竞争严重（线程冲突严重）的情况，CAS自旋的概率会比较大，从而浪费更多的CPU资源，效率低于synchronized。</p>
<p><strong>3、只能保证一个共享变量的原子操作：</strong></p>
<p>当对一个共享变量执行操作时，我们可以使用循环CAS的方式来保证原子操作，但是对多个共享变量操作时，循环CAS就无法保证操作的原子性，这个时候就可以用锁。 </p>
</blockquote>
<h3 id="5-什么是原子类">5. 什么是原子类</h3>
<blockquote>
<p><strong>参考回答</strong>：</p>
<ul>
<li>
<p>java.util.concurrent.atomic包：是原子类的小工具包，支持在单个变量上解解锁的线程安全编程。原子变量类相当于一种泛化的volatile变量，能够支持原子的和有条件的读-改-写操作。</p>
</li>
<li>
<p>比如：AtomicInteger表示一个int类型的值，并提供了get和set方法，这些Volatile类型的int变量在读取和写入上有着相同的内存语义。它还提供了一个原子的compareAndSet方法（如果该方法成功执行，那么将实现与读取/写入一个volatile变量相同的内存效果），以及原子的添加、递增和递减等方法。AtomicInteger表面上非常像一个扩展的Counter类，但在发生竞争的情况下能提供更高的可伸缩性，因为它直接利用了硬件对并发的支持。</p>
</li>
</ul>
<p>简单来说就是原子类来实现CAS无锁模式的算法。</p>
</blockquote>
<h3 id="6-原子类的常用类">6. 原子类的常用类</h3>
<p><strong>参考回答</strong>：</p>
<blockquote>
<ul>
<li>
<p>AtomicBoolean</p>
</li>
<li>
<p>AtomicInteger</p>
</li>
<li>
<p>AtomicLong</p>
</li>
<li>
<p>AtomicReference </p>
</li>
</ul>
</blockquote>
<h3 id="7-说一下Atomic的原理">7. 说一下Atomic的原理?</h3>
<p><strong>参考回答</strong>：</p>
<blockquote>
<ul>
<li>Atomic包中的类基本的特性就是在多线程环境下，当有多个线程同时对单个（包括基本类型及引用类型）变量进行操作时，具有排他性，即当多个线程同时对该变量的值进行更新时，仅有一个线程能成功，而未成功的线程可以自旋锁一样，继续尝试，一直等到执行成功。</li>
</ul>
</blockquote>
<h3 id="8-死锁与活锁的区别，死锁与饥饿的区别">8. 死锁与活锁的区别，死锁与饥饿的区别?</h3>
<p><strong>参考回答</strong>：</p>
<blockquote>
<p><strong>死锁：</strong>是指两个或两个以上的进程（或线程）在执行过程中，因争夺资源而造成的一种互相等待的现象，若无外力作用，它们都将无法推进下去。</p>
<p><strong>活锁：</strong>任务或者执行者没有被阻塞，由于某些条件没有满足，导致一直重复尝试，失败，尝试，失败。</p>
<p>活锁和死锁的区别在于，处于活锁的实体是在不断的改变状态，这就是所谓的“活”，而处于死锁的实体表现为等待；活锁有可能自行解开，死锁则不能。</p>
<p><strong>饥饿：</strong>一个或者多个线程因为种种原因无法获得所需要的资源，导致一直无法执行的状态。 </p>
<p>Java中导致饥饿的原因:</p>
<p>1、高优先级线程吞噬所有的低优先级线程的CPU时间。</p>
<p>2、线程被永久堵塞在一个等待进入同步块的状态，因为其他线程总是能在它之前持续地对该同步块进行访问。</p>
<p>3、线程在等待一个本身也处于永久等待完成的对象(比如调用这个对象的wait方法)，因为其他线程总是被持续地获得唤醒。 </p>
</blockquote>
<h3 id="9-如何避免死锁">9. 如何避免死锁</h3>
<blockquote>
<p>死锁是多线程编程中的一种常见问题，它发生在两个或多个线程相互等待对方释放资源的情况下，导致程序无法继续执行。为了避免死锁，我们可以采用以下策略：</p>
<ol>
<li>
<p><strong>锁顺序</strong>：定义一个固定的锁获取顺序，并要求所有线程都按照相同的顺序获取锁。这可以减少不同线程之间资源争夺的可能性。</p>
</li>
<li>
<p><strong>超时机制</strong>：在获取锁时，设置一个超时时间。如果超过指定时间仍然无法获取锁，线程应该释放已经持有的锁并重试，或者采取其他适当的措施。这有助于避免线程无限期地等待锁。</p>
</li>
<li>
<p><strong>避免嵌套锁</strong>：尽量避免在一个锁的持有期间再次尝试获取其他锁。如果确实需要获取多个锁，请确保获取的顺序是固定的，以减少死锁风险。</p>
</li>
<li>
<p><strong>使用锁机制</strong>：比如Java中的ReentrantLock，它支持可中断的锁获取和条件等待，有助于避免死锁。 </p>
</li>
</ol>
</blockquote>
<h3 id="10-为什么-wait-和-notify-方法要在同步块中调用">10. 为什么 wait 和 notify 方法要在同步块中调用</h3>
<blockquote>
<p>调用wait()就是释放锁，释放锁的前提是必须要先获得锁，先获得锁才能释放锁。</p>
<p>notify(),notifyAll()是将锁交给含有wait()方法的线程，让其继续执行下去，如果自身没有锁，怎么叫把锁交给其他线程 。</p>
</blockquote>
<h3 id="11-说下对AQS的理解">11. 说下对AQS的理解</h3>
<p>AQS（AbstractQueuedSynchronizer）是Java并发编程中的一个重要组件，它是一个抽象类，提供了线程同步的底层实现机制。AQS的作用是实现线程的同步和互斥操作，它提供了两种主要的锁机制，分别是排他锁和共享锁。</p>
<p><strong>排他锁也称为独占锁</strong>，在多个线程竞争同一共享资源时，同一时刻只允许一个线程访问该共享资源，即多个线程中只有一个线程获得锁资源。在AQS中，排他锁是通过内置的同步状态来实现的。当同步状态为0时，表示锁是未被获取的；当同步状态大于0时，表示锁已经被获取且被占用；当同步状态小于0时，表示锁已经被获取但是处于等待状态。</p>
<p><strong>共享锁</strong>允许多个线程同时获得锁资源，但是在同一时刻只有一个线程可以获取到锁的拥有权，其他线程需要等待该线程释放锁。在AQS中，共享锁的实现与排他锁类似，也是通过先进内置的同步状态来实现的。</p>
<p>AQS通过一个内置的<strong>FIFO</strong>（先进先出）等待队列来实现线程的排队和调度。当线程需要获取锁资源时，如果锁已经被其他线程获取，则该线程会被加入到等待队列中等待。当锁被释放时，等待队列中的第一个线程会获得锁资源并继续执行。</p>
<p>在实现AQS时，需要继承自AQS类并实现其抽象方法。其中比较重要的方法包括：tryAcquire()和tryRelease()方法，用于实现锁的获取和释放；acquire()和release()方法，用于实现阻塞和唤醒操作；isHeldExclusively()方法，用于判断是否是排他锁。 </p>
<p>答案：</p>
<blockquote>
<p>AQS是多线程同步器，它是J.U.C包中多个组件的底层实现，如Lock、CountDownLatch、Semaphore等都用到了AQS。<strong>从本质上来说，AQS提供了两种锁机制，分别是排他锁，和共享锁。</strong>排他锁，就是存在多线程竞争同一共享资源时，同一时刻只允许一个线程访问该共享资源，也就是多个线程中只能有一个线程获得锁资源，比如Lock中的ReentrantLock重入锁实现就是用到了AQS中的排他锁功能。<strong>共享锁也称为读锁</strong>，就是在同一时刻允许多个线程同时获得锁资源，比如CountDownLatch和Semaphore都是用到了AQS中的共享锁功能。</p>
<p>AQS有三个核心的问题：</p>
<p>AQS维持着一个int类型的互斥变量state来记录锁竞争的一个状态，0表示当前没有任何线程竞争锁资源，而大于等于1表示已经有线程正在持有锁资源。一个线程来获取锁资源的时候，首先判断state是否等于0，如果是(无锁状态)，则把这个state更新成1，表示占用到锁。此时如果多个线程进行同样的操作，会造成线程安全问题。AQS采用了CAS机制来保证互斥变量state的原子性。</p>
<p>未获取到锁资源的线程通过Unsafe类中的park方法对线程进行阻塞，把阻塞的线程按照先进先出的原则加入到一个双向链表的结构<strong>CLH</strong>中，当获得锁资源的线程释放锁之后，会从双向链表的头部去唤醒下一个等待的线程再去竞争锁。</p>
<p><strong>CLH 队列</strong>是一个虚拟的双向队列,用于存储等待锁的线程。当线程尝试获取同步状态失败时，会将其封装成一个节点加入到队列的尾部，并处于等待状态。线程通过自旋的方式不断检查其前驱节点的状态来判断自己是否能够获取到锁。当持有锁的线程释放锁时，会唤醒其后继节点的线程进行竞争获取。</p>
<p>另外关于公平性和非公平性问题，AQS的处理方式是，在竞争锁资源的时候，公平锁需要判断双向链表中是否有阻塞的线程，如果有，则需要去排队等待；而非公平锁的处理方式是，不管双向链表中是否存在等待锁的线程，都会直接尝试更改互斥变量state去竞争锁。 </p>
</blockquote>
<p><a target="_blank" rel="noopener" href="https://pdai.tech/md/java/thread/java-thread-x-lock-AbstractQueuedSynchronizer.html">JUC锁: 锁核心类AQS详解</a></p>
<p><a target="_blank" rel="noopener" href="https://javaguide.cn/java/concurrent/aqs.html">AQS 详解</a></p>
<h3 id="12-说下CAS的原理">12. 说下CAS的原理</h3>
<blockquote>
<p>CAS（Compare And Swap）是一种<strong>乐观的并发控制机制</strong>，它的核心原理是基于硬件层面的原子性保证。CAS操作包含三个操作数——内存位置（V）、预期原值（A）和新值（B）。它的工作原理是：</p>
<ol>
<li>
<p>在将新值写入内存之前，CAS操作会先比较内存位置的值是否与预期原值相匹配。</p>
</li>
<li>
<p>如果内存位置的值与预期原值相匹配，那么处理器会自动将该位置的值更新为新值。</p>
</li>
<li>
<p>如果内存位置的值与预期原值不匹配，则CAS操作失败，不会修改内存值。</p>
</li>
</ol>
<p>CAS的优势在于它没有阻塞状态，不会引起线程上下文的切换和调度问题。然而，CAS也存在一些缺点，例如ABA问题和开销问题。ABA问题是指一个值原来是A，变成了B，又变成了A，那么使用CAS进行检查时会发现它的值没有发生变化，但是实际上却变化了。开销问题则是因为CAS自旋操作需要不断轮询内存位置，直到成功为止，这会消耗大量的CPU资源。 </p>
</blockquote>
<h3 id="13-ReentrantLock中的公平锁和非公平锁的底层实现">13. ReentrantLock中的公平锁和非公平锁的底层实现</h3>
<blockquote>
<p>ReentrantLock是Java中提供的一种可重入锁，它支持两种锁的模式：公平锁和非公平锁。这两种锁模式的底层实现略有不同：</p>
<ol>
<li>
<p><strong>公平锁（Fair Lock）</strong>：公平锁的特点是按照请求锁的顺序来分配，即先到先得。在ReentrantLock中，通过构造函数可以选择创建一个公平锁。公平锁的底层实现使用了一个FIFO队列（First - In - First - Out），即等待队列。当一个线程请求锁时，如果锁已经被其他线程持有，请求线程会被放入等待队列的末尾，按照请求的顺序等待锁的释放。当锁被释放时，等待队列中的第一个线程会被唤醒并获得锁。</p>
</li>
<li>
<p><strong>非公平锁（Non - Fair Lock）</strong>：非公平锁不考虑请求锁的顺序，它允许新的请求线程插队并尝试立即获取锁，而不管其他线程是否在等待。在ReentrantLock中，默认情况下创建的是非公平锁。非公平锁的底层实现中，有一个等待队列，但它不会严格按照请求的顺序来分配锁，而是根据线程竞争的情况来判断是否立即分配给请求线程。</p>
</li>
</ol>
<p>底层实现中，无论是公平锁还是非公平锁，都使用了类似的同步器（Sync）来管理锁的状态和线程的竞争。不同之处在于如何处理等待队列中的线程，以及是否按照请求的顺序来分配锁。</p>
<p>需要注意的是，公平锁虽然遵循公平性原则，但在高并发情况下可能会引入较大的性能开销，因为每次都要维护一个有序的等待队列。而非公平锁则更加灵活，但可能导致某些线程一直获取不到锁。 </p>
</blockquote>
<h3 id="14-AQS是怎么实现同步管理的-底层数据结构">14. AQS是怎么实现同步管理的? 底层数据结构?</h3>
<p><strong>参考回答</strong>：</p>
<blockquote>
<p>AQS主要依赖于<strong>一个双向链表</strong>和一个<strong>volatile类型的整数state</strong>来实现同步控制。该整数state用来表示同步状态，一般情况下，state=0表示没有线程占用同步资源，state&gt;0表示有线程占用同步资源，state&gt;1表示同步资源已经被争用了多次，比如ReentrantLock可以允许一个线程多次获得锁，每次state值加1。</p>
<p>AQS实现同步的关键在于，它提供了一个基于FIFO队列的等待队列，通过将等待线程加入等待队列中，然后在释放同步状态的时候，从等待队列中唤醒等待线程，从而实现了同步机制。</p>
<p>AQS的实现主要有两种方式：独占式（Exclusive）和共享式（Shared）。独占式是指只有一个线程可以占用同步资源，比如ReentrantLock，而共享式是指多个线程可以同时占用同步资源，比如CountDownLatch。在AQS中，这两种方式的实现是基本相同的，区别在于获取和释放同步状态的方式不同。 </p>
</blockquote>
<h3 id="15-什么是可重入，什么是可重入锁">15. 什么是可重入，什么是可重入锁?</h3>
<p><strong>参考回答</strong>：</p>
<blockquote>
<p>“可重入锁”概念是：自己可以再次获取自己的内部锁。比如一个线程获得了某个对象的锁，此时这个对象锁还没有释放，当其再次想要获取这个对象的锁的时候还是可以获取的，如果不可锁重入的话，就会造成死锁。同一个线程每次获取锁，锁的计数器都自增1，所以要等到锁的计数器下降为0时才能释放锁。</p>
</blockquote>
<h3 id="16-公平锁和非公平锁有什么区别">16. 公平锁和非公平锁有什么区别?</h3>
<p><strong>参考回答</strong>：</p>
<blockquote>
<ul>
<li>
<p>公平锁：锁被释放之后，先申请的线程先得到锁。性能较差一些，因为公平锁为了保证时间上的绝对顺序，上下文切换更频繁。</p>
</li>
<li>
<p>非公平锁：锁被释放之后，后申请的线程可能会先获取到锁，是随机或者按照其他优先级排序的。性能更好，但可能会导致某些线程永远无法获取到锁。 </p>
</li>
</ul>
</blockquote>
<h3 id="17-为什么非公平锁比公平锁性能更好">17. 为什么非公平锁比公平锁性能更好?</h3>
<blockquote>
<p><strong>参考回答</strong>：</p>
<ul>
<li>
<p>公平锁执行流程：获取锁时，先将线程自己添加到同步队列的队尾并休眠，当某线程用完锁之后，会去唤醒同步队列队首的线程尝试去获取锁，锁的使用同步也就是队列中的先后顺序，在整个过程中，线程会从运行状态切换到休眠状态，再从休眠状态恢复成运行状态，但线程每次休眠和恢复都需要从用户态转换成内核态，而这个状态的转换是比较慢的，所以公平锁的执行速度会比较慢。</p>
</li>
<li>
<p>非公平锁执行流程：当线程获取锁时，会先通过CAS尝试获取锁，如果获取成功就直接拥有锁，如果获取锁失败才会进入同步队列，等待下次尝试获取锁。这样做的好处是，获取锁不遵循先到先得的规则，从而避免了一次线程休眠和恢复的操作，这样就加速了程序的执行效率。 </p>
</li>
</ul>
</blockquote>
<h3 id="18-ReentrantLock是如何实现公平锁的-非公平锁的">18. ReentrantLock是如何实现公平锁的? 非公平锁的?</h3>
<p><strong>参考回答</strong>：</p>
<blockquote>
<p>ReentrantLock类内部总共存在Sync、NonfairSync、FairSync三个类，NonfairSync与FairSync类继承自Sync类，Sync类继承自AbstractQueueuedSynchronizer抽象类。</p>
<p>非公平锁是ReentrantLock的默认实现。公平锁对比非公平锁的实现差异主要体现在tryAcquire方法（获取锁）这里。非公平锁（NonfairSync）的tryAcquire实现直接调用了父类Sync中的nonfairTryAcquire。</p>
<p>而公平锁tryAcquire的唯一不同的点为判断条件多了hasQueuedPredecessors()方法，即加入了同步队列中当前节点是否有前驱节点的判断，如果该方法返回true，则表示有线程比当前线程更早地请求获取锁，因此需要等待前驱线程获取并释放锁之后才能继续获取锁（这就叫公平）。</p>
</blockquote>
<h3 id="19-ReentrantReadWriteLock是什么">19. ReentrantReadWriteLock是什么?</h3>
<p><strong>参考回答</strong>：</p>
<blockquote>
<p>答：<code>ReentrantReadWriteLock</code>实现了<code>ReadWriteLock</code>，是一个可重入的读写锁，既可以保证多个线程同时读的效率，同时又可以保证有写入操作时的线程安全。</p>
<p><code>ReentrantReadWriteLock</code>其实是两把锁，一把是WriteLock（写锁），一把是ReadLock（读锁）。读锁是共享锁，写锁是独占锁。读锁可以被同时读，可以同时被多个线程持有，而写锁最多只能同时被一个线程持有。 </p>
</blockquote>
<h3 id="20-共享锁和独占锁有什么区别">20. 共享锁和独占锁有什么区别?</h3>
<blockquote>
<p><strong>参考回答</strong>：</p>
<ul>
<li>
<p>共享锁：一把锁可以被多个线程同时获得。</p>
</li>
<li>
<p>独占锁：一把锁只能被一个线程获得。</p>
</li>
</ul>
</blockquote>
<h3 id="21-线程持有读锁还能获取写锁吗">21. 线程持有读锁还能获取写锁吗?</h3>
<p><strong>参考回答</strong>：</p>
<blockquote>
<p>在线程持有读锁的情况下：该线程不能取得写锁(因为获取写锁的时候，如果发现当前的读锁被占用，就马上获取失败，不管读锁是不是被当前线程持有)。</p>
<p>在线程持有写锁的情况下：该线程可以继续获取读锁（获取读锁时如果发现写锁被占用，只有写锁没有被当前线程占用的情况才会获取失败）。</p>
</blockquote>
<h3 id="22-什么是锁的升降级-RentrantReadWriteLock为什么不支持锁升级">22. 什么是锁的升降级? RentrantReadWriteLock为什么不支持锁升级?</h3>
<p><strong>参考回答</strong>：</p>
<blockquote>
<p>写锁可以降级为读锁，但是读锁却不能升级为写锁。这是因为读锁升级为写锁会引起线程的争夺，毕竟写锁属于是独占锁，这样的话，会影响性能。另外，还可能会有死锁问题发生。举个例子：假设两个线程的读锁都想升级写锁，则需要对方都释放自己锁，而双方都不释放，就会产生死锁。 </p>
</blockquote>
<h3 id="23-ReentrantReadWriteLock底层读写状态如何设计的">23. ReentrantReadWriteLock底层读写状态如何设计的?</h3>
<p><strong>参考回答</strong>：</p>
<blockquote>
<p>答：高16位为读锁，低16位为写锁。 </p>
</blockquote>
<h2 id="并发安全容器-并发工具类">并发安全容器/并发工具类</h2>
<h3 id="1-JDK7与JDK8之间HashMap的区别？">1. JDK7与JDK8之间HashMap的区别？</h3>
<blockquote>
<ol>
<li>
<p>JDK8中新增了红黑树，JDK8是通过数组+链表+红黑树来实现的；</p>
</li>
<li>
<p>JDK7中链表的插入是用的头插法，而JDK8中则改为了尾插法；</p>
</li>
<li>
<p>JDK8中因为使用了红黑树保证了插入和查询的效率，所以实际上JDK8中的Hash算法实现的复杂度降低了；</p>
</li>
<li>
<p>JDK8中数组扩容的条件也发生了变化，只会判断是否当前元素个数是否超过了阈值，而不再判断当前put进来的元素对应的数组下标位置是否有值；</p>
</li>
<li>
<p>JDK7中是先扩容再添加新元素，JDK8中是先添加新元素然后再扩容。 </p>
</li>
</ol>
</blockquote>
<h3 id="2-ConcurrentHashMap和Hashtable的区别">2. ConcurrentHashMap和Hashtable的区别?</h3>
<p><strong>参考回答</strong>：</p>
<blockquote>
<p>ConcurrentHashMap和Hashtable的区别主要体现在实现线程安全的方式上不同。</p>
<p><strong>底层数据结构</strong>：JDK1.7的ConcurrentHashMap底层采用分段的数组+链表实现，JDK1.8采用的数据结构跟HashMap1.8的结构一样，数组+链表/红黑二叉树。Hashtable和JDK1.8之前的HashMap的底层数据结构类似都是采用数组+链表的形式，数组是HashMap的主体，链表则是主要为了解决哈希冲突而存在的；</p>
<p><strong>实现线程安全的方式（重要）</strong>：</p>
<p>在JDK1.7的时候，ConcurrentHashMap对整个桶数组进行了分割分段(Segment，分段锁)，每一把锁只锁容器其中一部分数据，多线程访问容器里不同数据段的数据，就不会存在锁竞争，提高并发访问率。</p>
<p>到了JDK1.8的时候，ConcurrentHashMap已经摒弃了Segment的概念，而是直接用Node数组+链表+红黑树的数据结构来实现，并发控制使用synchronized和CAS来操作。(JDK1.6以后synchronized锁做了很多优化) 整个看起来就像是优化过且线程安全的HashMap，虽然在JDK1.8中还能看到Segment的数据结构，但是已经简化了属性，只是为了兼容旧版本；</p>
<p>Hashtable(同一把锁)：使用synchronized来保证线程安全，效率非常低下。当一个线程访问同步方法时，其他线程也访问同步方法，可能会进入阻塞或轮询状态，如使用put添加元素，另一个线程不能使用put添加元素，也不能使用get，竞争会越来越激烈效率越低。 </p>
</blockquote>
<h3 id="3-ConcurrentHashMap-JDK1-7实现的原理是什么">3. ConcurrentHashMap JDK1.7实现的原理是什么?</h3>
<blockquote>
<p><strong>参考回答</strong>：</p>
<ul>
<li>
<p>首先将数据分为一段一段（这个“段”就是Segment）的存储，然后给每一段数据配一把锁，当一个线程占用锁访问其中一个段数据时，其他段的数据也能被其他线程访问。</p>
</li>
<li>
<p>ConcurrentHashMap是由Segment数组结构和HashEntry数组结构组成。</p>
</li>
<li>
<p>Segment继承了ReentrantLock，所以Segment是一种可重入锁，扮演锁的角色。HashEntry用于存储键值对数据。</p>
</li>
<li>
<p>一个ConcurrentHashMap里包含一个Segment数组，Segment的个数一旦初始化就不能改变。Segment数组的大小默认是16，也就是说默认可以同时支持16个线程并发写。</p>
</li>
<li>
<p>Segment的结构和HashMap类似，是一种数组和链表结构，一个Segment包含一个HashEntry数组，每个HashEntry是一个链表结构的元素，每个Segment守护着一个HashEntry数组里的元素，当对HashEntry数组的数据进行修改时，必须首先获得对应的Segment的锁。也就是说，对同一Segment的并发写入会被阻塞，不同Segment的写入是可以并发执行的。 </p>
</li>
</ul>
</blockquote>
<h3 id="4-ConcurrentHashMap-JDK1-8实现的原理是什么">4. ConcurrentHashMap JDK1.8实现的原理是什么?</h3>
<p><strong>参考回答</strong>：</p>
<blockquote>
<p>JDK1.8 ConcurrentHashMap取消了Segment分段锁，采用Node + CAS + synchronized来保证并发安全。数据结构跟HashMap 1.8的结构类似，数组+链表/红黑二叉树。Java 8在链表长度超过一定阈值8（同时满足容量&gt;=64）时将链表（寻址时间复杂度为O(N)）转换为红黑树（寻址时间复杂度为O(log(N))）。</p>
<p>Java 8中，锁粒度更细，synchronized只锁定当前链表或红黑二叉树的首节点，这样只要hash不冲突，就不会产生并发，就不会影响其他Node的读写，效率大幅提升。</p>
</blockquote>
<h3 id="5-ConcurrentHashMap-JDK1-7的实现和1-8的实现有什么区别">5. ConcurrentHashMap JDK1.7的实现和1.8的实现有什么区别?</h3>
<blockquote>
<p><strong>参考回答</strong>：</p>
<ul>
<li>
<p><strong>线程安全实现方式</strong>：JDK 1.7采用Segment分段锁来保证安全，Segment是继承自ReentrantLock。JDK1.8放弃了Segment分段锁的设计，采用Node + CAS + synchronized保证线程安全，锁粒度更细，synchronized只锁定当前链表或红黑二叉树的首节点。</p>
</li>
<li>
<p><strong>Hash碰撞解决方法</strong>：JDK 1.7采用拉链法，JDK1.8采用拉链法结合红黑树（链表长度超过一定阈值时，将链表转换为红黑树）。</p>
</li>
<li>
<p><strong>并发度</strong>：JDK 1.7最大并发度是Segment的个数，默认是16。JDK 1.8最大并发度是Node数组的大小，并发度更大。 </p>
</li>
</ul>
</blockquote>
<h3 id="6-JDK1-8中，ConCurrentHashmap什么情况下链表才会转换成红黑树进行存储">6. JDK1.8中，ConCurrentHashmap什么情况下链表才会转换成红黑树进行存储?</h3>
<p><strong>参考回答</strong>：</p>
<blockquote>
<p>答：链表长度大于等于8，且数组长度大于等于64。</p>
<p>并非一开始就创建红黑树结构，如果当前Node数组长度小于阈值MIN_TREEIFY_CAPACITY，默认为64，先通过扩大数组容量为原来的两倍以缓解单个链表元素过大的性能问题。</p>
</blockquote>
<h3 id="7-JDK1-8中，ConcurrentHashmap的put过程是怎样的">7. JDK1.8中，ConcurrentHashmap的put过程是怎样的?</h3>
<p><strong>参考回答</strong>：</p>
<blockquote>
<p>整体流程跟HashMap比较类似，大致是以下几步：</p>
<ul>
<li>
<p>如果桶数组未初始化，则初始化；</p>
</li>
<li>
<p>如果待插入的元素所在的桶为空，则尝试把此元素直接插入到桶的第一个位置；</p>
</li>
<li>
<p>如果正在扩容，则当前线程一起加入到扩容的过程中；</p>
</li>
<li>
<p>如果待插入的元素所在的桶不为空且没在迁移元素，则锁住这个桶；</p>
</li>
<li>
<p>如果当前桶中元素以链表方式存储，则在链表中寻找该元素或者插入元素；</p>
</li>
<li>
<p>如果当前桶中元素以红黑树方式存储，则在红黑树中寻找该元素或者插入元素；</p>
</li>
<li>
<p>如果元素存在，则覆盖旧值；</p>
</li>
<li>
<p>如果元素不存在，整个Map的元素个数加1，并检查是否需要扩容； </p>
</li>
</ul>
</blockquote>
<h3 id="8-ConcurrentHashMap的get方法是否要加锁，为什么">8. ConcurrentHashMap的get方法是否要加锁，为什么?</h3>
<p><strong>参考回答</strong>：</p>
<blockquote>
<p>答：不需要。get方法不涉及对变量的修改，所以会导致并发下可能处问题的原因就是读共享变量的可见性问题。而ConcurrentHashMap中，对get方法中用到的共享变量都使用volatile关键字修饰，所以整个get方法不加锁也不会有问题。</p>
</blockquote>
<h3 id="9-ConcurrentHashMap默认初始容量是多少">9. ConcurrentHashMap默认初始容量是多少?</h3>
<p><strong>参考回答</strong>：</p>
<blockquote>
<p>答：初始容量为16</p>
</blockquote>
<h3 id="10-ConcurrentHashMap的key，value是否可以为null">10. ConcurrentHashMap的key，value是否可以为null?</h3>
<p><strong>参考回答</strong>：</p>
<blockquote>
<p>答：不行。如果key或者value为null会抛出空指针异常。(原因是因为没办法解决get返回值为null时的二义性问题，即没办法确定是存储的值本身为null，还是说值不存在)；</p>
<p>注意：HashMap允许使用null作为值和键。(因为HashMap只能单线程下使用，所以hashmap可以用containsKey来二次判断，排除二义性问题) </p>
</blockquote>
<h3 id="11-存储在ConcurrentHashMap中每个节点是什么样的，有哪些变量">11.存储在ConcurrentHashMap中每个节点是什么样的，有哪些变量?</h3>
<p><strong>参考回答</strong>：</p>
<blockquote>
<p>答：它是实现Map.Entry&lt;K, V&gt;接口。里面存放了hash，key，value，以及next节点。它的value和next节点是用volatile进行修饰，可以保证多线程之间的可见性。</p>
</blockquote>
<h3 id="12-什么是BlockingQueue">12. 什么是BlockingQueue?</h3>
<p><strong>参考回答</strong>：</p>
<blockquote>
<p>阻塞队列(BlockingQueue)是一个支持两个附加操作的队列。这两个附加的操作支持阻塞的插入和移除方法。</p>
<ol>
<li>
<p>支持阻塞的插入方法：意思是当队列满时，队列会阻塞插入元素的线程，直到队列不满。</p>
</li>
<li>
<p>支持阻塞的移除方法：意思是在队列为空时，获取元素的线程会等待队列变为非空。 </p>
</li>
</ol>
</blockquote>
<h3 id="13-你了解哪些阻塞队列">13.你了解哪些阻塞队列</h3>
<blockquote>
<ul>
<li>
<p>ArrayBlockingQueue：一个由数组结构组成的有界阻塞队列。</p>
</li>
<li>
<p>LinkedBlockingQueue：一个由链表结构组成的阻塞队列。此队列创建时可以不指定容量大小，默认是Integer.MAX_VALUE，也就是无界的。但也可以指定队列大小，从而成为有界的。</p>
</li>
<li>
<p>PriorityBlockingQueue：一个支持优先级排序的无界阻塞队列。默认情况下元素采取自然顺序升序排列。也可以自定义类实现compareTo()方法来指定元素排序规则。</p>
</li>
<li>
<p>DelayQueue：一个使用优先级队列实现的无界阻塞队列。队列使用PriorityQueue来实现。队列中的元素必须实现Delayed接口，在创建元素时可以指定多久才能从队列中获取当前元素。只有在延迟期满时才能从队列中提取元素。（常用在缓存有效期，定时任务调度等场景）</p>
</li>
<li>
<p>SynchronousQueue：一个不存储元素的阻塞队列。每一个put操作必须等待一个take操作，否则不能继续添加元素。队列本身并不存储任何元素，非常适合传递性场景。</p>
</li>
<li>
<p>LinkedTransferQueue：一个由链表结构组成的单向无界阻塞队列。它设计了一种直接在生产者和消费者之间传输元素的机制，称为“transfer”。当生产者调用transfer(e)方法时，它会阻塞直到有一个消费者接收该元素。适用于需要高效地在生产者和消费者之间直接传输数据的场景，尤其是当生产者和消费者之间的速度大致匹配时。</p>
</li>
<li>
<p>LinkedBlockingDeque：一个由链表结构组成的双向阻塞队列。所谓双向队列指的是可以从队列的两端插入和移出元素。相比其他的阻塞队列，LinkedBlockingDeque多了addFirst、addLast、offerFirst、offerLast、peekFirst和peekLast等方法。双向阻塞队列可以运用在“工作窃取”模式中。 </p>
</li>
</ul>
</blockquote>
<h3 id="14-ArrayBlockingQueue和LinkedBlockingQueue有什么区别">14. ArrayBlockingQueue和LinkedBlockingQueue有什么区别?</h3>
<p><strong>参考回答</strong>：</p>
<blockquote>
<p>答：ArrayBlockingQueue和LinkedBlockingQueue是Java并发包中常用的两种阻塞队列实现，它们都是线程安全的。不过，它们之间也存在下面这些区别：</p>
<ul>
<li>
<p>底层实现：ArrayBlockingQueue基于数组实现，而LinkedBlockingQueue基于链表实现。</p>
</li>
<li>
<p>是否有界：ArrayBlockingQueue是有界队列，必须在创建时指定容量大小。LinkedBlockingQueue创建时可以不指定容量大小，默认是Integer.MAX_VALUE，也就是无界的。但也可以指定队列大小，从而成为有界的。</p>
</li>
<li>
<p>锁是否分离：ArrayBlockingQueue中的锁是没有分离的，即生产和消费用的是同一个锁；LinkedBlockingQueue中的锁是分离的，即生产用的是putLock，消费是takeLock，这样可以防止生产者和消费者线程之间的锁争夺。</p>
</li>
<li>
<p>内存占用：ArrayBlockingQueue需要提前分配数组内存，而LinkedBlockingQueue则是动态分配链表节点内存。这意味着，ArrayBlockingQueue在创建时就会占用一定的内存空间，且往往申请的内存比实际所用的内存更大，而LinkedBlockingQueue则是根据元素的增加而逐渐占用内存空间。 </p>
</li>
</ul>
</blockquote>
<h3 id="15-如果队列是空的，消费者会一直等待，当生产者添加元素时，消费者是如何知道当前队列有元素的呢">15. 如果队列是空的，消费者会一直等待，当生产者添加元素时，消费者是如何知道当前队列有元素的呢?</h3>
<p><strong>参考回答</strong>：</p>
<blockquote>
<p>答：使用通知模式实现。所谓通知模式，当消费者从空的队列获取元素时会阻塞住消费者，此时如果生产者放了一个元素进入队列，则需要通知阻塞住消费者当前有元素可取。同理当生产者往满的队列里添加元素时会阻塞住生产者，当消费者消费了一个队列中的元素后，会通知生产者当前队列可用。通过查看JDK源码发现部分阻塞队列使用了Condition来实现。 </p>
</blockquote>
<h3 id="16-CountDownLatch，CyclicBarrier，Semaphore，Exchanger了解吗">16. CountDownLatch，CyclicBarrier，Semaphore，Exchanger了解吗?</h3>
<blockquote>
<p><strong>参考回答</strong>：</p>
<ul>
<li>
<p>CountDownLatch：倒计数器。允许一个或多个线程等待其他线程完成操作。</p>
</li>
<li>
<p>CyclicBarrier的字面意思是可循环使用（Cyclic）的屏障（Barrier）。它要做的事情是，让一组线程到达一个屏障（也可以叫同步点）时被阻塞，直到最后一个线程到达屏障时，屏障才会开门，所有被屏障拦截的线程才会继续运行。</p>
</li>
<li>
<p>Semaphore（信号量）：是用来控制同时访问特定资源的线程数量，它通过协调各个线程，以保证合理的使用公共资源。</p>
</li>
<li>
<p>Exchanger（交换者）：是一个用于线程间协作的工具类。Exchanger用于进行线程间的数据交换。它提供一个同步点，在这个同步点，两个线程可以交换彼此的数据。 </p>
</li>
</ul>
</blockquote>
<h3 id="17-CyclicBarrier和CountDownLatch有什么区别">17. CyclicBarrier和CountDownLatch有什么区别?</h3>
<p><strong>参考回答</strong>：</p>
<blockquote>
<ol>
<li>CyclicBarrier是可重用的，其中的线程会等待所有的线程完成任务。届时，屏障将被拆除，并可以选择性地做一些特定的动作。</li>
</ol>
<p>CountDownLatch是一次性的，不同的线程在同一个计数器上工作，直到计数器为0.</p>
<ul>
<li>CyclicBarrier面向的是线程数；</li>
</ul>
<p>CountDownLatch面向的是任务数。</p>
<ul>
<li>
<p>在使用CyclicBarrier时，你必须在构造中指定参与协作的线程数，这些线程必须调用await()方法；使用CountDownLatch时，则必须要指定任务数，至于这些任务由哪些线程完成无关紧要。</p>
</li>
<li>
<p>CyclicBarrier可以在所有的线程释放后重新使用；CountDownLatch在计数器为0时不能再使用。 </p>
</li>
</ul>
</blockquote>
<h3 id="18-常见函数">18.常见函数</h3>
<blockquote>
<p>在 JUC（Java.util.concurrent）中，一些常用的函数及其作用如下：</p>
<ol>
<li>
<p><code>park()</code> 和 <code>unpark()</code>：</p>
<ul>
<li>
<p><code>park()</code>：用于阻塞当前线程。</p>
</li>
<li>
<p><code>unpark(Thread thread)</code>：用于唤醒指定的被 <code>park()</code> 阻塞的线程。</p>
</li>
</ul>
</li>
<li>
<p><code>wait()</code>、<code>notify()</code> 和 <code>notifyAll()</code>：</p>
<ul>
<li>
<p><code>wait()</code>：使当前线程等待，直到其他线程调用此对象的 <code>notify()</code> 方法或 <code>notifyAll()</code> 方法。</p>
</li>
<li>
<p><code>notify()</code>：唤醒在此对象监视器上等待的单个线程。</p>
</li>
<li>
<p><code>notifyAll()</code>：唤醒在此对象监视器上等待的所有线程。</p>
</li>
</ul>
</li>
<li>
<p><code>Thread.sleep(long millis)</code>：使当前正在执行的线程暂停指定的毫秒数。</p>
</li>
<li>
<p><code>CountDownLatch</code>：</p>
<ul>
<li>
<p><code>countDown()</code>：使计数器减 1。</p>
</li>
<li>
<p><code>await()</code>：等待计数器变为 0。</p>
</li>
</ul>
</li>
<li>
<p><code>CyclicBarrier</code>：</p>
<ul>
<li><code>await()</code>：等待所有线程都到达屏障点。</li>
</ul>
</li>
<li>
<p><code>Semaphore</code>：</p>
<ul>
<li>
<p><code>acquire()</code>：获取一个许可，如果没有可用许可则阻塞。</p>
</li>
<li>
<p><code>release()</code>：释放一个许可。</p>
</li>
</ul>
</li>
<li>
<p><code>Future</code> 和 <code>CompletableFuture</code>：用于处理异步任务的结果。</p>
</li>
</ol>
<p>这些函数和类为多线程编程提供了丰富的工具，帮助开发者更有效地管理线程的同步、协作和异步操作。 </p>
</blockquote>
</article><div class="post-copyright"><div class="post-copyright__title"><span class="post-copyright-info"><h>JUC基础面试题</h></span></div><div class="post-copyright__type"><span class="post-copyright-info"><a href="https://outoflovenicoo.github.io/posts/2025-01-09-JUC%E5%9F%BA%E7%A1%80%E9%9D%A2%E8%AF%95%E9%A2%98.html">https://outoflovenicoo.github.io/posts/2025-01-09-JUC基础面试题.html</a></span></div><div class="post-copyright-m"><div class="post-copyright-m-info"><div class="post-copyright-a"><h>作者</h><div class="post-copyright-cc-info"><h>OutOfLove🥝</h></div></div><div class="post-copyright-c"><h>发布于</h><div class="post-copyright-cc-info"><h>2025-01-09</h></div></div><div class="post-copyright-u"><h>更新于</h><div class="post-copyright-cc-info"><h>2025-03-23</h></div></div><div class="post-copyright-c"><h>许可协议</h><div class="post-copyright-cc-info"><a class="icon" rel="noopener" target="_blank" title="Creative Commons" href="https://creativecommons.org/"><i class="fab fa-creative-commons"></i></a><a rel="noopener" target="_blank" title="CC BY-NC-SA 4.0" href="https://creativecommons.org/licenses/by-nc-sa/4.0/">CC BY-NC-SA 4.0</a></div></div></div></div></div><div class="tag_share"><div class="post-meta__tag-list"><a class="post-meta__tags" href="/tags/JUC/"><div class="tags-punctuation"><svg class="faa-tada icon" style="height:1.1em;width:1.1em;fill:currentColor;position:relative;top:2px;margin-right:3px" aria-hidden="true"><use xlink:href="#icon-sekuaibiaoqian"></use></svg></div>JUC</a></div></div><link rel="stylesheet" href="/css/coin.css" media="defer" onload="this.media='all'"/><div class="post-reward"><button class="tip-button reward-button"><span class="tip-button__text">投喂作者</span><div class="coin-wrapper"><div class="coin"><div class="coin__middle"></div><div class="coin__back"></div><div class="coin__front"></div></div></div><div class="reward-main"><ul class="reward-all"><li class="reward-item"><a href="https://tuchuang.voooe.cn/images/2023/01/04/2.webp" target="_blank"><img class="post-qr-code-img" src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="https://tuchuang.voooe.cn/images/2023/01/04/2.webp" alt="微信"/></a><div class="post-qr-code-desc">微信</div></li><li class="reward-item"><a href="https://tuchuang.voooe.cn/images/2023/01/04/20f8e49805975b8f8.webp" target="_blank"><img class="post-qr-code-img" src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="https://tuchuang.voooe.cn/images/2023/01/04/20f8e49805975b8f8.webp" alt="支付宝"/></a><div class="post-qr-code-desc">支付宝</div></li></ul></div></button></div><audio id="coinAudio" src="https://npm.elemecdn.com/akilar-candyassets@1.0.36/audio/aowu.m4a"></audio><script defer="defer" src="/js/coin.js"></script><nav class="pagination-post" id="pagination"><div class="prev-post pull-left"><a href="/posts/2025-01-01-Java%E5%9F%BA%E7%A1%80.html"><img class="prev-cover" src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="https://source.fomal.cc/img/default_cover_14.webp" onerror="onerror=null;src='/assets/r2.jpg'" alt="cover of previous post"><div class="pagination-info"><div class="label">上一篇</div><div class="prev_info">Java基础面试题</div></div></a></div><div class="next-post pull-right"><a href="/posts/2025331p.html"><img class="next-cover" src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="https://source.fomal.cc/img/default_cover_14.webp" onerror="onerror=null;src='/assets/r2.jpg'" alt="cover of next post"><div class="pagination-info"><div class="label">下一篇</div><div class="next_info">MyBatis面试题</div></div></a></div></nav><hr/><div id="post-comment"><div class="comment-head"><div class="comment-headline"><i class="fas fa-comments fa-fw"></i><span> 评论</span></div></div><div class="comment-wrap"><div><div id="twikoo-wrap"></div></div></div></div></div><div class="aside-content" id="aside-content"><div class="sticky_layout"><div class="card-widget" id="card-toc"><div class="item-headline"><svg class="meta_icon" style="width:22px;height:22px;position:relative;top:5px"><use xlink:href="#icon-mulu1"></use></svg><span style="font-weight:bold">目录</span><span class="toc-percentage"></span></div><div class="toc-content"><ol class="toc"><li class="toc-item toc-level-1"><a class="toc-link"><span class="toc-text">学习</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#1-Future"><span class="toc-text">1.Future</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%EF%BC%881%EF%BC%89Future%E7%9A%84%E7%94%A8%E6%B3%95"><span class="toc-text">（1）Future的用法</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%EF%BC%882%EF%BC%89CompletableFuture%E7%9A%84%E7%94%A8%E6%B3%95"><span class="toc-text">（2）CompletableFuture的用法</span></a></li></ol></li><li class="toc-item toc-level-1"><a class="toc-link"><span class="toc-text">面试题目</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#%E5%B9%B6%E5%8F%91%E5%9F%BA%E7%A1%80"><span class="toc-text">并发基础</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#1-%E7%BA%BF%E7%A8%8B%E7%8A%B6%E6%80%81%E5%A6%82%E4%BD%95%E6%B5%81%E8%BD%AC"><span class="toc-text">1.线程状态如何流转</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#2-Java%E5%88%9B%E5%BB%BA%E7%BA%BF%E7%A8%8B%E7%9A%84%E6%96%B9%E5%BC%8F"><span class="toc-text">2.Java创建线程的方式</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#3-%E2%AD%90%EF%B8%8F%E5%90%AF%E5%8A%A8%E7%BA%BF%E7%A8%8B%E4%B8%BA%E4%BD%95%E8%B0%83%E7%94%A8start%E8%80%8C%E4%B8%8D%E6%98%AFrun%E6%96%B9%E6%B3%95"><span class="toc-text">3. ⭐️启动线程为何调用start而不是run方法</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#4-wait-%E3%80%81notify-%E5%92%8C-notifyAll-%E3%80%81sleep-%E3%80%81yield"><span class="toc-text">4. wait()、notify()和 notifyAll()、sleep()、yield()</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#5-Java-%E4%B8%AD-interrupted-%E5%92%8C-isInterrupted-%E6%96%B9%E6%B3%95%E7%9A%84%E5%8C%BA%E5%88%AB%EF%BC%9F"><span class="toc-text">5.Java 中 interrupted 和 isInterrupted 方法的区别？</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#6-%E5%90%8C%E6%AD%A5%E6%96%B9%E6%B3%95%E5%92%8C%E5%90%8C%E6%AD%A5%E5%9D%97%EF%BC%8C%E5%93%AA%E4%B8%AA%E6%98%AF%E6%9B%B4%E5%A5%BD%E7%9A%84%E9%80%89%E6%8B%A9"><span class="toc-text">6. 同步方法和同步块，哪个是更好的选择?</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#7-%E4%BB%80%E4%B9%88%E6%98%AF%E7%BA%BF%E7%A8%8B%E5%90%8C%E6%AD%A5%E5%92%8C%E7%BA%BF%E7%A8%8B%E4%BA%92%E6%96%A5%EF%BC%8C%E6%9C%89%E5%93%AA%E5%87%A0%E7%A7%8D%E5%AE%9E%E7%8E%B0%E6%96%B9%E5%BC%8F%EF%BC%9F"><span class="toc-text">7.什么是线程同步和线程互斥，有哪几种实现方式？</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#8-%E5%9C%A8%E7%9B%91%E8%A7%86%E5%99%A8-Monitor-%E5%86%85%E9%83%A8%EF%BC%8C%E6%98%AF%E5%A6%82%E4%BD%95%E5%81%9A%E7%BA%BF%E7%A8%8B%E5%90%8C%E6%AD%A5%E7%9A%84%EF%BC%9F%E7%A8%8B%E5%BA%8F%E5%BA%94%E8%AF%A5%E5%81%9A%E5%93%AA%E7%A7%8D%E7%BA%A7%E5%88%AB%E7%9A%84%E5%90%8C%E6%AD%A5%EF%BC%9F"><span class="toc-text">8.在监视器(Monitor)内部，是如何做线程同步的？程序应该做哪种级别的同步？</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#9-%E5%A6%82%E6%9E%9C%E4%BD%A0%E6%8F%90%E4%BA%A4%E4%BB%BB%E5%8A%A1%E6%97%B6%EF%BC%8C%E6%A0%B8%E5%BF%83%E7%BA%BF%E7%A8%8B%E6%95%B0%E5%B7%B2%E8%BE%BE%E5%88%B0%E9%85%8D%E7%BD%AE%E7%9A%84%E6%95%B0%E9%87%8F%EF%BC%8C%E8%BF%99%E6%97%B6%E4%BC%9A%E5%8F%91%E7%94%9F%E4%BB%80%E4%B9%88"><span class="toc-text">9.如果你提交任务时，核心线程数已达到配置的数量，这时会发生什么</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#10-%E5%9C%A8-Java-%E7%A8%8B%E5%BA%8F%E4%B8%AD%E6%80%8E%E4%B9%88%E4%BF%9D%E8%AF%81%E5%A4%9A%E7%BA%BF%E7%A8%8B%E7%9A%84%E8%BF%90%E8%A1%8C%E5%AE%89%E5%85%A8%EF%BC%9F"><span class="toc-text">10.在 Java 程序中怎么保证多线程的运行安全？</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#11-%E7%BA%BF%E7%A8%8B%E7%B1%BB%E7%9A%84%E6%9E%84%E9%80%A0%E6%96%B9%E6%B3%95%E3%80%81%E9%9D%99%E6%80%81%E5%9D%97%E6%98%AF%E8%A2%AB%E5%93%AA%E4%B8%AA%E7%BA%BF%E7%A8%8B%E8%B0%83%E7%94%A8%E7%9A%84"><span class="toc-text">11.线程类的构造方法、静态块是被哪个线程调用的</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#12-Java%E4%B8%AD%E6%80%8E%E4%B9%88%E8%8E%B7%E5%8F%96%E4%B8%80%E4%BB%BD%E7%BA%BF%E7%A8%8Bdump%E6%96%87%E4%BB%B6%EF%BC%9F%E4%BD%A0%E5%A6%82%E4%BD%95%E5%9C%A8Java%E4%B8%AD%E8%8E%B7%E5%8F%96%E7%BA%BF%E7%A8%8B%E5%A0%86%E6%A0%88%EF%BC%9F"><span class="toc-text">12. Java中怎么获取一份线程dump文件？你如何在Java中获取线程堆栈？</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#13-%E4%B8%80%E4%B8%AA%E7%BA%BF%E7%A8%8B%E8%BF%90%E8%A1%8C%E6%97%B6%E5%8F%91%E7%94%9F%E5%BC%82%E5%B8%B8%E4%BC%9A%E6%80%8E%E6%A0%B7%EF%BC%9F"><span class="toc-text">13. 一个线程运行时发生异常会怎样？</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#14-%E5%A4%9A%E7%BA%BF%E7%A8%8B%E7%9A%84%E5%B8%B8%E7%94%A8%E6%96%B9%E6%B3%95"><span class="toc-text">14.多线程的常用方法</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#15-%E2%9D%93%E4%BB%8B%E7%BB%8D%E4%B8%80%E4%B8%8B-ThreadLocal"><span class="toc-text">15.❓介绍一下 ThreadLocal</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#16-ThreadLocal-%E5%86%85%E5%AD%98%E6%B3%84%E9%9C%B2%E9%97%AE%E9%A2%98%E4%BA%86%E8%A7%A3%E5%90%97"><span class="toc-text">16.ThreadLocal 内存泄露问题了解吗</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#17-%E4%B8%BA%E4%BB%80%E4%B9%88%E7%94%A8ThreadLocal%E4%B8%8D%E7%94%A8%E7%BA%BF%E7%A8%8B%E6%88%90%E5%91%98%E5%8F%98%E9%87%8F"><span class="toc-text">17.为什么用ThreadLocal不用线程成员变量?</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E2%AD%90%EF%B8%8FJava%E5%B9%B6%E5%8F%91%E7%90%86%E8%AE%BA%EF%BC%88Volatile-Synchronized-CAS%EF%BC%89"><span class="toc-text">⭐️Java并发理论（Volatile&#x2F;Synchronized&#x2F;CAS）</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#1-%E7%BA%BF%E7%A8%8B%E4%B9%8B%E9%97%B4%E5%A6%82%E4%BD%95%E9%80%9A%E4%BF%A1%E5%8F%8A%E7%BA%BF%E7%A8%8B%E4%B9%8B%E9%97%B4%E5%A6%82%E4%BD%95%E5%90%8C%E6%AD%A5"><span class="toc-text">1. 线程之间如何通信及线程之间如何同步</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#2-Java%E5%86%85%E5%AD%98%E6%A8%A1%E5%9E%8B%EF%BC%88JMM%EF%BC%89"><span class="toc-text">2.Java内存模型（JMM）</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#3-Happens-Before-%E5%8E%9F%E5%88%99"><span class="toc-text">3.Happens-Before 原则</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#4-Java-%E6%80%8E%E4%B9%88%E8%BF%9B%E8%A1%8C%E5%B9%B6%E5%8F%91%E6%8E%A7%E5%88%B6%EF%BC%9F"><span class="toc-text">4.Java 怎么进行并发控制？</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#5-synchronized%E5%85%B3%E9%94%AE%E5%AD%97"><span class="toc-text">5. synchronized关键字</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#6-%E8%AF%B4%E8%AF%B4%E8%87%AA%E5%B7%B1%E6%98%AF%E6%80%8E%E4%B9%88%E4%BD%BF%E7%94%A8synchronized%E5%85%B3%E9%94%AE%E5%AD%97%EF%BC%8C%E5%9C%A8%E9%A1%B9%E7%9B%AE%E4%B8%AD%E7%94%A8%E5%88%B0%E4%BA%86%E5%90%97"><span class="toc-text">6. 说说自己是怎么使用synchronized关键字，在项目中用到了吗</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#7-%E8%AF%B4%E4%B8%80%E4%B8%8Bsynchronized%E5%BA%95%E5%B1%82%E5%AE%9E%E7%8E%B0%E5%8E%9F%E7%90%86"><span class="toc-text">7. 说一下synchronized底层实现原理?</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#8-synchronized%E5%8F%AF%E9%87%8D%E5%85%A5%E7%9A%84%E5%8E%9F%E7%90%86"><span class="toc-text">8. synchronized可重入的原理</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#9-%E4%BB%80%E4%B9%88%E6%98%AF%E8%87%AA%E6%97%8B"><span class="toc-text">9. 什么是自旋</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#10-%E5%A4%9A%E7%BA%BF%E7%A8%8B%E4%B8%ADsynchronized%E9%94%81%E5%8D%87%E7%BA%A7%E7%9A%84%E5%8E%9F%E7%90%86%E6%98%AF%E4%BB%80%E4%B9%88"><span class="toc-text">10. 多线程中synchronized锁升级的原理是什么?</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#11-%E7%BA%BF%E7%A8%8BB%E6%80%8E%E4%B9%88%E7%9F%A5%E9%81%93%E7%BA%BF%E7%A8%8BA%E4%BF%AE%E6%94%B9%E4%BA%86%E5%8F%98%E9%87%8F"><span class="toc-text">11. 线程B怎么知道线程A修改了变量</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#12-%E5%BD%93%E4%B8%80%E4%B8%AA%E7%BA%BF%E7%A8%8B%E8%BF%9B%E5%85%A5%E4%B8%80%E4%B8%AA%E5%AF%B9%E8%B1%A1%E7%9A%84synchronized%E6%96%B9%E6%B3%95A%E4%B9%8B%E5%90%8E%EF%BC%8C%E5%85%B6%E5%AE%83%E7%BA%BF%E7%A8%8B%E6%98%AF%E5%90%A6%E5%8F%AF%E8%BF%9B%E5%85%A5%E6%AD%A4%E5%AF%B9%E8%B1%A1%E7%9A%84synchronized%E6%96%B9%E6%B3%95B"><span class="toc-text">12. 当一个线程进入一个对象的synchronized方法A之后，其它线程是否可进入此对象的synchronized方法B?</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#13-synchronized%E3%80%81volatile%E3%80%81CAS%E6%AF%94%E8%BE%83"><span class="toc-text">13. synchronized、volatile、CAS比较</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#14-synchronized%E5%92%8CLock%E6%9C%89%E4%BB%80%E4%B9%88%E5%8C%BA%E5%88%AB"><span class="toc-text">14. synchronized和Lock有什么区别?</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#15-synchronized%E5%92%8CLock%E5%A6%82%E4%BD%95%E9%80%89%E6%8B%A9"><span class="toc-text">15. synchronized和Lock如何选择?</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#16-synchronized%E5%92%8CReentrantLock%E5%8C%BA%E5%88%AB%E6%98%AF%E4%BB%80%E4%B9%88"><span class="toc-text">16. synchronized和ReentrantLock区别是什么?</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#17-volatile%E5%85%B3%E9%94%AE%E5%AD%97%E7%9A%84%E4%BD%9C%E7%94%A8"><span class="toc-text">17. volatile关键字的作用</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#18-Java%E4%B8%AD%E8%83%BD%E5%88%9B%E5%BB%BAvolatile%E6%95%B0%E7%BB%84%E5%90%97"><span class="toc-text">18. Java中能创建volatile数组吗?</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#19-volatile%E8%83%BD%E4%BD%BF%E5%BE%97%E4%B8%80%E4%B8%AA%E9%9D%9E%E5%8E%9F%E5%AD%90%E6%93%8D%E4%BD%9C%E5%8F%98%E6%88%90%E5%8E%9F%E5%AD%90%E6%93%8D%E4%BD%9C%E5%90%97"><span class="toc-text">19. volatile能使得一个非原子操作变成原子操作吗?</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#20-synchronized%E5%92%8Cvolatile%E7%9A%84%E5%8C%BA%E5%88%AB%E6%98%AF%E4%BB%80%E4%B9%88"><span class="toc-text">20. synchronized和volatile的区别是什么?</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#21-%E8%AF%B4%E4%B8%8B%E4%BD%A0%E5%AF%B9volatile%E7%9A%84%E7%90%86%E8%A7%A3"><span class="toc-text">21. 说下你对volatile的理解</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E7%BA%BF%E7%A8%8B%E6%B1%A0"><span class="toc-text">线程池</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#1-%E4%BB%80%E4%B9%88%E6%98%AF%E7%BA%BF%E7%A8%8B%E6%B1%A0%EF%BC%9F%E4%B8%BA%E4%BB%80%E4%B9%88%E8%A6%81%E7%94%A8%E7%BA%BF%E7%A8%8B%E6%B1%A0"><span class="toc-text">1. 什么是线程池？为什么要用线程池?</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#2-%E6%A0%B8%E5%BF%83%E5%8F%82%E6%95%B0%E6%9C%89%E5%93%AA%E4%BA%9B"><span class="toc-text">2. 核心参数有哪些?</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#3-%E7%BA%BF%E7%A8%8B%E6%B1%A0%E7%9A%84%E7%A7%8D%E7%B1%BB%EF%BC%8C%E5%8C%BA%E5%88%AB%E5%92%8C%E4%BD%BF%E7%94%A8%E5%9C%BA%E6%99%AF"><span class="toc-text">3. 线程池的种类，区别和使用场景</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#4-%E7%BA%BF%E7%A8%8B%E6%B1%A0%E7%9A%84%E6%8B%92%E7%BB%9D%E7%AD%96%E7%95%A5%E6%9C%89%E5%93%AA%E4%BA%9B"><span class="toc-text">4. 线程池的拒绝策略有哪些</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#5-%E5%9C%A8Java%E4%B8%ADExecutor%E5%92%8CExecutors%E7%9A%84%E5%8C%BA%E5%88%AB"><span class="toc-text">5. 在Java中Executor和Executors的区别?</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#6-%E7%BA%BF%E7%A8%8B%E6%B1%A0%E9%83%BD%E6%9C%89%E5%93%AA%E4%BA%9B%E7%8A%B6%E6%80%81"><span class="toc-text">6.线程池都有哪些状态</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#7-%E7%BA%BF%E7%A8%8B%E6%B1%A0%E4%B8%ADsubmit-%E5%92%8Cexecute-%E6%96%B9%E6%B3%95%E6%9C%89%E4%BB%80%E4%B9%88%E5%8C%BA%E5%88%AB"><span class="toc-text">7. 线程池中submit()和execute()方法有什么区别?</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#8-%E5%88%86%E6%9E%90%E7%BA%BF%E7%A8%8B%E6%B1%A0%E7%9A%84%E5%AE%9E%E7%8E%B0%E5%8E%9F%E7%90%86%E5%92%8C%E7%BA%BF%E7%A8%8B%E7%9A%84%E8%B0%83%E5%BA%A6%E8%BF%87%E7%A8%8B"><span class="toc-text">8. 分析线程池的实现原理和线程的调度过程</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#9-%E7%BA%BF%E7%A8%8B%E6%B1%A0%E7%9A%84%E6%9C%80%E5%A4%A7%E7%BA%BF%E7%A8%8B%E6%95%B0%E7%9B%AE%E6%A0%B9%E6%8D%AE%E4%BB%80%E4%B9%88%E7%A1%AE%E5%AE%9A"><span class="toc-text">9. 线程池的最大线程数目根据什么确定</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#10-%E7%BA%BF%E7%A8%8B%E6%B1%A0%E5%A6%82%E4%BD%95%E8%B0%83%E4%BC%98"><span class="toc-text">10. 线程池如何调优</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#11-%E7%BA%BF%E7%A8%8B%E6%B1%A0%E5%A6%82%E4%BD%95%E5%AE%9E%E7%8E%B0%E5%8A%A8%E6%80%81%E4%BF%AE%E6%94%B9"><span class="toc-text">11. 线程池如何实现动态修改?</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#12-%E4%BD%BF%E7%94%A8%E6%97%A0%E7%95%8C%E9%98%9F%E5%88%97%E7%9A%84%E7%BA%BF%E7%A8%8B%E6%B1%A0%E4%BC%9A%E5%AF%BC%E8%87%B4%E4%BB%80%E4%B9%88%E9%97%AE%E9%A2%98"><span class="toc-text">12. 使用无界队列的线程池会导致什么问题?</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#13-%E7%BA%BF%E7%A8%8B%E6%B1%A0%E7%9A%84%E9%97%AE%E9%A2%98%EF%BC%8C%E5%A6%82%E6%9E%9C%E7%BA%BF%E7%A8%8B%E6%B1%A0%E5%BD%93%E5%89%8D%E5%A4%84%E4%BA%8E%E7%A9%BA%E9%97%B2%E7%9A%84%E7%8A%B6%E6%80%81%EF%BC%8C%E6%A0%B8%E5%BF%83%E7%BA%BF%E7%A8%8B%E6%95%B0%E9%87%8F%E6%98%AF%E4%B8%8D%E4%BC%9A%E8%A2%AB%E9%94%80%E6%AF%81%E7%9A%84%EF%BC%8C%E9%82%A3%E8%BF%99%E5%87%A0%E4%B8%AA%E6%A0%B8%E5%BF%83%E7%BA%BF%E7%A8%8B%E5%A4%84%E4%BA%8E%E4%BB%80%E4%B9%88%E7%8A%B6%E6%80%81%EF%BC%9F%E4%B8%BA%E4%BB%80%E4%B9%88%E5%A4%84%E4%BA%8E%E8%BF%99%E4%B8%AA%E7%8A%B6%E6%80%81"><span class="toc-text">13. 线程池的问题，如果线程池当前处于空闲的状态，核心线程数量是不会被销毁的，那这几个核心线程处于什么状态？为什么处于这个状态?</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#14-%E5%A6%82%E6%9E%9C%E4%B8%8D%E5%85%81%E8%AE%B8%E7%BA%BF%E7%A8%8B%E6%B1%A0%E4%B8%A2%E5%BC%83%E4%BB%BB%E5%8A%A1%EF%BC%8C%E5%BA%94%E8%AF%A5%E9%80%89%E6%8B%A9%E5%93%AA%E4%B8%AA%E6%8B%92%E7%BB%9D%E7%AD%96%E7%95%A5%EF%BC%9F"><span class="toc-text">14. 如果不允许线程池丢弃任务，应该选择哪个拒绝策略？</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#15-Callable%E5%92%8CRunnable%E6%8E%A5%E5%8F%A3%E6%9C%89%E4%BB%80%E4%B9%88%E5%8C%BA%E5%88%AB%EF%BC%9F"><span class="toc-text">15. Callable和Runnable接口有什么区别？</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#16-%E7%BA%BF%E7%A8%8B%E6%B1%A0%E4%B8%AD%E7%BA%BF%E7%A8%8B%E5%BC%82%E5%B8%B8%E5%90%8E%EF%BC%9A%E9%94%80%E6%AF%81%E8%BF%98%E6%98%AF%E5%A4%8D%E7%94%A8%EF%BC%9F"><span class="toc-text">16. 线程池中线程异常后：销毁还是复用？</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#17-%E7%BA%BF%E7%A8%8B%E6%B1%A0%E9%98%BB%E5%A1%9E%E9%98%9F%E5%88%97%E7%B1%BB%E5%9E%8B"><span class="toc-text">17.线程池阻塞队列类型</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#Java%E4%B8%AD%E7%9A%84%E9%94%81"><span class="toc-text">Java中的锁</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#1-Lock%E6%8E%A5%E5%8F%A3%E5%92%8Csynchronized%E5%AF%B9%E6%AF%94%E5%90%8C%E6%AD%A5%E5%AE%83%E6%9C%89%E4%BB%80%E4%B9%88%E4%BC%98%E5%8A%BF"><span class="toc-text">1. Lock接口和synchronized对比同步它有什么优势?</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#2-%E4%B9%90%E8%A7%82%E9%94%81%E5%92%8C%E6%82%B2%E8%A7%82%E9%94%81%E7%9A%84%E7%90%86%E8%A7%A3%E5%8F%8A%E5%A6%82%E4%BD%95%E5%AE%9E%E7%8E%B0%EF%BC%8C%E6%9C%89%E5%93%AA%E4%BA%9B%E5%AE%9E%E7%8E%B0%E6%96%B9%E5%BC%8F"><span class="toc-text">2. 乐观锁和悲观锁的理解及如何实现，有哪些实现方式?</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#3-%E4%BB%80%E4%B9%88%E6%98%AFCAS"><span class="toc-text">3. 什么是CAS</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#4-CAS%E7%9A%84%E4%BC%9A%E4%BA%A7%E7%94%9F%E4%BB%80%E4%B9%88%E9%97%AE%E9%A2%98"><span class="toc-text">4. CAS的会产生什么问题?</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#5-%E4%BB%80%E4%B9%88%E6%98%AF%E5%8E%9F%E5%AD%90%E7%B1%BB"><span class="toc-text">5. 什么是原子类</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#6-%E5%8E%9F%E5%AD%90%E7%B1%BB%E7%9A%84%E5%B8%B8%E7%94%A8%E7%B1%BB"><span class="toc-text">6. 原子类的常用类</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#7-%E8%AF%B4%E4%B8%80%E4%B8%8BAtomic%E7%9A%84%E5%8E%9F%E7%90%86"><span class="toc-text">7. 说一下Atomic的原理?</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#8-%E6%AD%BB%E9%94%81%E4%B8%8E%E6%B4%BB%E9%94%81%E7%9A%84%E5%8C%BA%E5%88%AB%EF%BC%8C%E6%AD%BB%E9%94%81%E4%B8%8E%E9%A5%A5%E9%A5%BF%E7%9A%84%E5%8C%BA%E5%88%AB"><span class="toc-text">8. 死锁与活锁的区别，死锁与饥饿的区别?</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#9-%E5%A6%82%E4%BD%95%E9%81%BF%E5%85%8D%E6%AD%BB%E9%94%81"><span class="toc-text">9. 如何避免死锁</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#10-%E4%B8%BA%E4%BB%80%E4%B9%88-wait-%E5%92%8C-notify-%E6%96%B9%E6%B3%95%E8%A6%81%E5%9C%A8%E5%90%8C%E6%AD%A5%E5%9D%97%E4%B8%AD%E8%B0%83%E7%94%A8"><span class="toc-text">10. 为什么 wait 和 notify 方法要在同步块中调用</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#11-%E8%AF%B4%E4%B8%8B%E5%AF%B9AQS%E7%9A%84%E7%90%86%E8%A7%A3"><span class="toc-text">11. 说下对AQS的理解</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#12-%E8%AF%B4%E4%B8%8BCAS%E7%9A%84%E5%8E%9F%E7%90%86"><span class="toc-text">12. 说下CAS的原理</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#13-ReentrantLock%E4%B8%AD%E7%9A%84%E5%85%AC%E5%B9%B3%E9%94%81%E5%92%8C%E9%9D%9E%E5%85%AC%E5%B9%B3%E9%94%81%E7%9A%84%E5%BA%95%E5%B1%82%E5%AE%9E%E7%8E%B0"><span class="toc-text">13. ReentrantLock中的公平锁和非公平锁的底层实现</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#14-AQS%E6%98%AF%E6%80%8E%E4%B9%88%E5%AE%9E%E7%8E%B0%E5%90%8C%E6%AD%A5%E7%AE%A1%E7%90%86%E7%9A%84-%E5%BA%95%E5%B1%82%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84"><span class="toc-text">14. AQS是怎么实现同步管理的? 底层数据结构?</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#15-%E4%BB%80%E4%B9%88%E6%98%AF%E5%8F%AF%E9%87%8D%E5%85%A5%EF%BC%8C%E4%BB%80%E4%B9%88%E6%98%AF%E5%8F%AF%E9%87%8D%E5%85%A5%E9%94%81"><span class="toc-text">15. 什么是可重入，什么是可重入锁?</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#16-%E5%85%AC%E5%B9%B3%E9%94%81%E5%92%8C%E9%9D%9E%E5%85%AC%E5%B9%B3%E9%94%81%E6%9C%89%E4%BB%80%E4%B9%88%E5%8C%BA%E5%88%AB"><span class="toc-text">16. 公平锁和非公平锁有什么区别?</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#17-%E4%B8%BA%E4%BB%80%E4%B9%88%E9%9D%9E%E5%85%AC%E5%B9%B3%E9%94%81%E6%AF%94%E5%85%AC%E5%B9%B3%E9%94%81%E6%80%A7%E8%83%BD%E6%9B%B4%E5%A5%BD"><span class="toc-text">17. 为什么非公平锁比公平锁性能更好?</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#18-ReentrantLock%E6%98%AF%E5%A6%82%E4%BD%95%E5%AE%9E%E7%8E%B0%E5%85%AC%E5%B9%B3%E9%94%81%E7%9A%84-%E9%9D%9E%E5%85%AC%E5%B9%B3%E9%94%81%E7%9A%84"><span class="toc-text">18. ReentrantLock是如何实现公平锁的? 非公平锁的?</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#19-ReentrantReadWriteLock%E6%98%AF%E4%BB%80%E4%B9%88"><span class="toc-text">19. ReentrantReadWriteLock是什么?</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#20-%E5%85%B1%E4%BA%AB%E9%94%81%E5%92%8C%E7%8B%AC%E5%8D%A0%E9%94%81%E6%9C%89%E4%BB%80%E4%B9%88%E5%8C%BA%E5%88%AB"><span class="toc-text">20. 共享锁和独占锁有什么区别?</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#21-%E7%BA%BF%E7%A8%8B%E6%8C%81%E6%9C%89%E8%AF%BB%E9%94%81%E8%BF%98%E8%83%BD%E8%8E%B7%E5%8F%96%E5%86%99%E9%94%81%E5%90%97"><span class="toc-text">21. 线程持有读锁还能获取写锁吗?</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#22-%E4%BB%80%E4%B9%88%E6%98%AF%E9%94%81%E7%9A%84%E5%8D%87%E9%99%8D%E7%BA%A7-RentrantReadWriteLock%E4%B8%BA%E4%BB%80%E4%B9%88%E4%B8%8D%E6%94%AF%E6%8C%81%E9%94%81%E5%8D%87%E7%BA%A7"><span class="toc-text">22. 什么是锁的升降级? RentrantReadWriteLock为什么不支持锁升级?</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#23-ReentrantReadWriteLock%E5%BA%95%E5%B1%82%E8%AF%BB%E5%86%99%E7%8A%B6%E6%80%81%E5%A6%82%E4%BD%95%E8%AE%BE%E8%AE%A1%E7%9A%84"><span class="toc-text">23. ReentrantReadWriteLock底层读写状态如何设计的?</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E5%B9%B6%E5%8F%91%E5%AE%89%E5%85%A8%E5%AE%B9%E5%99%A8-%E5%B9%B6%E5%8F%91%E5%B7%A5%E5%85%B7%E7%B1%BB"><span class="toc-text">并发安全容器&#x2F;并发工具类</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#1-JDK7%E4%B8%8EJDK8%E4%B9%8B%E9%97%B4HashMap%E7%9A%84%E5%8C%BA%E5%88%AB%EF%BC%9F"><span class="toc-text">1. JDK7与JDK8之间HashMap的区别？</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#2-ConcurrentHashMap%E5%92%8CHashtable%E7%9A%84%E5%8C%BA%E5%88%AB"><span class="toc-text">2. ConcurrentHashMap和Hashtable的区别?</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#3-ConcurrentHashMap-JDK1-7%E5%AE%9E%E7%8E%B0%E7%9A%84%E5%8E%9F%E7%90%86%E6%98%AF%E4%BB%80%E4%B9%88"><span class="toc-text">3. ConcurrentHashMap JDK1.7实现的原理是什么?</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#4-ConcurrentHashMap-JDK1-8%E5%AE%9E%E7%8E%B0%E7%9A%84%E5%8E%9F%E7%90%86%E6%98%AF%E4%BB%80%E4%B9%88"><span class="toc-text">4. ConcurrentHashMap JDK1.8实现的原理是什么?</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#5-ConcurrentHashMap-JDK1-7%E7%9A%84%E5%AE%9E%E7%8E%B0%E5%92%8C1-8%E7%9A%84%E5%AE%9E%E7%8E%B0%E6%9C%89%E4%BB%80%E4%B9%88%E5%8C%BA%E5%88%AB"><span class="toc-text">5. ConcurrentHashMap JDK1.7的实现和1.8的实现有什么区别?</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#6-JDK1-8%E4%B8%AD%EF%BC%8CConCurrentHashmap%E4%BB%80%E4%B9%88%E6%83%85%E5%86%B5%E4%B8%8B%E9%93%BE%E8%A1%A8%E6%89%8D%E4%BC%9A%E8%BD%AC%E6%8D%A2%E6%88%90%E7%BA%A2%E9%BB%91%E6%A0%91%E8%BF%9B%E8%A1%8C%E5%AD%98%E5%82%A8"><span class="toc-text">6. JDK1.8中，ConCurrentHashmap什么情况下链表才会转换成红黑树进行存储?</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#7-JDK1-8%E4%B8%AD%EF%BC%8CConcurrentHashmap%E7%9A%84put%E8%BF%87%E7%A8%8B%E6%98%AF%E6%80%8E%E6%A0%B7%E7%9A%84"><span class="toc-text">7. JDK1.8中，ConcurrentHashmap的put过程是怎样的?</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#8-ConcurrentHashMap%E7%9A%84get%E6%96%B9%E6%B3%95%E6%98%AF%E5%90%A6%E8%A6%81%E5%8A%A0%E9%94%81%EF%BC%8C%E4%B8%BA%E4%BB%80%E4%B9%88"><span class="toc-text">8. ConcurrentHashMap的get方法是否要加锁，为什么?</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#9-ConcurrentHashMap%E9%BB%98%E8%AE%A4%E5%88%9D%E5%A7%8B%E5%AE%B9%E9%87%8F%E6%98%AF%E5%A4%9A%E5%B0%91"><span class="toc-text">9. ConcurrentHashMap默认初始容量是多少?</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#10-ConcurrentHashMap%E7%9A%84key%EF%BC%8Cvalue%E6%98%AF%E5%90%A6%E5%8F%AF%E4%BB%A5%E4%B8%BAnull"><span class="toc-text">10. ConcurrentHashMap的key，value是否可以为null?</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#11-%E5%AD%98%E5%82%A8%E5%9C%A8ConcurrentHashMap%E4%B8%AD%E6%AF%8F%E4%B8%AA%E8%8A%82%E7%82%B9%E6%98%AF%E4%BB%80%E4%B9%88%E6%A0%B7%E7%9A%84%EF%BC%8C%E6%9C%89%E5%93%AA%E4%BA%9B%E5%8F%98%E9%87%8F"><span class="toc-text">11.存储在ConcurrentHashMap中每个节点是什么样的，有哪些变量?</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#12-%E4%BB%80%E4%B9%88%E6%98%AFBlockingQueue"><span class="toc-text">12. 什么是BlockingQueue?</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#13-%E4%BD%A0%E4%BA%86%E8%A7%A3%E5%93%AA%E4%BA%9B%E9%98%BB%E5%A1%9E%E9%98%9F%E5%88%97"><span class="toc-text">13.你了解哪些阻塞队列</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#14-ArrayBlockingQueue%E5%92%8CLinkedBlockingQueue%E6%9C%89%E4%BB%80%E4%B9%88%E5%8C%BA%E5%88%AB"><span class="toc-text">14. ArrayBlockingQueue和LinkedBlockingQueue有什么区别?</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#15-%E5%A6%82%E6%9E%9C%E9%98%9F%E5%88%97%E6%98%AF%E7%A9%BA%E7%9A%84%EF%BC%8C%E6%B6%88%E8%B4%B9%E8%80%85%E4%BC%9A%E4%B8%80%E7%9B%B4%E7%AD%89%E5%BE%85%EF%BC%8C%E5%BD%93%E7%94%9F%E4%BA%A7%E8%80%85%E6%B7%BB%E5%8A%A0%E5%85%83%E7%B4%A0%E6%97%B6%EF%BC%8C%E6%B6%88%E8%B4%B9%E8%80%85%E6%98%AF%E5%A6%82%E4%BD%95%E7%9F%A5%E9%81%93%E5%BD%93%E5%89%8D%E9%98%9F%E5%88%97%E6%9C%89%E5%85%83%E7%B4%A0%E7%9A%84%E5%91%A2"><span class="toc-text">15. 如果队列是空的，消费者会一直等待，当生产者添加元素时，消费者是如何知道当前队列有元素的呢?</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#16-CountDownLatch%EF%BC%8CCyclicBarrier%EF%BC%8CSemaphore%EF%BC%8CExchanger%E4%BA%86%E8%A7%A3%E5%90%97"><span class="toc-text">16. CountDownLatch，CyclicBarrier，Semaphore，Exchanger了解吗?</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#17-CyclicBarrier%E5%92%8CCountDownLatch%E6%9C%89%E4%BB%80%E4%B9%88%E5%8C%BA%E5%88%AB"><span class="toc-text">17. CyclicBarrier和CountDownLatch有什么区别?</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#18-%E5%B8%B8%E8%A7%81%E5%87%BD%E6%95%B0"><span class="toc-text">18.常见函数</span></a></li></ol></li></ol></li></ol></div></div></div></div></main><footer id="footer" style="background-color: transparent;"><div id="footer-wrap"><div id="ft"><div class="ft-item-1"><div class="t-top"><div class="t-t-l"><p class="ft-t t-l-t">格言🧬</p><div class="bg-ad"><div>再看看那个光点，它就在这里，这是家园，这是我们 —— 你所爱的每一个人，你认识的一个人，你听说过的每一个人，曾经有过的每一个人，都在它上面度过他们的一生✨</div><div class="btn-xz-box"><a class="btn-xz" target="_blank" rel="noopener" href="https://stellarium.org/">点击开启星辰之旅</a></div></div></div><div class="t-t-r"><p class="ft-t t-l-t">猜你想看💡</p><ul class="ft-links"><li><a href="/posts/eec9786.html">魔改指南</a><a href="/box/nav/">网址导航</a></li><li><a href="/social/link/">我的朋友</a><a href="/comments/">留点什么</a></li><li><a href="/personal/about/">关于作者</a><a href="/archives/">文章归档</a></li><li><a href="/categories/">文章分类</a><a href="/tags/">文章标签</a></li><li><a href="/box/Gallery/">我的画廊</a><a href="/personal/bb/">我的唠叨</a></li><li><a href="/site/time/">建设进程</a><a href="/site/census/">网站统计</a></li></ul></div></div></div><div class="ft-item-2"><p class="ft-t">推荐友链⌛</p><div class="ft-img-group"><div class="img-group-item"><a target="_blank" rel="noopener" href="https://www.fomal.cc/" title="Fomalhaut🥝"><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="https://lskypro.acozycotage.net/LightPicture/2022/12/60e5d4e39da7c077.webp" alt=""/></a></div><div class="img-group-item"><a href="javascript:void(0)" title="广告位招租"><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="https://lskypro.acozycotage.net/LightPicture/2022/12/65307a5828af6790.webp" alt=""/></a></div><div class="img-group-item"><a href="javascript:void(0)" title="广告位招租"><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="https://lskypro.acozycotage.net/LightPicture/2022/12/65307a5828af6790.webp" alt=""/></a></div><div class="img-group-item"><a href="javascript:void(0)" title="广告位招租"><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="https://lskypro.acozycotage.net/LightPicture/2022/12/65307a5828af6790.webp" alt=""/></a></div><div class="img-group-item"><a href="javascript:void(0)" title="广告位招租"><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="https://lskypro.acozycotage.net/LightPicture/2022/12/65307a5828af6790.webp" alt=""/></a></div><div class="img-group-item"><a href="javascript:void(0)" title="广告位招租"><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="https://lskypro.acozycotage.net/LightPicture/2022/12/65307a5828af6790.webp" alt=""/></a></div><div class="img-group-item"><a href="javascript:void(0)" title="广告位招租"><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="https://lskypro.acozycotage.net/LightPicture/2022/12/65307a5828af6790.webp" alt=""/></a></div><div class="img-group-item"><a href="javascript:void(0)" title="广告位招租"><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="https://lskypro.acozycotage.net/LightPicture/2022/12/65307a5828af6790.webp" alt=""/></a></div></div></div></div><div class="copyright"><span><b>&copy;2022-2025</b></span><span><b>&nbsp;&nbsp;By OutOfLove🥝</b></span></div><div id="workboard"></div><p id="ghbdages"><a class="github-badge" target="_blank" href="https://hexo.io/" style="margin-inline:5px" title="博客框架为Hexo_v6.3.0"><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="https://sourcebucket.s3.ladydaily.com/badge/Frame-Hexo-blue.svg" alt=""/></a><a class="github-badge" target="_blank" href="https://butterfly.js.org/" style="margin-inline:5px" title="主题版本Butterfly_v4.3.1"><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="https://sourcebucket.s3.ladydaily.com/badge/Theme-Butterfly-6513df.svg" alt=""/></a><a class="github-badge" target="_blank" href="https://vercel.com/" style="margin-inline:5px" title="本站采用多线部署，主线路托管于Vercel"><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="https://sourcebucket.s3.ladydaily.com/badge/Hosted-Vercel-brightgreen.svg" alt=""/></a><a class="github-badge" target="_blank" href="https://user.51.la/" style="margin-inline:5px" title="本站数据分析得益于51la技术支持"><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="https://sourcebucket.s3.ladydaily.com/badge/Analytics-51la-3db1eb.svg" alt=""/></a><a class="github-badge" target="_blank" href="https://icp.gov.moe/?keyword=20226665" style="margin-inline:5px" title="本站已加入萌ICP豪华套餐，萌ICP备20226665号"><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="https://sourcebucket.s3.ladydaily.com/badge/萌ICP备-20226665-fe1384.svg" alt=""/></a><a class="github-badge" target="_blank" href="https://bitiful.dogecast.com/buckets" style="margin-inline:5px" title="本网站经Service Worker分流至缤纷云对象存储"><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src=" https://sourcebucket.s3.ladydaily.com/badge/Bucket-缤纷云-9c62da.svg" alt=""/></a><a class="github-badge" target="_blank" href="https://www.netdun.net/" style="margin-inline:5px" title="本站使用网盾星球提供CDN加速与防护"><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="https://sourcebucket.s3.ladydaily.com/badge/CDN-网盾星球-fff2cc.svg" alt=""/></a><a class="github-badge" target="_blank" href="https://github.com/" style="margin-inline:5px" title="本网站源码由Github提供存储仓库"><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src=" https://sourcebucket.s3.ladydaily.com/badge/Source-Github-d021d6.svg" alt=""/></a></p></div></footer></div><div id="rightside"><div id="rightside-config-hide"><button id="readmode" type="button" title="阅读模式"><i class="fas fa-book-open"></i></button><a class="icon-V hidden" onclick="switchNightMode()" title="浅色和深色模式转换"><svg width="25" height="25" viewBox="0 0 1024 1024"><use id="modeicon" xlink:href="#icon-moon"></use></svg></a><button id="hide-aside-btn" type="button" title="单栏和双栏切换"><i class="fas fa-arrows-alt-h"></i></button><button class="share" type="button" title="右键模式" onclick="changeMouseMode()"><i class="fas fa-mouse"></i></button></div><div id="rightside-config-show"><button id="rightside_config" type="button" title="设置"><i class="fas fa-cog right_side"></i></button><button class="close" id="mobile-toc-button" type="button" title="目录"><i class="fas fa-list-ul"></i></button><button class="share" type="button" title="分享链接" onclick="share()"><i class="fas fa-share-nodes"></i></button><a id="to_comment" href="#post-comment" title="直达评论"><i class="fas fa-comments"></i></a><button id="go-up" type="button" title="回到顶部"><i class="fas fa-arrow-up"></i><span id="percent">0<span>%</span></span></button><button id="go-down" type="button" title="直达底部" onclick="btf.scrollToDest(document.body.scrollHeight, 500)"><i class="fas fa-arrow-down"></i></button></div></div><div id="local-search"><div class="search-dialog"><nav class="search-nav"><span class="search-dialog-title">搜索</span><span id="loading-status"></span><button class="search-close-button"><i class="fas fa-times"></i></button></nav><div class="is-center" id="loading-database"><i class="fas fa-spinner fa-pulse"></i><span>  数据库加载中</span></div><div class="search-wrap"><div id="local-search-input"><div class="local-search-box"><input class="local-search-box--input" placeholder="搜索文章" type="text"/></div></div><hr/><div id="local-search-results"></div></div></div><div id="search-mask"></div></div><div class="js-pjax" id="rightMenu"><div class="rightMenu-group rightMenu-small"><a class="rightMenu-item" href="javascript:window.history.back();"><i class="fa fa-arrow-left"></i></a><a class="rightMenu-item" href="javascript:window.history.forward();"><i class="fa fa-arrow-right"></i></a><a class="rightMenu-item" href="javascript:window.location.reload();"><i class="fa fa-refresh"></i></a><a class="rightMenu-item" href="javascript:rmf.scrollToTop();"><i class="fa fa-arrow-up"></i></a></div><div class="rightMenu-group rightMenu-line hide" id="menu-text"><a class="rightMenu-item" href="javascript:rmf.copySelect();"><i class="fa fa-copy"></i><span>复制</span></a><a class="rightMenu-item" href="javascript:window.open(&quot;https://www.baidu.com/s?wd=&quot;+window.getSelection().toString());window.location.reload();"><i class="fa fa-search"></i><span>百度搜索</span></a></div><div class="rightMenu-group rightMenu-line hide" id="menu-too"><a class="rightMenu-item" href="javascript:window.open(window.getSelection().toString());window.location.reload();"><i class="fa fa-link"></i><span>转到链接</span></a></div><div class="rightMenu-group rightMenu-line hide" id="menu-paste"><a class="rightMenu-item" href="javascript:rmf.paste()"><i class="fa fa-copy"></i><span>粘贴</span></a></div><div class="rightMenu-group rightMenu-line hide" id="menu-post"><a class="rightMenu-item" href="#post-comment"><i class="fas fa-comment"></i><span>空降评论</span></a><a class="rightMenu-item" href="javascript:rmf.copyWordsLink()"><i class="fa fa-link"></i><span>复制本文地址</span></a></div><div class="rightMenu-group rightMenu-line hide" id="menu-to"><a class="rightMenu-item" href="javascript:rmf.openWithNewTab()"><i class="fa fa-window-restore"></i><span>新窗口打开</span></a><a class="rightMenu-item" id="menu-too" href="javascript:rmf.open()"><i class="fa fa-link"></i><span>转到链接</span></a><a class="rightMenu-item" href="javascript:rmf.copyLink()"><i class="fa fa-copy"></i><span>复制链接</span></a></div><div class="rightMenu-group rightMenu-line hide" id="menu-img"><a class="rightMenu-item" href="javascript:rmf.saveAs()"><i class="fa fa-download"></i><span>保存图片</span></a><a class="rightMenu-item" href="javascript:rmf.openWithNewTab()"><i class="fa fa-window-restore"></i><span>在新窗口打开</span></a><a class="rightMenu-item" href="javascript:rmf.copyLink()"><i class="fa fa-copy"></i><span>复制图片链接</span></a></div><div class="rightMenu-group rightMenu-line"><a class="rightMenu-item" href="javascript:randomPost()"><i class="fa fa-paper-plane"></i><span>随便逛逛</span></a><a class="rightMenu-item" href="javascript:switchNightMode();"><i class="fa fa-moon"></i><span>昼夜切换</span></a><a class="rightMenu-item" href="/personal/about/"><i class="fa fa-info-circle"></i><span>关于博客</span></a><a class="rightMenu-item" href="javascript:toggleWinbox();"><i class="fas fa-cog"></i><span>美化设置</span></a><a class="rightMenu-item" href="javascript:rmf.fullScreen();"><i class="fas fa-expand"></i><span>切换全屏</span></a><a class="rightMenu-item" href="javascript:window.print();"><i class="fa-solid fa-print"></i><span>打印页面</span></a></div></div><div><script src="/js/utils.js"></script><script src="/js/main.js"></script><script src="https://cdn.staticfile.org/fancyapps-ui/4.0.31/fancybox.umd.min.js"></script><script src="https://lf3-cdn-tos.bytecdntp.com/cdn/expire-1-M/instant.page/5.1.0/instantpage.min.js" type="module"></script><script src="https://lf3-cdn-tos.bytecdntp.com/cdn/expire-1-M/vanilla-lazyload/17.3.1/lazyload.iife.min.js"></script><script src="/js/search/local-search.js"></script><script async="async">var preloader = {
  endLoading: () => {
    document.body.style.overflow = 'auto';
    document.getElementById('loading-box').classList.add("loaded")
  },
  initLoading: () => {
    document.body.style.overflow = '';
    document.getElementById('loading-box').classList.remove("loaded")

  }
}
window.addEventListener('load',preloader.endLoading())
setTimeout(function(){preloader.endLoading();}, 5000);
document.getElementById('loading-box').addEventListener('click',()=> {preloader.endLoading()})</script><div class="js-pjax"><script>if (!window.MathJax) {
  window.MathJax = {
    tex: {
      inlineMath: [ ['$','$'], ["\\(","\\)"]],
      tags: 'ams'
    },
    chtml: {
      scale: 1.2
    },
    options: {
      renderActions: {
        findScript: [10, doc => {
          for (const node of document.querySelectorAll('script[type^="math/tex"]')) {
            const display = !!node.type.match(/; *mode=display/)
            const math = new doc.options.MathItem(node.textContent, doc.inputJax[0], display)
            const text = document.createTextNode('')
            node.parentNode.replaceChild(text, node)
            math.start = {node: text, delim: '', n: 0}
            math.end = {node: text, delim: '', n: 0}
            doc.math.push(math)
          }
        }, ''],
        insertScript: [200, () => {
          document.querySelectorAll('mjx-container:not\([display]\)').forEach(node => {
            const target = node.parentNode
            if (target.nodeName.toLowerCase() === 'li') {
              target.parentNode.classList.add('has-jax')
            } else {
              target.classList.add('has-jax')
            }
          });
        }, '', false]
      }
    }
  }
  
  const script = document.createElement('script')
  script.src = 'https://cdnjs.cloudflare.com/ajax/libs/mathjax/3.2.2/es5/tex-mml-chtml.min.js'
  script.id = 'MathJax-script'
  script.async = true
  document.head.appendChild(script)
} else {
  MathJax.startup.document.state(0)
  MathJax.texReset()
  MathJax.typeset()
}</script><script>(()=>{
  const init = () => {
    twikoo.init(Object.assign({
      el: '#twikoo-wrap',
      envId: '',
      region: '',
      onCommentLoaded: function () {
        btf.loadLightbox(document.querySelectorAll('#twikoo .tk-content img:not(.tk-owo-emotion)'))
      }
    }, null))
  }

  const getCount = () => {
    const countELement = document.getElementById('twikoo-count')
    if(!countELement) return
    twikoo.getCommentsCount({
      envId: '',
      region: '',
      urls: [window.location.pathname],
      includeReply: false
    }).then(function (res) {
      countELement.innerText = res[0].count
    }).catch(function (err) {
      console.error(err);
    });
  }

  const runFn = () => {
    init()
    
  }

  const loadTwikoo = () => {
    if (typeof twikoo === 'object') {
      setTimeout(runFn,0)
      return
    } 
    getScript('https://cdn.staticfile.org/twikoo/1.6.8/twikoo.all.min.js').then(runFn)
  }

  if ('Twikoo' === 'Twikoo' || !true) {
    if (true) btf.loadComment(document.getElementById('twikoo-wrap'), loadTwikoo)
    else loadTwikoo()
  } else {
    window.loadOtherComment = () => {
      loadTwikoo()
    }
  }
})()</script></div><script src="https://cdn.staticfile.org/jquery/3.6.3/jquery.min.js"></script><script async src="https://cdn1.tianli0.top/npm/vue@2.6.14/dist/vue.min.js"></script><script async src="https://cdn1.tianli0.top/npm/element-ui@2.15.6/lib/index.js"></script><script async src="https://cdn.bootcdn.net/ajax/libs/clipboard.js/2.0.11/clipboard.min.js"></script><script defer type="text/javascript" src="https://cdn1.tianli0.top/npm/sweetalert2@8.19.0/dist/sweetalert2.all.js"></script><script async src="//npm.elemecdn.com/pace-js@1.2.4/pace.min.js"></script><script defer src="https://cdn1.tianli0.top/gh/nextapps-de/winbox/dist/winbox.bundle.min.js"></script><script async src="//at.alicdn.com/t/c/font_3586335_hsivh70x0fm.js"></script><script async src="//at.alicdn.com/t/c/font_3636804_gr02jmjr3y9.js"></script><script async src="//at.alicdn.com/t/c/font_3612150_kfv55xn3u2g.js"></script><script async src="https://cdn.wpon.cn/2022-sucai/Gold-ingot.js"></script><canvas id="universe"></canvas><canvas id="snow"></canvas><script defer src="/js/fomal.js"></script><link rel="stylesheet" href="https://lf6-cdn-tos.bytecdntp.com/cdn/expire-1-M/aplayer/1.10.1/APlayer.min.css" media="print" onload="this.media='all'"><script src="https://lf6-cdn-tos.bytecdntp.com/cdn/expire-1-M/aplayer/1.10.1/APlayer.min.js"></script><script src="https://cdn1.tianli0.top/npm/js-heo@1.0.12/metingjs/Meting.min.js"></script><script src="https://lib.baomitu.com/pjax/0.2.8/pjax.min.js"></script><script>let pjaxSelectors = ["head > title","#config-diff","#body-wrap","#rightside-config-hide","#rightside-config-show","#web_bg",".js-pjax","#bibi","body > title","#app","#tag-echarts","#posts-echart","#categories-echarts"]

var pjax = new Pjax({
  elements: 'a:not([target="_blank"])',
  selectors: pjaxSelectors,
  cacheBust: false,
  analytics: false,
  scrollRestoration: false
})

document.addEventListener('pjax:send', function () {

  // removeEventListener scroll 
  window.tocScrollFn && window.removeEventListener('scroll', window.tocScrollFn)
  window.scrollCollect && window.removeEventListener('scroll', scrollCollect)

  typeof preloader === 'object' && preloader.initLoading()
  document.getElementById('rightside').style.cssText = "opacity: ''; transform: ''"
  
  if (window.aplayers) {
    for (let i = 0; i < window.aplayers.length; i++) {
      if (!window.aplayers[i].options.fixed) {
        window.aplayers[i].destroy()
      }
    }
  }

  typeof typed === 'object' && typed.destroy()

  //reset readmode
  const $bodyClassList = document.body.classList
  $bodyClassList.contains('read-mode') && $bodyClassList.remove('read-mode')

  typeof disqusjs === 'object' && disqusjs.destroy()
})

document.addEventListener('pjax:complete', function () {
  window.refreshFn()

  document.querySelectorAll('script[data-pjax]').forEach(item => {
    const newScript = document.createElement('script')
    const content = item.text || item.textContent || item.innerHTML || ""
    Array.from(item.attributes).forEach(attr => newScript.setAttribute(attr.name, attr.value))
    newScript.appendChild(document.createTextNode(content))
    item.parentNode.replaceChild(newScript, item)
  })

  GLOBAL_CONFIG.islazyload && window.lazyLoadInstance.update()

  typeof chatBtnFn === 'function' && chatBtnFn()
  typeof panguInit === 'function' && panguInit()

  // google analytics
  typeof gtag === 'function' && gtag('config', '', {'page_path': window.location.pathname});

  // baidu analytics
  typeof _hmt === 'object' && _hmt.push(['_trackPageview',window.location.pathname]);

  typeof loadMeting === 'function' && document.getElementsByClassName('aplayer').length && loadMeting()

  // prismjs
  typeof Prism === 'object' && Prism.highlightAll()

  typeof preloader === 'object' && preloader.endLoading()
})

document.addEventListener('pjax:error', (e) => {
  if (e.request.status === 404) {
    pjax.loadUrl('/404.html')
  }
})</script><script async data-pjax src="//busuanzi.ibruce.info/busuanzi/2.3/busuanzi.pure.mini.js"></script></div><!-- hexo injector body_end start --> <script data-pjax>if(document.getElementById('recent-posts') && (location.pathname ==='/'|| '/' ==='all')){
    var parent = document.getElementById('recent-posts');
    var child = '<div class="recent-post-item" style="width:100%;height: auto"><div id="catalog_magnet"><div class="magnet_item"><a class="magnet_link" href="https://outoflovenicoo.github.io/categories/刷题/"><div class="magnet_link_context" style=""><span style="font-weight:500;flex:1">🍡 MakeFanの刷题笔记 (2)</span><span style="padding:0px 4px;border-radius: 8px;"><i class="fas fa-arrow-circle-right"></i></span></div></a></div><div class="magnet_item"><a class="magnet_link" href="https://outoflovenicoo.github.io/categories/面试题/"><div class="magnet_link_context" style=""><span style="font-weight:500;flex:1">🍼 MakeFanの面试题总结 (9)</span><span style="padding:0px 4px;border-radius: 8px;"><i class="fas fa-arrow-circle-right"></i></span></div></a></div><div class="magnet_item"><a class="magnet_link" href="https://outoflovenicoo.github.io/categories/学习方法优化/"><div class="magnet_link_context" style=""><span style="font-weight:500;flex:1">🍉 MakeFanの学习方法优化反思 (1)</span><span style="padding:0px 4px;border-radius: 8px;"><i class="fas fa-arrow-circle-right"></i></span></div></a></div><div class="magnet_item"><a class="magnet_link" href="https://outoflovenicoo.github.io/categories/学习/"><div class="magnet_link_context" style=""><span style="font-weight:500;flex:1">🍟 MakeFanの学习笔记 (10)</span><span style="padding:0px 4px;border-radius: 8px;"><i class="fas fa-arrow-circle-right"></i></span></div></a></div><div class="magnet_item"><a class="magnet_link" href="https://outoflovenicoo.github.io/categories/演示/"><div class="magnet_link_context" style=""><span style="font-weight:500;flex:1">🍥 小Fの案例演示笔记 (1)</span><span style="padding:0px 4px;border-radius: 8px;"><i class="fas fa-arrow-circle-right"></i></span></div></a></div><div class="magnet_item" style="visibility: hidden"></div><a class="magnet_link_more"  href="https://outoflovenicoo.github.io/categories/" style="flex:1;text-align: center;margin-bottom: 10px;">查看更多...</a></div></div>';
    console.log('已挂载magnet')
    parent.insertAdjacentHTML("afterbegin",child)}
     </script><style>#catalog_magnet{flex-wrap: wrap;display: flex;width:100%;justify-content:space-between;padding: 10px 10px 0 10px;align-content: flex-start;}.magnet_item{flex-basis: calc(33.333333333333336% - 5px);background: #e9e9e9;margin-bottom: 10px;border-radius: 8px;transition: all 0.2s ease-in-out;}.magnet_item:hover{background: var(--text-bg-hover)}.magnet_link_more{color:#555}.magnet_link{color:black}.magnet_link:hover{color:white}@media screen and (max-width: 600px) {.magnet_item {flex-basis: 100%;}}.magnet_link_context{display:flex;padding: 10px;font-size:16px;transition: all 0.2s ease-in-out;}.magnet_link_context:hover{padding: 10px 20px;}</style>
    <style></style><script data-pjax>
  function butterfly_swiper_injector_config(){
    var parent_div_git = document.getElementById('recent-posts');
    var item_html = '<div class="recent-post-item" style="height: auto;width: 100%"><div class="blog-slider swiper-container-fade swiper-container-horizontal" id="swiper_container"><div class="blog-slider__wrp swiper-wrapper" style="transition-duration: 0ms;"><div class="blog-slider__item swiper-slide" style="width: 750px; opacity: 1; transform: translate3d(0px, 0px, 0px); transition-duration: 0ms;"><a class="blog-slider__img" onclick="pjax.loadUrl(&quot;posts/2025-03-09-MySQL 如何存储数据？.html&quot;);" href="javascript:void(0);" alt=""><img width="48" height="48" src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="https://source.fomal.cc/img/default_cover_14.webp" alt="" onerror="this.src=https://unpkg.zhimg.com/akilar-candyassets/image/loading.gif; this.onerror = null;"/></a><div class="blog-slider__content"><span class="blog-slider__code">2025-03-09</span><a class="blog-slider__title" onclick="pjax.loadUrl(&quot;posts/2025-03-09-MySQL 如何存储数据？.html&quot;);" href="javascript:void(0);" alt="">MySQL 如何存储数据？</a><div class="blog-slider__text">🥧MySQL 如何存储数据？</div><a class="blog-slider__button" onclick="pjax.loadUrl(&quot;posts/2025-03-09-MySQL 如何存储数据？.html&quot;);" href="javascript:void(0);" alt="">详情       </a></div></div><div class="blog-slider__item swiper-slide" style="width: 750px; opacity: 1; transform: translate3d(0px, 0px, 0px); transition-duration: 0ms;"><a class="blog-slider__img" onclick="pjax.loadUrl(&quot;posts/2025-03-09-联合索引学习笔记.html&quot;);" href="javascript:void(0);" alt=""><img width="48" height="48" src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="https://source.fomal.cc/img/default_cover_15.webp" alt="" onerror="this.src=https://unpkg.zhimg.com/akilar-candyassets/image/loading.gif; this.onerror = null;"/></a><div class="blog-slider__content"><span class="blog-slider__code">2025-03-09</span><a class="blog-slider__title" onclick="pjax.loadUrl(&quot;posts/2025-03-09-联合索引学习笔记.html&quot;);" href="javascript:void(0);" alt="">联合索引学习笔记</a><div class="blog-slider__text">🥧联合索引学习</div><a class="blog-slider__button" onclick="pjax.loadUrl(&quot;posts/2025-03-09-联合索引学习笔记.html&quot;);" href="javascript:void(0);" alt="">详情       </a></div></div><div class="blog-slider__item swiper-slide" style="width: 750px; opacity: 1; transform: translate3d(0px, 0px, 0px); transition-duration: 0ms;"><a class="blog-slider__img" onclick="pjax.loadUrl(&quot;posts/2025-01-09-实习经验.html&quot;);" href="javascript:void(0);" alt=""><img width="48" height="48" src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="https://source.fomal.cc/img/default_cover_14.webp" alt="" onerror="this.src=https://unpkg.zhimg.com/akilar-candyassets/image/loading.gif; this.onerror = null;"/></a><div class="blog-slider__content"><span class="blog-slider__code">2025-01-09</span><a class="blog-slider__title" onclick="pjax.loadUrl(&quot;posts/2025-01-09-实习经验.html&quot;);" href="javascript:void(0);" alt="">实习经验</a><div class="blog-slider__text">🥧本人的实习经验总结</div><a class="blog-slider__button" onclick="pjax.loadUrl(&quot;posts/2025-01-09-实习经验.html&quot;);" href="javascript:void(0);" alt="">详情       </a></div></div><div class="blog-slider__item swiper-slide" style="width: 750px; opacity: 1; transform: translate3d(0px, 0px, 0px); transition-duration: 0ms;"><a class="blog-slider__img" onclick="pjax.loadUrl(&quot;posts/2025-01-09-阿里开发规约学习总结.html&quot;);" href="javascript:void(0);" alt=""><img width="48" height="48" src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="https://source.fomal.cc/img/default_cover_15.webp" alt="" onerror="this.src=https://unpkg.zhimg.com/akilar-candyassets/image/loading.gif; this.onerror = null;"/></a><div class="blog-slider__content"><span class="blog-slider__code">2025-01-09</span><a class="blog-slider__title" onclick="pjax.loadUrl(&quot;posts/2025-01-09-阿里开发规约学习总结.html&quot;);" href="javascript:void(0);" alt="">阿里开发规约学习总结</a><div class="blog-slider__text">🥧阿里开发规约学习总结</div><a class="blog-slider__button" onclick="pjax.loadUrl(&quot;posts/2025-01-09-阿里开发规约学习总结.html&quot;);" href="javascript:void(0);" alt="">详情       </a></div></div><div class="blog-slider__item swiper-slide" style="width: 750px; opacity: 1; transform: translate3d(0px, 0px, 0px); transition-duration: 0ms;"><a class="blog-slider__img" onclick="pjax.loadUrl(&quot;posts/2025-01-09-JVM基础面试题.html&quot;);" href="javascript:void(0);" alt=""><img width="48" height="48" src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="https://source.fomal.cc/img/default_cover_15.webp" alt="" onerror="this.src=https://unpkg.zhimg.com/akilar-candyassets/image/loading.gif; this.onerror = null;"/></a><div class="blog-slider__content"><span class="blog-slider__code">2025-01-09</span><a class="blog-slider__title" onclick="pjax.loadUrl(&quot;posts/2025-01-09-JVM基础面试题.html&quot;);" href="javascript:void(0);" alt="">JVM基础面试题</a><div class="blog-slider__text">🥧JVM基础面试题总结</div><a class="blog-slider__button" onclick="pjax.loadUrl(&quot;posts/2025-01-09-JVM基础面试题.html&quot;);" href="javascript:void(0);" alt="">详情       </a></div></div><div class="blog-slider__item swiper-slide" style="width: 750px; opacity: 1; transform: translate3d(0px, 0px, 0px); transition-duration: 0ms;"><a class="blog-slider__img" onclick="pjax.loadUrl(&quot;posts/2025-01-09-Redis面试题.html&quot;);" href="javascript:void(0);" alt=""><img width="48" height="48" src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="https://source.fomal.cc/img/default_cover_15.webp" alt="" onerror="this.src=https://unpkg.zhimg.com/akilar-candyassets/image/loading.gif; this.onerror = null;"/></a><div class="blog-slider__content"><span class="blog-slider__code">2025-01-09</span><a class="blog-slider__title" onclick="pjax.loadUrl(&quot;posts/2025-01-09-Redis面试题.html&quot;);" href="javascript:void(0);" alt="">Redis面试题</a><div class="blog-slider__text">🥧本人的Redis面试题</div><a class="blog-slider__button" onclick="pjax.loadUrl(&quot;posts/2025-01-09-Redis面试题.html&quot;);" href="javascript:void(0);" alt="">详情       </a></div></div><div class="blog-slider__item swiper-slide" style="width: 750px; opacity: 1; transform: translate3d(0px, 0px, 0px); transition-duration: 0ms;"><a class="blog-slider__img" onclick="pjax.loadUrl(&quot;posts/2025-01-09-场景题.html&quot;);" href="javascript:void(0);" alt=""><img width="48" height="48" src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="https://source.fomal.cc/img/default_cover_14.webp" alt="" onerror="this.src=https://unpkg.zhimg.com/akilar-candyassets/image/loading.gif; this.onerror = null;"/></a><div class="blog-slider__content"><span class="blog-slider__code">2025-01-09</span><a class="blog-slider__title" onclick="pjax.loadUrl(&quot;posts/2025-01-09-场景题.html&quot;);" href="javascript:void(0);" alt="">场景题</a><div class="blog-slider__text">🥧本人的场景题面试总结</div><a class="blog-slider__button" onclick="pjax.loadUrl(&quot;posts/2025-01-09-场景题.html&quot;);" href="javascript:void(0);" alt="">详情       </a></div></div><div class="blog-slider__item swiper-slide" style="width: 750px; opacity: 1; transform: translate3d(0px, 0px, 0px); transition-duration: 0ms;"><a class="blog-slider__img" onclick="pjax.loadUrl(&quot;posts/2025331n.html&quot;);" href="javascript:void(0);" alt=""><img width="48" height="48" src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="https://source.fomal.cc/img/default_cover_14.webp" alt="" onerror="this.src=https://unpkg.zhimg.com/akilar-candyassets/image/loading.gif; this.onerror = null;"/></a><div class="blog-slider__content"><span class="blog-slider__code">2025-01-09</span><a class="blog-slider__title" onclick="pjax.loadUrl(&quot;posts/2025331n.html&quot;);" href="javascript:void(0);" alt="">分布式学习笔记</a><div class="blog-slider__text">🥧本人的分布式学习笔记</div><a class="blog-slider__button" onclick="pjax.loadUrl(&quot;posts/2025331n.html&quot;);" href="javascript:void(0);" alt="">详情       </a></div></div><div class="blog-slider__item swiper-slide" style="width: 750px; opacity: 1; transform: translate3d(0px, 0px, 0px); transition-duration: 0ms;"><a class="blog-slider__img" onclick="pjax.loadUrl(&quot;posts/2025-01-09-Spring基础面试题.html&quot;);" href="javascript:void(0);" alt=""><img width="48" height="48" src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="https://source.fomal.cc/img/default_cover_15.webp" alt="" onerror="this.src=https://unpkg.zhimg.com/akilar-candyassets/image/loading.gif; this.onerror = null;"/></a><div class="blog-slider__content"><span class="blog-slider__code">2025-01-09</span><a class="blog-slider__title" onclick="pjax.loadUrl(&quot;posts/2025-01-09-Spring基础面试题.html&quot;);" href="javascript:void(0);" alt="">Spring基础面试题</a><div class="blog-slider__text">🥧本人的Spring基础面试总结</div><a class="blog-slider__button" onclick="pjax.loadUrl(&quot;posts/2025-01-09-Spring基础面试题.html&quot;);" href="javascript:void(0);" alt="">详情       </a></div></div><div class="blog-slider__item swiper-slide" style="width: 750px; opacity: 1; transform: translate3d(0px, 0px, 0px); transition-duration: 0ms;"><a class="blog-slider__img" onclick="pjax.loadUrl(&quot;posts/2025331m.html&quot;);" href="javascript:void(0);" alt=""><img width="48" height="48" src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="https://source.fomal.cc/img/default_cover_14.webp" alt="" onerror="this.src=https://unpkg.zhimg.com/akilar-candyassets/image/loading.gif; this.onerror = null;"/></a><div class="blog-slider__content"><span class="blog-slider__code">2025-01-09</span><a class="blog-slider__title" onclick="pjax.loadUrl(&quot;posts/2025331m.html&quot;);" href="javascript:void(0);" alt="">Rabbitmq面试题</a><div class="blog-slider__text">🥧本人的Rabbitmq面试题总结</div><a class="blog-slider__button" onclick="pjax.loadUrl(&quot;posts/2025331m.html&quot;);" href="javascript:void(0);" alt="">详情       </a></div></div><div class="blog-slider__item swiper-slide" style="width: 750px; opacity: 1; transform: translate3d(0px, 0px, 0px); transition-duration: 0ms;"><a class="blog-slider__img" onclick="pjax.loadUrl(&quot;posts/2025331p.html&quot;);" href="javascript:void(0);" alt=""><img width="48" height="48" src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="https://source.fomal.cc/img/default_cover_14.webp" alt="" onerror="this.src=https://unpkg.zhimg.com/akilar-candyassets/image/loading.gif; this.onerror = null;"/></a><div class="blog-slider__content"><span class="blog-slider__code">2025-01-09</span><a class="blog-slider__title" onclick="pjax.loadUrl(&quot;posts/2025331p.html&quot;);" href="javascript:void(0);" alt="">MyBatis面试题</a><div class="blog-slider__text">🥧本人的MyBatis面试题总结</div><a class="blog-slider__button" onclick="pjax.loadUrl(&quot;posts/2025331p.html&quot;);" href="javascript:void(0);" alt="">详情       </a></div></div><div class="blog-slider__item swiper-slide" style="width: 750px; opacity: 1; transform: translate3d(0px, 0px, 0px); transition-duration: 0ms;"><a class="blog-slider__img" onclick="pjax.loadUrl(&quot;posts/2023454z.html&quot;);" href="javascript:void(0);" alt=""><img width="48" height="48" src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="https://source.fomal.cc/img/default_cover_15.webp" alt="" onerror="this.src=https://unpkg.zhimg.com/akilar-candyassets/image/loading.gif; this.onerror = null;"/></a><div class="blog-slider__content"><span class="blog-slider__code">2024-08-09</span><a class="blog-slider__title" onclick="pjax.loadUrl(&quot;posts/2023454z.html&quot;);" href="javascript:void(0);" alt="">学习方法优化与反思</a><div class="blog-slider__text">🥧学习方法优化与反思</div><a class="blog-slider__button" onclick="pjax.loadUrl(&quot;posts/2023454z.html&quot;);" href="javascript:void(0);" alt="">详情       </a></div></div><div class="blog-slider__item swiper-slide" style="width: 750px; opacity: 1; transform: translate3d(0px, 0px, 0px); transition-duration: 0ms;"><a class="blog-slider__img" onclick="pjax.loadUrl(&quot;posts/2025-01-09-JUC基础面试题.html&quot;);" href="javascript:void(0);" alt=""><img width="48" height="48" src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="https://source.fomal.cc/img/default_cover_15.webp" alt="" onerror="this.src=https://unpkg.zhimg.com/akilar-candyassets/image/loading.gif; this.onerror = null;"/></a><div class="blog-slider__content"><span class="blog-slider__code">2025-01-09</span><a class="blog-slider__title" onclick="pjax.loadUrl(&quot;posts/2025-01-09-JUC基础面试题.html&quot;);" href="javascript:void(0);" alt="">JUC基础面试题</a><div class="blog-slider__text">🥧本人的JUC基础面试总结</div><a class="blog-slider__button" onclick="pjax.loadUrl(&quot;posts/2025-01-09-JUC基础面试题.html&quot;);" href="javascript:void(0);" alt="">详情       </a></div></div><div class="blog-slider__item swiper-slide" style="width: 750px; opacity: 1; transform: translate3d(0px, 0px, 0px); transition-duration: 0ms;"><a class="blog-slider__img" onclick="pjax.loadUrl(&quot;posts/2023-06-09-Hot100刷题笔记.html&quot;);" href="javascript:void(0);" alt=""><img width="48" height="48" src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="https://source.fomal.cc/img/default_cover_15.webp" alt="" onerror="this.src=https://unpkg.zhimg.com/akilar-candyassets/image/loading.gif; this.onerror = null;"/></a><div class="blog-slider__content"><span class="blog-slider__code">2022-08-09</span><a class="blog-slider__title" onclick="pjax.loadUrl(&quot;posts/2023-06-09-Hot100刷题笔记.html&quot;);" href="javascript:void(0);" alt="">Hot100刷题笔记</a><div class="blog-slider__text">🥧本人的Hot100刷题笔记</div><a class="blog-slider__button" onclick="pjax.loadUrl(&quot;posts/2023-06-09-Hot100刷题笔记.html&quot;);" href="javascript:void(0);" alt="">详情       </a></div></div><div class="blog-slider__item swiper-slide" style="width: 750px; opacity: 1; transform: translate3d(0px, 0px, 0px); transition-duration: 0ms;"><a class="blog-slider__img" onclick="pjax.loadUrl(&quot;posts/2025-01-01-Java基础.html&quot;);" href="javascript:void(0);" alt=""><img width="48" height="48" src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="https://source.fomal.cc/img/default_cover_14.webp" alt="" onerror="this.src=https://unpkg.zhimg.com/akilar-candyassets/image/loading.gif; this.onerror = null;"/></a><div class="blog-slider__content"><span class="blog-slider__code">2025-01-09</span><a class="blog-slider__title" onclick="pjax.loadUrl(&quot;posts/2025-01-01-Java基础.html&quot;);" href="javascript:void(0);" alt="">Java基础面试题</a><div class="blog-slider__text">🥧本人的Java基础面试总结</div><a class="blog-slider__button" onclick="pjax.loadUrl(&quot;posts/2025-01-01-Java基础.html&quot;);" href="javascript:void(0);" alt="">详情       </a></div></div><div class="blog-slider__item swiper-slide" style="width: 750px; opacity: 1; transform: translate3d(0px, 0px, 0px); transition-duration: 0ms;"><a class="blog-slider__img" onclick="pjax.loadUrl(&quot;posts/2023-01-09-Redis学习笔记.html&quot;);" href="javascript:void(0);" alt=""><img width="48" height="48" src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="https://source.fomal.cc/img/default_cover_14.webp" alt="" onerror="this.src=https://unpkg.zhimg.com/akilar-candyassets/image/loading.gif; this.onerror = null;"/></a><div class="blog-slider__content"><span class="blog-slider__code">2023-01-09</span><a class="blog-slider__title" onclick="pjax.loadUrl(&quot;posts/2023-01-09-Redis学习笔记.html&quot;);" href="javascript:void(0);" alt="">Redis学习笔记</a><div class="blog-slider__text">🥧本人的Redis学习笔记</div><a class="blog-slider__button" onclick="pjax.loadUrl(&quot;posts/2023-01-09-Redis学习笔记.html&quot;);" href="javascript:void(0);" alt="">详情       </a></div></div><div class="blog-slider__item swiper-slide" style="width: 750px; opacity: 1; transform: translate3d(0px, 0px, 0px); transition-duration: 0ms;"><a class="blog-slider__img" onclick="pjax.loadUrl(&quot;posts/2024-06-09-排序算法总结.html&quot;);" href="javascript:void(0);" alt=""><img width="48" height="48" src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="https://source.fomal.cc/img/default_cover_14.webp" alt="" onerror="this.src=https://unpkg.zhimg.com/akilar-candyassets/image/loading.gif; this.onerror = null;"/></a><div class="blog-slider__content"><span class="blog-slider__code">2023-10-09</span><a class="blog-slider__title" onclick="pjax.loadUrl(&quot;posts/2024-06-09-排序算法总结.html&quot;);" href="javascript:void(0);" alt="">排序算法总结</a><div class="blog-slider__text">🥧本人的排序算法总结</div><a class="blog-slider__button" onclick="pjax.loadUrl(&quot;posts/2024-06-09-排序算法总结.html&quot;);" href="javascript:void(0);" alt="">详情       </a></div></div><div class="blog-slider__item swiper-slide" style="width: 750px; opacity: 1; transform: translate3d(0px, 0px, 0px); transition-duration: 0ms;"><a class="blog-slider__img" onclick="pjax.loadUrl(&quot;posts/2024-08-09-好的博客分享.html&quot;);" href="javascript:void(0);" alt=""><img width="48" height="48" src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="https://source.fomal.cc/img/default_cover_14.webp" alt="" onerror="this.src=https://unpkg.zhimg.com/akilar-candyassets/image/loading.gif; this.onerror = null;"/></a><div class="blog-slider__content"><span class="blog-slider__code">2024-08-09</span><a class="blog-slider__title" onclick="pjax.loadUrl(&quot;posts/2024-08-09-好的博客分享.html&quot;);" href="javascript:void(0);" alt="">好的博客分享</a><div class="blog-slider__text">🥧好的博客学习分享</div><a class="blog-slider__button" onclick="pjax.loadUrl(&quot;posts/2024-08-09-好的博客分享.html&quot;);" href="javascript:void(0);" alt="">详情       </a></div></div><div class="blog-slider__item swiper-slide" style="width: 750px; opacity: 1; transform: translate3d(0px, 0px, 0px); transition-duration: 0ms;"><a class="blog-slider__img" onclick="pjax.loadUrl(&quot;posts/2023-01-09-Spring学习笔记.html&quot;);" href="javascript:void(0);" alt=""><img width="48" height="48" src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="https://source.fomal.cc/img/default_cover_14.webp" alt="" onerror="this.src=https://unpkg.zhimg.com/akilar-candyassets/image/loading.gif; this.onerror = null;"/></a><div class="blog-slider__content"><span class="blog-slider__code">2022-01-09</span><a class="blog-slider__title" onclick="pjax.loadUrl(&quot;posts/2023-01-09-Spring学习笔记.html&quot;);" href="javascript:void(0);" alt="">Spring学习笔记</a><div class="blog-slider__text">🥧本人的Spring学习笔记</div><a class="blog-slider__button" onclick="pjax.loadUrl(&quot;posts/2023-01-09-Spring学习笔记.html&quot;);" href="javascript:void(0);" alt="">详情       </a></div></div><div class="blog-slider__item swiper-slide" style="width: 750px; opacity: 1; transform: translate3d(0px, 0px, 0px); transition-duration: 0ms;"><a class="blog-slider__img" onclick="pjax.loadUrl(&quot;posts/2023-01-09-MySQL面试题.html&quot;);" href="javascript:void(0);" alt=""><img width="48" height="48" src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="https://source.fomal.cc/img/default_cover_15.webp" alt="" onerror="this.src=https://unpkg.zhimg.com/akilar-candyassets/image/loading.gif; this.onerror = null;"/></a><div class="blog-slider__content"><span class="blog-slider__code">2023-01-09</span><a class="blog-slider__title" onclick="pjax.loadUrl(&quot;posts/2023-01-09-MySQL面试题.html&quot;);" href="javascript:void(0);" alt="">MySQL面试题</a><div class="blog-slider__text">🥧本人的MySQL面试题总结</div><a class="blog-slider__button" onclick="pjax.loadUrl(&quot;posts/2023-01-09-MySQL面试题.html&quot;);" href="javascript:void(0);" alt="">详情       </a></div></div><div class="blog-slider__item swiper-slide" style="width: 750px; opacity: 1; transform: translate3d(0px, 0px, 0px); transition-duration: 0ms;"><a class="blog-slider__img" onclick="pjax.loadUrl(&quot;posts/2023-01-09-MyBatis-Plus-入门.html&quot;);" href="javascript:void(0);" alt=""><img width="48" height="48" src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="https://source.fomal.cc/img/default_cover_15.webp" alt="" onerror="this.src=https://unpkg.zhimg.com/akilar-candyassets/image/loading.gif; this.onerror = null;"/></a><div class="blog-slider__content"><span class="blog-slider__code">2023-01-09</span><a class="blog-slider__title" onclick="pjax.loadUrl(&quot;posts/2023-01-09-MyBatis-Plus-入门.html&quot;);" href="javascript:void(0);" alt="">MyBatis Plus 入门</a><div class="blog-slider__text">🥧本人的MyBatis面试题总结</div><a class="blog-slider__button" onclick="pjax.loadUrl(&quot;posts/2023-01-09-MyBatis-Plus-入门.html&quot;);" href="javascript:void(0);" alt="">详情       </a></div></div><div class="blog-slider__item swiper-slide" style="width: 750px; opacity: 1; transform: translate3d(0px, 0px, 0px); transition-duration: 0ms;"><a class="blog-slider__img" onclick="pjax.loadUrl(&quot;posts/2023-01-09-Git基础.html&quot;);" href="javascript:void(0);" alt=""><img width="48" height="48" src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="https://source.fomal.cc/img/default_cover_15.webp" alt="" onerror="this.src=https://unpkg.zhimg.com/akilar-candyassets/image/loading.gif; this.onerror = null;"/></a><div class="blog-slider__content"><span class="blog-slider__code">2023-01-09</span><a class="blog-slider__title" onclick="pjax.loadUrl(&quot;posts/2023-01-09-Git基础.html&quot;);" href="javascript:void(0);" alt="">Git基础</a><div class="blog-slider__text">🥧本人的Git基础总结</div><a class="blog-slider__button" onclick="pjax.loadUrl(&quot;posts/2023-01-09-Git基础.html&quot;);" href="javascript:void(0);" alt="">详情       </a></div></div><div class="blog-slider__item swiper-slide" style="width: 750px; opacity: 1; transform: translate3d(0px, 0px, 0px); transition-duration: 0ms;"><a class="blog-slider__img" onclick="pjax.loadUrl(&quot;posts/2013454d.html&quot;);" href="javascript:void(0);" alt=""><img width="48" height="48" src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="https://source.fomal.cc/img/default_cover_14.webp" alt="" onerror="this.src=https://unpkg.zhimg.com/akilar-candyassets/image/loading.gif; this.onerror = null;"/></a><div class="blog-slider__content"><span class="blog-slider__code">2022-08-09</span><a class="blog-slider__title" onclick="pjax.loadUrl(&quot;posts/2013454d.html&quot;);" href="javascript:void(0);" alt="">Markdown语法与外挂标签写法汇总</a><div class="blog-slider__text">🥧本文汇总Markdown格式以及外挂标签在网页端的渲染效果，可作为文档进行查询</div><a class="blog-slider__button" onclick="pjax.loadUrl(&quot;posts/2013454d.html&quot;);" href="javascript:void(0);" alt="">详情       </a></div></div></div><div class="blog-slider__pagination swiper-pagination-clickable swiper-pagination-bullets"></div></div></div>';
    console.log('已挂载butterfly_swiper')
    parent_div_git.insertAdjacentHTML("afterbegin",item_html)
    }
  var elist = 'undefined'.split(',');
  var cpage = location.pathname;
  var epage = '/';
  var flag = 0;

  for (var i=0;i<elist.length;i++){
    if (cpage.includes(elist[i])){
      flag++;
    }
  }

  if ((epage ==='all')&&(flag == 0)){
    butterfly_swiper_injector_config();
  }
  else if (epage === cpage){
    butterfly_swiper_injector_config();
  }
  </script><script defer src="https://npm.elemecdn.com/hexo-butterfly-swiper/lib/swiper.min.js"></script><script defer data-pjax src="https://npm.elemecdn.com/hexo-butterfly-swiper/lib/swiper_init.js"></script><div class="js-pjax"><script async="async">var arr = document.getElementsByClassName('recent-post-item');
for(var i = 0;i<arr.length;i++){
    arr[i].classList.add('wow');
    arr[i].classList.add('animate__zoomIn');
    arr[i].setAttribute('data-wow-duration', '2s');
    arr[i].setAttribute('data-wow-delay', '200ms');
    arr[i].setAttribute('data-wow-offset', '30');
    arr[i].setAttribute('data-wow-iteration', '1');
  }</script><script async="async">var arr = document.getElementsByClassName('card-widget');
for(var i = 0;i<arr.length;i++){
    arr[i].classList.add('wow');
    arr[i].classList.add('animate__zoomIn');
    arr[i].setAttribute('data-wow-duration', '2s');
    arr[i].setAttribute('data-wow-delay', '200ms');
    arr[i].setAttribute('data-wow-offset', '30');
    arr[i].setAttribute('data-wow-iteration', '1');
  }</script></div><script defer src="https://npm.elemecdn.com/hexo-butterfly-wowjs/lib/wow.min.js"></script><script defer src="https://npm.elemecdn.com/hexo-butterfly-wowjs/lib/wow_init.js"></script><script data-pjax src="https://npm.elemecdn.com/hexo-filter-gitcalendar/lib/gitcalendar.js"></script><script data-pjax>
  function gitcalendar_injector_config(){
      var parent_div_git = document.getElementById('gitZone');
      var item_html = '<div class="recent-post-item" id="gitcalendarBar" style="width:100%;height:auto;padding:10px;"><style>#git_container{min-height: 320px}@media screen and (max-width:650px) {#git_container{min-height: 0px}}</style><div id="git_loading" style="width:10%;height:100%;margin:0 auto;display: block;"><svg xmlns="http://www.w3.org/2000/svg" xmlns:xlink="http://www.w3.org/1999/xlink" viewBox="0 0 50 50" style="enable-background:new 0 0 50 50" xml:space="preserve"><path fill="#d0d0d0" d="M25.251,6.461c-10.318,0-18.683,8.365-18.683,18.683h4.068c0-8.071,6.543-14.615,14.615-14.615V6.461z" transform="rotate(275.098 25 25)"><animatetransform attributeType="xml" attributeName="transform" type="rotate" from="0 25 25" to="360 25 25" dur="0.6s" repeatCount="indefinite"></animatetransform></path></svg><style>#git_container{display: none;}</style></div><div id="git_container"></div></div>';
      parent_div_git.insertAdjacentHTML("afterbegin",item_html)
      console.log('已挂载gitcalendar')
      }

    if( document.getElementById('gitZone') && (location.pathname ==='/site/census/'|| '/site/census/' ==='all')){
        gitcalendar_injector_config()
        GitCalendarInit("/api?null",['#d9e0df', '#c6e0dc', '#a8dcd4', '#9adcd2', '#89ded1', '#77e0d0', '#5fdecb', '#47dcc6', '#39dcc3', '#1fdabe', '#00dab9'],'null')
    }
  </script><!-- hexo injector body_end end --></body></html>